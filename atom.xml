<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中间件兴趣圈</title>
  
  <subtitle>关注微信公众号「中间件兴趣圈」，第一时间获取最新干货！</subtitle>
  <link href="https://www.codingw.net/atom.xml" rel="self"/>
  
  <link href="https://www.codingw.net/"/>
  <updated>2021-03-29T04:23:58.789Z</updated>
  <id>https://www.codingw.net/</id>
  
  <author>
    <name>中间件兴趣圈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这些关于线程池相关的高频面试题你都知道吗</title>
    <link href="https://www.codingw.net/posts/194b9de.html"/>
    <id>https://www.codingw.net/posts/194b9de.html</id>
    <published>2021-03-24T15:52:54.000Z</published>
    <updated>2021-03-29T04:23:58.789Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h4 id="1、java-线程池的核心属性有哪些，其含义是什么？"><a href="#1、java-线程池的核心属性有哪些，其含义是什么？" class="headerlink" title="1、java 线程池的核心属性有哪些，其含义是什么？"></a>1、java 线程池的核心属性有哪些，其含义是什么？</h4><p>JAVA 线程池的核心属性如下：</p><ul><li>int corePoolSize<br>核心线程数</li><li>int maximumPoolSize<br>线程池最大线程数</li><li>long keepAliveTime<br>线程保持活跃的时间</li><li>TimeUnit unit<br>keepAliveTime 的时间单位</li><li>BlockingQueue&lt; Runnable &gt; workQueue<br>任务挤压队列</li><li>ThreadFactory threadFactory<br>线程创建工厂类</li><li>RejectedExecutionHandler handler<br>拒绝策略</li></ul><h4 id="2、向线程池提交任务时线程创建过程？"><a href="#2、向线程池提交任务时线程创建过程？" class="headerlink" title="2、向线程池提交任务时线程创建过程？"></a>2、向线程池提交任务时线程创建过程？</h4><p>那当用户向线程池提交一个任务的时候，线程池会如何创建线程呢？</p><a id="more"></a><ol><li><p>首先线程池会判断当前已创建的线程是否小于 corePoolSize  (核心线程数)，如果小于，则无论已创建的线程是否空闲，<strong>都会选择创建一个新的线程来执行该任务，直到已创建的线程等于核心线程数</strong>。</p></li><li><p>当线程池中已创建的线程数等于核心核心线程数时，用户继续向线程池提交任务时，此时会先判断任务队列是否已满：<br>  1）如果任务队列未满，则将任务放入队列中。<br>  2）如果任务队列已满，则判断当前线程数量是否超过了最大线程数量，如果未超过，则创建一个新的线程来执行该任务，如果线程池已创建的线程数量等最大线程数，则执行拒绝策略。</p></li></ol><p><strong>所以如果线程池使用的队列无界队列，最大线程数会变的没有意义。</strong></p><h4 id="3、线程池的拒绝策略有哪些，其使用场景分别是什么？"><a href="#3、线程池的拒绝策略有哪些，其使用场景分别是什么？" class="headerlink" title="3、线程池的拒绝策略有哪些，其使用场景分别是什么？"></a>3、线程池的拒绝策略有哪些，其使用场景分别是什么？</h4><p>JUC 默认提供了如下拒绝策略：</p><ul><li>AbortPolicy<br>   拒绝，直接抛出 RejectedExecutionException，默认值。</li><li>CallerRunsPolicy<pre><code>由调用线程直接运行任务的 run 方法，即异步转同步。</code></pre></li><li>DiscardOldestPolicy<pre><code> 丢弃任务队列中最新进入</code></pre></li><li>DiscardPolicy<pre><code>  拒绝了，就不执行，“当没事人事”样。</code></pre></li></ul><p><strong>拒绝策略触发的条件</strong>：线程池使用的是有界任务队列时，才有可能被触发，当队列已满，并且线程池创建的线程已经达到了最大允许的线程池时。</p><p><strong>默认情况下，通常使用 AbortPolicy 即可</strong>。</p><p>CallerRunsPolicy 异步转同步在出现拒绝的情况下其实意义不大，没有想出其合适的场景，因为需要执行拒绝策略的时候，已经处理变慢了，再同步执行任务，只会增加服务器的负载，不利于恢复问题。</p><p>DiscardOldestPolicy 这种策略，通常用于类似记录轨迹，偶尔丢失点数据没关系，但希望最新的数据能得到保存。</p><p>DiscardPolicy 策略，通常用来异步打印日志，直接忽略不执行，期望保存旧的数据。</p><h4 id="4、如何选择阻塞队列"><a href="#4、如何选择阻塞队列" class="headerlink" title="4、如何选择阻塞队列"></a>4、如何选择阻塞队列</h4><p><strong>阿里内部的开源规范明确禁止使用无界队列</strong>，因为如果使用无界队列，任务会不受限制的往线程池中提交，有可能造成内存溢出。</p><p>如果使用无界队列，<strong>最大线程数</strong>这个参数将会<strong>失效</strong>，因为永远也不会创建多于核心线程数量的线程。</p><h4 id="5、线程池工厂有和实际用处"><a href="#5、线程池工厂有和实际用处" class="headerlink" title="5、线程池工厂有和实际用处"></a>5、线程池工厂有和实际用处</h4><p>ThreadFactory threadFactory，线程池工厂，在使用线程池时，强烈推荐使用自己定义的线程工厂，<strong>这样能为线程池中的线程进行命名</strong>，方便跟大家使用 jsatck 命令查看线程栈时，能快速识别对应的线程。</p><h4 id="6、keepAliveTime参数的作用"><a href="#6、keepAliveTime参数的作用" class="headerlink" title="6、keepAliveTime参数的作用"></a>6、keepAliveTime参数的作用</h4><p>keepAliveTime ：通俗点来说，这个参数表示线程的最大空闲时间，即如果线程没有在执行任务，能存活的时间。</p><p><strong>默认情况下，该参数只针对 超过 核心线程数(corePoolSize) 的线程</strong>。</p><p>当然如果 <strong>allowCoreThreadTimeOut</strong> 设置为 ture ，则核心线程数也会因为空闲而被关闭。</p><p><strong>那如何来设置 keepAliveTime 呢？</strong></p><p>如果流量是一波一波的，不建议设置该值，考虑如下场景：</p><p>如果业务每隔 10分钟来一波流量洪峰，每一波处理3分钟，如果将 keepAliveTime 设置为 5分钟，为了节省资源，最小线程数设置为10，最大线程数设置100,这样一波流量过来，10个核心线程肯定处理不过来，马上创建线程，然后处理过后，创建的线程由于空闲，则相继关闭，然后又来一波流量，又创建，这样其实线程池的意义就不大了。</p><p>一般使用线程池，基本上我会将 corePoolSize 与 maxPoolSize 设置相等，同一个项目中，不同的业务，对应不同的线程池，实现线程隔离。</p><p><strong>本期就介绍到这里了，希望对你有所帮助，同时也希望一键三连，给作者一些鼓励。</strong></p><hr><p>见字如面,我是威哥,一个从普通二本院校毕业,从未曾接触分布式、微服务、高并发到通过<strong>技术分享</strong>实现职场蜕变，成长为RocketMQ社区优秀布道师、大厂资深架构师，出版《RocketMQ技术内幕》一书，在CSDN中记录了我的成长历程，欢迎大家关注，私信，一起交流进步。</p><p>分享笔者一个硬核的RocketMQ电子书：<br><img src="https://img-blog.csdnimg.cn/2021032212002741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>获取方式：微信搜索【中间件兴趣圈】，回复RMQPDF即可获取。</p><p><strong>如果大家需要深入研究Raft协议，可以观看笔者关于Raft协议的系列文章</strong>：<br>1、<a href="https://mp.weixin.qq.com/s/VZSF82NEcCa8NE-WMdXrCA">RocketMQ 多副本前置篇：初探raft协议</a><br>2、<a href="https://mp.weixin.qq.com/s/wCYH7y2m_Oqcpt_vGNAU1A">源码分析RocketMQ多副本之Leader选主</a><br>3、<a href="https://mp.weixin.qq.com/s/KaXGxphzO1yKGM2RNpvNaA">源码分析 RocketMQ DLedger(多副本) 之日志追加流程</a><br>4、<a href="https://mp.weixin.qq.com/s/0UiQR_tzlqyRrl1CA8PLrw">源码分析 RocketMQ DLedger(多副本) 之日志复制-上篇</a><br>5、<a href="https://mp.weixin.qq.com/s/Ld5PAHJLj-z6aB0cmJGKrw">源码分析 RocketMQ DLedger(多副本) 之日志复制-下篇</a><br>6、<a href="https://mp.weixin.qq.com/s/Ld5PAHJLj-z6aB0cmJGKrw">https://mp.weixin.qq.com/s/sGcOL9zcJBQ2NMXwodSgzQ</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1、java-线程池的核心属性有哪些，其含义是什么？&quot;&gt;&lt;a href=&quot;#1、java-线程池的核心属性有哪些，其含义是什么？&quot; class=&quot;headerlink&quot; title=&quot;1、java 线程池的核心属性有哪些，其含义是什么？&quot;&gt;&lt;/a&gt;1、java 线程池的核心属性有哪些，其含义是什么？&lt;/h4&gt;&lt;p&gt;JAVA 线程池的核心属性如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int corePoolSize&lt;br&gt;核心线程数&lt;/li&gt;
&lt;li&gt;int maximumPoolSize&lt;br&gt;线程池最大线程数&lt;/li&gt;
&lt;li&gt;long keepAliveTime&lt;br&gt;线程保持活跃的时间&lt;/li&gt;
&lt;li&gt;TimeUnit unit&lt;br&gt;keepAliveTime 的时间单位&lt;/li&gt;
&lt;li&gt;BlockingQueue&amp;lt; Runnable &amp;gt; workQueue&lt;br&gt;任务挤压队列&lt;/li&gt;
&lt;li&gt;ThreadFactory threadFactory&lt;br&gt;线程创建工厂类&lt;/li&gt;
&lt;li&gt;RejectedExecutionHandler handler&lt;br&gt;拒绝策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;2、向线程池提交任务时线程创建过程？&quot;&gt;&lt;a href=&quot;#2、向线程池提交任务时线程创建过程？&quot; class=&quot;headerlink&quot; title=&quot;2、向线程池提交任务时线程创建过程？&quot;&gt;&lt;/a&gt;2、向线程池提交任务时线程创建过程？&lt;/h4&gt;&lt;p&gt;那当用户向线程池提交一个任务的时候，线程池会如何创建线程呢？&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.codingw.net/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="线程池" scheme="https://www.codingw.net/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>面试官：你是如何判断一个线程池需要创建多少个线程</title>
    <link href="https://www.codingw.net/posts/cbce658b.html"/>
    <id>https://www.codingw.net/posts/cbce658b.html</id>
    <published>2021-03-23T15:57:28.000Z</published>
    <updated>2021-03-29T04:21:43.451Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>目前按照我看过的一些开源框架，线程池中线程数量主要是根据应用的类型：IO密集型（2n +1 ），CPU密集型设置为 n + 1。</p><p>但实际情况往往复杂的多，不会按照这个进行设置，进行这种设置，通常是框架层面，例如netty,dubbo这种底层通讯框架会参考这样的标准去设置，在实际业务中往往不会这样做。</p><p>对于IO密集型网上还有一个公式：线程数 = CPU核心数/(1-阻塞系数)</p><p>这个阻塞系数一般为0.8~0.9之间，可以取0.8或者0.9。</p><p>我觉这个公式有一定的道理，考虑了阻塞的概念。</p><p>在我们的业务开发中，基本上都是IO密集型，因为往往都会去操作数据库，访问redis，es等存储型组件，涉及磁盘IO，网络IO。</p><p>那什么场景下是CPU密集型呢？纯计算类，例如计算圆周率的位数，当然我们基本接触不到。</p><p><strong>IO密集型，可以考虑多设置一些线程，主要目的是可以增加IO的并发度，CPU密集型不宜设置过多线程，因为是会造成线程切换，浪费时间。</strong></p><p><strong>接下来我们以一个实际的场景来说明如何设置线程数量。</strong></p><a id="more"></a><p>一个4C8G的机器上部署了一个MQ消费者，在RocketMQ的实现中，消费端也是用一个线程池来消费线程的，那这个线程数要怎么设置呢？</p><p>如果按照 2n + 1 的公式，线程数设置为 9个，但在我们实践过程中发现如果增大线程数量，会显著提高消息的处理能力，说明 2n + 1 对于业务场景来说，并不太合适。</p><p>如果套用 线程数 = CPU核心数/(1-阻塞系数) 阻塞系数取 0.8 ，线程数为 20 。阻塞系数取 0.9，大概线程数40，20个线程数我觉得可以。</p><p>如果我们发现数据库的操作耗时比较多，此时可以继续提高阻塞系数，从而增大线程数量。</p><p><strong>那我们怎么判断需要增加更多线程呢？</strong>其实我觉得我们可以用jstack命令查看一下进程的线程栈，<strong>如果发现线程池中大部分线程都处于等待获取任务，则说明线程够用</strong>，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210323235416859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果大部分线程都处于运行状态，可以继续适当调高线程数量。</p><p><strong>本期就介绍到这里了，希望对你有所帮助，同时也希望一键三连，给作者一些鼓励。</strong></p><hr><p>见字如面,我是威哥,一个从普通二本院校毕业,从未曾接触分布式、微服务、高并发到通过<strong>技术分享</strong>实现职场蜕变，成长为RocketMQ社区优秀布道师、大厂资深架构师，出版《RocketMQ技术内幕》一书，在CSDN中记录了我的成长历程，欢迎大家关注，私信，一起交流进步。</p><p>分享笔者一个硬核的RocketMQ电子书：<br><img src="https://img-blog.csdnimg.cn/2021032212002741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>获取方式：微信搜索【中间件兴趣圈】，回复RMQPDF即可获取。</p><p><strong>如果大家需要深入研究Raft协议，可以观看笔者关于Raft协议的系列文章</strong>：<br>1、<a href="https://mp.weixin.qq.com/s/VZSF82NEcCa8NE-WMdXrCA">RocketMQ 多副本前置篇：初探raft协议</a><br>2、<a href="https://mp.weixin.qq.com/s/wCYH7y2m_Oqcpt_vGNAU1A">源码分析RocketMQ多副本之Leader选主</a><br>3、<a href="https://mp.weixin.qq.com/s/KaXGxphzO1yKGM2RNpvNaA">源码分析 RocketMQ DLedger(多副本) 之日志追加流程</a><br>4、<a href="https://mp.weixin.qq.com/s/0UiQR_tzlqyRrl1CA8PLrw">源码分析 RocketMQ DLedger(多副本) 之日志复制-上篇</a><br>5、<a href="https://mp.weixin.qq.com/s/Ld5PAHJLj-z6aB0cmJGKrw">源码分析 RocketMQ DLedger(多副本) 之日志复制-下篇</a><br>6、<a href="https://mp.weixin.qq.com/s/Ld5PAHJLj-z6aB0cmJGKrw">https://mp.weixin.qq.com/s/sGcOL9zcJBQ2NMXwodSgzQ</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前按照我看过的一些开源框架，线程池中线程数量主要是根据应用的类型：IO密集型（2n +1 ），CPU密集型设置为 n + 1。&lt;/p&gt;
&lt;p&gt;但实际情况往往复杂的多，不会按照这个进行设置，进行这种设置，通常是框架层面，例如netty,dubbo这种底层通讯框架会参考这样的标准去设置，在实际业务中往往不会这样做。&lt;/p&gt;
&lt;p&gt;对于IO密集型网上还有一个公式：线程数 = CPU核心数/(1-阻塞系数)&lt;/p&gt;
&lt;p&gt;这个阻塞系数一般为0.8~0.9之间，可以取0.8或者0.9。&lt;/p&gt;
&lt;p&gt;我觉这个公式有一定的道理，考虑了阻塞的概念。&lt;/p&gt;
&lt;p&gt;在我们的业务开发中，基本上都是IO密集型，因为往往都会去操作数据库，访问redis，es等存储型组件，涉及磁盘IO，网络IO。&lt;/p&gt;
&lt;p&gt;那什么场景下是CPU密集型呢？纯计算类，例如计算圆周率的位数，当然我们基本接触不到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO密集型，可以考虑多设置一些线程，主要目的是可以增加IO的并发度，CPU密集型不宜设置过多线程，因为是会造成线程切换，浪费时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接下来我们以一个实际的场景来说明如何设置线程数量。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.codingw.net/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="线程池" scheme="https://www.codingw.net/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>知乎高赞:为什么同样是分布式架构的Kafka需要Leader而Redis不需要</title>
    <link href="https://www.codingw.net/posts/6947ca27.html"/>
    <id>https://www.codingw.net/posts/6947ca27.html</id>
    <published>2021-03-22T04:11:24.000Z</published>
    <updated>2021-03-29T04:19:52.169Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Redis不需要Leader这个观点其实有歧义，是不准确的，题目的问题本质其实是涉及数据分片、数据复制一致性。</p><h2 id="1、Redis-Cluster-架构"><a href="#1、Redis-Cluster-架构" class="headerlink" title="1、Redis Cluster 架构"></a>1、Redis Cluster 架构</h2><p>在Redis3.0版本开始，Redis引入了一种去中心化的集群架构，采用预分片的模式，一个集群中所有节点总共对应16384个槽位，在对一个key进行写入时，首先对key取hashcode，然后求模来映射到具体的某一个节点，其部署架构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210322115450433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述每一个节点中存储的数据都不一样，即每一个节点存储整体数据的一部分，<strong>并且为了实现去中心化</strong>每一个节点需要存储集群中所有key所对应存档的节点信息(即Key的路由信息)，这样当客户端将查询key1的请求发送到redisA节点，但该key1实际存储在redisB节点，此时A节点需将该节点路由到实际存储该key的节点，内部实现一个重定向，从而实现访问任意一个节点都能查询到存储的值。</p><a id="more"></a><p>在<strong>上述架构中是不需要存在Leader的，这也是所谓的集群去中心化设计思想的关键</strong>，但问题来了，如果集群中任意一个节点宕机不可用，存储在该节点中的数据就会丢失，为了解决这个问题，通常会引入主从架构，架构图如下所示：<br><img src="https://img-blog.csdnimg.cn/2021032211550568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>具体的做法是为每一个主节点引入一个或多个从节点，用来拷贝主节点的数据，上<strong>图中的每一个虚线框表示一个复制组，也称之为副本，副本之间的数据期望完全一致。</strong></p><p>在主从架构中如何保证数据一致性呢？通常主从集群与客户端之间的交互方式有如下几种：</p><ul><li>客户端发送写请求到Master，在Master节点写入成功就返回给客户端，同时从节点异步复制数据，<strong>主从存在延迟，并且当主节点宕机存在丢数据的风险</strong>。</li><li>客户端发送写请求到Master，Master节点写入成功后，需要等待从从节点同样写入成功后才会向客户端返回成功，该方式会<strong>增大延迟，增加主从数据延迟</strong>，但还是<strong>无法避免主从数据不一致</strong>。</li></ul><p>上述两种情况，<strong>都无法确保数据在主从两个节点上的一致性</strong>。</p><p>为什么同步双写也无法保证数据的一致性呢？<br><img src="https://img-blog.csdnimg.cn/20210322115521498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>客户端只有在master,slave同步写入成功后才会收到响应，乍一看，能提供一致性，其实不然，试想一下，例如将key1的数据先写入到Master节点，在写入从节点的过程中出现错误，客户端会收到写入失败，但此时去往master中查询key1的数据，却能查询出上一次请求失败的数据，即客户端虽然收到了写入失败，但主节点却写入成功，造成了<strong>数据语义上的不一致性</strong>。</p><p>即主从同步这种架构，主从节点、客户端的确认机制存在天然的不足，为了解决该问题，Raft等分布式副本数据强一致性协议就闪亮登场了。</p><h2 id="2、副本之间强一致性协议"><a href="#2、副本之间强一致性协议" class="headerlink" title="2、副本之间强一致性协议"></a>2、副本之间强一致性协议</h2><p>为了解决数据的高可用性，避免单点故障，通常会将数据同步为多份，高可用性是解决了，但带来了另外一个问题，多个副本数据之间如何保证一致性，为了解决该问题出现了诸如 raft、paxos等一致性协议。</p><p>Raft协议的数据复制说明图如下：<br><img src="https://img-blog.csdnimg.cn/20210322115548437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>图中客户端向Raft协议集群发起一个写请求，集群中的 <strong>Leader 节点</strong>来处理写请求，首先数据先存入 Leader 节点，然后需要广播给它的所有从节点，从节点接收到 Leader 节点的数据推送对数据进行存储，然后向主节点汇报存储的结果，<strong>Leader 节点会对该日志的存储结果进行仲裁，如果超过集群数量的一半都成功存储了该数据</strong>，主节点则向客户端返回写入成功，否则向客户端写入写入失败。</p><p><strong>并且，如果只有主节点写入成功，但其他从节点没有写入成功，就算数据被写入到Leader节点，但这部分数据对客户端来说是可见的。</strong></p><p>Raft协议主要分为两个部分：Leader节点选举与日志复制。</p><p>Leader节点选举：从集群中选举一个Leader节点用于<strong>处理数据的读写</strong>，从节点只负责从Leader节点同步数据，并且Leader节点宕机，会自动触发选举，选举出一个新的Leader节点。</p><p>日志复制：数据写入主节点后，主节点需要将数据转发给从节点，只有集群中<strong>超过半数节点</strong>都成功将一条数据写入才向客户端返回成功。</p><p>Raft协议的实现细节本文不打算深究，大家如果感兴趣，可以在文末查看笔者有关Raft协议的专栏，本文只从设计层面剖析为什么Raft协议能实现数据的一致性。</p><p><strong>笔者认为Raft协议能确保数据的一致性，主要是引入了全局日志序号与已提交指针。</strong></p><h4 id="2-1-引入了全局日志序号"><a href="#2-1-引入了全局日志序号" class="headerlink" title="2.1 引入了全局日志序号"></a>2.1 引入了全局日志序号</h4><p>为了方便对日志进行管理与辨别，raft 协议为一条一条的消息进行编号，每一条消息达到主节点时会生成一个全局唯一的递增号，这样可以根据日志序号来快速的判断数据在主从复制过程中数据是否一致。</p><h4 id="2-2-已提交指针"><a href="#2-2-已提交指针" class="headerlink" title="2.2 已提交指针"></a>2.2 已提交指针</h4><p>我们知道，日志先写入主节点，然后再进行传播，在集群中超过半数节点的写入成功之前，这条日志都不能认为<strong>写入成功</strong>，尽管已经存储到了主节点中，为了让客户端对这条日志不可见，Raft协议引入了<strong>已提交指针，只有小于等于已提交的数据才能被客户端感知</strong>。</p><p>一条日志要能被提交的充分必要条件是日志得到了集群内超过半数节点成功追加，才能被认为已提交，才会向客户端返回成功，<strong>这样就实现了数据在集群内、客户端与集群之间的数据一致性语义</strong>。</p><p>为了让大家更加深入的理解Raft协议数据性一致性问题，给出如下<strong>思考题</strong>，主从切换会导致Raft丢失数据吗？</p><p>例如一个Raft协议中有3个节点，各个节点的写入情况如下：</p><p>Node1：100</p><p>Node2：89</p><p>Node3：88</p><p>其中Node1为Leader节点，如果Node1节点宕机，整个集群触发重新选举，会丢失数据吗？</p><p><strong>答案是肯定不会的</strong>。</p><p>首先我们要先明白，在上面的状态下，已提交指针为89，因为集群有两个节点都成功写入了89，即向客户端返回成功的数据也是序号为89的数据，在选举过程中，Node3不可能会被选举为Leader，因为Node3中存储的数据小于Node2存储的数据，当Node2选举为新的Leader时，Node3会向Node2同步数据。</p><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文从知乎上一个不严紧的问题出发，挖掘该问题的本质：分布式数据存储的数据分片与高可用(避免单点故障)，从而又引发新的问题（数据副本之间的一致性）</p><p><strong>本期就介绍到这里了，希望对你有所帮助，同时也希望一键三连，给作者一些鼓励。</strong></p><hr><p>见字如面,我是威哥,一个从普通二本院校毕业,从未曾接触分布式、微服务、高并发到通过<strong>技术分享</strong>实现职场蜕变，成长为RocketMQ社区优秀布道师、大厂资深架构师，出版《RocketMQ技术内幕》一书，在CSDN中记录了我的成长历程，欢迎大家关注，私信，一起交流进步。</p><p>分享笔者一个硬核的RocketMQ电子书：<br><img src="https://img-blog.csdnimg.cn/2021032212002741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>获取方式：微信搜索【中间件兴趣圈】，回复RMQPDF即可获取。</p><p><strong>如果大家需要深入研究Raft协议，可以观看笔者关于Raft协议的系列文章</strong>：<br>1、<a href="https://mp.weixin.qq.com/s/VZSF82NEcCa8NE-WMdXrCA">RocketMQ 多副本前置篇：初探raft协议</a><br>2、<a href="https://mp.weixin.qq.com/s/wCYH7y2m_Oqcpt_vGNAU1A">源码分析RocketMQ多副本之Leader选主</a><br>3、<a href="https://mp.weixin.qq.com/s/KaXGxphzO1yKGM2RNpvNaA">源码分析 RocketMQ DLedger(多副本) 之日志追加流程</a><br>4、<a href="https://mp.weixin.qq.com/s/0UiQR_tzlqyRrl1CA8PLrw">源码分析 RocketMQ DLedger(多副本) 之日志复制-上篇</a><br>5、<a href="https://mp.weixin.qq.com/s/Ld5PAHJLj-z6aB0cmJGKrw">源码分析 RocketMQ DLedger(多副本) 之日志复制-下篇</a><br>6、<a href="https://mp.weixin.qq.com/s/Ld5PAHJLj-z6aB0cmJGKrw">https://mp.weixin.qq.com/s/sGcOL9zcJBQ2NMXwodSgzQ</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis不需要Leader这个观点其实有歧义，是不准确的，题目的问题本质其实是涉及数据分片、数据复制一致性。&lt;/p&gt;
&lt;h2 id=&quot;1、Redis-Cluster-架构&quot;&gt;&lt;a href=&quot;#1、Redis-Cluster-架构&quot; class=&quot;headerlink&quot; title=&quot;1、Redis Cluster 架构&quot;&gt;&lt;/a&gt;1、Redis Cluster 架构&lt;/h2&gt;&lt;p&gt;在Redis3.0版本开始，Redis引入了一种去中心化的集群架构，采用预分片的模式，一个集群中所有节点总共对应16384个槽位，在对一个key进行写入时，首先对key取hashcode，然后求模来映射到具体的某一个节点，其部署架构如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210322115450433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;上述每一个节点中存储的数据都不一样，即每一个节点存储整体数据的一部分，&lt;strong&gt;并且为了实现去中心化&lt;/strong&gt;每一个节点需要存储集群中所有key所对应存档的节点信息(即Key的路由信息)，这样当客户端将查询key1的请求发送到redisA节点，但该key1实际存储在redisB节点，此时A节点需将该节点路由到实际存储该key的节点，内部实现一个重定向，从而实现访问任意一个节点都能查询到存储的值。&lt;/p&gt;</summary>
    
    
    
    <category term="分布式" scheme="https://www.codingw.net/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
    <category term="数据分片" scheme="https://www.codingw.net/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87/"/>
    
    <category term="一致性" scheme="https://www.codingw.net/tags/%E4%B8%80%E8%87%B4%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>剥丝抽茧｜阿里面试题解读：MQ消费端遇到瓶颈该怎么办？</title>
    <link href="https://www.codingw.net/posts/b86dd57b.html"/>
    <id>https://www.codingw.net/posts/b86dd57b.html</id>
    <published>2021-03-15T04:09:34.000Z</published>
    <updated>2021-03-29T04:17:32.347Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="１、面试场景与面试技巧"><a href="#１、面试场景与面试技巧" class="headerlink" title="１、面试场景与面试技巧"></a>１、面试场景与面试技巧</h2><p>金三银四招聘季，一位粉丝朋友最近在蚂蚁金服第二轮面试时遇到这样一个问题：<strong>如果MQ消费遇到瓶颈时该如何处理</strong>?。</p><p><strong>横向扩容</strong>，相比很多读者与我这位朋友一样会脱口而出，<strong>面试官显然不会满意这样的回答</strong>，然后追问道：<strong>横向扩容是堆机器，还有没有其他办法呢</strong>？</p><p>在面试过程中，个人建议大家在听到问题后稍作思考，不要立马给出太直接的答案，而是应该与面试官进行探讨，一方面可更深刻的理解面试官的出题初衷，同时可以给自己梳理一下思路。</p><p>消费端遇到瓶颈，<strong>这是一个结果，但引起这个结果的原因是什么呢？</strong>在没有弄清楚原因之前<strong>谈优化、解决方案都会显得很苍白</strong>。</p><p>在这样的面试场景中，我们该如何探讨交流呢？我的思路如下：</p><ul><li>尝试与面试官探讨如何判断消费端遇到瓶颈</li><li>如何查找根因 </li><li>提出解决方案</li></ul><blockquote><p>温馨提示：为了本文观点的严谨性，本文主要以RocketMQ为例进行剖析。</p></blockquote><a id="more"></a><h2 id="２、如何判断消费端遇到瓶颈"><a href="#２、如何判断消费端遇到瓶颈" class="headerlink" title="２、如何判断消费端遇到瓶颈"></a>２、如何判断消费端遇到瓶颈</h2><p>在RocketMQ消费领域中判断消费端遇到瓶颈通常有两个重要的指标：</p><ul><li>消息积压数量（延迟数量）</li><li>lastConsumeTime</li></ul><p>在开源版本的控制台rocketmq-console界面中，可以查阅一个消费端上述两个指标，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210315120506640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>Delay：消息积压数量，即消费端还剩下多少消息未处理，<strong>该值越大，说明消费端遇到瓶颈了</strong>。</li><li>LastConsumeTime：表示上一次成功消费的消息的存储时间，<strong>该值离当前时间越大，同样能说明消费端遇到瓶颈了</strong>。</li></ul><p>那为什么会积压呢？消费端是在哪遇到瓶颈了呢？</p><h2 id="３、如何定位问题"><a href="#３、如何定位问题" class="headerlink" title="３、如何定位问题"></a>３、如何定位问题</h2><p>消费端出现瓶颈，如何识别是客户端的问题还是服务端的问题，一个<strong>最简单的办法</strong>是看集群内其他消费组是否也有积压，特别是和有问题的消费组订阅同一个主题的其他消费组是否有积压，按照笔者的经验，出现消息积压通常是客户端的问题，可以通过查询 rocketmq_client.log加以证明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &quot;flow&quot; rocketmq_client.log</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20210315120528384.png#pic_center" alt="在这里插入图片描述"><br>出现<strong>so do flow control</strong> 这样的日志，说明触发了消费的限流，其直接触发原因：就是消息消费端积压消息，即消费端无法消费已拉取的消息，为了避免内存泄露，RocketMQ在消费端没有将消息处理完成后，不会继续向服务端拉取消息，并打印上述日志。</p><p><strong>那如何定位消费端慢在哪呢？是卡在哪行代码呢？</strong></p><p>通常的排查方法是跟踪线程栈，即利用jstack命令查看线程运行情况，以此来探究线程的运行情况。</p><p>通常使用的命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep java</span><br><span class="line">jstack pid &gt; j1.log</span><br></pre></td></tr></table></figure><p>通常为了对比，我一般会连续打印5个文件，从而可以在5个文件中查看同一个消费者线程，其状态是否变化，如果未变化，则说明该线程卡主，那就是我们重点需要关注的地方。</p><p>在RocketMQ中，消费端线程以ConsumeMessageThread_开头，通过对线程的判断，如下代码让人为之兴奋：<br><img src="https://img-blog.csdnimg.cn/20210315120556745.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>消费端线程的状态是RUNNABLE，但在5个文件中其状态都是一样，基本可以断定线程卡在具体的代码，从示例代码中是卡在掉一个外部的http借口，从而加以解决，通常在涉及外部调用，特别是http调用，可以设置一个超时时间，避免长时间等待。</p><h2 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h2><p>其实根据第三步骤，大概率能明确是哪个地方慢，遇到了性能瓶颈，通常无非就是调第三方服务，数据库等问题出现了瓶颈，然后对症下药。数据库等性能优化，并不在本文的讨论范围之内，故这里可以点到为止，当然面试官后续可能会继续聊数据库优化等话题，这样就实现了与面试官的交流互动，一环扣一环，技术交流氛围友好，面试通过率大大提高。</p><p>最后，我还想和大家探讨一个问题，<strong>出现消息积压就一定意味着遇到消费瓶颈</strong>，一定需要处理吗？</p><p><strong>其实也不然</strong>，我们回想一下为什么需要使用MQ，不就是利用异步解耦与<strong>削峰填谷</strong>吗？例如在双十一期间，大量突发流量汇入，此时很可能导致消息积压，这正式我们的用意，用MQ抗住突发流量，后端应用慢慢消费，保证消费端的稳定，在积压的情况下，如果tps正常，即问题不大，<strong>这个时候通常的处理方式就是横向扩容</strong>，尽可能的降低积压，减少业务的延迟。</p><p>本文就介绍到这里了。如果大家对RocketMQ感兴趣，可以在CSDN上免费下载由阿里巴巴根据我公众号中RocketMQ专栏整理的电子书：<br><img src="https://img-blog.csdnimg.cn/20210315120617963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>下载链接：<a href="https://download.csdn.net/download/prestigeding/15769453">RocketMQ电子书下载链接</a></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;１、面试场景与面试技巧&quot;&gt;&lt;a href=&quot;#１、面试场景与面试技巧&quot; class=&quot;headerlink&quot; title=&quot;１、面试场景与面试技巧&quot;&gt;&lt;/a&gt;１、面试场景与面试技巧&lt;/h2&gt;&lt;p&gt;金三银四招聘季，一位粉丝朋友最近在蚂蚁金服第二轮面试时遇到这样一个问题：&lt;strong&gt;如果MQ消费遇到瓶颈时该如何处理&lt;/strong&gt;?。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;横向扩容&lt;/strong&gt;，相比很多读者与我这位朋友一样会脱口而出，&lt;strong&gt;面试官显然不会满意这样的回答&lt;/strong&gt;，然后追问道：&lt;strong&gt;横向扩容是堆机器，还有没有其他办法呢&lt;/strong&gt;？&lt;/p&gt;
&lt;p&gt;在面试过程中，个人建议大家在听到问题后稍作思考，不要立马给出太直接的答案，而是应该与面试官进行探讨，一方面可更深刻的理解面试官的出题初衷，同时可以给自己梳理一下思路。&lt;/p&gt;
&lt;p&gt;消费端遇到瓶颈，&lt;strong&gt;这是一个结果，但引起这个结果的原因是什么呢？&lt;/strong&gt;在没有弄清楚原因之前&lt;strong&gt;谈优化、解决方案都会显得很苍白&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在这样的面试场景中，我们该如何探讨交流呢？我的思路如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;尝试与面试官探讨如何判断消费端遇到瓶颈&lt;/li&gt;
&lt;li&gt;如何查找根因 &lt;/li&gt;
&lt;li&gt;提出解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：为了本文观点的严谨性，本文主要以RocketMQ为例进行剖析。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="RocketMQ" scheme="https://www.codingw.net/categories/RocketMQ/"/>
    
    
    <category term="消息消费" scheme="https://www.codingw.net/tags/%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    
    <category term="积压" scheme="https://www.codingw.net/tags/%E7%A7%AF%E5%8E%8B/"/>
    
  </entry>
  
  <entry>
    <title>事务消息应用场景、实现原理与项目实战(附全部源码)</title>
    <link href="https://www.codingw.net/posts/b6f85d12.html"/>
    <id>https://www.codingw.net/posts/b6f85d12.html</id>
    <published>2021-03-08T15:32:44.000Z</published>
    <updated>2021-03-29T04:15:03.263Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、活动中心场景介绍"><a href="#1、活动中心场景介绍" class="headerlink" title="1、活动中心场景介绍"></a>1、活动中心场景介绍</h2><p>在电商系统上线初期，往往会进行一些“拉新”活动，例如活动部门提出<strong>新用户注册送积分、送优惠券活动</strong>。</p><p>基于分布式、微服务的设计理念，通常的架构设计（子系统交互）如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210306232931379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其核心系统介绍如下：</p><ul><li>账户中心<br>提供用户登录、用户注册等服务，一个新用户注册时，向MQ服务器中的USER_REGISTER主题发送一条消息，主流程结束，与送积分，送优惠券等过程解耦。</li><li>优惠券（券系统）<br>提供发放优惠券、使用优惠券等与券相关的基础服务。</li><li>积分中心<br>提供积分相关的服务，例如积分赠送、积分消费、积分查询等基础服务。</li><li>送积分服务（消费者）<br>订阅MQ，按照规则决定是否需要赠送积分，如果需要则调用积分相关的基础接口，完成积分的发放。</li><li>送优惠券（消费者）<br>订阅MQ，按照规则决定是否需要赠送优惠券，如果需要则调用券系统相关的基础接口，完成优惠券的发放。</li></ul><p>上面的架构设计非常优雅，但并不是无懈可击，读者们肯定会想到<strong>如果新用户注册成功，但消息发送到MQ失败，或者消息成功发送到MQ，但发送完MQ后系统出现异常导致用户注册失败又该如何呢？</strong></p><p>上面的问题其实就是<strong>典型的分布式事务问题</strong>：即如何保证<strong>用户注册(数据库操作)与MQ消息发送</strong>这两个分布式操作的一致性。</p><p><strong>RocketMQ事务消息闪亮登场</strong>。</p><a id="more"></a><h2 id="2、事务消息实现原理"><a href="#2、事务消息实现原理" class="headerlink" title="2、事务消息实现原理"></a>2、事务消息实现原理</h2><p>一言以蔽之：RocketMQ事务消息要解决的问题是消息发送与业务的一致性，其<strong>解决思路：二阶段提交与事务状态回查</strong>，其具体实现流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210306232953163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其核心设计理念：</p><ul><li>应用程序开启一个数据库事务，进行数据库操作，并且在事务中发送一条PREPARE消息，PREPARE消息发送成功后通知应用程序记录本地事务状态，然后提交本地事务。</li><li>RocketMQ在收到类型为PREPARE的消息时，首先<strong>备份消息的原主题与原消息消费队列</strong>，然后将消息存储在主题为RMQ_SYS_TRANS_HALF_TOPIC的消息队列中，故PREPARE的消息是不会被客户端消费的。</li><li>Broker消息服务器开启一个定时任务处理RMQ_SYS_TRANS_HALF_TOPIC中的消息，会每隔指定时间向消息发送者发起<strong>事务状态查询请求</strong> ,询问消息发送者客户端本地事务是否成功，然后根据回查状态决定是提交还是回滚，即对处于PREPARE状态进行提交或回滚操作。<ul><li>发送者如果明确得知事务成功，则可以返回COMMIT，服务端会提交该条消息，具体操作是恢复原消息的主题与队列，重新发送到Broker，消费端感知后消费。</li><li>发送这如果无法明确得知事务状态，则返回UNOWN，此时服务端会等待一定时间后再次向发送者询问，默认询问15次。</li><li>发送者如果非常明确得知事务失败，则可以返回ROLLBACK。</li></ul></li></ul><p>在具体实践中，消息发送者在无法获取事务状态时不要武断的返回ROLLBACK，而是要返回UNOWN，让服务端定时重试回查，说明如下：<br><img src="https://img-blog.csdnimg.cn/20210306233009668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在将PREPARE消息发送到Broker后，服务端发起事务查询时本地事务可能还未提交，为了避免无效的事务回查机制，RocketMQ通常至少在收到PREPARE消息6s后才会发起第一次事务回查，可通过 transactionTimeOut 配置。故客户端在实现事务回查时无法证明事务状态时不应该返回ROLLBACK，而是返回UNOWN。</p><h2 id="3、事务消息实战"><a href="#3、事务消息实战" class="headerlink" title="3、事务消息实战"></a>3、事务消息实战</h2><p>光说不练假把式，接下来以一个<strong>新用户注册送优惠券的场景</strong>来详细介绍如何使用事务消息。</p><p>项目模块职责说明如下：<br><img src="https://img-blog.csdnimg.cn/20210306233026408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>事务消息的核心代码组装在transaction-service，其核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20210306233041246.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中核心要点如下：</p><ul><li>UserServiceImpl<br>Dubbo接口业务实现类，类似MVC的控制层，在这里做一些参数验证，但<strong>不执行具体的业务逻辑</strong>，只是发送一条<strong>事务消息</strong>到MQ。</li><li>UserRegTransactionListener<br>事务监听器，在 executeLocalTransaction 方法中执行业务逻辑，数据库本地事务加在该方法。</li></ul><blockquote><p>温馨提示：之所以不在UserServicveImpl中执行本地事务，是因为 executeLocalTransaction 中抛出的异常会被RocketMQ框架捕捉，及异常无法被UserServiceImpl感知，即无法实现其事务的一致性。</p></blockquote><p>接下来展示其核心代码，如全部源码已上传到github仓库。</p><blockquote><p>仓库地址：<a href="https://github.com/dingwpmz/rocketmq-learning">https://github.com/dingwpmz/rocketmq-learning</a></p></blockquote><h4 id="3-1-UserServiceImpl-核心实现"><a href="#3-1-UserServiceImpl-核心实现" class="headerlink" title="3.1 UserServiceImpl 核心实现"></a>3.1 UserServiceImpl 核心实现</h4><p><img src="https://img-blog.csdnimg.cn/20210306233127637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>UserServiceImpl 的核心要点如下：</p><ul><li>首先应该对<strong>参数进行校验、业务逻辑进行校验</strong>，如果不满足业务条件，会发送一些无效消息到MQ，虽然不会造成业务异常，但会<strong>消耗性能</strong></li><li>发送事务消息，<strong>建议对消息设置Key</strong>,Key的值可以用<strong>业务处理流水号</strong>(可唯一表示该业务操作)或者<strong>核心业务字段</strong>(例如订单编号)</li><li>业务入口类可通过<strong>事务消息发送状态</strong>来判断<strong>业务是否失败</strong>。</li></ul><h4 id="3-2-UserRegTransactionListener-核心实现"><a href="#3-2-UserRegTransactionListener-核心实现" class="headerlink" title="3.2 UserRegTransactionListener 核心实现"></a>3.2 UserRegTransactionListener 核心实现</h4><p>事务监听器需要实现执行本地事务与事务回查两个接口。</p><h5 id="3-2-1-实现-executeLocalTransaction"><a href="#3-2-1-实现-executeLocalTransaction" class="headerlink" title="3.2.1 实现 executeLocalTransaction"></a>3.2.1 实现 executeLocalTransaction</h5><p>首先需要实现 executeLocalTransaction 方法，执行本地事务，其代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210306233143554.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中几个关键点说明如下：</p><ul><li>在该方法上添加数据库事务标签。</li><li>执行业务逻辑，示例Demo只是将用户数据存储到数据库。</li><li>如果业务执行失败，可明确告知需要回滚，上层调用方也可根据ROLLBACK_MESSAGE进行相应的处理。</li><li>如果业务成功，<strong>不建议直接返回COMMIT，而是建议返回UNKNOW</strong>,因为该方法尽管在方法最后一行，但可能发生断电等异常情况，数据库并没有成功。</li></ul><h5 id="3-2-2-实现-checkLocalTransaction"><a href="#3-2-2-实现-checkLocalTransaction" class="headerlink" title="3.2.2 实现 checkLocalTransaction"></a>3.2.2 实现 checkLocalTransaction</h5><p>其次需要实现事务状态回查，用来RocketMQ服务端感知事务是否成功，其实现原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210306233158471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其实现关键点如下：</p><ul><li>如果能明确得知本地事务成功，则返回COMMIT_MESSAGE</li><li>如该不能明确得知本地事务成功，<strong>不能返回ROLLBACK_MESSAGE</strong>,而是返回UNKNOW，等待服务端下一次事务回查(不会立即触发)，<strong>服务端默认回查15次，如果15次都得到UNKNOW，则会回滚该消息</strong>。</li></ul><h4 id="3-3-代码获取"><a href="#3-3-代码获取" class="headerlink" title="3.3 代码获取"></a>3.3 代码获取</h4><p>上文只是将事务消息的核心代码加以解读，并重点阐述每个步骤的<strong>实现关键点</strong>，笔者基于SpringBoot，尝试结合场景学习RocketMQ的使用技巧，<strong>其代码上传到了github仓库</strong>。<br><img src="https://img-blog.csdnimg.cn/20210307102835363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><a href="https://github.com/dingwpmz/rocketmq-learning">https://github.com/dingwpmz/rocketmq-learning</a>，期待你的<strong>Star</strong>。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、活动中心场景介绍&quot;&gt;&lt;a href=&quot;#1、活动中心场景介绍&quot; class=&quot;headerlink&quot; title=&quot;1、活动中心场景介绍&quot;&gt;&lt;/a&gt;1、活动中心场景介绍&lt;/h2&gt;&lt;p&gt;在电商系统上线初期，往往会进行一些“拉新”活动，例如活动部门提出&lt;strong&gt;新用户注册送积分、送优惠券活动&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;基于分布式、微服务的设计理念，通常的架构设计（子系统交互）如下图所示：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210306232931379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其核心系统介绍如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;账户中心&lt;br&gt;提供用户登录、用户注册等服务，一个新用户注册时，向MQ服务器中的USER_REGISTER主题发送一条消息，主流程结束，与送积分，送优惠券等过程解耦。&lt;/li&gt;
&lt;li&gt;优惠券（券系统）&lt;br&gt;提供发放优惠券、使用优惠券等与券相关的基础服务。&lt;/li&gt;
&lt;li&gt;积分中心&lt;br&gt;提供积分相关的服务，例如积分赠送、积分消费、积分查询等基础服务。&lt;/li&gt;
&lt;li&gt;送积分服务（消费者）&lt;br&gt;订阅MQ，按照规则决定是否需要赠送积分，如果需要则调用积分相关的基础接口，完成积分的发放。&lt;/li&gt;
&lt;li&gt;送优惠券（消费者）&lt;br&gt;订阅MQ，按照规则决定是否需要赠送优惠券，如果需要则调用券系统相关的基础接口，完成优惠券的发放。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面的架构设计非常优雅，但并不是无懈可击，读者们肯定会想到&lt;strong&gt;如果新用户注册成功，但消息发送到MQ失败，或者消息成功发送到MQ，但发送完MQ后系统出现异常导致用户注册失败又该如何呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的问题其实就是&lt;strong&gt;典型的分布式事务问题&lt;/strong&gt;：即如何保证&lt;strong&gt;用户注册(数据库操作)与MQ消息发送&lt;/strong&gt;这两个分布式操作的一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RocketMQ事务消息闪亮登场&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="RocketMQ" scheme="https://www.codingw.net/categories/RocketMQ/"/>
    
    
    <category term="实战" scheme="https://www.codingw.net/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="事务消息" scheme="https://www.codingw.net/tags/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>Netty进阶：手把手教你如何编写一个NIO服务端</title>
    <link href="https://www.codingw.net/posts/381d8256.html"/>
    <id>https://www.codingw.net/posts/381d8256.html</id>
    <published>2021-02-24T14:01:59.000Z</published>
    <updated>2021-03-29T04:12:10.902Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Netty是一款非常优秀的网络编程框架，是对NIO的二次封装，本文将重点剖析Netty服务端的启动流程，深入底层了解如何使用NIO编程服务端。</p><p><strong>本文是笔者基于问题的启发式源码阅读技巧的展示</strong>，建议带着如下问题开始本文的阅读：</p><ul><li>ServerBootstrap 的 option 与 childOption 分别有什么作用</li><li>服务端IO通道如何绑定事件链。</li><li>ServerBootstrap 的 handler 方法与 childHandler 方法的区别又是什么？</li><li>childHandler中的方法在服务端bind方法时会被调用吗？</li></ul><a id="more"></a><h2 id="1、Netty服务端启动示例"><a href="#1、Netty服务端启动示例" class="headerlink" title="1、Netty服务端启动示例"></a>1、Netty服务端启动示例</h2><p>基于Netty的使用示例如下：<br><img src="https://img-blog.csdnimg.cn/20210219232527622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：创建主从多Reactor线程模型的Boss线程组，通常只需要设置一个线程，用于监听客户端的连接请求(OP_ACCEPT)。</p><p>代码@2：创建主从多Reactor线程模型的Work线程组，即IO线程组，默认为CPU核数的两倍。</p><p>代码@3：创建Netty服务端启动工具类ServerBootstrap。</p><p>代码@4：调用group方法设置主从线程组。</p><p>代码@5：设置通道的类型，服务端NIO通道类型 NioServerSocketChannel。</p><p>代码@6：通过option方法为通道服务端通道选项。</p><p>代码@7：通过chiildOption方法为IO通道设置选项。</p><p>代码@8：通过ChannelInitializer添加自定义的ChannelHandler，通常包括编码解码器、业务Handler。</p><p>代码@9：调用管道的addLast添加自定义编码解码器。</p><p>代码@10：调用bind方法绑定到服务端指定接口，绑定完成后则在指点端口上监听客户端的连接。</p><p>服务端的核心流程入口为bind方法，接下来我们将详细分析其实现原理，继续体会NIO编程技巧。</p><h2 id="2、Netty服务端启动流程"><a href="#2、Netty服务端启动流程" class="headerlink" title="2、Netty服务端启动流程"></a>2、Netty服务端启动流程</h2><p>通过跟踪其bind方法，最终将进入到AbstractBootstrap的doBind方法。<br><img src="https://img-blog.csdnimg.cn/20210219234131283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其关键实现点：<br>代码@1：通过调用initAndRegister方法完成底层网络初始化与通道注册工作。<br>代码@2：如果初始化与注册工作已完成，则直接调用doBind0方法完成绑定操作。<br>代码@3：如果初始化与注册工作未完成，则通过regFuture（注册凭证）中添加监听器，等注册完成后再执行doBind0方法。</p><blockquote><p>技巧提示：基于Future异步编程，在主线程中通过调用future.isDone方法判断异步方法是否已完成，如果未完成，通过在该凭证上添加监听器（事件回调），操作完成后执行回调逻辑。</p></blockquote><p>从上面的方法来看服务端的绑定流程包<strong>含初始化与绑定两个子流程</strong>，接下来将分别深入探讨。</p><h4 id="2-1-通道初始化"><a href="#2-1-通道初始化" class="headerlink" title="2.1 通道初始化"></a>2.1 通道初始化</h4><p>基于NIO编程，需要先创建通道，然后将其注册到<strong>事件选择器</strong>，这个过程由 AbstractBootstrap 的 initAndRegister 方法实现。<br><img src="https://img-blog.csdnimg.cn/20210221201948839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>实现的关键点如下：<br>代码@1：创建NIO服务端通道实现类NioServerSocketChannel的实例。</p><p>代码@2：调用 init 方法初始化通道。</p><p>代码@3：将通道注册到事件轮询器EventLoopGroup</p><p>代码@4：:如果通道已注册，但发生了错误则调用通道close方法回收相关资源，如果未注册成功，则强制清除通道占用的资源，特别是文件占用符。</p><p>关于通道的注册逻辑已经在<a href="https://blog.csdn.net/prestigeding/article/details/112972761">手把手教你如何编写一个NIO客户端</a> 中已详细介绍，故接下来重点关注一下服务端通道的注册流程。</p><h5 id="2-1-1-服务端通道初始化流程"><a href="#2-1-1-服务端通道初始化流程" class="headerlink" title="2.1.1 服务端通道初始化流程"></a>2.1.1 服务端通道初始化流程</h5><p>AbstractBootstrap 的 init 方法是一个抽象方法，具体有其子类实现：<br><img src="https://img-blog.csdnimg.cn/20210221205105995.png#pic_center" alt="在这里插入图片描述"><br>服务端通道的初始化代码由ServerBootstrap的init方法。<br><img src="https://img-blog.csdnimg.cn/20210221205717118.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：首先将通过ServerBootstrap设置的选项与附加选项初始化到通道中。<br><img src="https://img-blog.csdnimg.cn/20210221210646200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step2：<strong>init 方法的关键点</strong>：将 handler 方法设置的事件链，同时新增  <strong>ServerBootstrapAcceptor</strong>  事件处理方法加入到 NioServerSocketChannel 的事件链，但并没有把 childHandler 中添加的事件链添加到NioServerSocketChannel。</p><p><strong>读者朋友们，请停下来思考一下，为什么会这样？从现在可以肯定的是 handler 方法定义的事件处理方法将在与 NioServerSocketChannel 相关的事件发生时其作用。</strong></p><p>要解开这个谜题，我们有必要来看看 ServerBootstrapAcceptor 是如何工作的。</p><h5 id="2-1-2-ServerBootstrapAcceptor-详解"><a href="#2-1-2-ServerBootstrapAcceptor-详解" class="headerlink" title="2.1.2 ServerBootstrapAcceptor 详解"></a>2.1.2 ServerBootstrapAcceptor 详解</h5><p>ServerBootstrapAcceptor 类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20210221212042124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>ServerBootstrapAcceptor方法只实现了inbound事件的channelRead事件。在详细探究它之前先看看属性：</p><ul><li>EventLoopGroup childGroup<br>事件执行器组，ServerBootstrap设置的从Reactor线程组，即Work线程组。</li><li>ChannelHandler childHandler<br>ServerBootstrap#childHandler 设置的事件处理器，也就是用户定义的事件处理器。</li></ul><p>接下来探究其 channelRead 方法的实现逻辑：<br><img src="https://img-blog.csdnimg.cn/20210221213106700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：channelRead竟然传入的是一个Channel，那这个Channel对象是NioSocketChannel吗？</p><p>是的，原来当 OP_ACCEPT 事件触发后，Server端会通过调用ServerSocketChannel 的 accept()方法，将返回一个 NioSocketChannel，读写操作的载体，在NIO中负责数据的读写。</p><p>Step2：将通过 childHandler 定义的事件处理器绑定到 NioSocketChannel。</p><p>最终完成 NioServerSocketChannel 与 NioSocketChannel 的初始化与事件绑定。</p><p>关于 NioSocketChannel 详细的初始化流程蕴含在 ChannelInitializer，其机制已经在 <a href="https://blog.csdn.net/prestigeding/article/details/112972761">手把手教你如何编写一个NIO客户端</a>  中详细介绍。</p><h4 id="2-2-NIO绑定机制"><a href="#2-2-NIO绑定机制" class="headerlink" title="2.2 NIO绑定机制"></a>2.2 NIO绑定机制</h4><p>在通道完成初始化与注册后，服务端需要进行端口绑定，由 AbstractBootstrap 的 doBind0 方法实现。<br><img src="https://img-blog.csdnimg.cn/20210221230446368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>bind 的核心实现最终是调用 Channel 的 bind 方法，最终由 AbstractChannel 类实现：<br><img src="https://img-blog.csdnimg.cn/20210221230647160.png#pic_center" alt="在这里插入图片描述"><br>bind事件将传播，根据Netty事件传播机制，bind 属于 ChannelOutbound事件，最终将调用 HeadContext的bind方法，最终将调用Unsafe的bind方法，更加具体是调用 AbstractChannel的内部类AbstractUnsafe的bind方法，其代码如下所示：<br><img src="https://img-blog.csdnimg.cn/20210221231103221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>doBind 方法是一个抽象方法，NIO服务端的实现：NioServerSocketChannel。<br><img src="https://img-blog.csdnimg.cn/20210221231251135.png" alt="在这里插入图片描述"><br>即最终通过调用NIO底层NioServerSocketChannel 的 bind 方法完成服务端通道的绑定操作，即实现服务端在特定端口监听客户客户端的连接请求。</p><p><strong>行文至此开头部门提出的问题大家都能解答了不</strong>，为了倒逼读者朋友门真正能理解开头部分的问题，<strong>建议读者进行总结，真正做到带着问题阅读源码</strong>，当然可以加笔者私信：dingwpmz，共同交流探讨。</p><hr><p>欢迎加笔者微信号(<strong>dingwpmz</strong>)，拉您如技术交流加群探讨，关注『中间件兴趣圈』回复<strong>【PDF】</strong>可获取海量学习资料。<br><img src="https://img-blog.csdnimg.cn/20210101213844526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty是一款非常优秀的网络编程框架，是对NIO的二次封装，本文将重点剖析Netty服务端的启动流程，深入底层了解如何使用NIO编程服务端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文是笔者基于问题的启发式源码阅读技巧的展示&lt;/strong&gt;，建议带着如下问题开始本文的阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ServerBootstrap 的 option 与 childOption 分别有什么作用&lt;/li&gt;
&lt;li&gt;服务端IO通道如何绑定事件链。&lt;/li&gt;
&lt;li&gt;ServerBootstrap 的 handler 方法与 childHandler 方法的区别又是什么？&lt;/li&gt;
&lt;li&gt;childHandler中的方法在服务端bind方法时会被调用吗？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Netty4" scheme="https://www.codingw.net/categories/Netty4/"/>
    
    
    <category term="Netty4" scheme="https://www.codingw.net/tags/Netty4/"/>
    
  </entry>
  
  <entry>
    <title>面试时遇到一致性哈希算法这样回答会让面试官眼前一亮</title>
    <link href="https://www.codingw.net/posts/ea6d8964.html"/>
    <id>https://www.codingw.net/posts/ea6d8964.html</id>
    <published>2021-02-02T14:39:36.000Z</published>
    <updated>2021-03-29T04:10:10.594Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>面试中一致性哈希算法被问到的概率非常大，本文将从如下三个方面探探一致性哈希算法，让大家轻松应对面试，并且说出宇宙不同的答案。</p><ul><li>一致性哈希算法经典实用场景</li><li>一致性哈希算法通常不适合用于服务类负载均衡</li><li>面试应对之策</li></ul><a id="more"></a><h2 id="1、一致性哈希算法经典使用场景"><a href="#1、一致性哈希算法经典使用场景" class="headerlink" title="1、一致性哈希算法经典使用场景"></a>1、一致性哈希算法经典使用场景</h2><p>在数据库存储领域如果单表数据量很大，通常会采用分库分表，同样在缓存领域同样需要分库，下面以一个非常常见的Redis分库架构为例进行阐述。<br><img src="https://img-blog.csdnimg.cn/20210131165549182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>将上述3个Redis节点称之为分片，每一个节点存储部分数据，期间需要使用负载均衡算法，将数据尽量分摊到各个节点，充分发挥分布式的优势，提升系统缓存访问的性能。</p><p>在分布缓存领域，对数据存在新增与查询，即数据通过路由算法存储在某一个节点后，查询时需要尽量路由到同一个节点，否则会出现查询未命中缓存的情况，<strong>这也是与分布式服务调用领域的负载算法一个不同点。</strong></p><p>分布式缓存存储类领域的负载均衡算法通常会使用某一个字段当<strong>分片键</strong>，在进行负载之前先求出分片字段对应的HashCode，然后与当前的节点数取模。**即 hashcode(分片键) % 节点总数(分片总数)**。</p><h4 id="1-1-在分布式缓存领域上述算法的弊端"><a href="#1-1-在分布式缓存领域上述算法的弊端" class="headerlink" title="1.1 在分布式缓存领域上述算法的弊端"></a>1.1 在分布式缓存领域上述算法的弊端</h4><p>先哈希再驱魔实现起来简单高效，但在分布式缓存领域存在一个<strong>致命的痛点</strong>，对扩容、缩容不友好，会降低缓存的命中率。</p><p>因扩容引起的数据命中率问题示意图如下：<br><img src="https://img-blog.csdnimg.cn/20210131165606197.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>例如当前集群中由3个节点存储，例如现在向集群中写入6个数据，其分片键的hashcode为1-6，数据的分布情况如上述所示，但由于随着业务的急剧增长，3台redis已经无法满足业务的需求，项目组决定对其进行扩容，从原先的3台扩容到4台，这个时候项目组尝试去缓存中查找 k1,k2,k3,k4,k5,k6时会出现什么问题？</p><p>根据 hashcode 再取模的方式，由于数量从3台到4台，经路由算法路由后，k4 会尝试从3.169的机器去查找，但对应的数据却存储在3.166上，以上面6个key的命中来看，只有50%的命中率，扩容后带来<strong>缓存穿透</strong>，大量数据进入到后台数据库。</p><p>在数据存储领域的第一种解决方案：<strong>成倍扩容</strong>。将原来的3个节点数量扩充倍，新增加的第一台数据来源于第一台，以此类推，第6台的数据来源于第3台，这样k6经过新的负载均衡算法会落到第6台，数据原本存在于第3台，而第6台的数据来源于第3台，这样避免了<strong>缓存穿透</strong>。</p><p><strong>成倍扩容能有效解决扩容后带来的缓存穿透问题，但这样做会造成资源的浪费</strong>，有没有其他更好的方法呢？</p><p>一致性哈希算法闪亮登场。</p><h4 id="1-2-一致性哈希算法"><a href="#1-2-一致性哈希算法" class="headerlink" title="1.2 一致性哈希算法"></a>1.2 一致性哈希算法</h4><p>一致性哈希算法</p><p>一致性哈希算法的设计理念如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210131165623526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先将哈希值映射到 0 ~ 2的32次方的一个圆中，然后将实际的物理节点的IP地址或取其hash值，放入到hash环中。</p><p><strong>然后对需要插入的数据先求哈希，再顺时针沿着哈希环，找到第一个实际节点，数据将存储到该实际节点上。</strong></p><p>扩容后的示例图：<br><img src="https://img-blog.csdnimg.cn/20210131165643642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从中可以看到受影响的范围能控制在两个节点的hashcode之间的部分数据，比起先哈希再取模，其未命中率将会得到极大的影响。</p><p>但一致性哈希算法要得到较好的效果，取决于各个实体节点在哈希环的分布情况，是否能分散，例如如下分布则会大打折扣：<br><img src="https://img-blog.csdnimg.cn/20210131165656914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这种情况会造成数据分布不均衡，为了解决数据很可能分布不均匀的情况，对一致性哈希算法，提出了改进，引入了虚拟节点的，可以设置一个哈希环中存在多少个虚拟节点，然后将虚拟节点映射到实体节点，从而解决数据分布吧均衡的问题。<br><img src="https://img-blog.csdnimg.cn/20210131165708941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这样通过为不同的的实际节点映射不同的虚拟节点，实现数据的均匀分布，并且扩容或缩容时并不会出现大面积的缓存穿透。</p><blockquote><p>温馨提示：上述的映射只是一个理想状态，其核心思路是为每一个实体节点创建多个虚拟节点，并且核心虚拟节点的Hash值越分散越好。</p></blockquote><p>大家可以思考一下，如何用JAVA来实现一致性哈希算法？</p><p>一致性哈希算法的两个关键：</p><ul><li><p>顺时针选择节点<br>可以使用TreeMap，一来具备排序功能，天然提供了相应的方法获取顺时针的一个元素。<br><strong>TreeMap 的 ceilingEntry()方法</strong>用于返回与大于或等于给定键元素(ele)的最小键元素链接的键值对。</p></li><li><p>虚拟节点如何生成分散的哈希值<br>生成分散的哈希值，通常可以基于md5加密算法来实现。<br><img src="https://img-blog.csdnimg.cn/20210131165728345.png#pic_center" alt="在这里插入图片描述"></p><h2 id="2、一致性哈希算法被“滥用”"><a href="#2、一致性哈希算法被“滥用”" class="headerlink" title="2、一致性哈希算法被“滥用”"></a>2、一致性哈希算法被“滥用”</h2></li></ul><p>一致性哈希算法在面对分布式缓存有着得天独厚的优势，因为它的产生就是为了解决分布式缓存扩容、缩容带来的缓存穿透问题。但现在一致性在分布式服务调用的负载算法竟然也引入了一致性哈希算法。</p><p>在Dubbo中为了实现客户端在服务调用时对服务提供者进行负载均衡，官方也提供了一致性哈希算法；在RocketMQ集群消费模式时消费队列的负载均衡机制竟然也实现了一致性哈希算法，<strong>但我觉得一致性哈希算法在这些领域完全无法发挥其他优势，比轮循、加权轮循、随机、加权随机算法等负载均衡算法相比，实现复杂，性能低下，运维管理复杂</strong>。</p><p>因为在服务调用等负载均衡算法，<strong>多次服务调用之间关联性不太强</strong>，在服务端扩容、缩容后，对于客户端来说其实并不关心路由到哪台服务器，其关心的是能否返回一台服务器即可。</p><h2 id="3、面试应对之策"><a href="#3、面试应对之策" class="headerlink" title="3、面试应对之策"></a>3、面试应对之策</h2><p>在面试过程中，遇到一致性哈希算的时候，尽量能从其使用场景：<strong>分布式缓存负载均衡</strong>，特别是突出<strong>扩容、缩容能有效避免缓存穿透的问题</strong>。同时需要阐述一致性哈希算法的缺陷以及其应对策略(虚拟节点)。</p><p>聊的差不多可以顺便提一下阅读过一致性哈希算法的源码：强调TreeMap与虚拟节点哈希值的生成方法。</p><p>最后可以尝试引导面试官聊聊现在一致性哈希算法有点被滥用的嫌疑，在轻松愉快的讨论中与面试交流技术，面试官好评度蹭蹭往上涨。</p><hr><p>欢迎加笔者微信号(<strong>dingwpmz</strong>)，拉您如技术交流加群探讨，关注『中间件兴趣圈』回复<strong>【PDF】</strong>可获取海量学习资料。<br><img src="https://img-blog.csdnimg.cn/20210101213844526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;面试中一致性哈希算法被问到的概率非常大，本文将从如下三个方面探探一致性哈希算法，让大家轻松应对面试，并且说出宇宙不同的答案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性哈希算法经典实用场景&lt;/li&gt;
&lt;li&gt;一致性哈希算法通常不适合用于服务类负载均衡&lt;/li&gt;
&lt;li&gt;面试应对之策&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="面试" scheme="https://www.codingw.net/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="面试" scheme="https://www.codingw.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Netty进阶：手把手教你如何编写一个NIO客户端</title>
    <link href="https://www.codingw.net/posts/76ab8a6b.html"/>
    <id>https://www.codingw.net/posts/76ab8a6b.html</id>
    <published>2021-01-27T14:47:09.000Z</published>
    <updated>2021-03-29T04:07:45.953Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Netty是一款非常优秀的网络编程框架，是对NIO的二次封装，本文将重点剖析Netty客户端的启动流程，深入底层了解如何使用NIO编程客户端。</p><p>本文是笔者<strong>基于问题的启发式源码阅读技巧的展示</strong>，请带着如下问题开始本文的阅读：</p><ul><li>Netty是如何将客户端的事件加入到事件链中？</li><li>Netty客户端在启动时需要注册读事件？</li><li>Netty客户端在启动时需要注册写事件？</li><li>如果让你基于NIO写一个客户端需要实现的关键点是什么呢？</li></ul><p><strong>上面的问题也可以这样问：在使用NIO实现客户端时该注册哪些事件？</strong></p><p>本节将详细学习Netty4客户端的启动流程，我们从一个Netty客户端使用示例入手。</p><a id="more"></a><h2 id="1、Netty-客户端示例"><a href="#1、Netty-客户端示例" class="headerlink" title="1、Netty 客户端示例"></a>1、Netty 客户端示例</h2><p>Netty客户端示例如下：<br><img src="https://img-blog.csdnimg.cn/20210121213057784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对上面的步骤一一说明如下：<br>代码@1：创建 NIO EventLoopGroup，NIO 事件轮询器。</p><p>代码@2：创建Bootstrap实例，Netty提供的客户端操作工具类。</p><p>代码@3：指定创建 Channel 类型，客户端是 NioSocketChannel。</p><p>代码@4：通过option方法设置网络相关属性，可多次调用。</p><p>代码@5：通过调用 handler 方法添加客户端的事件处理器链。具体使用匿名类 ChannelInitializer，事件处理器链中通常会包含<strong>编码器</strong>、<strong>解码器</strong>、<strong>业务处理Handler</strong>(业务处理的入口)。</p><p>代码@6：调用 connect 方法异步建立连接。通过调用sync()方法转同步调用，等连接成功建立后才返回。</p><p>代码@7：创建一个Close Future，并且同步等待关闭事件的到达。</p><p>代码@8：安全优雅的关闭事件线程组。在具体事件过程中并不会这么使用，而是会将连接进行缓存，例如使用一个Map按IP进行缓存，发往同一个IP的请求使用同一条连接，在需要断开连接时再调用方法。</p><blockquote><p>温馨提示：上述只是Demo级的示例，但不影响对本文的探讨，后续会给出工业级的Netty使用实战。</p></blockquote><h2 id="2、Netty客户端启动流程"><a href="#2、Netty客户端启动流程" class="headerlink" title="2、Netty客户端启动流程"></a>2、Netty客户端启动流程</h2><p>本文试图揭晓Netty客户端的启动流程，让大家从底层彻底掌握其实现细节，便于更好的使用Netty，特别是对应排障起到一个很好的技能储备。</p><p>Netty 客户端的启动流程入口：<br><img src="https://img-blog.csdnimg.cn/20210121214929305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其最终调用其 doConnect 方法。<br><img src="https://img-blog.csdnimg.cn/20210121223152756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：调用 initAndRegister 初始化和注册到事件选择器，可联想 NIO 中通道创建后需要注册读写事件，这里就是需要将通道注册到事件选择器，稍后会重点介绍。</p><p>代码@2：initAndRegister 采用了异步机制，更确切是采用了 Future模式。如果已经完成则直接调用 doConnect0 方法执行连接。</p><p>代码@3：否则在 Future 上注册事件监听器，等注册成功后再进行调用连接。</p><p>接下来会对上面两个重要步骤进行详细介绍，<strong>这里给我们使用 Future 模式提供了很好的示例</strong>。</p><h4 id="2-1-通道注册"><a href="#2-1-通道注册" class="headerlink" title="2.1 通道注册"></a>2.1 通道注册</h4><p>客户端在连接之前需要先将通道注册到事件选择器(Selector)中，具体事项如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210121224450572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>关键如下：<br>代码@1：调用 init 方法对通过进行初始化，稍后详细介绍。<br>代码@2：将通过注册到事件轮询器中。</p><h5 id="2-1-1-通道初始化"><a href="#2-1-1-通道初始化" class="headerlink" title="2.1.1 通道初始化"></a>2.1.1 通道初始化</h5><p>通道初始化其代码如下：<br><img src="https://img-blog.csdnimg.cn/20210121225407845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：将用户定义的Handler加入到事件处理器链(ChannelPipeline)，这里非常关键：客户端在启动时我们是通过 Bootstrap 的 handler 方法设置事件链。<br>代码@2、3主要是设置网络选项、属性。</p><p><strong>思考题：Netty是如何将客户端定义的多个Handler加入到事件链中呢？</strong></p><p>这个问题其实的<strong>本质</strong>是用户自定义的 <strong>ChannelInitializer 的 initChannel 方法</strong>在什么时候调用。</p><p>要解开该问题，我们就需要来看一下 ChannelInitializer。<br><img src="https://img-blog.csdnimg.cn/20210121231001723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上面图的几个关键点：</p><ul><li>将Handler 加入到 ChannelPipeline 时其 handlerAdded 方法会被调用，其逻辑是如果该通道已经被注册到事件处理器则调用 initChannel 方法。</li><li>通道被注册到事件选择器(Selector)时会调用。</li><li>initChannel 方法支持幂等，保证一个通道的 initChannel 方法不会被多次调用。</li></ul><h5 id="2-1-2-通道注册"><a href="#2-1-2-通道注册" class="headerlink" title="2.1.2 通道注册"></a>2.1.2 通道注册</h5><p>通道注册的入口方法：SingleThreadEventLoop。<br><img src="https://img-blog.csdnimg.cn/20210121232021382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>NIO 的最终入口为 AbstractChannel 的内部类 AbstractUnsafe 的 register 的方法。<br><img src="https://img-blog.csdnimg.cn/20210123215108397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这里无不透漏着Netty一个非常重要的编程技巧：一个通道会持有一个事件选择器(EventLoop)，如果调用通道的方法的线程不是EventLoop，则会把任务提交到EventLoop中执行。</strong></p><p>接下来重点看一下register0 方法，非常关键的一个方法。<br><img src="https://img-blog.csdnimg.cn/20210123221908421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：进行底层NIO层面的注册，最终调用 AbstractNio 的 doRegister。<br><img src="https://img-blog.csdnimg.cn/2021012322573249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>注意：通道注册，其注册的OP为0，并没有关注任何的事件(读、写等)**，</strong>那问题来了，读写等事件在什么时候注册呢？**</p><p>代码@2：触发 handlerAdd 事件，因为在介绍ChannelInitializer handlerAdd事件执行的条件是通道已注册，如果未注册会将任务先挂起，这里就是触发其执行。</p><p>代码@3：传播通道注册事件，即在调用底层 NIO 的 register 方法将通道注册到事件选择器(Selector)后传播注册事件。</p><p>代码@4：如果通道激活并且是首次注册，则传播通道<strong>激活事件</strong>。</p><p>代码@5：如果通道不是首次注册并且开启了<strong>自动注册读事件</strong>，则自动为通道注册读事件。beginRead 方法最终会调用 AbstractNioChannel 的如下方法，底层使用了NIO的 selectionKey.interestOps 方法。<br><img src="https://img-blog.csdnimg.cn/20210123230411135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>通道的注册流程就介绍到这里了。</p><p><strong>在NIO中，如果不注册读事件，不会从底层网络中读取数据，则对应客户端来说就不会去处理响应包，相对服务端来说不会去解析请求包，也就是无法完成请求与响应，故在NIO编程中，通道必须注册读事件。</strong></p><p>注册的逻辑就基本完成了，那问题来了，虽然开启了自动注册读事件，但初次注册时只是传播了channelActive事件，那在何时会注册读事件呢？</p><p>原理在传播 channelActive 事件后，在开启了自动注册读事件后自动注册读事件，其代码在 DefaultChannelPipeline 中内部类 HeadContext 的 channelActive 方法，其代码截图如下：<br><img src="https://img-blog.csdnimg.cn/20210123231714544.png#pic_center" alt="在这里插入图片描述"></p><h4 id="2-2-连接服务端"><a href="#2-2-连接服务端" class="headerlink" title="2.2 连接服务端"></a>2.2 连接服务端</h4><p>在来看一下客户端的启动核心方法：<br><img src="https://img-blog.csdnimg.cn/20210121223152756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在完成了通道的初始化并注册到事件选择器后，接下来就需要向服务端发起连接操作，最终调用 doConnect0 方法，其基本的调用链如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210123233327899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>故接下来我们重点从 AbstractNioUnsafe 的 connect 方法进行深入追踪。<br><img src="https://img-blog.csdnimg.cn/2021012323434047.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上面的方法几个关键点如下：</p><ul><li>获取通道是否激活。</li><li>调用内部的doConnect 完成连接，将调用底层NIO相关的方法，从该方法可以学习如何编写NIO的连接代码，稍后会详细介绍。</li><li>由于NIO都是非阻塞的，<strong>doConnect</strong> 方法返回后并不代表通道已成功连接到服务端，故需要开启一个定时任务进行跟踪(<strong>连接超时时间</strong>)。</li></ul><p>接下来我们详细介绍一下如何使用NIO编写连接代码。<br><img src="https://img-blog.csdnimg.cn/20210123235116476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：客户端连接服务端，通常是采用随机端口，当如果需要绑定到指定端口，调用 SocketChannel 的 bind 方法即可。</p><p>代码@2：调用底层 NIO 的 connect 方法，注意该方法并不会阻塞，返回成功表示连接建立成功；返回 false 表示还在连接中。</p><p>代码@3：如果是连接中，则注册OP_CONNECT事件，等连接成功后会收到对应的事件。</p><p>注册 OP_CONNECT 事件后，在事件选择器 NioEventLoop 的事件处理流程中会专门处理 OP_CONNECT 事件：<br><img src="https://img-blog.csdnimg.cn/20210123235729734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>NIO模式代码最终调用 NioSocketChannel 的 doFinishConnect 方法：<br><img src="https://img-blog.csdnimg.cn/20210124104542925.png#pic_center" alt="在这里插入图片描述"><br>该方法通道在非阻塞模式下，如果连接未成功建立会返回false，由于这里是基于事件选择的，是在连接成功创建后才会触发，故这里只是简单的进行校验连接是否成功建立。</p><p>最后通道成功建立，需要触发通道激活事件，见下图所示：<br><img src="https://img-blog.csdnimg.cn/20210124105235773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="AbstractNioChannel#fulfillConnectPromise"><br><strong>行文至此开头部门提出的问题都得到了针对性的解答</strong>，为了倒逼读者朋友门真正能理解开头部分的问题，<strong>建议读者进行总结，真正做到带着问题阅读源码</strong>，当然可以加笔者私信：dingwpmz，共同交流探讨。</p><hr><p>欢迎加笔者微信号(<strong>dingwpmz</strong>)，拉您如技术交流加群探讨，关注『中间件兴趣圈』回复<strong>【PDF】</strong>可获取海量学习资料。<br><img src="https://img-blog.csdnimg.cn/20210101213844526.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Netty是一款非常优秀的网络编程框架，是对NIO的二次封装，本文将重点剖析Netty客户端的启动流程，深入底层了解如何使用NIO编程客户端。&lt;/p&gt;
&lt;p&gt;本文是笔者&lt;strong&gt;基于问题的启发式源码阅读技巧的展示&lt;/strong&gt;，请带着如下问题开始本文的阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Netty是如何将客户端的事件加入到事件链中？&lt;/li&gt;
&lt;li&gt;Netty客户端在启动时需要注册读事件？&lt;/li&gt;
&lt;li&gt;Netty客户端在启动时需要注册写事件？&lt;/li&gt;
&lt;li&gt;如果让你基于NIO写一个客户端需要实现的关键点是什么呢？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;上面的问题也可以这样问：在使用NIO实现客户端时该注册哪些事件？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本节将详细学习Netty4客户端的启动流程，我们从一个Netty客户端使用示例入手。&lt;/p&gt;</summary>
    
    
    
    <category term="Netty4" scheme="https://www.codingw.net/categories/Netty4/"/>
    
    
    <category term="Netty4" scheme="https://www.codingw.net/tags/Netty4/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo的设计理念原来就藏在这三张图中</title>
    <link href="https://www.codingw.net/posts/2e7bc25b.html"/>
    <id>https://www.codingw.net/posts/2e7bc25b.html</id>
    <published>2021-01-17T12:53:08.000Z</published>
    <updated>2021-01-17T12:54:07.042Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Dubbo在众多的微服务框架中脱颖而出，占据RPC服务框架的半壁江山，非常具有普适性，熟练掌握 Dubbo的应用技巧后深刻理解其内部实现原理，让大家能更好的掌控工作，助力职场，特别能让大家在面试中脱颖而出。</p><p>那Dubbo内部的设计理念，实现原理是什么呢？</p><p>本文将结合官方提供的3张图，从如下三个方面介绍其内部的核心实现、以及如何指导实践。</p><a id="more"></a><h2 id="1、服务注册与发现机制"><a href="#1、服务注册与发现机制" class="headerlink" title="1、服务注册与发现机制"></a>1、服务注册与发现机制</h2><p>Dubbo的服务注册与发现机制如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210116210800489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在Dubbo中存在4类角色：</p><ul><li>Registry<br>注册中心。</li><li>Consumer<br>服务调用者、消费端。</li><li>Provider<br>服务提供者。</li><li>Monitor<br>监控中心。</li></ul><p>具体的交互流程包括如下关键步骤：</p><ol><li>服务提供者在启动的时候向注册中心进行注册。</li><li>消息消费者在启动的时候向注册中心订阅指定服务，注册中心将以某种机制（推或拉）模式告知消费端服务提供者列表。</li><li>当服务提供者数量变化（服务提供者扩容、缩容、宕机等因素），注册中心需要以某种方式(推或拉)告知消费端，以便消费端进行正常的负载均衡。</li><li>服务提供者、服务消费者向监控中心汇报TPS等调用数据，以便监控中心进行可视化展示等。</li></ol><p>Dubbo官方提供了多种注册中心，接下来将以使用最为普遍的Zookeeper进一步介绍注册中心的原理。</p><p>首先我们来看一下Zookeeper注册中心中的数据存储目录结构，从目录结构来窥探其实现机制。<br><img src="https://img-blog.csdnimg.cn/20210116210830727.png#pic_center" alt="在这里插入图片描述"><br>Dubbo Zookeeper注册中心，其目录组织结构为 /dubbo/{ServiceName}，再每一个服务名称下会有4个目录：</p><ul><li>providers<br>服务提供者列表。</li><li>consumers<br>消费者列表</li><li>routers<br>路由规则列表，关于一个服务可以设置多个路由规则。</li><li>configurators<br>动态配置条目。在Dubbo中可以在不重启消费者、服务提供者的前提下动态修改服务提供者、服务消费者的配置，例如修改线程的数量，超时时间等参数。</li></ul><p>基于Zookeeper注册中心的实现细节如下：</p><ol><li>服务提供者启动时会向注册中心注册，主要是在对应服务的providers目录下增加一条记录(<strong>临时节点</strong>)，同时监听 configurators节点。</li><li>服务消费者启动时会向注册中心订阅，主要是在对应服务的consumers目录下增加一条记录(<strong>临时节点</strong>)，同时监听 configurators、routers 目录。</li><li>由于当有新的服务提供者上线后 providers 目录会增加一条记录，消费者能立马收到一个服务提供者列表变化的通知，得以将最新的服务提供者列表推送给服务调用方(消费端)；如果一个服务提供者宕机，由于创建的节点是临时节点，Zookeeper会将该节点移除，同样会触发事件，消费端得知最新的服务提供者列表，从而实现路由的动态注册与发现。</li><li>当Dubbo新版本上线后，如果需要进行灰度发布，可以通过dubbo-admin等管理平台添加路由规则，最终会写入到指定服务的router节点(持久节点)，服务调用方会监听该节点的变化，从而感知最新的路由规则，将其用于服务提供者的筛选，从而实现灰度发布等功能。</li><li>configurators 节点的运作机制与 router 节点一样，就不重复介绍。</li></ol><p><strong>扩展思考</strong>：</p><p>1、如果注册中心全部宕机，对整个服务体系会有什么影响？</p><p>如果整个注册中心全部宕机，整个<strong>服务调用</strong>能正常工作，不会影响现有的服务消费者调用，但消费端无法发现新注册的服务提供者。</p><p>2、如果注册中心内存溢出或频繁发生 Full Gc，对整个集群又会带来什么影响呢？</p><p>如果频繁发生Full GC，并且如果Full GC的时间超过了Zookeeper会话的过期时间，将会造成<strong>非常严重的影响</strong>，会触发所有临时节点被删除，消费端将无法感知服务提供者的存在，影响服务调用，将大面积抛出 No provider 等错误。<strong>正所谓成也临时节点、败也临时节点</strong>。</p><p><strong>为了避免Full Gc带来的严重后果，用于Dubbo注册中心的Zookeeper，一定会要独享，并及时做好内存、CPU等的监控与告警。</strong></p><h2 id="2、服务调用"><a href="#2、服务调用" class="headerlink" title="2、服务调用"></a>2、服务调用</h2><p>Dubbo的服务调用设计十分优雅，其实现原理如下图所示：<br><img src="https://img-blog.csdnimg.cn/20210116210853206.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>服务调用，重点阐述客户端发起一个RPC服务调用时的所有实现细节，包括<strong>服务发现</strong>、<strong>故障转移</strong>、<strong>路由转发</strong>、<strong>负载均衡</strong>等方面，是Dubbo实现灰度发布的理论基础。</p><h4 id="2-1-服务发现"><a href="#2-1-服务发现" class="headerlink" title="2.1 服务发现"></a>2.1 服务发现</h4><p>客户端在向服务端发起请求时，首先需要知道的是当前有哪些可用的服务提供者，通常有两种服务发现机制：</p><ul><li><p>静态化配置<br>不妨回想一下，在Dubbo等微服务框架出现之前，一个模块调用另外一个模块通常的做法是使用一个配置文件，将服务提供的列表配置配置在配置文件中，客户端从按照配置文件中的列表进行沦陷。</p><p>其<strong>弊端</strong>也非常明显：如果需要调用的服务众多，配置文件会变得臃肿，对扩容缩容的管理、机器宕机等变更不友好，管理非常困难。</p></li><li><p>动态发现</p><p>通常基于注册中心实现服务的注册与动态发现，由于上文已详细介绍，在这里就不累述。</p></li></ul><h4 id="2-2-负载均衡"><a href="#2-2-负载均衡" class="headerlink" title="2.2 负载均衡"></a>2.2 负载均衡</h4><p>客户端通过服务发现机制，能动态发现当前存活的服务提供者列表，接下来要考虑的是如果从服务提供者列表中选择一个服务提供者发起调用，这就是所谓的<strong>负载均衡</strong>，即 LoadBalance。</p><p>在Dubbo中默认提供了随机、加权随机、最少活跃连接、一致性Hash等负载均衡算法。</p><h4 id="2-3-路由机制"><a href="#2-3-路由机制" class="headerlink" title="2.3 路由机制"></a>2.3 路由机制</h4><p>其实Dubbo中不仅提供了负载均衡机制，还提供了智能路由机制，这是实现<strong>Dubbo灰度发布</strong>的理论基础。</p><p>所谓的路由机制，是在服务提供者列表中，再设置一定的规则，进行过滤选择，负载均衡时只从路由过滤规则筛选出来的服务提供者列表中选择，为了更加形象的阐述路由机制的工作原理，给出如下示意图：<br><img src="https://img-blog.csdnimg.cn/20210116210919335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述设置了一条路由规则，即查询机构ID为102的查询用户请求信息，请发送到新版本，即192168.3.102上，那主要在进行负载均衡之前先执行路由规则，从原始的服务提供者列表者按照路由规则进行过滤，从中挑选出符合要求的提供者列表，然后再进行负载均衡。</p><p><strong>路由机制的核心理念</strong>：在进行<strong>负载均衡之前</strong>先对<strong>服务提供者列表</strong>运用<strong>路由规则</strong>，得出一个参与负载均衡的提供者列表。</p><h4 id="2-4-故障转移"><a href="#2-4-故障转移" class="headerlink" title="2.4 故障转移"></a>2.4 故障转移</h4><p>远程服务调用通常涉及到网络等因素，客户端向服务提供者发起RPC请求调用时并不一定100%成功，当调用失败后该采用何种策略呢？</p><p>Dubbo提供了如下策略：</p><ul><li><p>failover<br>失败后选择另外一台服务提供者进行重试，重试次数可配置，通常适合<strong>实现幂等服务的场景</strong>。</p></li><li><p>failfast</p><p>快速失败，失败后立即返回错误。</p></li><li><p>failsafe<br>调用失败后打印错误日志，返回成功，通常<strong>用于记录审计日志等场景</strong>。</p></li><li><p>failback<br>调用失败后，返回成功，但会在后台定时无限次重试，重启后不再重试。</p></li><li><p>forking<br>并发调用，收到第一个响应结果后返回给客户端。通常适合<strong>实时性要求比较高的场景</strong>，但浪费服务器资源，通常可以通过forks参数设置并发调用度。</p></li></ul><h2 id="3、线程派发机制"><a href="#3、线程派发机制" class="headerlink" title="3、线程派发机制"></a>3、线程派发机制</h2><p>Dubbo的通信线程模型入下图所示：<br><img src="https://img-blog.csdnimg.cn/20210116210947560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="3-1-网络通信协议"><a href="#3-1-网络通信协议" class="headerlink" title="3.1 网络通信协议"></a>3.1 网络通信协议</h4><p>网络传输通常需要自定义通信协议，通常采用 <strong>Header + Body 的协议设计理念</strong>，并且 Header 长度固定，并且包含一个长度字段，用于记录整个协议包的大小。</p><p>网络传输为了提高传输效率，可以采取对传输数据进行压缩，通常是对 body 进行序列化与压缩。</p><p>Dubbo支持目前支持 java、compactedjava、nativejava、fastjson、fst、hessian2、kryo等序列化协议。</p><h4 id="3-2-线程派发机制"><a href="#3-2-线程派发机制" class="headerlink" title="3.2 线程派发机制"></a>3.2 线程派发机制</h4><p>在Dubbo中默认会创建200个线程用于处理业务方法，所谓的线程派发机制就是IO线程如何决定何种请求转发到哪类线程中执行。</p><p>目前Dubbo中<strong>所有的心跳包、网络读写在IO线程中执行</strong>，无法通过配置进行修改。</p><p>Dubbo提供了如下几种线程派发机制(Dispatcher)：</p><ul><li><p>all<br>所有的请求转发到业务线程池中执行（除IO读写、心跳包）</p></li><li><p>message<br>只有请求事件在线程池中执行，其他在IO线程上执行。</p></li><li><p>connection<br>请求事件在线程池中执行，<strong>连接、断开连接事件排队执行（含一个线程的线程池）</strong>。</p></li><li><p>direct</p><p>所有请求直接在IO线程中执行。</p></li></ul><blockquote><p>温馨提示：有关线程模型，网络通信模式，可以参考笔者如下这篇文章。</p></blockquote><p>线程派发机制之所有会有多种策略，主要是考虑<strong>线程切换</strong>带来的开销是否能容忍，即线程切换带来的开销小于多线程处理带来的提升。</p><p>例如在Dubbo中，对心跳包只需直接返回PONG包（OK），逻辑非常简单，如果将其转换到业务线程池，并不能带来性能提升，反而因为需要线程切换，带来性能损耗，故在IO线程中直接发送响应包是一个非常可取的做法。</p><p>在网络编程中需要遵循一条<strong>最佳实践</strong>：<strong>IO线程中不能有阻塞操作，阻塞操作需要转发到业务线程池</strong>。</p><hr><p>欢迎关注『中间件兴趣圈』，回复【专栏】获取12个JAVA主流中间件的源码剖析专栏，回复PDF可以获取海量学习资源，快速进阶打怪，实现职场的突破。<br><img src="https://img-blog.csdnimg.cn/20210117195147360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dubbo在众多的微服务框架中脱颖而出，占据RPC服务框架的半壁江山，非常具有普适性，熟练掌握 Dubbo的应用技巧后深刻理解其内部实现原理，让大家能更好的掌控工作，助力职场，特别能让大家在面试中脱颖而出。&lt;/p&gt;
&lt;p&gt;那Dubbo内部的设计理念，实现原理是什么呢？&lt;/p&gt;
&lt;p&gt;本文将结合官方提供的3张图，从如下三个方面介绍其内部的核心实现、以及如何指导实践。&lt;/p&gt;</summary>
    
    
    
    <category term="Dubbo" scheme="https://www.codingw.net/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://www.codingw.net/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>面试官:Netty的线程模型可不是Reactor这么简单</title>
    <link href="https://www.codingw.net/posts/4ec081f3.html"/>
    <id>https://www.codingw.net/posts/4ec081f3.html</id>
    <published>2021-01-10T12:38:01.000Z</published>
    <updated>2021-01-10T12:43:01.734Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>笔者看来Netty的内核主要包括如下图三个部分：<br><img src="https://img-blog.csdnimg.cn/20210109203705225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其各个核心模块主要的职责如下：</p><ul><li><p>内存管理<br>主要提高高效的内存管理，包含内存分配，内存回收。</p></li><li><p>网通通道<br>复制网络通信，例如实现对NIO、OIO等底层JAVA API 的封装，简化网络编程模型。</p></li><li><p>线程模型</p><p>提供高效的线程协作模型。</p></li></ul><p>大家不妨回想一下在以往的面试的过程中，面试官通常会问：<strong>Netty 的线程模型是什么？</strong></p><p><strong>主从多 Reactor 模型</strong>，相信大家都能脱口而出，然后呢？就没有然后了？</p><p>线程模型在网络通信中主要解决什么样的问题？在 Netty 中又是如何解决的，Netty 的线程模型为什么如此高效？请容我慢慢道来。</p><blockquote><p>温馨提示：为了保证文章观点的严谨性，将探究领域锁定在：Netty NIO 相关。</p></blockquote><a id="more"></a><h2 id="1、主从多-Reactor-模型"><a href="#1、主从多-Reactor-模型" class="headerlink" title="1、主从多 Reactor 模型"></a>1、主从多 Reactor 模型</h2><p>主从多 Reactor 模型是业界一种非常经典的线程编程模型，其原理图如下所示：<br><img src="https://img-blog.csdnimg.cn/20210109203728396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们首先简单介绍一下上图中涉及的几个重要角色：</p><ul><li><p>Acceptor </p><p>请求接收者，在实践时其职责类似服务器，并不真正负责连接请求的建立，而只将其请求委托 Main Reactor 线程池来实现，起到一个转发的作用。</p></li><li><p>Main Reactor<br>主 Reactor 线程组，主要<strong>负责连接事件</strong>，并将<strong>IO读写请求转发到 SubReactor 线程池</strong>。当然在一些需要对客户端进行权限控制等场景下，权限校验的职责可以放到 Main Reactor 线程池，即 <strong>Main Reactor 也可以注册通道的读写事件</strong>，读取客户端权限校验相关的数据包，执行权限验证，权限验证通过后再将2通道注册到IO线程。</p></li><li><p>Sub Reactor<br>Main Reactor 通常监听客户端连接后会将通道的读写转发到 Sub Reactor 线程池中一个线程(负载均衡)，负责数据的读写。在 NIO 中 通常注册通道的读(OP_READ)、写事件(OP_WRITE)。</p></li></ul><p>为了更加深刻的理解主从 Reactor 模型，我们来看一下网络通讯一般会包含哪些关键动作：<br><img src="https://img-blog.csdnimg.cn/20210109203831368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一个网络交互通常的几个步骤如下：</p><ul><li>服务端启动，并在特定端口上监听，例如 web 应用的 80端口。</li><li>客户端发起TCP的三次握手，与服务端建立连接，这里以 NIO 为例，连接成功建立后会创建NioSocketChannel对象。</li><li>服务端通过 NioSocketChannel 从网卡中<strong>读取数据</strong>。</li><li>服务端根据<strong>通信协议</strong>从二进制流中<strong>解码</strong>出一个个请求。</li><li>根据请求，<strong>执行对应的业务操作</strong>，例如 Dubbo 服务端接受一个查询用户ID为1的用户信息。</li><li>将业务执行结果返回到客户端，通常涉及到<strong>协议编码、压缩</strong>等。</li></ul><p><strong>线程模型需要解决的问题</strong>：连接监听、网络读写、编码、解码、业务执行这些操作步骤如何运用<strong>多线程编程</strong>，提升性能。</p><p>主从多Reactor模型是如何解决上面的问题呢？</p><ol><li><p>连接建立（OP_ACCEPT）由 Main Reactor 线程池负责，创建NioSocketChannel后，将其转发给SubReactor。</p></li><li><p>SubReactor 线程池主要<strong>负责网络的读写</strong>（从网络中读字节流、将字节流发送到网络中），即注册OP_READ、OP_WRITE，并且<strong>同一个通道会绑定一个SubReactor线程</strong>。</p></li><li><p>编码、解码、业务执行，则具体情况具体分析</p><p>通常<strong>编码、解码会放在IO线程中执行，而业务逻辑的执行通常会采用额外的线程池</strong>，但不是绝对的，一个好的框架通常会使用参数来进行定制化选择，例如 ping、pong 这种心跳包，直接在 IO 线程中执行，无需再转发到业务线程池，避免线程切换开销。</p></li></ol><blockquote><p>温馨提示：在网络编程中，通常将用于网络读写的线程称为IO线程。</p></blockquote><h2 id="2、Netty-的线程模型"><a href="#2、Netty-的线程模型" class="headerlink" title="2、Netty 的线程模型"></a>2、Netty 的线程模型</h2><p>Netty的线程模型是基于主从多Reactor模型。<br><img src="https://img-blog.csdnimg.cn/2021010920401035.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Netty 中网络的连接事件(OP_ACCEPT)由Main Reactor 线程组实现，<strong>即 Boss Group，通常只需设置一个线程</strong>。</p><p>网络的<strong>读写</strong>操作由 Work Group ( Sub Reactor) 线程组来实现，线程的个数默认为 2 * CPU Core，<strong>一个 Channel 绑定到其中一个 Work 线程，一个 Work 线程中可以绑定多个 Channel</strong>。</p><p>在 Netty 中编码、解码等操作会被封装成一个一个事件处理器(ChannelHandler)，那这些 Handler 是在IO线程池中执行？</p><p>默认情况下ChannelHandler 是在 IO 线程中执行，那如何改变默认行为呢？其关键代码如下：<br><img src="https://img-blog.csdnimg.cn/20210109204026244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>关键点</strong>：在将事件处理器添加到事件链时可以指定在哪个线程池中执行，如果不指定则为<strong>IO线程</strong>中执行。</p><p>面试官：<strong>通常业务操作会专门开辟一个线程池，那业务处理完成之后，如何将响应结果通过 IO 线程写入到网卡中呢？</strong><br><img src="https://img-blog.csdnimg.cn/20210109204041129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>业务线程调用 Channel 对象的 write 方法并不会立即写入网络，只是将数据放入一个待写入队列(缓存区)，然后IO线程每次执行事件选择后，会从待写入缓存区中获取写入任务，将数据真正写入到网络中，数据到达网卡之前会经过一系列的 Channel Handler(Netty事件传播机制)，最终写入网卡。</p><p>最后再来介绍一下 Netty 中 IO 线程的大体工作流程。<br><img src="https://img-blog.csdnimg.cn/20210109204102599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>IO线程处理的关键点：</p><ul><li>每一IO线程在执行上述操作时是串行执行的，即注册在一个 Selector(事件选择器)中的所有通道，<strong>同一时间只有一个通道的事件被处理。</strong>这也是为什么NIO应对大文件传输时不具备优势的根本原因。</li><li>IO 线程在处理完所有就绪事件后，还会从任务队列(Task Queue)获取任务，例如上文中提到的业务线程在执行完业务后需要将返回结果写入网络，<strong>Netty 中所有的网络读写操作只能在IO线程中真正获得运行</strong>，故业务线程需要将带写入的响应结果封装成 Task，放入到 IO 线程任务队列中。</li></ul><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>回到到主题，如果我们在面试过程中碰到面试官提问“Netty 的线程模型是什么？”时，我们应该可以从容应对了。</p><p>我觉得可以从如下几个方面进行展开。</p><ol><li>Netty 的线程模型基于主从多Reactor模型。通常由一个线程负责处理OP_ACCEPT事件，拥有 CPU 核数的两倍的IO线程处理读写事件。</li><li>一个通道的IO操作会绑定在一个IO线程中，而一个IO线程可以注册多个通道。</li><li>在一个网络通信中通常会包含网络数据读写，编码、解码、业务处理。默认情况下编码、解码等操作会在IO线程中运行，但也可以指定其他线程池。</li><li>通常业务处理会单独开启业务线程池，但也可以进一步细化，例如心跳包可以直接在IO线程中处理，而需要再转发给业务线程池，避免线程切换。</li><li>在一个IO线程中所有通道的事件是<strong>串行处理</strong>的。</li></ol><hr><p>更多文章请关注[中间件兴趣圈]，回复【专栏】获取12个JAVA主流源码分析专栏；回复[PDF]可获取海量学习资料，助力职场。</p><p><img src="https://img-blog.csdnimg.cn/20210110203438586.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者看来Netty的内核主要包括如下图三个部分：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210109203705225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其各个核心模块主要的职责如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内存管理&lt;br&gt;主要提高高效的内存管理，包含内存分配，内存回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网通通道&lt;br&gt;复制网络通信，例如实现对NIO、OIO等底层JAVA API 的封装，简化网络编程模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程模型&lt;/p&gt;
&lt;p&gt;提供高效的线程协作模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家不妨回想一下在以往的面试的过程中，面试官通常会问：&lt;strong&gt;Netty 的线程模型是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从多 Reactor 模型&lt;/strong&gt;，相信大家都能脱口而出，然后呢？就没有然后了？&lt;/p&gt;
&lt;p&gt;线程模型在网络通信中主要解决什么样的问题？在 Netty 中又是如何解决的，Netty 的线程模型为什么如此高效？请容我慢慢道来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：为了保证文章观点的严谨性，将探究领域锁定在：Netty NIO 相关。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="netty" scheme="https://www.codingw.net/categories/netty/"/>
    
    
    <category term="Netty" scheme="https://www.codingw.net/tags/Netty/"/>
    
    <category term="面试" scheme="https://www.codingw.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一文揭晓通信协议设计的奥妙，直接“秒杀“面试官</title>
    <link href="https://www.codingw.net/posts/ff6cd24b.html"/>
    <id>https://www.codingw.net/posts/ff6cd24b.html</id>
    <published>2021-01-03T14:20:39.000Z</published>
    <updated>2021-01-03T14:28:26.943Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上一篇详细介绍了Netty的编解码的基本实现原理，本节将重点探讨网络编程中一种非常通用的协议设计方法论：<strong>协议头 + 消息体</strong>。</p><p>所谓的通信协议就是通信双方共同遵循的一种“约定”，用于通信发送方将内容按照“通信协议”所规定的格式组装成<strong>“二进制流”</strong>，通信接收方按照“通信协议”所规定的格式正确的从二进制流中解码出一个个原始请求。</p><p><strong>那通信协议如何设计呢？</strong></p><a id="more"></a><h2 id="1、通用的协议设计方法论"><a href="#1、通用的协议设计方法论" class="headerlink" title="1、通用的协议设计方法论"></a>1、通用的协议设计方法论</h2><p>在网络编程中，流行这一种经典的协议设计方法论：协议头 + 消息体。<br><img src="https://img-blog.csdnimg.cn/2021010315133342.png#pic_center" alt="在这里插入图片描述">其设计的关键点如下：</p><ul><li><strong>协议头的长度是固定的</strong>，通常为<strong>识别</strong>出<strong>一个业务的最小长度</strong>。</li><li>协议头中会包含一个<strong>长度字段</strong>，用来标识一个完整包的长度，用来表示长度字段的字节位数直接决定了一个包的最大长度，长度字段通常被设计为4个字节。</li><li>消息体中存储业务数据，例如如果是一个Dubbo协议，那消息体中可能会包含请求参数、调用的服务名等，而且字符串类的存储通常会采取字段长度、字段内容的组织方式。</li></ul><p>为了有一个更直观的展示，我以一个简单的RPC通信场景为例，实现类似Dubbo服务的远程服务调用，其通信协议可以简单设置成下图所示：<br><img src="https://img-blog.csdnimg.cn/2021010315383066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>基于 Header + Boby 的通信协议设计模式后，通信接受方就能很好的从二进制流中非常容易的解码出一条一条原始的请求数据包，解码的基本套路如下(<strong>在面试中面试官非常喜欢问的“粘包”问题的破解之道</strong>)</p><ul><li>首先判断<strong>累积缓存区</strong>中是否存在一个<strong>完整的Head头部</strong>，例如上述示例中，一个包的Header的长度为6个字节，那首先判断累积缓存中可读字节数是否大于等于6，<strong>如果不足6个字节，跳过本次处理，等待更多数据到达累积缓存区</strong>。</li><li>尝试将头部6个字节读取，并且<strong>提取长度字段中存储的数值</strong>，即包长度，然后判断累积缓存区中可读字节数大于等于整个包的长度，<strong>如果累积缓存区不包含一个完整的数据包，则跳过本次处理，等待更多数据到达累积缓存区。</strong></li><li>如果包含一个完整的包，则按照通信协议的格式按序读取相关的内容。</li></ul><p>正是因为这种设计理念非常通用，Netty 对上述协议设计进行了统一封装：LengthFieldBasedFrameDecoder 闪亮登场了，<strong>接下来我们来看看Netty是如何进行封装的，揭晓更多的实现细节，让大家做到理论与实践相结合。</strong></p><h2 id="2、LengthFieldBasedFrameDecoder-详解"><a href="#2、LengthFieldBasedFrameDecoder-详解" class="headerlink" title="2、LengthFieldBasedFrameDecoder 详解"></a>2、LengthFieldBasedFrameDecoder 详解</h2><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p><img src="https://img-blog.csdnimg.cn/20210103161101564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来对其核心属性进行一个详细的解读：</p><ul><li>ByteOrder byteOrder<br>字节序列，Netty默认使用大端序列（主要是针对int、long等数值类型），所谓的大端序列，通常可以这样理解，接收端收到的字节流的顺序是从数值类型的高字节。</li><li>int maxFrameLength<br>一条消息最大的长度。</li><li>int lengthFieldOffset<br>代表长度字段的开始偏移量。</li><li>int lengthFieldLength<br>代表长度字段占用的字节长度。</li><li>int lengthFieldEndOffset<br>代表长度字段的结束偏移量，等于lengthFieldOffset + lengthFieldLength。</li><li>int lengthAdjustment<br>长度适配适配值。该值表示协议中长度字段与消息体字段直接的距离。</li><li>int initialBytesToStrip<br>跳过一个包中前面多少个字节不处理，<strong>通常是将协议头部跳过，只将消息体中内容传输到下游时使用</strong>。</li><li>boolean failFast<br>是否快速失败。</li><li> boolean discardingTooLongFrame<br>是否吞没（跳过）大帧包。</li><li>long tooLongFrameLength<br>当前在处理吞没大包的实际大小。</li><li>long bytesToDiscard</li></ul><p><strong>下一次解码之前，需要先忽略的字节数</strong>，当遇到超过maxFrameLength的包时使用。</p><p>上面的属性如果不太好理解，没关系，**因为本节的最后会有两张图勾画出协议的全貌(用图示的方式勾画出各个属性的位置与含义)**。</p><h4 id="2-2-decode-方法详解"><a href="#2-2-decode-方法详解" class="headerlink" title="2.2 decode 方法详解"></a>2.2 decode 方法详解</h4><p>接下来我们来看一下其decode方法，通过阅读源码的方法来理解其内部的工作原理。</p><p>LengthFieldBasedFrameDecoder#decode<br><img src="https://img-blog.csdnimg.cn/20210103162758778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：跳过无效数据包的处理逻辑。如果<strong>discardingTooLongFrame</strong>为true，表示正在处理<strong>大于**</strong>maxFrameLength<strong>的包，需要跳过这个超长的包，不对其解码，由于数据是陆续到达累积缓存区，并不能一次跳过整个无效包，故需引入 bytesToDiscard 变量，用于记录本次能跳过的字节，当 bytesToDiscard 为 0后表示一个无效包已全部跳过，需要处理正常数据包，此时discardingTooLongFrame 会重置为 false。<br><img src="https://img-blog.csdnimg.cn/20210103163914626.png" alt="LengthFieldBasedFrameDecoder#decode"><br>Step2：</strong>如果累积缓冲区的可读字节大小小于length字段的结束偏移量<strong>，返回null，结束解码，说明该累积缓存区中的数据还不完整。<br><img src="https://img-blog.csdnimg.cn/20210103164503153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step3：尝试从累积缓存区中获取包的长度。其中表示 lengthFiedlOffset 表示长度字段的其实偏移量，在结合长度字段的长度 lengthFieldLength ，再结合字节序列</strong>（大端序列、小端序列）**。<br><img src="https://img-blog.csdnimg.cn/2021010316591174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step4：这里是包长度超过协议允许的最大包长度时的处理逻辑，再这里大家先姑且跳过 lengthAdjustment 属性的含义。</p><ul><li>如果当前累积缓存区中的可读字节大于 frameLength，大于当前包的长度，可以通过调用 skipBytes 方法跳过这包。</li><li>如果当前累积缓存区的可读自己小于 frmaeLength，需要分多次跳过，故先将累积区中的数据全部跳过，然后通过 bytesToDiscard 记录还需要跳过的字节数。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210103173012169.png#pic_center" alt="在这里插入图片描述"><br>Step5：<strong>如果累积缓存区中的数据不包含一个完整的包，返回null，结束本次解码，等待更多的数据包到到来。</strong><br><img src="https://img-blog.csdnimg.cn/20210103174100193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step6：通过 ByteBuf 的 slince 方法，提取一个完整的包长度，解码出完整的数据包，完成一个数据包解码。</p><h4 id="2-3-图解-LengthFieldBasedFrame-协议"><a href="#2-3-图解-LengthFieldBasedFrame-协议" class="headerlink" title="2.3 图解 LengthFieldBasedFrame 协议"></a>2.3 图解 LengthFieldBasedFrame 协议</h4><p>在Netty 的 LengthFieldBasedFrameDecoder 中有一个 lengthAdjustment 属性，可以是正数，也可以是负数，其使用的代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameLength += lengthAdjustment + lengthFieldEndOffset</span><br></pre></td></tr></table></figure><p>lengthAdjustment 长度调整字段，可以为正数，也可以为负数，主要的作用是 长度字段中的值是否包含 Header 长度本身，严格意义上来说应该是包含 长度字段之前的字节序列。</p><p>1、lengthAdjustment &gt; 0<br><img src="https://img-blog.csdnimg.cn/20210103210634448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2、lengthAdjustment &lt; 0<br>在大多数情况下，length字段表示消息正文的长度，但是有些协议，其长度表示的是整个消息的长度，故Netty为了适配这种情况，可以通过 lengthAdjustment 设置为负数，来调节数据帧的大小。<br><img src="https://img-blog.csdnimg.cn/20210103211439214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>总结</strong>：lengthAdjustment 的出现是Netty<strong>为了适配现有的协议而设计出来的字段</strong>，即 Netty LengthFieldBasedFrameDecoder 是为了i给 header + body ，并且基于长度字段的协议一种通用的解决方案，可以通过 lengthAdjustment 来准确表示数据帧(业务数据的长度)，这里是一种<strong>逆向思维</strong>。</p><h2 id="3、协议设计子类的最佳实践"><a href="#3、协议设计子类的最佳实践" class="headerlink" title="3、协议设计子类的最佳实践"></a>3、协议设计子类的最佳实践</h2><p><strong>最佳实践：</strong> LengthFieldBasedFrameDecoder 的 decode 方法的职责是从二进制流中解码出一个完整的数据包，其返回类型还是 ByteBuf，故自定义的编码解码器的 decode 方法就是先调用父类的 decode 方法 得到 ByteBuf ，然后对 ByteBuf 中的数据解码出对象。</p><p>即 LengthFieldBasedFrameDecoder 并不负责将 ByteBuf 转换为协议对象，而是从二进制流中解码出一个数据帧，而将ByteBuf 转换为协议对象的职责由其子类实现，通常的编码风格如下：<br><img src="https://img-blog.csdnimg.cn/20210103212109895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><p>更多文章建议关注『中间件兴趣圈』，回复【专栏】获取12个JAVA主流中间件源码剖析，并包含大量实战案例、架构设计理念；回复【PDF】可获取海量学习资料，助力突破职场瓶颈。</p><p><img src="https://img-blog.csdnimg.cn/20201231115902671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇详细介绍了Netty的编解码的基本实现原理，本节将重点探讨网络编程中一种非常通用的协议设计方法论：&lt;strong&gt;协议头 + 消息体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓的通信协议就是通信双方共同遵循的一种“约定”，用于通信发送方将内容按照“通信协议”所规定的格式组装成&lt;strong&gt;“二进制流”&lt;/strong&gt;，通信接收方按照“通信协议”所规定的格式正确的从二进制流中解码出一个个原始请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那通信协议如何设计呢？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="netty" scheme="https://www.codingw.net/categories/netty/"/>
    
    <category term="网络编程" scheme="https://www.codingw.net/categories/netty/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="通讯协议" scheme="https://www.codingw.net/categories/netty/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>图文并茂剖析Netty编解码以及背后的设计理念</title>
    <link href="https://www.codingw.net/posts/cd43c662.html"/>
    <id>https://www.codingw.net/posts/cd43c662.html</id>
    <published>2020-12-31T04:06:35.000Z</published>
    <updated>2020-12-31T04:04:23.223Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文主要介绍网络通信中与通信息息相关的重要部分：通信协议的底层实现原理：<strong>编码与解码</strong>。</p><blockquote><p>温馨提示：源码分析或许比较枯燥，在浏览的过程中建议重点关注<strong>黑色</strong>字体与<strong>流程图</strong>，是<strong>根据源码进行的提炼</strong>，突出源码背后的<strong>设计理念</strong>。</p></blockquote><a id="more"></a><h2 id="1、Netty4编码解码概述"><a href="#1、Netty4编码解码概述" class="headerlink" title="1、Netty4编码解码概述"></a>1、Netty4编码解码概述</h2><p>Netty中定义的编码解码器核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20201230195200318.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Decoder(解码器) 继承自 Inbound 事件处理器，而Encoder(编码器)继承自Outbound事件处理器。</strong></p><p>其实不难理解，以服务端接收请求、返回响应结果的视角来看这个问题：</p><p>当服务端通过网络IO接收到字节序列时，从底层网络套接字中将字节流读取到接受缓存区(ByteBuf)，服务端的职责首先需要从<strong>二进制流中解码</strong>出一个<strong>完整的请求</strong>，然后“读懂请求”的含义进行对应的业务逻辑处理，处理完毕后首先需要将响应结果(通常为JSON字符串)<strong>编码成二级制流</strong>，通过网络进行传递，客户端收到二进制流后同样进行解码。</p><p><strong>解码</strong>：针对的是输入，故继承 InBound 入端事件。<br><strong>编码</strong>：针对的是输出，故继承 OutBound 出端事件。</p><p>了解了上述基本点后，接下来对上述核心类一一做个介绍：</p><ul><li>ByteToMessageDecoder<br>解码器，将字节流解码成消息(message)。</li><li>MessageToByteEncoder<br>编码器，将消息(message)编码成字节流。</li><li>MessageToMessageEncoder<br>编码器,将消息编码成”另一种消息“，更通用，”另一种消息“由泛型指定。</li><li>MessageToMessageDecoder<br>解码器，将消息解码成“另一种消息”，更通用，“另一种消息”由泛型指定。</li></ul><p>下面介绍Netty4<strong>自带的协议解码器</strong>，是<strong>ByteToMessageDecoder</strong>的子类。</p><ul><li>LineBasedFrameDecoder<br>基于换行符的分隔符，使用\n或\r\n分隔符来标志一个字节序列的结束。</li><li>DelimiterBasedFrameDecoder<br>基于自定义的分隔符，使用定义的分隔符来标志一个字节序列的结束。</li><li>FixedLengthFrameDecoder<br>固定长度的编码器。在实际使用时，如果单条消息不足定义的长度，通常需要人为填充。</li><li>LengthFieldBasedFrameDecoder<br>基于长度字段的协议，通过指定一个长度字段，该字段的存储字节固定，例如3个字节或4个字节等，然后该字段中存储消息的长度，这样在解码时可以非常方便的判断一条消息的长度，这是一个非常经典的client-server协议格式，下面会对其进行详细解读。</li></ul><h2 id="2、源码分析解码器实现原理"><a href="#2、源码分析解码器实现原理" class="headerlink" title="2、源码分析解码器实现原理"></a>2、源码分析解码器实现原理</h2><p>ByteToMessageDecoder 是 Netty 解码器实现的基类，典型的模板设计模式。</p><p><strong>解码器引入的目的</strong>是为了<strong>解决网络编程中的“粘包问题”</strong>，网络传输基于字节流，客户端多个线程通过一条长连接向服务端发送多个请求，服务端在处理命令之前如何正确拆解出一条完整的请求信息呢？</p><p>例如客户端A的三个线程t1、t2、t3 使用同一条连接(类比Dubbo客户端)发送了3个请求，内容分别为 A, BCD, E 。</p><p>服务端基于NIO来处理，当请求陆续到达服务端的接受缓存区，NIO 读事件触发，可能第一次网络读，从网络中读取的内容为AB字节序列(包含第一个请求包全部，第二个请求包部分)，紧接着再读取CDE序列，如果服务端每接受到一部分数据就当成一个完整的请求去处理的话，明显与客户端原始请求存在差别。</p><p>故为了解决服务端、客户端能对同一个字节流具有相同的理解语义，所谓的<strong>通信协议</strong>因此诞生了，通俗一点就是客户端、服务端如果界定一个完整请求包。</p><p>最常见的几种协议：</p><ul><li>每一行一个数据包，即在每一个请求包最后以 /r/n 结尾</li><li>固定长度，请求内容不足使用特殊字符填充</li><li>协议头 + 协议体 ，其中协议头定长，并且内部会含有一个表示包长度的字段。</li></ul><blockquote><p>上述具体协议，将在下篇文章中如何定制私有化协议(编码解码)</p></blockquote><p>接下来将通过阅读源码的方式探究Netty中解码的实现原理，<strong>并总结其核心设计关键点</strong>。</p><p>ByteToMessageDecoder Netty 网络解码器的模板父类， Netty 的扩展是基于事件链机制，即解码器实现的是 InBound 事件处理器。</p><p><strong>在阅读解码器实现原理的同时，大家可以关注一个解码器实现的事件方法，再次感悟一下不同场景应该选用实现哪个事件方法。</strong></p><h4 id="2-1-channelRead"><a href="#2-1-channelRead" class="headerlink" title="2.1 channelRead"></a>2.1 channelRead</h4><p>通道读时间，Netty底层通过Nio Socket 读取到的字节序列后通过传播 channelRead 事件，让上层的事件处理器对接受到的数据进行处理，解码器的职责就是从二进制流中解码出一条条消息。</p><p>其处理的代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201230214650227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上面的实现要点如下：<br>代码@1：对待处理数据类型进行判断，如果是ByteBuf，则尝试从流中解码请求，如果不是合适的类型，直接调用ctx.fireChannelRead 方法继续向事件链进行传播。</p><p>代码@2：构造CodecOutputList out对象，用来存储经过该解码器解码出来的的消息，其内部数据结构为List。</p><p>代码@3：如果该解码器中的接收缓冲区(累积缓存区)为空，表示第一次接码消息，设置 first 为 true，并直接将接收到的数据设置为接收缓存区。</p><p>代码@4：如果当前累积缓存区不为空，需要计算累积缓存区是否能容纳当前接收到的数据，如果无法存储，则需要对累积缓存区进行扩容，<strong>扩容的套路就是先申请一个容量大的缓存区，然后将原先的累积缓存区中的数据复制到新的缓存区，然后释放旧的缓存区。</strong></p><p>代码@5：调用callDecode方法对累积缓存区中的数据，进行尝试解码，将解码后的结果存放在out对象中(稍后会对该方法详细进行讲解)。</p><p>在调用完用户自定义的协议解码后，<strong>开始进行资源的回收逻辑</strong>。</p><p>代码@6：如果累积缓存区不为空，并且读写缓存区中所有的数据已全部处理，重置numReads与累积缓存区cumulation。</p><p>代码@7：如果 numReads 超过 discardAfterReads，需要对累积缓存去进行压缩</p><p><strong>设计目的：主要是避免内存泄漏，节省内存空间。 numReads 表示的含义是对累积缓存区解码的次数，如果多次解码都未全部将累积缓存区全部处理完成，当新的数据到达累积缓存区，极大可能需要进行扩容，从而造成累积缓存区的膨胀，如果不丢弃已处理的数据，及时释放内存空间，避免扩容，否则会导致累积缓存区无限扩容，内存资源得到极大的消耗。</strong></p><p>代码@8：将解码后的请求继续向事件链进行传播，例如业务处理器，业务处理器可以基于请求对象进行编码的根本原因就是首先进入的解码器，解码出一个一个请求后，业务处理器根据请求进行对应的业务逻辑处理。</p><p>代码@9：处理完后，对out结果list对象进行回收，这里使用了Netty的对象缓存机制（对象池）。</p><p>接下来探究一下 callDecode 的核心实现逻辑：<br><img src="https://img-blog.csdnimg.cn/20201230225925317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>该方法的实现要点如下：<br>代码@1：首先对参数进行一个详细介绍：</p><ul><li>ChannelHandlerContext ctx：事件处理器链当前处理器的上下文环境。</li><li>ByteBuf in：累积缓存区。</li><li>List&lt; Object &gt; out：解码后的结果列表。</li></ul><p>代码@2： while (in.isReadable()) ，NIO读取经典写法，判断读缓存区是否还有可读字节，从@3到@8都是对该缓存区的处理。</p><p>代码@3：由于这里处于一个循环中，一次循环后如果out解码结果列表不为空，<strong>会立即将解码后的请求</strong>通过调用 fireChannelRead 向后面的事件处理其传播。</p><p>代码@4：oldInputLength，当前累积缓存区可读大小。</p><p>代码@5：decode 该方法是一个抽象方法，尝试从累积缓存区中解码出完整的请求，由具体的<strong>协议实现类</strong>去实现。</p><p>代码@6,7：如果累积缓存区中不包含一条完整的请求，本次解码结束，等待更多数据到达接受缓存区(<strong>下一次读事件触发，继续通过网络读API从Socket中读取字节流</strong>)。</p><p>代码@8：如果singleDecode=true，表示不支持多次解码，故跳出。</p><p>为了加深理解上述流程，Netty 解码器的核心实现流程如下：<br><img src="https://img-blog.csdnimg.cn/20201230231134883.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="2-3-channelReadComplete-事件"><a href="#2-3-channelReadComplete-事件" class="headerlink" title="2.3 channelReadComplete 事件"></a>2.3 channelReadComplete 事件</h4><p>通道读完成事件，这是每一次读就绪事件处理完成后，会传播该事件。<br><img src="https://img-blog.csdnimg.cn/20201230231746117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在每一次读处理完成后，Netty为了保证累积缓存区不至于浪费空间，进行一次压缩，其设计理念在上文已提到。</p><h4 id="2-4-channelInactive事件"><a href="#2-4-channelInactive事件" class="headerlink" title="2.4 channelInactive事件"></a>2.4 channelInactive事件</h4><p>通道在非激活状态时会触发该事件。<br><img src="https://img-blog.csdnimg.cn/20201230232436368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：尝试通过调用 channelInputClosed方法最后尝试进行解码。<br>代码@2：如果累积缓存区不为空，释放累积缓存区。<br>代码@3：传播一次通道读事件。<br>代码@4：如果代码@1在通道非激活时还解码到新数据了，则传播一次通道完成度事件。<br>代码@5：根据callChannelInactive参数，决定是否传播通道非激活事件。<br><img src="https://img-blog.csdnimg.cn/20201230232809664.png#pic_center" alt="在这里插入图片描述"><br>代码@1：如果累积缓冲区不为空，则调用callDecode方法，对累积缓存区进行解码，因为累积缓存区中的数据的读取已经和底层网络通道无关了，通道关闭后，该部分数据还是要尽量处理。</p><p>代码@2：再解码一次，由于这个方法，是直接调用抽象方法decode，最终解码的结果放在out中，解码后，如果有消息，最终还会触发一次通道读事件和通道读完成事件。</p><h4 id="2-5-handlerRemoved-事件"><a href="#2-5-handlerRemoved-事件" class="headerlink" title="2.5 handlerRemoved 事件"></a>2.5 handlerRemoved 事件</h4><p>handlerRemoved事件，该事件的触发有两种情况：</p><ul><li>在调用handlerAdd事件失败后，接着调用handlerRemoved事件。</li><li>在通道关闭后，DefaultChannelPipeline 的 HeadContext 的 channelUnregistered 中传播完通道事件取消注册事件后，会销毁注册在该通道上的事件注册器，此时也会触发handlerRemoved事件。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201230233351223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从实现来看，也非常简单，就是将累积缓存区中未处理的数据传播到其下游的事件处理器，传播之后再从事件链中移除，体现了其“高度负责”的一面。</p><p><strong>对于解码的核心设计理念再做一个总结：</strong></p><ul><li>引入累积缓存区，存储从网络底层接受的数据。</li><li>对累积缓存区中的数据尝试解码，如果能解码出一条请求，就解码并将数据传入到后续处理器。</li><li>如果累积缓存区中不包含一条完整的消息，则结束本次解码，等待后续更多的数据到达缓存区。</li></ul><p><strong>那问题又来了，如何判别累积缓存区中是否包含一条完整的消息呢？如何进行协议的设计呢？</strong></p><p><strong>此部分内容将在下文：如何使用Netty设计一款通信协议。</strong></p><h2 id="3、源码分析编码器实现原理"><a href="#3、源码分析编码器实现原理" class="headerlink" title="3、源码分析编码器实现原理"></a>3、源码分析编码器实现原理</h2><p>Netty将消息(请求对象、响应结果) 按特定格式转换为二进制流。<br>MessageToByteEncoder的核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20201230234244975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其核心属性如下：</p><ul><li>private final TypeParameterMatcher matcher<br>参数类型匹配器，其实就是匹配MessageToByteEncoder的泛型参数。</li><li>private final boolean preferDirect<br>在解码时，是否倾向与使用堆外内存。</li></ul><p>MessageToByteEncoder是outbound处理器，只需 wrtie 事件做处理。<br><img src="https://img-blog.csdnimg.cn/2020123023464832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：如果待处理的对象类型符合该编码器期待的类型，则对数据进行编码，否则直接调用ctx.write方法@6，传播write事件。<br>代码@2：根据是否使用堆外内存，使用内存分配器分配堆内存或堆外内存， 其bufer默认的大小为256字节。<br>代码@3：根据协议将数据编码到ByteBuf中，由协议设计者去实现。<br>代码@4：<strong>对输入参数进行回收</strong>。<strong>因为经过该方法的处理，已经将输入参数转换为其他形式的数据，该数据的生命周期结束了</strong>，尝试回收(引用计数法)。<br>代码@5：如果byteBuf可读，则将这些数据传播到下一个事件处理器处理。<br>代码@7：对内存进行回收。</p><hr><p>更多文章建议关注『中间件兴趣圈』，获取12个JAVA主流中间件源码剖析，并包含大量实战案例、架构设计理念。</p><p><img src="https://img-blog.csdnimg.cn/20201231115902671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍网络通信中与通信息息相关的重要部分：通信协议的底层实现原理：&lt;strong&gt;编码与解码&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：源码分析或许比较枯燥，在浏览的过程中建议重点关注&lt;strong&gt;黑色&lt;/strong&gt;字体与&lt;strong&gt;流程图&lt;/strong&gt;，是&lt;strong&gt;根据源码进行的提炼&lt;/strong&gt;，突出源码背后的&lt;strong&gt;设计理念&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="netty4" scheme="https://www.codingw.net/categories/netty4/"/>
    
    
    <category term="netty" scheme="https://www.codingw.net/tags/netty/"/>
    
    <category term="编码" scheme="https://www.codingw.net/tags/%E7%BC%96%E7%A0%81/"/>
    
    <category term="通信协议" scheme="https://www.codingw.net/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>从年末生产故障解锁RocketMQ集群部署最佳实践</title>
    <link href="https://www.codingw.net/posts/8956924f.html"/>
    <id>https://www.codingw.net/posts/8956924f.html</id>
    <published>2020-12-27T02:06:35.000Z</published>
    <updated>2020-12-27T02:18:22.267Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>笔者比较“悲催”，临近年末由笔者维护的生产MQ集群中的一台物理机内存故障导致操作系统异常重启，持续10分钟中出现众多的应用发送客户端出现发送消息超时，导致事故并定性为S1，笔者的“年终奖”。。。</p><h2 id="1、故障描述"><a href="#1、故障描述" class="headerlink" title="1、故障描述"></a>1、故障描述</h2><p>RocketMQ 集群采取的部署架构为2主2从，其部署架构如下图所示：<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传<br><img src="https://img-blog.csdnimg.cn/20201227093130257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其部署架构中一个非常明显的特点是一台物理机上分别部署了 nameserver，broker 两个进程。</p><p>其中一台机器(192.168.3.100)的内存出现故障，导致机器重启，但Linux操作系统由于重启需要自检等因素，整个重启过程竟然持续了将近10分钟，客户端的发送超时持续10分钟，这显然是不能接受的！！！</p><p>RocketMQ的高可用设计何在？接下来我们将详细介绍其分析过程。</p><a id="more"></a><h2 id="2、故障分析"><a href="#2、故障分析" class="headerlink" title="2、故障分析"></a>2、故障分析</h2><p>当得知一台机器故障导致故障持续10分钟，我的第一反应是不应该呀，因为 RocketMQ 集群是分布式部署架构，天然支持故障发现与故障恢复，消息发送客户端能自动感知 Broker 异常的的时间绝对不会超过10分钟，那故障又是怎么发生的呢？</p><p>首先我们先来回顾一下RocketMQ的路由注册与发现机制。</p><h4 id="2-1-RocketMQ路由注册与剔除机制"><a href="#2-1-RocketMQ路由注册与剔除机制" class="headerlink" title="2.1 RocketMQ路由注册与剔除机制"></a>2.1 RocketMQ路由注册与剔除机制</h4><p><img src="https://img-blog.csdnimg.cn/20201227093154348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其路由注册、剔除机制说明如下：</p><ul><li>集群中所有Broker每隔30s向集群中所有的NameServer发送心跳包，注册Topic路由信息。</li><li>NameServer在收到Broker端的心跳包时首先会更新路由表，并记录收到心跳包的时间。</li><li>NameServer会启动一个定时任务每10s会扫描Broker，如果Nameserver连续120s未收到Broker的心跳包，会判定Broker已下线，将从路由表中将该Broker移除。</li><li>如果Nameserver与Broker端的长连接断开，NameServer会立即感知Broker下线并从路由表中将该Broker移除。</li><li>消息客户端(消息发送者、消息消费者)在任意时刻只会和其中一台NameServer建立连接，并每隔30s向NameServer查询路由信息，如果查询到结果会更新发送者的本地路由信息。</li></ul><p>从上述的路由注册、剔除机制来看，当一台Broker服务器宕机，消息发送者感知路由信息发生变化需要的时间是多长呢？</p><p>分如下两种情况分别讨论：</p><ul><li>NameServer与Broker服务器TCP连接断开，此时NameServer能立即感知路由信息变化，将其从路由表中移除，从而消息发送端应该在30s左右就能感知路由发送变化，在此30s内在发送端会出现消息发送失败,但结合发送规避机制，并不会对发送方带来重大故障，可接受。</li><li>如果NameServer与Broker服务器的TCP连接未断开，但Broker已无法提供服务(例如假死)，此时NameServer需要120s才能感知Broker宕机，此时消息发送端最多需要150s才能感知其路由信息的变化。</li></ul><p><strong>但问题来了，为什么在生产实际过程中一台Broker由于内存故障重启,10分钟后重启成功后业务才恢复，即业务才真正感知Broker宕机呢？</strong></p><p>既然出现了，我们就需要对其进行分析，给出解决方案，避免不会在生产环境出现同类型的错误。</p><h4 id="2-2-故障排查经过"><a href="#2-2-故障排查经过" class="headerlink" title="2.2 故障排查经过"></a>2.2 故障排查经过</h4><p>先查询客户端的日志(/home/{user}/logs/rocketmqlogs/rocketmq_client.log)，从中可以看到从客户端第一次报消息发送超时的时间是14:44，其日志输出如下：<br><img src="https://img-blog.csdnimg.cn/2020122709322326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>由于192.168.3.100机器内存故障，故首先去查看该集群中其他nameserver中的日志，看正常机器中的NameServer感知broker-a故障的时长，其日志如下所示：<br><img src="https://img-blog.csdnimg.cn/20201227093237477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从中可以看出192.138.3.101的nameserver基本在2分钟左右才感知其宕机，即虽然机器在重启，但可能由于操作系统要做硬件自检等其他原因，TCP连接并未断开，故nameserver在120s后才感知其宕机，从路由信息表中将该broker移除，那按照路由剔除机制，客户端应该在150秒的时间内感知其变化，那为什么没感知呢？</p><p>继续查看客户端路由信息，查看客户端感知路由信息发生变化的时间点，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093255965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从客户端日志来看，客户端在14:53:46才感知其变化，这又是为什么呢？</p><p><strong>原来客户端在更新路由信息时报超时异常，其截图如下所示：</strong>：<br><img src="https://img-blog.csdnimg.cn/20201227093317856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从发生故障到故障恢复期间，客户端一直尝试从已发生故障的NameServer去更新路由信息，但一直返回超时，这样就导致了客户端一直无法获取最新的路由信息，故一直无法感知已宕机的Broker。</p><p><strong>从日志分析来看，到目前来说就比较明朗了，客户端之所有没有在120s之内感知其路由信息的变化，是因为客户端一直尝试从已宕机的nameserver去更新路由信息，但由于一直无法请求成功，故客户端的缓存路由信息一直无法得到更新，造成了上面的现象</strong></p><p>那问题来了，按照我们对RocketMQ的认识，NameServer宕机，客户端会自动去从nameserver列表中选择下一个nameserver，<strong>那为什么这里并没有发生nameserver切换</strong>，而是等到14:53才切换呢？</p><p>接下来我们将目光投向NameServer的切换代码，其代码片段如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093337453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中的几个关键分析如下：</p><ul><li>客户端能通过缓存中的连接发送RPC请求的前提条件是channel的isActive方法返回true，即底层TCP连接处于激活状态。</li><li>在客户端向服务端发起RPC请求时，如果出现非超时类异常，会执行closeChannel方法，该方法会关闭连接并从连接缓存表中移除，这个非常关键，因为在切换NameServer时如果缓存中存在连接并连接处于激活状态，就不会切换nameserver。</li><li>如果发送RPC超时，rocketmq会根据clientCloseSocketIfTimeout参数来决定是否关闭连接，但遗憾的是该参数默认为false，并且并未提供修改的入口。</li></ul><p>那问题分析到这里，已经非常明了，由于机器内存故障触发重启并且重启前需要自检等因素，造成nameserver,broker无法再处理请求但底层TCP连接并未断开，导致发生超时错误，但客户端并不会关闭与故障机器nameserver的TCP连接，导致无法切换，等到机器重新启动后，TCP连接断开，故障机器重启完成后感知路由信息变化，故障恢复。</p><p><strong>经过上面的问题分析，其故障原因如下</strong>：<br>192.168.3.100机器在内存故障后重启，整个重启耗时10分钟，并且在重启过程中TCP连接未断开，192.168.3.101 nameserver在故障发送时2分钟左右才感知路由变化，但部分客户端时连接192.168.3.100的nameserver，客户端尝试从该nameserver查询路由信息，但一直返回超时，<strong>由于没有关闭连接，导致客户端并不会切换到</strong>3.101的nameserver，直到客户端与nameserver的TCP连接断开后，切换到另外一个3.101的nameserver，故障在指定时间内得以恢复。</p><p><strong>根本原因：其实是nameserver的假死导致路由信息无法更新。</strong></p><h2 id="3、最佳实践"><a href="#3、最佳实践" class="headerlink" title="3、最佳实践"></a>3、最佳实践</h2><p>经过上面的故障，个人觉得nameserver不应该与broker部署在一起，如果nameserver与broker并不部署在一起，上面的问题能得到有效避免，其部署架构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093642967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这样的部署架构如果面对上面的故障，Broker假死的情况，能有效避免吗？答案是可以的。</strong></p><p>如果192.168.3.100的broker假死，那么3.110,3.111的nameserver都能在2分钟内感知broker-a宕机，然后客户端能成功从nameserver处获得最新的路由信息，如果nameserver假死，出现超时错误，只要broker不宕机，则通过缓存，还是能正常工作的，<strong>但如果nanmeserver,broker一起假死，则上述架构还是无法规避上面的问题</strong>。</p><p><strong>故本次的最佳实践主要包含如下两条</strong>：<br>1、nameserver与broker一定要分开部署，进行隔离。<br>2、nameserver与客户端的连接，应该在超时后，关闭连接，触发nameserver漂移，需要修改源码。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者比较“悲催”，临近年末由笔者维护的生产MQ集群中的一台物理机内存故障导致操作系统异常重启，持续10分钟中出现众多的应用发送客户端出现发送消息超时，导致事故并定性为S1，笔者的“年终奖”。。。&lt;/p&gt;
&lt;h2 id=&quot;1、故障描述&quot;&gt;&lt;a href=&quot;#1、故障描述&quot; class=&quot;headerlink&quot; title=&quot;1、故障描述&quot;&gt;&lt;/a&gt;1、故障描述&lt;/h2&gt;&lt;p&gt;RocketMQ 集群采取的部署架构为2主2从，其部署架构如下图所示：&lt;br&gt;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227093130257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其部署架构中一个非常明显的特点是一台物理机上分别部署了 nameserver，broker 两个进程。&lt;/p&gt;
&lt;p&gt;其中一台机器(192.168.3.100)的内存出现故障，导致机器重启，但Linux操作系统由于重启需要自检等因素，整个重启过程竟然持续了将近10分钟，客户端的发送超时持续10分钟，这显然是不能接受的！！！&lt;/p&gt;
&lt;p&gt;RocketMQ的高可用设计何在？接下来我们将详细介绍其分析过程。&lt;/p&gt;</summary>
    
    
    
    <category term="RocketMQ" scheme="https://www.codingw.net/categories/RocketMQ/"/>
    
    <category term="故障分析" scheme="https://www.codingw.net/categories/RocketMQ/%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/tags/rocketmq/"/>
    
    <category term="故障" scheme="https://www.codingw.net/tags/%E6%95%85%E9%9A%9C/"/>
    
    <category term="假死" scheme="https://www.codingw.net/tags/%E5%81%87%E6%AD%BB/"/>
    
    <category term="集群部署" scheme="https://www.codingw.net/tags/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读方法、误区与三种境界</title>
    <link href="https://www.codingw.net/posts/5cfc78e.html"/>
    <id>https://www.codingw.net/posts/5cfc78e.html</id>
    <published>2020-12-20T10:31:26.000Z</published>
    <updated>2020-12-20T10:32:50.588Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在技术职场中普遍存在如下几种现象：</p><ul><li>对待工作中所使用的技术<strong>不需要阅读源码</strong>，只需在开发过程中能够熟练运用就行</li><li>看源码太费时间，而且容易忘记，如果从实际使用过程中出现的问题出发，针对性的阅读源码，其学习效率会更高效，所以平时无需看源码。</li></ul><p>对此我有着不同的理解，容我慢慢道来。</p><p>本文将从如下4个角度进行剖析：</p><ol><li>源码阅读的必要性</li><li>源码阅读技巧</li><li>源码阅读的三种境界</li><li>源码阅读的误区</li></ol><a id="more"></a><h2 id="1、源码阅读必要性"><a href="#1、源码阅读必要性" class="headerlink" title="1、源码阅读必要性"></a>1、源码阅读必要性</h2><h4 id="1-1-通用型基础技术应该深入源码研究"><a href="#1-1-通用型基础技术应该深入源码研究" class="headerlink" title="1.1 通用型基础技术应该深入源码研究"></a>1.1 通用型基础技术应该深入源码研究</h4><p>在 JAVA 领域中笔者认为通用型基础技术包含 JAVA 集合、Java并发(JUC)。这类技术是项目中使用的高频技术，在合适的场景中选用合适的数据结构、选用合适的线程并发模型、合理控制锁粒度等都能显著提高应用程序的可用性、健壮性。</p><p>通用型技术正因为其具有普遍性，横向对比更具代表性，职场面试时的可辨别性非常高，<strong>如何在高样本中突出自己就显得极为必要，通过阅读源码，深刻理解其内部原理成为我们的不二法宝。</strong></p><p>当然通过阅读源码并不是知晓原理的唯一方法，但作为一个名程序员、直面代码，亲自感受代码的魅力或许来的更加直接。</p><h4 id="1-2-重点领域应深入源码研究"><a href="#1-2-重点领域应深入源码研究" class="headerlink" title="1.2 重点领域应深入源码研究"></a>1.2 重点领域应深入源码研究</h4><p>为了提高辨识度作为职场的我们应该打造自己的专属标签，即<strong>“亮点”</strong>。通常情况我们应该选择在日常工作中使用的技术，在积累了丰富的使用经验、线上故障排查经验的前提下，应该深入研究其源码，成体系掌握该技术，从而对其更具掌控性，做到提前预判线上问题，规避大量线上故障，提升稳定性，助力业务降本增效。</p><p>例如笔者所在公司在微服务、消息中间件领域分别采用了 Dubbo、RocketMQ，并且笔者有幸参与到这项技术栈的运用与运维，积累了丰富的使用经验，为此笔者为了突出在这两个领域的优势，详细阅读其源码，并作成专栏发布在『中间件兴趣圈』公众号与CSDN等知识分享平台，由于是成体系剖析的原因被出版社相中，邀请出书，《RocketMQ技术内幕》一书就在这样的背景中应运而生，<strong>从而成为笔者职业技能中非常亮眼的标签，助力职场</strong>。</p><p><strong>源码阅读确实很重要，但一定需要成体系研究</strong>，大部分人认为<strong>在处理问题时再根据具体问题去看源码，会更有针对性，觉得没必要成体系看</strong>。</p><p>不可否认这有其正确性的一面，从问题本身出发，看源码效率更快，“投入产出比”更高，随着遇到的问题越来越多，对该技术理解也会越来越深，这个其实就是我们通常讲的<strong>“经验”</strong>。我觉得大部分情况下是可取的，<strong>这个过程其实是一个被动的过程</strong>，并且如果生产环节由于并发不高等因素，可能一年、两年也不会出现一两次故障，这样就会造成经验的积累会非常慢，从而使得工作了4、5年的朋友其竞争力还不如工作2,3年的重要原因，<strong>所以我的观点是如果是想打造成自己的专属亮点的话，我们还是需要主动通过阅读其源码，成体系掌握其设计理念、实现原理，更好的打造自己的专属亮点。</strong></p><h2 id="2、如何阅读源码"><a href="#2、如何阅读源码" class="headerlink" title="2、如何阅读源码"></a>2、如何阅读源码</h2><p>既然阅读源码非常有必要，那如何阅读源码呢？笔者根据多年的源码阅读经验整理了如下方法论：</p><ol><li>了解这款中间件的使用场景、以及架构设计中将承担的责任。</li><li>寻找官方文档，从整体上把握这款中间件的设计理念。</li><li>搭建自己的开发调试环境，运行官方提供Demo示例，为后续深入研究打下基础。</li><li>先主干流程再分支流程，注意切割，逐个击破。</li><li>阅读源码过程中带着思考与质疑思维。</li></ol><p>理解了其使用场景后，结合官方文档，尝试理解该中间件需要解决的问题、并思考如何解决，思考过程中并不一定要求我们想出一个具体的答案，只是在真正步入源码阅读时能更快感悟其代码含义。</p><p>当然在阅读源码的<strong>过程中可能会到难题</strong>，遇到无法理解作者的实现意图，特别是遇到一些自己不太熟悉的编程方式(例如位运算)，此时通常有<strong>两种解决方案</strong>：</p><ol><li>通过DEBUG，结合运行时数据，方便对代码的理解。</li><li>从易到难，可以先尝试阅读一下JAVA集合框架的源码，提炼出一套自己的源码研究方法论。</li></ol><p><strong>源码阅读其实最难的不是代码本身</strong>，也不是无法理解其设计理念，<strong>最难的是坚持</strong>，故在这里借用笔者的座右铭与大家共勉：越努力越幸运，唯有坚持不懈。</p><h2 id="3、源码阅读的三层境界"><a href="#3、源码阅读的三层境界" class="headerlink" title="3、源码阅读的三层境界"></a>3、源码阅读的三层境界</h2><p>接下来我想再结合笔者4年源码阅读的历程，谈谈我对源码阅读的一些更深层次的理解，介绍一下笔者在各个阶段阅读源码所处的状态。</p><ol><li>源码阅读的初级阶段<br>笔者的老粉丝们应该能感觉到笔者初期的源码阅读文章，基本上是<strong>记流水账</strong>,其最直观的表现现象是对源码一样一行加注释，只关注底层实现细节，但并未形成更高层次认知，对其设计理念并未提炼与深度领悟。 </li><li>能提问、思考、并提炼<br>随着技术类文章的持续分享，笔者认识了很多大牛、发现与大牛交流的时候，一开始并不会说细节，而是讲设计理念，这就要求我们在<strong>阅读源码的时候多思考</strong>，并反问自己如果需要自己实现的话我们该如何着手，如何设计，带着疑问去研究源码，通过对比，思考，会对其背后的理念有了更深刻的理解。</li><li>思考、质疑、验证<br>其实无论是哪个开源框架都会存在BUG或者实现并不合理的地方，如果大家在阅读源码的时候能够思考并开始质疑其不合理性，并能通过验证证明自己的观点，然后与官方取得联系，交流，建Isuue，共同促进社区的发展，说明我们的能力、思考得到了极大的提升。</li></ol><p>关于这一点，可以参考笔者对 Sentinel 对应熔断实现机制进行的质疑与思考过程。</p><p><a href="https://mp.weixin.qq.com/s/4HrfIfwszrW-q2BUcVwlhw">从Sentinel Dubbo 适配器看限流与熔断（实战思考篇）</a></p><h2 id="4、源码阅读误区"><a href="#4、源码阅读误区" class="headerlink" title="4、源码阅读误区"></a>4、源码阅读误区</h2><p><strong>源码阅读是手段，但一定不是目的。</strong></p><p>我在面试过程中发现好多候选者在谈到某一项技术时，首先不是介绍其原理，而是一下子具体到某个类啥的，这些类是如何如何工作等等，其实这是不太妥当的，源码阅读的目的是主要是深入理解其设计理念、工作机制，方便我们在实际使用过程中对其成体系的认识，加强对它的驾驭能力，做到提前规避风险。</p><p>其次源码阅读<strong>非常不建议</strong>一上来就直接DEBUG。如果一开始就使用DEBUG，很容易会迷失在代码的各个分支中，<strong>缺乏全局视角</strong>，从而变得没有头绪，极大的增加了源码理解的难度，很容易让我们半途而废。</p><p><strong>最后学习一门技术并一定要深入源码</strong>，特别是非主流，非重点打造的领域。对于此类我们通常只需根据阅读官方文档，了解其使用场景、能解决什么问题，理解其设计理念、工作机制，灵活运用解决具体问题即可。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>源码阅读并不是目的，只是手段。对于通用型基础技术诸如JAVA集合、并发、需重点打造为亮点的领域建议大家阅读其源码，成体系深入细节掌握其工作机制，增强其驾驭能力，拥有提前规避风险的能力。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在技术职场中普遍存在如下几种现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对待工作中所使用的技术&lt;strong&gt;不需要阅读源码&lt;/strong&gt;，只需在开发过程中能够熟练运用就行&lt;/li&gt;
&lt;li&gt;看源码太费时间，而且容易忘记，如果从实际使用过程中出现的问题出发，针对性的阅读源码，其学习效率会更高效，所以平时无需看源码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对此我有着不同的理解，容我慢慢道来。&lt;/p&gt;
&lt;p&gt;本文将从如下4个角度进行剖析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码阅读的必要性&lt;/li&gt;
&lt;li&gt;源码阅读技巧&lt;/li&gt;
&lt;li&gt;源码阅读的三种境界&lt;/li&gt;
&lt;li&gt;源码阅读的误区&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="源码" scheme="https://www.codingw.net/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="阅读" scheme="https://www.codingw.net/tags/%E9%98%85%E8%AF%BB/"/>
    
    <category term="源码分享" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"/>
    
    <category term="源码阅读" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="技巧" scheme="https://www.codingw.net/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Netty4 事件处理传播机制</title>
    <link href="https://www.codingw.net/posts/be152999.html"/>
    <id>https://www.codingw.net/posts/be152999.html</id>
    <published>2020-12-19T14:11:01.000Z</published>
    <updated>2020-12-24T10:12:35.186Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本节将详细分析Netty事件传播机制，即事件链的实现机制。</p><p>本文重点的行文思路：</p><ul><li>详解事件的触发事件</li><li>事件传播机制</li><li>思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？</li></ul><a id="more"></a><p>Netty4的事件链核心类如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215532749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下先详细介绍上述核心类的核心方法。<br>1、ChannelPipeline<br>“Channel流水线”，即Channel管道（事件处理链），其主要核心方法包括如下三类。<br><strong>添加类操作</strong></p><ul><li>ChannelPipeline addFirst(String name, ChannelHandler handler)</li><li>ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler)</li><li>ChannelPipeline addFirst(ChannelHandler… handlers)</li><li>ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler… handlers)</li><li>ChannelPipeline addLast(String name, ChannelHandler handler)</li><li>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler)</li><li>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler)</li></ul><p>其中省略了addLast、addBefore、addAfter的其他重载方法，模式为addFirst类似。在这里着重讲解一下各个参数的含义。</p><ul><li>EventExecutorGroup group<br>ChannelHandler执行的线程组EventLoop，如果为空，则ChannelHandler在Channel所注册的EventLoop。</li><li>String name<br>ChannelHandler的名称，DefaultChannelPipeline会避免因重名而修改ChannelHandler的名称。</li></ul><p><strong>ChannelHandler的增删改查</strong></p><ul><li>ChannelPipeline remove(ChannelHandler handler)<br>ChannelHandler removeFirst()<br>省略其他API，此类API其实能反映出ChannelPipeline内部是一个双链表结构。</li></ul><p><strong>入端(inbound)事件传播</strong></p><ul><li>ChannelPipeline fireChannelRegistered()</li><li>ChannelPipeline fireChannelUnregistered()</li><li>ChannelPipeline fireChannelActive()</li><li>ChannelPipeline fireChannelInactive()</li><li>ChannelPipeline fireExceptionCaught(Throwable cause)</li><li>ChannelPipeline fireUserEventTriggered(Object event)</li><li>ChannelPipeline fireChannelRead(Object msg)</li><li>ChannelPipeline fireChannelReadComplete()</li><li>ChannelPipeline fireChannelWritabilityChanged()<br>不难看出，此类API方法名 fire + ChannelInboundHandler 中的方法。特别注意的是fireChannelRead(Object msg)的参数为通过网络SocketChannel#read一次读取的字节数组（ByteBuf），跟随着事件处理器一步一步的处理。</li></ul><p><strong>出端(outbound)事件传播</strong></p><ul><li>ChannelFuture bind(SocketAddress localAddress)</li><li>ChannelFuture connect(SocketAddress remoteAddress)</li><li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)</li><li>ChannelFuture disconnect()</li><li>ChannelFuture close()</li><li>ChannelFuture deregister()</li><li>ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise)</li><li>ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise)</li><li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</li><li>ChannelFuture disconnect(ChannelPromise promise)</li><li>ChannelFuture close(ChannelPromise promise)</li><li>ChannelFuture deregister(ChannelPromise promise)</li><li>ChannelPipeline read()</li><li>ChannelFuture write(Object msg)</li><li>ChannelFuture write(Object msg, ChannelPromise promise)</li><li>ChannelPipeline flush()</li><li>ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)</li><li>ChannelFuture writeAndFlush(Object msg)<br>不难看出，上述方法为ChannelOutboundHandler的方法。</li></ul><h2 id="2、DefaultChannelPipeline"><a href="#2、DefaultChannelPipeline" class="headerlink" title="2、DefaultChannelPipeline"></a>2、DefaultChannelPipeline</h2><p>ChannelPipeline的简单类图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215634424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合head、taill与下面的构造函数可知DefaultChannelPipeline的结构是其双链表，其中head、tail为双链表的首尾节点，并且其引用不能更改，其中节点（Node）实现为AbstractChannelHandlerContext，其内部必然定义两个属性prev与next，分别代表前一个节点与下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从这里看一个Channel对应一个ChannelPipeline。</p><h3 id="2-1-事件链构建"><a href="#2-1-事件链构建" class="headerlink" title="2.1 事件链构建"></a>2.1 事件链构建</h3><p>本节将以addFirst方法为例展示ChannelPipeline事件链的维护实现。<br>DefaultChannelPipeline#addFirst</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addFirst(<span class="keyword">null</span>, name, handler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>内部调用其重载方法。接下来重点分析该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;     <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);                                                                                                                        <span class="comment">// @2</span></span><br><span class="line">            name = filterName(name, handler);</span><br><span class="line">            newCtx = newContext(group, name, handler);                                                                                         <span class="comment">// @3</span></span><br><span class="line">            addFirst0(newCtx);                                                                                                                                   <span class="comment">// @4                                   </span></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;                                                                                                                                        <span class="comment">// @5</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;                                                                                                                  <span class="comment">// @6</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);                                                                                                                    <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先对参数简单说明一下：</p><ul><li>EventExecutorGroup group：指定ChannelHandler在哪个事件选择器中执行(EventLoopGroup)，如果为空，表示在Channel注册的事件轮询器中执行。</li><li>String name：ChannelHandler名称。</li><li>ChannelHandler channelHandler：待添加的事件处理器。</li></ul><p>代码@2：检查是否重复添加，声明为Shareable的ChannelHandler允许重复添加。</p><p>代码@3：使用AbstractChannelHandlerContext类包装ChannelHandler，即双链表结构的Node类为AbstractChannelHandlerContext。</p><p>代码@4：将AbstractChannelHandlerContext调用addFirst0添加到双链表的“第一条”，其实是添加到双链表头结点(HeaderContext)的next值执行该节点。</p><p>代码@5-代码@7都是处理handerAdd事件，如果通道还未注册，handerAdd事件会“挂起”，也就是需要等待通道被注册后才执行，其实现思路也是构建PendingHandlerCallback链，DefaultChannelPipeline内部持有该链的头节点，待通道注册后，顺序触发handlerAdd事件的传播。</p><p>接下来看一下addFirst0的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext nextCtx = head.next;    </span><br><span class="line">        newCtx.prev = head;                                                        </span><br><span class="line">        newCtx.next = nextCtx;                                                  </span><br><span class="line">        head.next = newCtx;                                                       </span><br><span class="line">        nextCtx.prev = newCtx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是典型的链表操作过程。<br>如果使用如下代码构建事件链，那事件是如何传播的呢？<br>p.addLast(“1”, new InboundHandlerA());<br>p.addLast(“2”, new InboundHandlerB());<br>p.addLast(“3”, new OutboundHandlerA());<br>p.addLast(“4”, new OutboundHandlerB());<br>p.addLast(“5”, new InboundOutboundHandlerX());<br>其构建的事件链最终如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215730318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但ChannelInboundHandler中的事件是如何传播的呢？ChannelOutboundHandler的事件又是如何传播的呢？</p><p>事件链中的节点对象为AbstractChannelHandlerContext，其类图如下：</p><p><img src="https://img-blog.csdnimg.cn/2020121321581174.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>HeadContext：事件链的头节点。</li><li>TailContext：事件链的尾节点。</li><li>DefaultChannelHandlerContext：用户定义的Handler所在的节点。</li></ul><h3 id="2-2-事件传播"><a href="#2-2-事件传播" class="headerlink" title="2.2 事件传播"></a>2.2 事件传播</h3><p>inbound事件与outbound事件传播机制实现原理相同，只是方向不同，inbound事件的传播从HeadContext开始，沿着next指针进行传播，而outbound事件传播从TailContext开始，沿着prev指针向前传播，故下文重点分析inbound事件传播机制。</p><p>DefaultChannelPipeline有关于ChannelInboundHandler的方法实现如下：<br><img src="https://img-blog.csdnimg.cn/20201213215906969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>所有的入端事件的传播入口都是从head开始传播</strong>。接下来我们以channelRead事件的传播为例，展示inbound的事件的流转。注意：以下观点都是针对NIO的读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline#fireChannelRead(Object msg) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">     AbstractChannelHandlerContext.invokeChannelRead(head, msg);  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先在NIO事件选择器在网络读事件就绪后，会调用底层SocketChanel#read 方法从读缓存中读取字节，在Netty中使用ByteBuf来存储，然后调用DefaultChannelPipeline # fireChannelRead 方法进行事件传播，每个ChannelHandler针对输入进行加工处理，ChannelPipeline因此而得名，有关Netty基于NIO的事件就绪选择实现将在Netty线程模型、IO读写流程部分详细讲解。</p><p>从代码@1处可得知，通过AbstractChannelHandlerContext的静态方法invokerChanelRead，从HeadContext处开始执行，</p><p>AbstractChannelHandlerContext#invokerChanelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, <span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        EventExecutor executor = next.executor();         <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;                                <span class="comment">// @2</span></span><br><span class="line">            next.invokeChannelRead(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;              <span class="comment">// @3</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种写法是Netty处理事件执行的“模板”方法，都是先获取需要执行的线程组(EventLoop),如果当前线程不属于Eventloop，则将任务提交到EventLoop中异步执行，如果在，则直接调用。第一次调用，该next指针为HeadContext，那接下来重点关注一下HeadContext的invokeChannelRead方法。<br>AbstractChannelHandlerContext#invokeChannelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;                                                                            <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);   <span class="comment">// @2</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);                                                                     <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该通道已经成功添加@1，则执行对应的事件@2，否则只是传播事件@3。</p><p>传播事件在AbstractChannelHandlerContext的实现思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext#fireChannelRead</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述就从事件链中按顺序提取inbound类型的处理器，上述代码要最终能结束，那么TailContext必须是Inbound类型的事件处理器。</p><p>从代码@2中执行完对应的事件处理逻辑后，事件如何向下传播呢？如果需要继续将事件传播的话，请调用ChannelInboundHandlerAdapter 对应的传播事件方法，如上例中的 ChannelInboundHandlerAdapter#fireChannelRead，该方法会将事件链继续往下传播，如果在对应的事件处理中继续调用fireChannelRead，则事件传播则停止传播，也就是并不是事件一定会顺着整个调用链到达事件链的尾部TailContext，在实践中请特别重视。</p><p>Netty inbound 事件传播流程图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215946585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述主要分析了inboud事件的传播机制，为了加深理解，我们接下来浏览一下HeadContext、TailContext是如何实现各个事件方法的，这些事件，后续在梳理Netty读写流程时会再详细介绍。</p><h3 id="2-3-源码分析DefaultChannelPipeline-HeadContex"><a href="#2-3-源码分析DefaultChannelPipeline-HeadContex" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$HeadContex"></a>2.3 源码分析DefaultChannelPipeline$HeadContex</h3><h4 id="2-3-1-HeadContext声明与构造方法"><a href="#2-3-1-HeadContext声明与构造方法" class="headerlink" title="2.3.1 HeadContext声明与构造方法"></a>2.3.1 HeadContext声明与构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;    <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;                                                                     <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;                        </span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：HeadContext实现ChannelInboundHandler与ChannelOutboundHandler，故它的inbound与outbound都返回true。<br>代码@2：Unsafe，Netty操作类。</p><h4 id="2-3-2-handlerAdded、handlerRemoved"><a href="#2-3-2-handlerAdded、handlerRemoved" class="headerlink" title="2.3.2 handlerAdded、handlerRemoved"></a>2.3.2 handlerAdded、handlerRemoved</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChanelHandler增加与移除事件处理逻辑：不做任何处理。为什么可以不传播呢？其实上文在讲解addFirst方法时已提到，在添加一个ChannelHandler到事件链时，会根据通道是否被注册，如果未注册，会先阻塞执行，DefaultChannelPipeline会保存一条执行链，等通道被注册后处触发执行，HeadContext作为一个非业务类型的事件处理器，对通道的增加与否无需关注。</p><h4 id="2-3-3-exceptionCaught"><a href="#2-3-3-exceptionCaught" class="headerlink" title="2.3.3 exceptionCaught"></a>2.3.3 exceptionCaught</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道异常处理事件的处理逻辑：HeadContext的选择是自己不关注，直接将异常事件往下传播。</p><h4 id="2-3-4-channelRegistered"><a href="#2-3-4-channelRegistered" class="headerlink" title="2.3.4 channelRegistered"></a>2.3.4 channelRegistered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">            <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">            callHandlerAddedForAllHandlers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通道注册事件处理逻辑：当通道成功注册后，判断是否是第一次注册，如果是第一次注册的话，调用所有的ChannelHandler#handlerAdd事件，因为当通道增加到事件链后，如果该通道还未注册，channelAdd事件不会马上执行，需要等通道注册后才执行，故在这里首先需要执行完挂起（延迟等待的任务）。然后调用fireChannelRegistered沿着事件链传播通道注册成功事件。</p><h4 id="2-3-5-channelUnregistered"><a href="#2-3-5-channelUnregistered" class="headerlink" title="2.3.5 channelUnregistered"></a>2.3.5 channelUnregistered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通道取消注册事件处理逻辑：首先传播事件，然后判断通道的状态，如果是处于关闭状态（通道调用了close方法），则需要移除所有的ChannelHandler。</p><h4 id="2-3-6-channelActive"><a href="#2-3-6-channelActive" class="headerlink" title="2.3.6 channelActive"></a>2.3.6 channelActive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> ctx.fireChannelActive();</span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通道激活事件的处理逻辑（TCP连接建立成功后触发）：首先传播该事件，如果开启自动读机制(autoRead为true)，则调用Channel#read方法，向NIO Selector注册读事件。</p><h4 id="2-3-7-channelInactive"><a href="#2-3-7-channelInactive" class="headerlink" title="2.3.7 channelInactive"></a>2.3.7 channelInactive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelInactive();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通道非激活事件处理逻辑：只传播事件。</p><h4 id="2-3-8-channelRead"><a href="#2-3-8-channelRead" class="headerlink" title="2.3.8 channelRead"></a>2.3.8 channelRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道读事件处理逻辑：向下传播事件，各个编码器、业务处理器将各自处理业务逻辑。</p><h4 id="2-3-9-channelReadComplete"><a href="#2-3-9-channelReadComplete" class="headerlink" title="2.3.9 channelReadComplete"></a>2.3.9 channelReadComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelReadComplete();</span><br><span class="line">readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道读完成事件，首先先传播事件，然后如果开启了自动读取的话，继续注册读事件。</p><h4 id="2-3-10-userEventTriggered"><a href="#2-3-10-userEventTriggered" class="headerlink" title="2.3.10 userEventTriggered"></a>2.3.10 userEventTriggered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireUserEventTriggered(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户自定义事件的处理逻辑：传播事件。</p><h4 id="2-3-11-channelWritabilityChanged"><a href="#2-3-11-channelWritabilityChanged" class="headerlink" title="2.3.11 channelWritabilityChanged"></a>2.3.11 channelWritabilityChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelWritabilityChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道可写状态变更事件的处理逻辑：传播事件。</p><p>接下来介绍HeadContext对于ChannelOutboundHander事件的处理逻辑：</p><h4 id="2-3-12-bind"><a href="#2-3-12-bind" class="headerlink" title="2.3.12 bind"></a>2.3.12 bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">( ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Unsafe实例完成具体的绑定操作，后续会重点分析该方法的实现原理。</p><p>由于HeadContex是outbound事件的尾部事件处理器，而且outbound是用户发送的API调用，其最终目的是希望通过Netty完成具体的网络操作，故HeadContex是离Netty底层机制最近的，到了这里，就意味者“应用程序”层面的定制化介绍，最终需要通过HeadContex直接调用Netty的API来完成具体的动作，故HeadContex关于outbound事件的实现，都是通过调用unsafe去完成具体的动作。故后面的方面就不在一一罗列。</p><h3 id="2-3-源码分析DefaultChannelPipeline-TailContext"><a href="#2-3-源码分析DefaultChannelPipeline-TailContext" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$TailContext"></a>2.3 源码分析DefaultChannelPipeline$TailContext</h3><p>TailContext由于是 inbound事件链的最后一站，故该节点大部分事件都是空实现，其他实现的方法，基本上就是释放一下资源，我们看一下TailContex关于channelRead事件的处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            onUnhandledInboundMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是主动调用ReferenceCountUtil.release(msg)释放资源。</p><p>Netty事件传播机制就讲解到这里了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节将详细分析Netty事件传播机制，即事件链的实现机制。&lt;/p&gt;
&lt;p&gt;本文重点的行文思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详解事件的触发事件&lt;/li&gt;
&lt;li&gt;事件传播机制&lt;/li&gt;
&lt;li&gt;思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="netty4" scheme="https://www.codingw.net/categories/netty4/"/>
    
    
    <category term="netty4" scheme="https://www.codingw.net/tags/netty4/"/>
    
    <category term="事件传播" scheme="https://www.codingw.net/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>源码分析RateLimiter SmoothWarmingUp 实现原理(文末附流程图)</title>
    <link href="https://www.codingw.net/posts/6c0cb4a9.html"/>
    <id>https://www.codingw.net/posts/6c0cb4a9.html</id>
    <published>2020-12-18T14:53:35.000Z</published>
    <updated>2020-12-24T10:12:48.764Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上一篇详细介绍了 <a href="https://blog.csdn.net/prestigeding/article/details/105027563">SmoothBursty</a> 的实现原理，本文将介绍带有预热机制的限速器实现原理。</p><h2 id="1、类图"><a href="#1、类图" class="headerlink" title="1、类图"></a>1、类图</h2><p><img src="https://img-blog.csdnimg.cn/20200329155128855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上文也详细介绍了 RateLimiter 相关的类图，本文就不详细介绍。</p><h2 id="2、SmoothWarmingUp-创建流程"><a href="#2、SmoothWarmingUp-创建流程" class="headerlink" title="2、SmoothWarmingUp 创建流程"></a>2、SmoothWarmingUp 创建流程</h2><p>创建 SmoothWarmingUp 限速器的入口为 RateLimiter 的 create 方法，其代码如下：<br>RateLimiter#create</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    checkArgument(warmupPeriod &gt;= <span class="number">0</span>, <span class="string">&quot;warmupPeriod must not be negative: %s&quot;</span>, warmupPeriod);</span><br><span class="line">    <span class="keyword">return</span> create(</span><br><span class="line">        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先先来看一下参数列表：</p><ul><li>double permitsPerSecond<br>每秒发放许可数量，即所谓的QPS。</li><li>long warmupPeriod<br>设置预热时间。</li><li>TimeUnit unit<br>warmupPeriod 的时间单位。</li></ul><p>代码@2：调用内部的重载方法创建 SmoothWarmingUp 。</p><a id="more"></a><p>RateLimiter#create</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">( SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit, <span class="keyword">double</span> coldFactor)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);  <span class="comment">// @1</span></span><br><span class="line">    rateLimiter.setRate(permitsPerSecond); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 SmoothWarmingUp 两个主要步骤分别是调用其构造方法首先创建 SmoothWarmingUp 实例，然后调用其 setRate 方法进行初始化速率。这里先突出 coldFactor，默认为 3.0，该属性的作用将在下文详细介绍。</p><p>我们先来重点探讨一下 setRate 方法的实现。最终会调用其父类 SmoothRateLimiter 的doSetRate 方法。</p><p>SmoothRateLimiter#doSetRate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1 </span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;   </span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;   <span class="comment">// @2</span></span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);  <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：基于当前时间重置 SmoothRateLimiter 内部的 storedPermits(已存储的许可数量) 与 nextFreeTicketMicros(下一次可以免费获取许可的时间) 值，所谓的免费指的是无需等待就可以获取设定速率的许可，该方法对理解限流许可的产生非常关键，稍后详细介绍。</p><p>代码@2：根据QPS算出一个稳定的获取1个许可的时间。以一秒发放5个许可，即限速为5QPS，那发放一个许可的世界间隔为 200ms，stableIntervalMicros 变量是以微妙为单位。</p><p>代码@4：调用 SmoothRateLimiter 的抽象方法 doSetRate 设置速率，这里会调用 SmoothWarmingUp 的 doSetRate 方法。</p><p>在介绍 SmoothWarmingUp 的 doSetRate 方法之前，我们先来看一下 resync 方法的实现。</p><p>SmoothRateLimiter#resync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;  <span class="comment">// @1 </span></span><br><span class="line">      <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();  <span class="comment">// @2</span></span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);    <span class="comment">// @3</span></span><br><span class="line">      nextFreeTicketMicros = nowMicros;   <span class="comment">// @4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果当前已启动时间大于nextFreeTicketMicros（下一次可以免费获取许可的时间），则需要重新计算许可，即又可以向许可池中添加许可。</p><p>代码@2：根据当前时间可增加的许可数量，由于 SmoothWarmingUp 实现了预热机制，平均生成一个许可的时间并不是固定不变的。具体由 coolDownIntervalMicros 方法实现，稍候详细介绍。</p><p>代码@3：计算当前可用的许可，将新增的这些许可添加到许可池，但不会超过其最大值。</p><p>代码@4：更新下一次可增加计算许可的时间。 </p><p>SmoothWarmingUp#coolDownIntervalMicros</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">coolDownIntervalMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现其实简单，用生成这些许可的总时间除以现在已经生成的许可数，即可得到当前时间点平均一个许可的生成时间。</p><ol><li><p>接下来重点探讨 SmoothWarmingUp 的 doSetRate 方法。<br>为了方便理解 SmoothWarmingUp doSetRate 方法，我根据 SmoothWarmingUp 类的注释，结合代码，给出如下示例图：<br><img src="https://img-blog.csdnimg.cn/20200329155338150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先我们先来根据 SmoothWarmingUp 的相关注释来理解一下上述这张图的几个要点。</p><ul><li>图中有两个阴影面积，一个用 stable，另外一个warm up period。在预热算法中，这两个阴影面积的关系与冷却因子相关。</li><li>冷却因子 coldFactor 表示的含义为 coldIntervalMicros 与  stableIntervalMicros 的比值。</li><li>warm up period 阴影面积 与 stable 阴影面积的比值等于 (coldIntervalMicros -  stableIntervalMicros ) / stableIntervalMicros ，例如 SmoothWarmingUp 固定的冷却因子为3，那么 coldIntervalMicros 与 stableIntervalMicros 的比值为 3，那  (coldIntervalMicros -  stableIntervalMicros ) / stableIntervalMicros 则为 2。</li><li>在预热算法中与数学中的积分相关（笔者对这方面的数学知识一窍不通），故这里只展示结论，而不做推导，阴影 WARM UP PERIOD 的面积等于 warmupPeriod,那阴影stable的面积等于 warmupPeriod/2。</li><li>存在如下等式 warmupPeriod/2 = thresholdPermits * stableIntervalMicros (长方形的面积)</li><li>同样存在如下等式 warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits) （梯形面积，(上底 + 下底 * 高 / 2) ）</li></ul><p>有了上述基本知识，我们再来看一下代码。</p><p>SmoothWarmingUp#doSetRate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = maxPermits;</span><br><span class="line">    <span class="keyword">double</span> coldIntervalMicros = stableIntervalMicros * coldFactor;                <span class="comment">// @1</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;    <span class="comment">// @2</span></span><br><span class="line">    maxPermits =</span><br><span class="line">          thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);   <span class="comment">// @3</span></span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);  <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;    <span class="comment">// @5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据冷却因子(coldFactor)来计算冷却间隔(单位为微秒)，等于冷却因子与 stableIntervalMicros 的乘积。从这里我们可以得出如下几个基本的概念。冷却因子 coldFactor 为 冷却间隔与稳定间隔的比例。</p><p>代码@2：通过  warmupPeriod/2 = thresholdPermits * stableIntervalMicros 等式，求出 thresholdPermits 的值。</p><p>代码@3：根据  warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)  表示可求出 maxPermits 的数量。</p><p>代码@4：斜率，表示的是从 stableIntervalMicros 到 coldIntervalMicros 这段时间，许可数量从 thresholdPermits 变为 maxPermits 的增长速率。</p><p>代码@5：根据 maxPermits 更新当前存储的许可，即当前剩余可消耗的许可数量。</p><h2 id="3、SmoothWarmingUp-acquire-流程"><a href="#3、SmoothWarmingUp-acquire-流程" class="headerlink" title="3、SmoothWarmingUp acquire 流程"></a>3、SmoothWarmingUp acquire 流程</h2><p>首先 acquire 的定义在其父类，这里是典型的模板模式，由其父类定义基本流程，由具体的子类实现其特定功能。RateLimiter 中的 acquire 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);    <span class="comment">// @1</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);   <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据当前剩余的许可与本次申请的许可来判断本次申请需要等待的时长，如果返回0则表示无需等待。</p><p>代码@2：如果需要等待的时间不为0，表示触发限速，睡眠指定时间后唤醒。</p><p>代码@3：返回本次申请等待的时长。</p><p>接下来重点介绍 reserve 方法的实现原理。</p><p>RateLimiter#reserve</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inal <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;  <span class="comment">// @1</span></span><br><span class="line">      <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros()); <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：限速器主要维护的重要数据字段(storedPermits)，对其进行维护时都需要先获取锁。</p><p>代码@2：调用内部方法 reserveAndGetWaitLength 来计算需要等待时间。</p><p>继续跟踪 reserveAndGetWaitLength 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据当前拥有的许可数量、当前时间判断待申请许可最早能得到满足的最早时间，用momentAvailable 表示。</p><p>代码@2：然后计算 momentAvailable 与 nowMicros 的差值与0做比较，得出需要等待的时间。</p><p>继续跟踪 reserveEarliestAvailable方法，该方法在 RateLimiter 中一个抽象方法，具体实现在其子类 SmoothRateLimiter 中。</p><p>SmoothRateLimiter#reserveEarliestAvailable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend; <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);  <span class="comment">// @4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);  <span class="comment">// @5</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;    <span class="comment">// @6</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：在尝试申请许可之前，先根据当前时间即发放许可速率更新 storedPermits 与 nextFreeTicketMicros（下一次可以免费获取许可的时间）。</p><p>代码@2：计算本次能从 storedPermits 中消耗的许可数量，取需要申请的许可数量与当前可用的许可数量的最小值，用 storedPermitsToSpend 表示。</p><p>代码@3：如果需要申请的许可数量(requiredPermits)大于当前剩余许可数量(storedPermits)，则还需要等待新的许可生成，用freshPermits 表示，即如果该值大于0，则表示本次申请需要阻塞一定时间。</p><p>代码@4：计算本次申请需要等待的时间，等待的时间由两部分组成，一部分是由 storedPermitsToWaitTime 方法返回的，另外一部分以稳定速率生成需要的许可，其需要时间为 freshPermits * stableIntervalMicros,稍后我们详细分析一下 storedPermitsToWaitTime 方法的实现。</p><p>代码@5：更新 nextFreeTicketMicros 为当前时间加上需要等待的时间。</p><p>代码@6：更新 storedPermits 的值，即减少本次已消耗的许可数量。</p><p>代码@7：请注意这里返回的 returnValue 的值，并没有包含由于剩余许可需要等待创建新许可的时间，即允许一定的突发流量，故本次计算需要的等待时间将对下一次请求生效。</p><p>接下来重点探讨一下 SmoothWarmingUp 的 storedPermitsToWaitTime 方法。</p><p>SmoothWarmingUp#SmoothWarmingUp </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line"><span class="keyword">double</span> availablePermitsAboveThreshold = storedPermits - thresholdPermits;   <span class="comment">// @2</span></span><br><span class="line"><span class="keyword">long</span> micros = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;  <span class="comment">// @3</span></span><br><span class="line"><span class="keyword">double</span> permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);  <span class="comment">// @31 </span></span><br><span class="line">                <span class="comment">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class="line">                <span class="keyword">double</span> length = permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">                     + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);             <span class="comment">// @32</span></span><br><span class="line">                micros = (<span class="keyword">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);                                                      <span class="comment">// @33</span></span><br><span class="line">                permitsToTake -= permitsAboveThresholdToTake;                                                                          <span class="comment">// @34</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">        micros += (stableIntervalMicros * permitsToTake);   <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先介绍其两个参数的含义：</p><ul><li>double storedPermits<br>当前存储的许可数量。</li><li>double permitsToTake<br>本次申请需要的许可数量。</li></ul><p>代码@2：availablePermitsAboveThreshold ，当前超出 thresholdPermits 的许可个数，如果超过 thresholdPermits ，申请许可将来源于超过的部分，只有其不足后，才会从 thresholdPermits 中申请，这部分的详细逻辑见代码@3。</p><p>代码@3：如果当前存储的许可数量超过了稳定许可 thresholdPermits，即存在预热的许可数量的申请逻辑，其实现关键点如下：</p><ul><li>获取本次从预热区间申请的许可数量。</li><li>从预热区间获取一个许可的时间其算法有点晦涩难懂，具体实现为@32~@34。</li></ul><p>代码@4：从稳定区间获取一个许可的时间，就容易理解，为固定的 stableIntervalMicros 。</p><blockquote><p>温馨提示：从预热区间计算获取多个许可的算法，与 slope 有关，笔者并未完成感悟，但至少我们需要明白的是，从 剩余许可(storedPermits)中申请许可时，优先消耗(大于thresholdPermits 的许可，即消耗 (thresholdPermits ~ maxPermit ) 之间的许可)。</p></blockquote><p>SmoothWarmingUp 的 acquire 流程就介绍到这里了。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>SmoothWarmingUp 的 acquire 的流程与 SmoothBursty 类似，故其流程图与下图通用，主要的区别生成一个许可的时间有变化，主要是提供了预热机制。<br><img src="https://img-blog.csdnimg.cn/20200329155751536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇详细介绍了 &lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/105027563&quot;&gt;SmoothBursty&lt;/a&gt; 的实现原理，本文将介绍带有预热机制的限速器实现原理。&lt;/p&gt;
&lt;h2 id=&quot;1、类图&quot;&gt;&lt;a href=&quot;#1、类图&quot; class=&quot;headerlink&quot; title=&quot;1、类图&quot;&gt;&lt;/a&gt;1、类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329155128855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;从上文也详细介绍了 RateLimiter 相关的类图，本文就不详细介绍。&lt;/p&gt;
&lt;h2 id=&quot;2、SmoothWarmingUp-创建流程&quot;&gt;&lt;a href=&quot;#2、SmoothWarmingUp-创建流程&quot; class=&quot;headerlink&quot; title=&quot;2、SmoothWarmingUp 创建流程&quot;&gt;&lt;/a&gt;2、SmoothWarmingUp 创建流程&lt;/h2&gt;&lt;p&gt;创建 SmoothWarmingUp 限速器的入口为 RateLimiter 的 create 方法，其代码如下：&lt;br&gt;RateLimiter#create&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; RateLimiter &lt;span class=&quot;title&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; permitsPerSecond, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; warmupPeriod, TimeUnit unit)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    checkArgument(warmupPeriod &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;warmupPeriod must not be negative: %s&amp;quot;&lt;/span&gt;, warmupPeriod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; create(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：首先先来看一下参数列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;double permitsPerSecond&lt;br&gt;每秒发放许可数量，即所谓的QPS。&lt;/li&gt;
&lt;li&gt;long warmupPeriod&lt;br&gt;设置预热时间。&lt;/li&gt;
&lt;li&gt;TimeUnit unit&lt;br&gt;warmupPeriod 的时间单位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码@2：调用内部的重载方法创建 SmoothWarmingUp 。&lt;/p&gt;</summary>
    
    
    
    <category term="sentinel" scheme="https://www.codingw.net/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="https://www.codingw.net/tags/sentinel/"/>
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="SmoothWarmingUp" scheme="https://www.codingw.net/tags/SmoothWarmingUp/"/>
    
    <category term="coldFactor" scheme="https://www.codingw.net/tags/coldFactor/"/>
    
  </entry>
  
  <entry>
    <title>源码分析RocketMQ ACL实现机制</title>
    <link href="https://www.codingw.net/posts/a6ee7996.html"/>
    <id>https://www.codingw.net/posts/a6ee7996.html</id>
    <published>2020-12-17T14:20:35.000Z</published>
    <updated>2020-12-24T10:13:02.005Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>有关RocketMQ ACL的使用请查看上一篇<a href="https://blog.csdn.net/prestigeding/article/details/94317946">《RocketMQ ACL使用指南》</a>，本文从源码的角度，分析一下RocketMQ ACL的实现原理。</p><blockquote><p>备注：RocketMQ在4.4.0时引入了ACL机制，本文代码基于RocketMQ4.5.0版本。</p></blockquote><p>根据RocketMQ ACL使用手册，我们应该首先看一下Broker服务器在开启ACL机制时如何加载配置文件，并如何工作的。</p><a id="more"></a><h2 id="1、BrokerController-initialAcl"><a href="#1、BrokerController-initialAcl" class="headerlink" title="1、BrokerController#initialAcl"></a>1、BrokerController#initialAcl</h2><p>Broker端ACL的入口代码为：BrokerController#initialAcl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialAcl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerConfig.isAclEnable()) &#123;                           <span class="comment">// @1</span></span><br><span class="line">        log.info(<span class="string">&quot;The broker dose not enable acl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;AccessValidator&gt; accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (accessValidators == <span class="keyword">null</span> || accessValidators.isEmpty()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;The broker dose not load the AccessValidator&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AccessValidator accessValidator: accessValidators) &#123;                       <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">final</span> AccessValidator validator = accessValidator;</span><br><span class="line">        <span class="keyword">this</span>.registerServerRPCHook(<span class="keyword">new</span> RPCHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//Do not catch the exception</span></span><br><span class="line">                validator.validate(validator.parse(request, remoteAddr));                         <span class="comment">// @4</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterResponse</span><span class="params">(String remoteAddr, RemotingCommand request, RemotingCommand response)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本方法的实现共4个关键点。<br>代码@1：首先判断Broker是否开启了acl，通过配置参数aclEnable指定，默认为false。</p><p>代码@2：使用类似SPI机制，加载配置的AccessValidator,该方法返回一个列表，其实现逻辑时读取META-INF/service/org.apache.rocketmq.acl.AccessValidator文件中配置的访问验证器，默认配置内容如下：<br><img src="https://img-blog.csdnimg.cn/20190707120439720.png" alt="在这里插入图片描述"><br>代码@3：遍历配置的访问验证器(AccessValidator),并向Broker处理服务器注册钩子函数，RPCHook的doBeforeRequest方法会在服务端接收到请求，将其请求解码后，执行处理请求之前被调用;RPCHook的doAfterResponse方法会在处理完请求后，将结果返回之前被调用，其调用如图所示：<br><img src="https://img-blog.csdnimg.cn/20190707120505807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码@4：在RPCHook#doBeforeRequest方法中调用AccessValidator#validate, 在真实处理命令之前，先执行ACL的验证逻辑，如果拥有该操作的执行权限，则放行，否则抛出AclException。</p><p>接下来，我们将重点放到Broker默认实现的访问验证器：PlainAccessValidator。</p><h2 id="2、PlainAccessValidator"><a href="#2、PlainAccessValidator" class="headerlink" title="2、PlainAccessValidator"></a>2、PlainAccessValidator</h2><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190707120530560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>AccessValidator<br>访问验证器接口，主要定义两个接口。<br>1）AccessResource parse(RemotingCommand request, String remoteAddr)<br>从请求头中解析本次请求对应的访问资源，即本次请求需要的访问权限。<br>2）void validate(AccessResource accessResource)<br>根据本次需要访问的权限，与请求用户拥有的权限进行对比验证，判断是拥有权限，如果没有访问该操作的权限，则抛出异常，否则放行。</li><li>PlainAccessValidator<br>RocketMQ默认提供的基于yml配置格式的访问验证器。</li></ul><p>接下来我们重点看一下PlainAccessValidator的parse方法与validate方法的实现细节。在讲解该方法之前，我们首先认识一下RocketMQ封装访问资源的PlainAccessResource。</p><h4 id="2-1-2-PlainAccessResource类图"><a href="#2-1-2-PlainAccessResource类图" class="headerlink" title="2.1.2 PlainAccessResource类图"></a>2.1.2 PlainAccessResource类图</h4><p><img src="https://img-blog.csdnimg.cn/20190707120741119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们对其属性一一做个介绍：</p><ul><li>private String accessKey<br>访问Key，用户名。</li><li>private String secretKey<br>用户密码。</li><li>private String whiteRemoteAddress<br>远程IP地址白名单。</li><li>private boolean admin<br>是否是管理员角色。</li><li>private byte defaultTopicPerm = 1<br>默认topic访问权限，即如果没有配置topic的权限，则Topic默认的访问权限为1，表示为DENY。</li><li>private byte defaultGroupPerm = 1<br>默认的消费组访问权限，默认为DENY。</li><li>private Map&lt;String, Byte&gt; resourcePermMap<br>资源需要的访问权限映射表。</li><li>private RemoteAddressStrategy remoteAddressStrategy<br>远程IP地址验证策略。</li><li>private int requestCode<br>当前请求的requestCode。</li><li>private byte[] content<br>请求头与请求体的内容。</li><li>private String signature<br>签名字符串，这是通常的套路，在客户端时，首先将请求参数排序，然后使用secretKey生成签名字符串，服务端重复这个步骤，然后对比签名字符串，如果相同，则认为登录成功，否则失败。</li><li>private String secretToken<br>密钥token。</li><li>private String recognition<br>目前作用未知，代码中目前未被使用。</li></ul><h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlainAccessValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aclPlugEngine = <span class="keyword">new</span> PlainPermissionLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数，直接创建PlainPermissionLoader对象，从命名上来看，应该是触发acl规则的加载，即解析plain_acl.yml，接下来会重点探讨，即acl启动流程之配置文件的解析。</p><h3 id="2-3-parse方法"><a href="#2-3-parse方法" class="headerlink" title="2.3 parse方法"></a>2.3 parse方法</h3><p>该方法的作用就是从请求命令中解析出本次访问所需要的访问权限，最终构建AccessResource对象，为后续的校验权限做准备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PlainAccessResource accessResource = <span class="keyword">new</span> PlainAccessResource();</span><br><span class="line"><span class="keyword">if</span> (remoteAddr != <span class="keyword">null</span> &amp;&amp; remoteAddr.contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：首先创建PlainAccessResource，从远程地址中提取出远程访问IP地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getExtFields() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(<span class="string">&quot;request&#x27;s extFields value is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">accessResource.setRequestCode(request.getCode());</span><br><span class="line">accessResource.setAccessKey(request.getExtFields().get(SessionCredentials.ACCESS_KEY));</span><br><span class="line">accessResource.setSignature(request.getExtFields().get(SessionCredentials.SIGNATURE));</span><br><span class="line">accessResource.setSecretToken(request.getExtFields().get(SessionCredentials.SECURITY_TOKEN));</span><br></pre></td></tr></table></figure><p>Step2：如果请求头中的扩展字段为空，则抛出异常，如果不为空，则从请求头中读取requestCode、accessKey(请求用户名)、签名字符串(signature)、secretToken。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.SEND_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.PUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.SEND_MESSAGE_V2:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;b&quot;</span>), Permission.PUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;originTopic&quot;</span>), Permission.PUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(<span class="string">&quot;group&quot;</span>)), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.PULL_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(<span class="string">&quot;consumerGroup&quot;</span>)), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.QUERY_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.HEART_BEAT:</span><br><span class="line">                    HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class);</span><br><span class="line">                    <span class="keyword">for</span> (ConsumerData data : heartbeatData.getConsumerDataSet()) &#123;</span><br><span class="line">                        accessResource.addResourceAndPerm(getRetryTopic(data.getGroupName()), Permission.SUB);</span><br><span class="line">                        <span class="keyword">for</span> (SubscriptionData subscriptionData : data.getSubscriptionDataSet()) &#123;</span><br><span class="line">                            accessResource.addResourceAndPerm(subscriptionData.getTopic(), Permission.SUB);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.UNREGISTER_CLIENT:</span><br><span class="line">                    <span class="keyword">final</span> UnregisterClientRequestHeader unregisterClientRequestHeader =</span><br><span class="line">                        (UnregisterClientRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(UnregisterClientRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(unregisterClientRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.GET_CONSUMER_LIST_BY_GROUP:</span><br><span class="line">                    <span class="keyword">final</span> GetConsumerListByGroupRequestHeader getConsumerListByGroupRequestHeader =</span><br><span class="line">                        (GetConsumerListByGroupRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(GetConsumerListByGroupRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(getConsumerListByGroupRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.UPDATE_CONSUMER_OFFSET:</span><br><span class="line">                    <span class="keyword">final</span> UpdateConsumerOffsetRequestHeader updateConsumerOffsetRequestHeader =</span><br><span class="line">                        (UpdateConsumerOffsetRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(UpdateConsumerOffsetRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(updateConsumerOffsetRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(updateConsumerOffsetRequestHeader.getTopic(), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AclException(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Step3：根据请求命令，设置本次请求需要拥有的权限，上述代码比较简单，就是从请求中得出本次操作的Topic、消息组名称，为了方便区分topic与消费组，消费组使用消费者对应的重试主题，当成资源的Key，从这里也可以看出，当前版本需要进行ACL权限验证的请求命令如下：</p><ul><li>SEND_MESSAGE</li><li>SEND_MESSAGE_V2</li><li>CONSUMER_SEND_MSG_BACK</li><li>PULL_MESSAGE</li><li>QUERY_MESSAGE</li><li>HEART_BEAT</li><li>UNREGISTER_CLIENT</li><li>GET_CONSUMER_LIST_BY_GROUP</li><li>UPDATE_CONSUMER_OFFSET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Content</span></span><br><span class="line">SortedMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : request.getExtFields().entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SessionCredentials.SIGNATURE.equals(entry.getKey())) &#123;</span><br><span class="line">        map.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">accessResource.setContent(AclUtils.combineRequestContent(request, map));</span><br><span class="line"><span class="keyword">return</span> accessResource;</span><br></pre></td></tr></table></figure><p>Step4：对扩展字段进行排序，便于生成签名字符串，然后将扩展字段与请求体(body)写入content字段。完成从请求头中解析出本次请求需要验证的权限。</p><h3 id="2-4-validate-方法"><a href="#2-4-validate-方法" class="headerlink" title="2.4 validate 方法"></a>2.4 validate 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(AccessResource accessResource)</span> </span>&#123;</span><br><span class="line">    aclPlugEngine.validate((PlainAccessResource) accessResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证权限，即根据本次请求需要的权限与当前用户所拥有的权限进行对比，如果符合，则正常执行；否则抛出AclException。</p><p>为了揭开配置文件的解析与验证，我们将目光投入到PlainPermissionLoader。</p><h2 id="3、PlainPermissionLoader"><a href="#3、PlainPermissionLoader" class="headerlink" title="3、PlainPermissionLoader"></a>3、PlainPermissionLoader</h2><p>该类的主要职责：加载权限，即解析acl主要配置文件plain_acl.yml。</p><h3 id="3-1-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190707121053922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面对其核心属性与核心方法一一介绍：</p><ul><li>DEFAULT_PLAIN_ACL_FILE<br>默认acl配置文件名称，默认值为conf/plain_acl.yml。</li><li>String fileName<br>acl配置文件名称，默认为DEFAULT_PLAIN_ACL_FILE ,可以通过系统参数-Drocketmq.acl.plain.file=fileName指定。</li><li>Map&lt;String, PlainAccessResource&gt; plainAccessResourceMap<br>解析出来的权限配置映射表，以用户名为键。</li><li>RemoteAddressStrategyFactory remoteAddressStrategyFactory<br>远程IP解析策略工厂，用于解析白名单IP地址。</li><li>boolean isWatchStart<br>是否开启了文件监听，即自动监听plain_acl.yml文件，一旦该文件改变，可在不重启服务器的情况下自动生效。</li><li>public PlainPermissionLoader()<br>构造方法。</li><li>public void load()<br>加载配置文件。</li><li>public void validate(PlainAccessResource plainAccessResource)<br>验证是否有权限访问待访问资源。</li></ul><h3 id="3-2-PlainPermissionLoader构造方法"><a href="#3-2-PlainPermissionLoader构造方法" class="headerlink" title="3.2 PlainPermissionLoader构造方法"></a>3.2 PlainPermissionLoader构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlainPermissionLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    load();</span><br><span class="line">    watch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中调用load与watch方法。</p><h3 id="3-3-load"><a href="#3-3-load" class="headerlink" title="3.3 load"></a>3.3 load</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, PlainAccessResource&gt; plainAccessResourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;RemoteAddressStrategy&gt; globalWhiteRemoteAddressStrategy = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String path = fileHome + File.separator + fileName;</span><br><span class="line">JSONObject plainAclConfData = AclUtils.getYamlDataObject(path,JSONObject.class);</span><br></pre></td></tr></table></figure><p>Step1：初始化plainAccessResourceMap(用户配置的访问资源，即权限容器)、globalWhiteRemoteAddressStrategy：全局IP白名单访问策略。配置文件，默认为${ROCKETMQ_HOME}/conf/plain_acl.yml。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONArray globalWhiteRemoteAddressesList = plainAclConfData.getJSONArray(<span class="string">&quot;globalWhiteRemoteAddresses&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (globalWhiteRemoteAddressesList != <span class="keyword">null</span> &amp;&amp; !globalWhiteRemoteAddressesList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; globalWhiteRemoteAddressesList.size(); i++) &#123;</span><br><span class="line">        globalWhiteRemoteAddressStrategy.add(remoteAddressStrategyFactory.</span><br><span class="line">        getRemoteAddressStrategy(globalWhiteRemoteAddressesList.getString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2：globalWhiteRemoteAddresses：全局白名单，类型为数组。根据配置的规则，使用remoteAddressStrategyFactory获取一个访问策略，下文会重点介绍其配置规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JSONArray accounts = plainAclConfData.getJSONArray(<span class="string">&quot;accounts&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (accounts != <span class="keyword">null</span> &amp;&amp; !accounts.isEmpty()) &#123;</span><br><span class="line">    List&lt;PlainAccessConfig&gt; plainAccessConfigList = accounts.toJavaList(PlainAccessConfig.class);</span><br><span class="line">    <span class="keyword">for</span> (PlainAccessConfig plainAccessConfig : plainAccessConfigList) &#123;</span><br><span class="line">        PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);</span><br><span class="line">        plainAccessResourceMap.put(plainAccessResource.getAccessKey(),plainAccessResource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy;</span><br><span class="line"><span class="keyword">this</span>.plainAccessResourceMap = plainAccessResourceMap;</span><br></pre></td></tr></table></figure><p>Step3：解析plain_acl.yml文件中的另外一个根元素accounts，用户定义的权限信息。从PlainAccessConfig的定义来看，accounts标签下支持如下标签：</p><ul><li>accessKey</li><li>secretKey</li><li>whiteRemoteAddress</li><li>admin</li><li>defaultTopicPerm</li><li>defaultGroupPerm</li><li>topicPerms</li><li>groupPerms<br>上述标签的说明，请参考：:<a href="https://blog.csdn.net/prestigeding/article/details/94317946">《RocketMQ ACL使用指南》</a> 。具体的解析过程比较容易，就不再细说。</li></ul><p>load方法主要完成acl配置文件的解析，将用户定义的权限加载到内存中。</p><h3 id="3-4-watch"><a href="#3-4-watch" class="headerlink" title="3.4 watch"></a>3.4 watch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String watchFilePath = fileHome + fileName;</span><br><span class="line">        FileWatchService fileWatchService = <span class="keyword">new</span> FileWatchService(<span class="keyword">new</span> String[] &#123;watchFilePath&#125;, <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;   </span><br><span class="line">                    log.info(<span class="string">&quot;The plain acl yml changed, reload the context&quot;</span>);</span><br><span class="line">                    load();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        fileWatchService.start();</span><br><span class="line">        log.info(<span class="string">&quot;Succeed to start AclWatcherService&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.isWatchStart = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Failed to start AclWatcherService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听器，默认以500ms的频率判断文件的内容是否变化。在文件内容发生变化后调用load()方法，重新加载配置文件。那FileWatchService是如何判断两个文件的内容发生了变化呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileWatchService#hash</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">hash</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    Path path = Paths.get(filePath);</span><br><span class="line">    md.update(Files.readAllBytes(path));</span><br><span class="line">    <span class="keyword">byte</span>[] hash = md.digest();</span><br><span class="line">    <span class="keyword">return</span> UtilAll.bytes2string(hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取文件md5签名来做对比，这里为什么不在启动时先记录上一次文件的修改时间，然后先判断其修改时间是否变化，再判断其内容是否真正发生变化。</p><h3 id="3-5-validate"><a href="#3-5-validate" class="headerlink" title="3.5 validate"></a>3.5 validate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check the global white remote addr</span></span><br><span class="line"><span class="keyword">for</span> (RemoteAddressStrategy remoteAddressStrategy : globalWhiteRemoteAddressStrategy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddressStrategy.match(plainAccessResource)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：首先使用全局白名单对资源进行验证，只要一个规则匹配，则返回，表示认证成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (plainAccessResource.getAccessKey() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No accessKey is configured&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!plainAccessResourceMap.containsKey(plainAccessResource.getAccessKey())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No acl config for %s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br><span class="line">Step2：如果请求信息中，没有设置用户名，则抛出未配置AccessKey异常；如果Broker中并为配置该用户的配置信息，则抛出AclException。</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the white addr for accesskey</span></span><br><span class="line">PlainAccessResource ownedAccess = plainAccessResourceMap.get(plainAccessResource.getAccessKey());</span><br><span class="line"><span class="keyword">if</span> (ownedAccess.getRemoteAddressStrategy().match(plainAccessResource)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：如果用户配置的白名单与待访问资源规则匹配的话，则直接发认证通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check the signature</span></span><br><span class="line">String signature = AclUtils.calSignature(plainAccessResource.getContent(), ownedAccess.getSecretKey());</span><br><span class="line"><span class="keyword">if</span> (!signature.equals(plainAccessResource.getSignature())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Check signature failed for accessKey=%s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4：验证签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkPerm(plainAccessResource, ownedAccess);</span><br></pre></td></tr></table></figure><p>Step5：调用checkPerm方法，验证需要的权限与拥有的权限是否匹配。</p><h4 id="3-5-1-checkPerm"><a href="#3-5-1-checkPerm" class="headerlink" title="3.5.1 checkPerm"></a>3.5.1 checkPerm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Permission.needAdminPerm(needCheckedAccess.getRequestCode()) &amp;&amp; !ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Need admin permission for request code=%d, but accessKey=%s is not&quot;</span>, needCheckedAccess.getRequestCode(), ownedAccess.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step6：如果当前的请求命令属于必须是Admin用户才能访问的权限，并且当前用户并不是管理员角色，则抛出异常，如下命令需要admin角色才能进行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Byte&gt; needCheckedPermMap = needCheckedAccess.getResourcePermMap();</span><br><span class="line">Map&lt;String, Byte&gt; ownedPermMap = ownedAccess.getResourcePermMap();</span><br><span class="line"><span class="keyword">if</span> (needCheckedPermMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If the needCheckedPermMap is null,then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> &amp;&amp; ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="comment">// If the ownedPermMap is null and it is an admin user, then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step7：如果该请求不需要进行权限验证，则通过认证，如果当前用户的角色是管理员，并且没有配置用户权限，则认证通过，返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Byte&gt; needCheckedEntry : needCheckedPermMap.entrySet()) &#123;</span><br><span class="line">    String resource = needCheckedEntry.getKey();</span><br><span class="line">    Byte neededPerm = needCheckedEntry.getValue();</span><br><span class="line">    <span class="keyword">boolean</span> isGroup = PlainAccessResource.isRetryTopic(resource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> || !ownedPermMap.containsKey(resource)) &#123;</span><br><span class="line">        <span class="comment">// Check the default perm</span></span><br><span class="line">        <span class="keyword">byte</span> ownedPerm = isGroup ? ownedAccess.getDefaultGroupPerm() : ownedAccess.getDefaultTopicPerm();</span><br><span class="line">        <span class="keyword">if</span> (!Permission.checkPermission(neededPerm, ownedPerm)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No default permission for %s&quot;</span>, PlainAccessResource.printStr(resource, isGroup)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Permission.checkPermission(neededPerm, ownedPermMap.get(resource))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No default permission for %s&quot;</span>, PlainAccessResource.printStr(resource, isGroup)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step8：遍历需要权限与拥有的权限进行对比，如果配置对应的权限，则判断是否匹配；如果未配置权限，则判断默认权限时是否允许，不允许，则抛出AclException。</p><p>验证逻辑就介绍到这里了，下面给出其匹配流程图：<br><img src="https://img-blog.csdnimg.cn/20190707121507431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述阐述了从Broker服务器启动、加载acl配置文件流程、动态监听配置文件、服务端权限验证流程，接下来我们看一下客户端关于ACL需要处理的事情。</p><h2 id="4、AclClientRPCHook"><a href="#4、AclClientRPCHook" class="headerlink" title="4、AclClientRPCHook"></a>4、AclClientRPCHook</h2><p>回顾一下，我们引入ACL机制后，客户端的代码示例如下：<br><img src="https://img-blog.csdnimg.cn/20190707121547164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其在创建DefaultMQProducer时，注册AclClientRPCHook钩子，会在向服务端发送远程命令前后执行其钩子函数，接下来我们重点分析一下AclClientRPCHook。</p><h3 id="4-1-doBeforeRequest"><a href="#4-1-doBeforeRequest" class="headerlink" title="4.1 doBeforeRequest"></a>4.1 doBeforeRequest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] total = AclUtils.combineRequestContent(request,</span><br><span class="line">           parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken()));   <span class="comment">// @1</span></span><br><span class="line">    String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey());                                                      <span class="comment">// @2</span></span><br><span class="line">    request.addExtField(SIGNATURE, signature);                                                                                                               <span class="comment">// @3</span></span><br><span class="line">    request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());         </span><br><span class="line">    <span class="comment">// The SecurityToken value is unneccessary,user can choose this one.</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCredentials.getSecurityToken() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：将Request请求参数进行排序，并加入accessKey。</p><p>代码@2：对排好序的请参数，使用用户配置的密码生成签名，并最近到扩展字段Signature，然后服务端也会按照相同的算法生成Signature，如果相同，则表示签名验证成功(类似于实现登录的效果)。</p><p>代码@3：将Signature、AccessKey等加入到请求头的扩展字段中，服务端拿到这些元数据，结合请求头中的信息，根据配置的权限，进行权限校验。</p><p>关于ACL客户端生成签名是一种通用套路，就不在细讲了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;有关RocketMQ ACL的使用请查看上一篇&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/94317946&quot;&gt;《RocketMQ ACL使用指南》&lt;/a&gt;，本文从源码的角度，分析一下RocketMQ ACL的实现原理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：RocketMQ在4.4.0时引入了ACL机制，本文代码基于RocketMQ4.5.0版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据RocketMQ ACL使用手册，我们应该首先看一下Broker服务器在开启ACL机制时如何加载配置文件，并如何工作的。&lt;/p&gt;</summary>
    
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/tags/rocketmq/"/>
    
    <category term="acl" scheme="https://www.codingw.net/tags/acl/"/>
    
  </entry>
  
  <entry>
    <title>源码分析RocketMQ消息轨迹</title>
    <link href="https://www.codingw.net/posts/e8f03b64.html"/>
    <id>https://www.codingw.net/posts/e8f03b64.html</id>
    <published>2020-12-15T14:01:35.000Z</published>
    <updated>2020-12-24T10:13:11.732Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文沿着<a href="https://blog.csdn.net/prestigeding/article/details/95922489">《RocketMQ消息轨迹-设计篇》</a>的思路，从如下3个方面对其源码进行解读：</p><ol><li>发送消息轨迹</li><li>消息轨迹格式</li><li>存储消息轨迹数据</li></ol><h2 id="1、发送消息轨迹流程"><a href="#1、发送消息轨迹流程" class="headerlink" title="1、发送消息轨迹流程"></a>1、发送消息轨迹流程</h2><p>首先我们来看一下在消息发送端如何启用消息轨迹，示例代码如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>,<span class="keyword">true</span>);      <span class="comment">// @1</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    SendResult sendResult = producer.send(msg);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出其关键点是在创建DefaultMQProducer时指定开启消息轨迹跟踪。我们不妨浏览一下DefaultMQProducer与启用消息轨迹相关的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, <span class="keyword">boolean</span> enableMsgTrace)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li>String producerGroup<br>生产者所属组名。</li><li>boolean enableMsgTrace<br>是否开启跟踪消息轨迹，默认为false。</li><li>String customizedTraceTopic<br>如果开启消息轨迹跟踪，用来存储消息轨迹数据所属的主题名称，默认为：RMQ_SYS_TRACE_TOPIC。</li></ul><h3 id="1-1-DefaultMQProducer构造函数"><a href="#1-1-DefaultMQProducer构造函数" class="headerlink" title="1.1 DefaultMQProducer构造函数"></a>1.1 DefaultMQProducer构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook, <span class="keyword">boolean</span> enableMsgTrace,<span class="keyword">final</span> String customizedTraceTopic)</span> </span>&#123;      <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">    defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">    <span class="comment">//if client open the message trace feature</span></span><br><span class="line">    <span class="keyword">if</span> (enableMsgTrace) &#123;                                                                                                                                                                                            <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AsyncTraceDispatcher dispatcher = <span class="keyword">new</span> AsyncTraceDispatcher(customizedTraceTopic, rpcHook);                                                         </span><br><span class="line">            dispatcher.setHostProducer(<span class="keyword">this</span>.getDefaultMQProducerImpl());</span><br><span class="line">            traceDispatcher = dispatcher;</span><br><span class="line">            <span class="keyword">this</span>.getDefaultMQProducerImpl().registerSendMessageHook(</span><br><span class="line">                <span class="keyword">new</span> SendMessageTraceHookImpl(traceDispatcher));                                                                                                                             <span class="comment">// @3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;system mqtrace hook init failed ,maybe can&#x27;t send msg trace data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先介绍一下其局部变量。</p><ul><li>String producerGroup<br>生产者所属组。</li><li>RPCHook rpcHook<br>生产者发送钩子函数。</li><li>boolean enableMsgTrace<br>是否开启消息轨迹跟踪。</li><li>String customizedTraceTopic<br>定制用于存储消息轨迹的数据。</li></ul><p>代码@2：用来构建AsyncTraceDispatcher，看其名：异步转发消息轨迹数据，稍后重点关注。</p><p>代码@3：构建SendMessageTraceHookImpl对象，并使用AsyncTraceDispatcher用来异步转发。</p><h3 id="1-2-SendMessageTraceHookImpl钩子函数"><a href="#1-2-SendMessageTraceHookImpl钩子函数" class="headerlink" title="1.2 SendMessageTraceHookImpl钩子函数"></a>1.2 SendMessageTraceHookImpl钩子函数</h3><h4 id="1-2-1-SendMessageTraceHookImpl类图"><a href="#1-2-1-SendMessageTraceHookImpl类图" class="headerlink" title="1.2.1 SendMessageTraceHookImpl类图"></a>1.2.1 SendMessageTraceHookImpl类图</h4><p><img src="https://img-blog.csdnimg.cn/20190803203518449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>SendMessageHook<br>消息发送钩子函数，用于在消息发送之前、发送之后执行一定的业务逻辑，是记录消息轨迹的最佳扩展点。</li><li>TraceDispatcher<br>消息轨迹转发处理器，其默认实现类AsyncTraceDispatcher，异步实现消息轨迹数据的发送。下面对其属性做一个简单的介绍：<ul><li>int queueSize<br>异步转发，队列长度，默认为2048，当前版本不能修改。</li><li>int batchSize<br>批量消息条数，消息轨迹一次消息发送请求包含的数据条数，默认为100，当前版本不能修改。</li><li>int maxMsgSize<br>消息轨迹一次发送的最大消息大小，默认为128K，当前版本不能修改。</li><li>DefaultMQProducer traceProducer<br>  用来发送消息轨迹的消息发送者。</li><li>ThreadPoolExecutor traceExecuter<br>线程池，用来异步执行消息发送。</li><li>AtomicLong discardCount<br>记录丢弃的消息个数。</li><li>Thread worker<br>woker线程，主要负责从追加队列中获取一批待发送的消息轨迹数据，提交到线程池中执行。</li><li>ArrayBlockingQueue&lt; TraceContext&gt; traceContextQueue<br>消息轨迹TraceContext队列，用来存放待发送到服务端的消息。</li><li>ArrayBlockingQueue&lt; Runnable&gt; appenderQueue<br>线程池内部队列，默认长度1024。</li><li>DefaultMQPushConsumerImpl hostConsumer<br>消费者信息，记录消息消费时的轨迹信息。</li><li>String traceTopicName<br>用于跟踪消息轨迹的topic名称。</li></ul></li></ol><h4 id="1-2-2-源码分析SendMessageTraceHookImpl"><a href="#1-2-2-源码分析SendMessageTraceHookImpl" class="headerlink" title="1.2.2 源码分析SendMessageTraceHookImpl"></a>1.2.2 源码分析SendMessageTraceHookImpl</h4><h5 id="1-2-2-1-sendMessageBefore"><a href="#1-2-2-1-sendMessageBefore" class="headerlink" title="1.2.2.1 sendMessageBefore"></a>1.2.2.1 sendMessageBefore</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(SendMessageContext context)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//if it is message trace data,then it doesn&#x27;t recorded</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || context.getMessage().getTopic().startsWith(((AsyncTraceDispatcher) localDispatcher).getTraceTopicName())) &#123;   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//build the context content of TuxeTraceContext</span></span><br><span class="line">    TraceContext tuxeContext = <span class="keyword">new</span> TraceContext();</span><br><span class="line">    tuxeContext.setTraceBeans(<span class="keyword">new</span> ArrayList&lt;TraceBean&gt;(<span class="number">1</span>));</span><br><span class="line">    context.setMqTraceContext(tuxeContext);</span><br><span class="line">    tuxeContext.setTraceType(TraceType.Pub);</span><br><span class="line">    tuxeContext.setGroupName(context.getProducerGroup());                                                                                                                       <span class="comment">// @2</span></span><br><span class="line">    <span class="comment">//build the data bean object of message trace</span></span><br><span class="line">    TraceBean traceBean = <span class="keyword">new</span> TraceBean();                                                                                                                                                <span class="comment">// @3</span></span><br><span class="line">    traceBean.setTopic(context.getMessage().getTopic());</span><br><span class="line">    traceBean.setTags(context.getMessage().getTags());</span><br><span class="line">    traceBean.setKeys(context.getMessage().getKeys());</span><br><span class="line">    traceBean.setStoreHost(context.getBrokerAddr());</span><br><span class="line">    traceBean.setBodyLength(context.getMessage().getBody().length);</span><br><span class="line">    traceBean.setMsgType(context.getMsgType());</span><br><span class="line">    tuxeContext.getTraceBeans().add(traceBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果topic主题为消息轨迹的Topic，直接返回。</p><p>代码@2：在消息发送上下文中，设置用来跟踪消息轨迹的上下环境，里面主要包含一个TraceBean集合、追踪类型（TraceType.Pub）与生产者所属的组。</p><p>代码@3：构建一条跟踪消息，用TraceBean来表示，记录原消息的topic、tags、keys、发送到broker地址、消息体长度等消息。</p><p>从上文看出，sendMessageBefore主要的用途就是在消息发送的时候，先准备一部分消息跟踪日志，存储在发送上下文环境中，此时并不会发送消息轨迹数据。</p><h5 id="1-2-2-2-sendMessageAfter"><a href="#1-2-2-2-sendMessageAfter" class="headerlink" title="1.2.2.2 sendMessageAfter"></a>1.2.2.2 sendMessageAfter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(SendMessageContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if it is message trace data,then it doesn&#x27;t recorded</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || context.getMessage().getTopic().startsWith(((AsyncTraceDispatcher) localDispatcher).getTraceTopicName())     <span class="comment">// @1</span></span><br><span class="line">        || context.getMqTraceContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult().getRegionId() == <span class="keyword">null</span></span><br><span class="line">        || !context.getSendResult().isTraceOn()) &#123;</span><br><span class="line">        <span class="comment">// if switch is false,skip it</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TraceContext tuxeContext = (TraceContext) context.getMqTraceContext();</span><br><span class="line">    TraceBean traceBean = tuxeContext.getTraceBeans().get(<span class="number">0</span>);                                                                                                <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">int</span> costTime = (<span class="keyword">int</span>) ((System.currentTimeMillis() - tuxeContext.getTimeStamp()) / tuxeContext.getTraceBeans().size());     <span class="comment">// @3</span></span><br><span class="line">    tuxeContext.setCostTime(costTime);                                                                                                                                      <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult().getSendStatus().equals(SendStatus.SEND_OK)) &#123;                                                                    </span><br><span class="line">        tuxeContext.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tuxeContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tuxeContext.setRegionId(context.getSendResult().getRegionId());                                                                                      </span><br><span class="line">    traceBean.setMsgId(context.getSendResult().getMsgId());</span><br><span class="line">    traceBean.setOffsetMsgId(context.getSendResult().getOffsetMsgId());</span><br><span class="line">    traceBean.setStoreTime(tuxeContext.getTimeStamp() + costTime / <span class="number">2</span>);</span><br><span class="line">    localDispatcher.append(tuxeContext);                                                                                                                                   <span class="comment">// @5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果topic主题为消息轨迹的Topic，直接返回。</p><p>代码@2：从MqTraceContext中获取跟踪的TraceBean，虽然设计成List结构体，但在消息发送场景，这里的数据永远只有一条，及时是批量发送也不例外。</p><p>代码@3：获取消息发送到收到响应结果的耗时。</p><p>代码@4：设置costTime(耗时)、success(是否发送成功)、regionId(发送到broker所在的分区)、msgId(消息ID，全局唯一)、offsetMsgId(消息物理偏移量，如果是批量消息，则是最后一条消息的物理偏移量)、storeTime，这里使用的是(客户端发送时间 + 二分之一的耗时)来表示消息的存储时间，这里是一个估值。</p><p>代码@5：将需要跟踪的信息通过TraceDispatcher转发到Broker服务器。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> Object ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = traceContextQueue.offer((TraceContext) ctx);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;buffer full&quot;</span> + discardCount.incrementAndGet() + <span class="string">&quot; ,context is &quot;</span> + ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一个非常关键的点是offer方法的使用，当队列无法容纳新的元素时会立即返回false，并不会阻塞。</p><p>接下来将目光转向TraceDispatcher的实现。</p><h3 id="1-3-TraceDispatcher实现原理"><a href="#1-3-TraceDispatcher实现原理" class="headerlink" title="1.3 TraceDispatcher实现原理"></a>1.3 TraceDispatcher实现原理</h3><p>TraceDispatcher，用于客户端消息轨迹数据转发到Broker，其默认实现类：AsyncTraceDispatcher。</p><h4 id="1-3-1-TraceDispatcher构造函数"><a href="#1-3-1-TraceDispatcher构造函数" class="headerlink" title="1.3.1 TraceDispatcher构造函数"></a>1.3.1 TraceDispatcher构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTraceDispatcher</span><span class="params">(String traceTopicName, RPCHook rpcHook)</span> <span class="keyword">throws</span> MQClientException </span>&#123;    </span><br><span class="line">    <span class="comment">// queueSize is greater than or equal to the n power of 2 of value</span></span><br><span class="line">    <span class="keyword">this</span>.queueSize = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">this</span>.batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.maxMsgSize = <span class="number">128000</span>;                                        </span><br><span class="line">    <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);         </span><br><span class="line">    <span class="keyword">this</span>.traceContextQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;TraceContext&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">this</span>.appenderQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueSize);</span><br><span class="line">    <span class="keyword">if</span> (!UtilAll.isBlank(traceTopicName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.traceTopicName = traceTopicName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.traceTopicName = MixAll.RMQ_SYS_TRACE_TOPIC;</span><br><span class="line">    &#125;                   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.traceExecuter = <span class="keyword">new</span> ThreadPoolExecutor(<span class="comment">// :</span></span><br><span class="line">        <span class="number">10</span>, <span class="comment">//</span></span><br><span class="line">        <span class="number">20</span>, <span class="comment">//</span></span><br><span class="line">        <span class="number">1000</span> * <span class="number">60</span>, <span class="comment">//</span></span><br><span class="line">        TimeUnit.MILLISECONDS, <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.appenderQueue, <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">&quot;MQTraceSendThread_&quot;</span>));</span><br><span class="line">    traceProducer = getAndCreateTraceProducer(rpcHook);      <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：初始化核心属性，该版本这些值都是“固化”的，用户无法修改。</p><ul><li>queueSize<br>队列长度，默认为2048，异步线程池能够积压的消息轨迹数量。</li><li>batchSize<br>一次向Broker批量发送的消息条数，默认为100.</li><li>maxMsgSize<br>向Broker汇报消息轨迹时，消息体的总大小不能超过该值，默认为128k。</li><li>discardCount<br>整个运行过程中，丢弃的消息轨迹数据，这里要说明一点的是，如果消息TPS发送过大，异步转发线程处理不过来时，会主动丢弃消息轨迹数据。</li><li>traceContextQueue<br>traceContext积压队列，客户端(消息发送、消息消费者)在收到处理结果后，将消息轨迹提交到噶队列中，则会立即返回。</li><li>appenderQueue<br>提交到Broker线程池中队列。</li><li>traceTopicName<br>用于接收消息轨迹的Topic，默认为RMQ_SYS_TRANS_HALF_TOPIC。</li><li>traceExecuter<br>用于发送到Broker服务的异步线程池，核心线程数默认为10，最大线程池为20，队列堆积长度2048，线程名称：MQTraceSendThread_。、</li><li>traceProducer<br>发送消息轨迹的Producer。</li></ul><p>代码@2：调用getAndCreateTraceProducer方法创建用于发送消息轨迹的Producer(消息发送者)，下面详细介绍一下其实现。</p><h4 id="1-3-2-getAndCreateTraceProducer详解"><a href="#1-3-2-getAndCreateTraceProducer详解" class="headerlink" title="1.3.2 getAndCreateTraceProducer详解"></a>1.3.2 getAndCreateTraceProducer详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefaultMQProducer <span class="title">getAndCreateTraceProducer</span><span class="params">(RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        DefaultMQProducer traceProducerInstance = <span class="keyword">this</span>.traceProducer;</span><br><span class="line">        <span class="keyword">if</span> (traceProducerInstance == <span class="keyword">null</span>) &#123;  <span class="comment">//@1</span></span><br><span class="line">            traceProducerInstance = <span class="keyword">new</span> DefaultMQProducer(rpcHook);</span><br><span class="line">            traceProducerInstance.setProducerGroup(TraceConstants.GROUP_NAME);</span><br><span class="line">            traceProducerInstance.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">            traceProducerInstance.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// The max size of message is 128K</span></span><br><span class="line">            traceProducerInstance.setMaxMessageSize(maxMsgSize - <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traceProducerInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果还未建立发送者，则创建用于发送消息轨迹的消息发送者，其GroupName为：_INNER_TRACE_PRODUCER，消息发送超时时间5s，最大允许发送消息大小118K。</p><h4 id="1-3-3-start"><a href="#1-3-3-start" class="headerlink" title="1.3.3 start"></a>1.3.3 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nameSrvAddr)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;     <span class="comment">// @1</span></span><br><span class="line">        traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">        traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">&quot;_&quot;</span> + nameSrvAddr);</span><br><span class="line">        traceProducer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AsyncRunnable(), <span class="string">&quot;MQ-AsyncTraceDispatcher-Thread-&quot;</span> + dispatcherId);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.worker.start();                                                                                   </span><br><span class="line">    <span class="keyword">this</span>.registerShutDownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始启动，其调用的时机为启动DefaultMQProducer时，如果启用跟踪消息轨迹，则调用之。</p><p>代码@1：如果用于发送消息轨迹的发送者没有启动，则设置nameserver地址，并启动着。</p><p>代码@2：启动一个线程，用于执行AsyncRunnable任务，接下来将重点介绍。</p><h4 id="1-3-4-AsyncRunnable"><a href="#1-3-4-AsyncRunnable" class="headerlink" title="1.3.4 AsyncRunnable"></a>1.3.4 AsyncRunnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">boolean</span> stopped;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            List&lt;TraceContext&gt; contexts = <span class="keyword">new</span> ArrayList&lt;TraceContext&gt;(batchSize);     <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">                TraceContext context = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//get trace data element from blocking Queue — traceContextQueue</span></span><br><span class="line">                    context = traceContextQueue.poll(<span class="number">5</span>, TimeUnit.MILLISECONDS);        <span class="comment">// @2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    contexts.add(context);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (contexts.size() &gt; <span class="number">0</span>) &#123;                                                                               :</span><br><span class="line">                AsyncAppenderRequest request = <span class="keyword">new</span> AsyncAppenderRequest(contexts);  <span class="comment">// @3</span></span><br><span class="line">                traceExecuter.submit(request);                                                               </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AsyncTraceDispatcher.<span class="keyword">this</span>.stopped) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stopped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：构建待提交消息跟踪Bean，每次最多发送batchSize，默认为100条。</p><p>代码@2：从traceContextQueue中取出一个待提交的TraceContext，设置超时时间为5s，即如何该队列中没有待提交的TraceContext，则最多等待5s。</p><p>代码@3：向线程池中提交任务AsyncAppenderRequest。</p><h4 id="1-3-5-AsyncAppenderRequest-sendTraceData"><a href="#1-3-5-AsyncAppenderRequest-sendTraceData" class="headerlink" title="1.3.5 AsyncAppenderRequest#sendTraceData"></a>1.3.5 AsyncAppenderRequest#sendTraceData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTraceData</span><span class="params">(List&lt;TraceContext&gt; contextList)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;TraceTransferBean&gt;&gt; transBeanMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;TraceTransferBean&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TraceContext context : contextList) &#123;        <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">if</span> (context.getTraceBeans().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Topic value corresponding to original message entity content</span></span><br><span class="line">        String topic = context.getTraceBeans().get(<span class="number">0</span>).getTopic();     <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">// Use  original message entity&#x27;s topic as key</span></span><br><span class="line">        String key = topic;</span><br><span class="line">        List&lt;TraceTransferBean&gt; transBeanList = transBeanMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (transBeanList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transBeanList = <span class="keyword">new</span> ArrayList&lt;TraceTransferBean&gt;();</span><br><span class="line">            transBeanMap.put(key, transBeanList);</span><br><span class="line">        &#125;</span><br><span class="line">        TraceTransferBean traceData = TraceDataEncoder.encoderFromContextBean(context);    <span class="comment">// @3</span></span><br><span class="line">        transBeanList.add(traceData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;TraceTransferBean&gt;&gt; entry : transBeanMap.entrySet()) &#123;       <span class="comment">// @4</span></span><br><span class="line">        flushData(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：遍历收集的消息轨迹数据。</p><p>代码@2：获取存储消息轨迹的Topic。</p><p>代码@3：对TraceContext进行编码，这里是消息轨迹的传输数据，稍后对其详细看一下，了解其上传的格式。</p><p>代码@4：将编码后的数据发送到Broker服务器。</p><h4 id="1-3-6-TraceDataEncoder-encoderFromContextBean"><a href="#1-3-6-TraceDataEncoder-encoderFromContextBean" class="headerlink" title="1.3.6 TraceDataEncoder#encoderFromContextBean"></a>1.3.6 TraceDataEncoder#encoderFromContextBean</h4><p>根据消息轨迹跟踪类型，其格式会有一些不一样，下面分别来介绍其合适。</p><h5 id="1-3-6-1-PUB-消息发送"><a href="#1-3-6-1-PUB-消息发送" class="headerlink" title="1.3.6.1 PUB(消息发送)"></a>1.3.6.1 PUB(消息发送)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Pub: &#123;</span><br><span class="line">    TraceBean bean = ctx.getTraceBeans().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//append the content of context and traceBean to transferBean&#x27;s TransData</span></span><br><span class="line">    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">     .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息轨迹数据的协议使用字符串拼接，字段的分隔符号为1，整个数据以2结尾，感觉这个设计还是有点“不可思议”，为什么不直接使用json协议呢？</p><h5 id="1-3-6-2-SubBefore-消息消费之前"><a href="#1-3-6-2-SubBefore-消息消费之前" class="headerlink" title="1.3.6.2 SubBefore(消息消费之前)"></a>1.3.6.2 SubBefore(消息消费之前)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (TraceBean bean : ctx.getTraceBeans()) &#123;</span><br><span class="line">    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轨迹就是按照上述顺序拼接而成，各个字段使用1分隔，每一条记录使用2结尾。</p><h5 id="1-3-2-3-SubAfter（消息消费后）"><a href="#1-3-2-3-SubAfter（消息消费后）" class="headerlink" title="1.3.2.3 SubAfter（消息消费后）"></a>1.3.2.3 SubAfter（消息消费后）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SubAfter: &#123;</span><br><span class="line">    <span class="keyword">for</span> (TraceBean bean : ctx.getTraceBeans()) &#123;</span><br><span class="line">        sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getContextCode()).append(TraceConstants.FIELD_SPLITOR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式编码一样，就不重复多说。</p><p>经过上面的源码跟踪，消息发送端的消息轨迹跟踪流程、消息轨迹数据编码协议就清晰了，接下来我们使用一张序列图来结束本部分的讲解。<br><img src="https://img-blog.csdnimg.cn/20190803204514547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其实行文至此，只关注了消息发送的消息轨迹跟踪，消息消费的轨迹跟踪又是如何呢？其实现原理其实是一样的，就是在消息消费前后执行特定的钩子函数，其实现类为ConsumeMessageTraceHookImpl，由于其实现与消息发送的思路类似，故就不详细介绍了。</p><h2 id="2、-消息轨迹数据如何存储"><a href="#2、-消息轨迹数据如何存储" class="headerlink" title="2、 消息轨迹数据如何存储"></a>2、 消息轨迹数据如何存储</h2><p>其实从上面的分析，我们已经得知，RocketMQ的消息轨迹数据存储在到Broker上，那消息轨迹的主题名如何指定？其路由信息又怎么分配才好呢？是每台Broker上都创建还是只在其中某台上创建呢？RocketMQ支持系统默认与自定义消息轨迹的主题。</p><h3 id="2-1-使用系统默认的主题名称"><a href="#2-1-使用系统默认的主题名称" class="headerlink" title="2.1 使用系统默认的主题名称"></a>2.1 使用系统默认的主题名称</h3><p>RocketMQ默认的消息轨迹主题为：RMQ_SYS_TRACE_TOPIC，那该Topic需要手工创建吗？其路由信息呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceTopicEnable()) &#123;    <span class="comment">// @1</span></span><br><span class="line">        String topic = <span class="keyword">this</span>.brokerController.getBrokerConfig().getMsgTraceTopicName();</span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line">        <span class="keyword">this</span>.systemTopicList.add(topic);</span><br><span class="line">        topicConfig.setReadQueueNums(<span class="number">1</span>);                                              <span class="comment">// @2</span></span><br><span class="line">        topicConfig.setWriteQueueNums(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码出自TopicConfigManager的构造函数，在Broker启动的时候会创建topicConfigManager对象，用来管理topic的路由信息。</p><p>代码@1：如果Broker开启了消息轨迹跟踪(traceTopicEnable=true)时，会自动创建默认消息轨迹的topic路由信息，注意其读写队列数为1。</p><h3 id="2-2-用户自定义消息轨迹主题"><a href="#2-2-用户自定义消息轨迹主题" class="headerlink" title="2.2 用户自定义消息轨迹主题"></a>2.2 用户自定义消息轨迹主题</h3><p>在创建消息发送者、消息消费者时，可以显示的指定消息轨迹的Topic，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook, <span class="keyword">boolean</span> enableMsgTrace,<span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">        AllocateMessageQueueStrategy allocateMessageQueueStrategy, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br></pre></td></tr></table></figure><p>通过customizedTraceTopic来指定消息轨迹Topic。</p><blockquote><p>温馨提示：通常在生产环境上，将不会开启自动创建主题，故需要RocketMQ运维管理人员提前创建好Topic。</p></blockquote><p>好了，本文就介绍到这里了，本文详细介绍了RocktMQ消息轨迹的实现原理，下一篇，我们将进入到多副本的学习中。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文沿着&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/95922489&quot;&gt;《RocketMQ消息轨迹-设计篇》&lt;/a&gt;的思路，从如下3个方面对其源码进行解读：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送消息轨迹&lt;/li&gt;
&lt;li&gt;消息轨迹格式&lt;/li&gt;
&lt;li&gt;存储消息轨迹数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1、发送消息轨迹流程&quot;&gt;&lt;a href=&quot;#1、发送消息轨迹流程&quot; class=&quot;headerlink&quot; title=&quot;1、发送消息轨迹流程&quot;&gt;&lt;/a&gt;1、发送消息轨迹流程&lt;/h2&gt;&lt;p&gt;首先我们来看一下在消息发送端如何启用消息轨迹，示例代码如下：&lt;/p&gt;</summary>
    
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/tags/rocketmq/"/>
    
    <category term="消息轨迹" scheme="https://www.codingw.net/tags/%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>AtomicIntegerArray源码分析与感悟.</title>
    <link href="https://www.codingw.net/posts/e3c7511d.html"/>
    <id>https://www.codingw.net/posts/e3c7511d.html</id>
    <published>2020-12-14T11:53:01.000Z</published>
    <updated>2020-12-24T10:13:23.731Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><a id="more"></a>![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)<p>AtomicIntegerArray，提供了一个原子访问数据中元素方法的一种途径。</p><p>对于这类原子操作，在理解上应该没什么问题，通过AtomitoIntegerArray，我学到如下几个关键点：</p><ul><li>int  sacle = unsafe.arrayIndexScale（int[].class）与  int base = unsafe.arrayBaseOffset(Int[].class);<br>其中 unsafe.arrayBaseOffset 获取该类型的数组，在对象存储时，存放第一个元素的内存地址，相对于数组对象起始地址的内存偏移量。unsafe.arrayIndexSacle(int[].class) 获取该类型的数组中元素的大小，占用多少个字节。</li><li>根据scale ，base 如何准备定位到任意一个下标的地址呢？请查看如下关键代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用于定位元素偏移量的控制值。</p><p>举例说明，int scale = 4;1个int类型，在java中占用4个字节。</p><p>Integer.numberOfLeadingZeros(scale); 返回 scale 高位连续0的个数，得出shift = 2, 而shift在如下方法使用</p><p>得出结论了吧，shift就是 用来定位数组中的内存位置，用来移位用的，每向左移动移位，在不越界的情况下，想当于乘以2。也就是int类型的长度为4，也就是第0个位置是0，第1(i)个位置是4,，第二个(i)位置是8，也就是偏移位置等于  i * 4,也就是  i &lt;&lt; 2;总结出一个乘法转换成移位操作的案例： a * (一个2的幂(n)的数)  =  a &lt;&lt; n; 给出一个指定2的幂的数，怎么算成n,,参照shift的计算方法。 </p><p>附上AtomicIntegerArray 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@code</span> int&#125; array in which elements may be updated atomically.</span></span><br><span class="line"><span class="comment"> * See the &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package</span></span><br><span class="line"><span class="comment"> * specification for description of the properties of atomic</span></span><br><span class="line"><span class="comment"> * variables.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArray</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2862133569453604235L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray of the given length, with all</span></span><br><span class="line"><span class="comment">     * elements initially zero.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray with the same length as, and</span></span><br><span class="line"><span class="comment">     * all elements copied from, the given array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array the array to copy elements from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if array is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">        <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the length of the array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value at position &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, newValue))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * and does not provide ordering guarantees, so is only rarely an</span></span><br><span class="line"><span class="comment">     * appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSet(i, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, current + delta))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">int</span> next = current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current values of array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current values of array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iMax = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            b.append(getRaw(byteOffset(i)));</span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            b.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;vip-container&quot;&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

&lt;p</summary>
      
    
    
    
    <category term="java" scheme="https://www.codingw.net/categories/java/"/>
    
    
    <category term="java" scheme="https://www.codingw.net/tags/java/"/>
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Filter机制概述</title>
    <link href="https://www.codingw.net/posts/a061d56c.html"/>
    <id>https://www.codingw.net/posts/a061d56c.html</id>
    <published>2020-12-12T11:10:01.000Z</published>
    <updated>2020-12-24T10:13:31.780Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo&#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter</span><br><span class="line">generic&#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter</span><br><span class="line">genericimpl&#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter</span><br><span class="line">token&#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter</span><br><span class="line">accesslog&#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter</span><br><span class="line">activelimit&#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span><br><span class="line">classloader&#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</span><br><span class="line">context&#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter</span><br><span class="line">consumercontext&#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter</span><br><span class="line">exception&#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br><span class="line">executelimit&#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span><br><span class="line">deprecated&#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter</span><br><span class="line">compatible&#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter</span><br><span class="line">timeout&#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter</span><br></pre></td></tr></table></figure><p>以其中一个来说明一下Filter的定义要素：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * EchoInvokerFilter</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Activate(group &#x3D; Constants.PROVIDER, order &#x3D; -110000)    &#x2F;&#x2F; @2</span><br><span class="line">public class EchoFilter implements Filter &#123;                                 &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        if (inv.getMethodName().equals(Constants.$ECHO) &amp;&amp; inv.getArguments() !&#x3D; null &amp;&amp; inv.getArguments().length &#x3D;&#x3D; 1)</span><br><span class="line">            return new RpcResult(inv.getArguments()[0]);</span><br><span class="line">        return invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：实现com.alibaba.dubbo.rpc.Filter接口。</p><p>代码@2：添加Activate，其注解含义如下：</p><ul><li><p>group： 所属组，String[],例如消费端、服务端。<br>value String[]，如果指定该值，只有当消费者或服务提供者URL中包含属性名为value的键值对，该过滤器才处于激活状态。</p></li><li><p>before：String[]，用于指定执行顺序，before指定的过滤器在该过滤器之前执行。</p></li><li><p>after：string[]，用于指定执行顺序，after指定的过滤器在该过滤器之后执行。</p></li><li><p>order：用户指定顺序，值越小，越先执行。<br>除了支持默认的过滤器外，Dubbo还支持自定义Filter，可以通过service.filter指定过滤器，多个用英文逗号隔开，其配置方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service ......&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure><p>当然，可以为所有服务提供者设置共用过滤器，其指定方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider ...&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:provider&gt;</span><br></pre></td></tr></table></figure><p>消费端自定义过滤器的key为reference.filter，其使用方法在&lt; dubbo:reference/&gt;标签或&lt; dubbo:consumer/&gt;标签下定义属性。关于自定义Filter的解析代码如下：<br>ExtensionLoader#getActivateExtension</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String key, String group) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        String value &#x3D; url.getParameter(key);                                                 &#x2F;&#x2F; @2</span><br><span class="line">        return getActivateExtension(url, value &#x3D;&#x3D; null || value.length() &#x3D;&#x3D; 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), group);    &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数说明。</p><ul><li>URL url：服务提供者或服务消费者url。</li><li>String key：过滤器属性key，服务提供者固定为:service.filter，服务消费者固定为reference.filter。</li><li>String group：服务提供者或服务消费者。</li></ul><p>代码@2：从url中获取配置的自定义filter。</p><p>代码@3：如果value不为空，则将字符串调用split转换为数组，然后调用getActivateExtension方法，获取符合条件的过滤器。</p><p>ExtensionLoader#getActivateExtension</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) &#123;</span><br><span class="line">        List&lt;T&gt; exts &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; names &#x3D; values &#x3D;&#x3D; null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);</span><br><span class="line">        if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">            getExtensionClasses();                                                                                                            &#x2F;&#x2F; @2</span><br><span class="line">            for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">                String name &#x3D; entry.getKey();</span><br><span class="line">                Activate activate &#x3D; entry.getValue();</span><br><span class="line">                if (isMatchGroup(group, activate.group())) &#123;                                                                        &#x2F;&#x2F; @3</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    if (!names.contains(name)</span><br><span class="line">                            &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)                    &#x2F;&#x2F; @4      </span><br><span class="line">                            &amp;&amp; isActive(activate, url)) &#123;                                                                                      &#x2F;&#x2F; @5</span><br><span class="line">                        exts.add(ext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; usrs &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.size(); i++) &#123;                                                                                           &#x2F;&#x2F; @6</span><br><span class="line">            String name &#x3D; names.get(i);</span><br><span class="line">            if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                    &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">                if (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    if (!usrs.isEmpty()) &#123;</span><br><span class="line">                        exts.addAll(0, usrs);</span><br><span class="line">                        usrs.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    usrs.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!usrs.isEmpty()) &#123;</span><br><span class="line">            exts.addAll(usrs);</span><br><span class="line">        &#125;</span><br><span class="line">        return exts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果配置的service.filter或referecnce.filter包含了-default，表示禁用系统默认提供的一系列过滤器。</p><p>代码@2：如果不禁用系统默认过滤器链，则首先加载所有默认过滤器。</p><p>代码@3：根据group刷选出适配的过滤器。</p><p>代码@4：也可以对单个filter进行禁用，其方法是-过滤器名称的方式。例如如想禁用AccessLogFilter，则可以通过-accesslog方式禁用。-key,key为/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中定义的key。</p><p>代码@5：判断过滤器是否激活，其逻辑是如果Filter上的@Activate注解value值不为空，则需要判断url中是否包含键为value的属性对，存在则启用，不存在则不启用。</p><p>代码@6：加载用户自定义的Filter，也即是service.filter或reference.filter指定的过滤器。<br>综上所述，Dubbo提供了过滤器机制，在真实服务被调用前提供扩展点。Filter机制就简单介绍到这里了，从下文开始会重点分析Dubbo服务提供的核心Filter。</p><p>如果需要自定过滤器，需要在自定的工程中META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中注册。</p><p>本文就介绍到这里了，从下篇开始将会根据Dubbo的功能特性来详细分析其实现过程，其本质都是各种Dubbo 过滤器器。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo&amp;#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;generic&amp;#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;genericimpl&amp;#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;token&amp;#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;accesslog&amp;#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;activelimit&amp;#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classloader&amp;#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;context&amp;#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumercontext&amp;#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exception&amp;#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executelimit&amp;#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deprecated&amp;#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compatible&amp;#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeout&amp;#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以其中一个来说明一下Filter的定义要素：&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="https://www.codingw.net/categories/dubbo/"/>
    
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="https://www.codingw.net/tags/dubbo/"/>
    
    <category term="Filter" scheme="https://www.codingw.net/tags/Filter/"/>
    
  </entry>
  
</feed>
