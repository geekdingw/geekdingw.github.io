<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中间件兴趣圈</title>
  
  <subtitle>关注微信公众号「中间件兴趣圈」，第一时间获取最新干货！</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-12-14T15:12:09.699Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>中间件兴趣圈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty4 事件处理传播机制</title>
    <link href="http://example.com/posts/be152999.html"/>
    <id>http://example.com/posts/be152999.html</id>
    <published>2020-12-13T14:11:01.000Z</published>
    <updated>2020-12-14T15:12:09.699Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本节将详细分析Netty事件传播机制，即事件链的实现机制。</p><p>本文重点的行文思路：</p><ul><li>详解事件的触发事件</li><li>事件传播机制</li><li>思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？</li></ul><a id="more"></a><p>Netty4的事件链核心类如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215532749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下先详细介绍上述核心类的核心方法。<br>1、ChannelPipeline<br>“Channel流水线”，即Channel管道（事件处理链），其主要核心方法包括如下三类。<br><strong>添加类操作</strong></p><ul><li>ChannelPipeline addFirst(String name, ChannelHandler handler)</li><li>ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler)</li><li>ChannelPipeline addFirst(ChannelHandler… handlers)</li><li>ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler… handlers)</li><li>ChannelPipeline addLast(String name, ChannelHandler handler)</li><li>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler)</li><li>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler)</li></ul><p>其中省略了addLast、addBefore、addAfter的其他重载方法，模式为addFirst类似。在这里着重讲解一下各个参数的含义。</p><ul><li>EventExecutorGroup group<br>ChannelHandler执行的线程组EventLoop，如果为空，则ChannelHandler在Channel所注册的EventLoop。</li><li>String name<br>ChannelHandler的名称，DefaultChannelPipeline会避免因重名而修改ChannelHandler的名称。</li></ul><p><strong>ChannelHandler的增删改查</strong></p><ul><li>ChannelPipeline remove(ChannelHandler handler)<br>ChannelHandler removeFirst()<br>省略其他API，此类API其实能反映出ChannelPipeline内部是一个双链表结构。</li></ul><p><strong>入端(inbound)事件传播</strong></p><ul><li>ChannelPipeline fireChannelRegistered()</li><li>ChannelPipeline fireChannelUnregistered()</li><li>ChannelPipeline fireChannelActive()</li><li>ChannelPipeline fireChannelInactive()</li><li>ChannelPipeline fireExceptionCaught(Throwable cause)</li><li>ChannelPipeline fireUserEventTriggered(Object event)</li><li>ChannelPipeline fireChannelRead(Object msg)</li><li>ChannelPipeline fireChannelReadComplete()</li><li>ChannelPipeline fireChannelWritabilityChanged()<br>不难看出，此类API方法名 fire + ChannelInboundHandler 中的方法。特别注意的是fireChannelRead(Object msg)的参数为通过网络SocketChannel#read一次读取的字节数组（ByteBuf），跟随着事件处理器一步一步的处理。</li></ul><p><strong>出端(outbound)事件传播</strong></p><ul><li>ChannelFuture bind(SocketAddress localAddress)</li><li>ChannelFuture connect(SocketAddress remoteAddress)</li><li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)</li><li>ChannelFuture disconnect()</li><li>ChannelFuture close()</li><li>ChannelFuture deregister()</li><li>ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise)</li><li>ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise)</li><li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</li><li>ChannelFuture disconnect(ChannelPromise promise)</li><li>ChannelFuture close(ChannelPromise promise)</li><li>ChannelFuture deregister(ChannelPromise promise)</li><li>ChannelPipeline read()</li><li>ChannelFuture write(Object msg)</li><li>ChannelFuture write(Object msg, ChannelPromise promise)</li><li>ChannelPipeline flush()</li><li>ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)</li><li>ChannelFuture writeAndFlush(Object msg)<br>不难看出，上述方法为ChannelOutboundHandler的方法。</li></ul><h2 id="2、DefaultChannelPipeline"><a href="#2、DefaultChannelPipeline" class="headerlink" title="2、DefaultChannelPipeline"></a>2、DefaultChannelPipeline</h2><p>ChannelPipeline的简单类图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215634424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合head、taill与下面的构造函数可知DefaultChannelPipeline的结构是其双链表，其中head、tail为双链表的首尾节点，并且其引用不能更改，其中节点（Node）实现为AbstractChannelHandlerContext，其内部必然定义两个属性prev与next，分别代表前一个节点与下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从这里看一个Channel对应一个ChannelPipeline。</p><h3 id="2-1-事件链构建"><a href="#2-1-事件链构建" class="headerlink" title="2.1 事件链构建"></a>2.1 事件链构建</h3><p>本节将以addFirst方法为例展示ChannelPipeline事件链的维护实现。<br>DefaultChannelPipeline#addFirst</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addFirst(<span class="keyword">null</span>, name, handler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>内部调用其重载方法。接下来重点分析该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;     <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);                                                                                                                        <span class="comment">// @2</span></span><br><span class="line">            name = filterName(name, handler);</span><br><span class="line">            newCtx = newContext(group, name, handler);                                                                                         <span class="comment">// @3</span></span><br><span class="line">            addFirst0(newCtx);                                                                                                                                   <span class="comment">// @4                                   </span></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;                                                                                                                                        <span class="comment">// @5</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;                                                                                                                  <span class="comment">// @6</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);                                                                                                                    <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先对参数简单说明一下：</p><ul><li>EventExecutorGroup group：指定ChannelHandler在哪个事件选择器中执行(EventLoopGroup)，如果为空，表示在Channel注册的事件轮询器中执行。</li><li>String name：ChannelHandler名称。</li><li>ChannelHandler channelHandler：待添加的事件处理器。</li></ul><p>代码@2：检查是否重复添加，声明为Shareable的ChannelHandler允许重复添加。</p><p>代码@3：使用AbstractChannelHandlerContext类包装ChannelHandler，即双链表结构的Node类为AbstractChannelHandlerContext。</p><p>代码@4：将AbstractChannelHandlerContext调用addFirst0添加到双链表的“第一条”，其实是添加到双链表头结点(HeaderContext)的next值执行该节点。</p><p>代码@5-代码@7都是处理handerAdd事件，如果通道还未注册，handerAdd事件会“挂起”，也就是需要等待通道被注册后才执行，其实现思路也是构建PendingHandlerCallback链，DefaultChannelPipeline内部持有该链的头节点，待通道注册后，顺序触发handlerAdd事件的传播。</p><p>接下来看一下addFirst0的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext nextCtx = head.next;    </span><br><span class="line">        newCtx.prev = head;                                                        </span><br><span class="line">        newCtx.next = nextCtx;                                                  </span><br><span class="line">        head.next = newCtx;                                                       </span><br><span class="line">        nextCtx.prev = newCtx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是典型的链表操作过程。<br>如果使用如下代码构建事件链，那事件是如何传播的呢？<br>p.addLast(“1”, new InboundHandlerA());<br>p.addLast(“2”, new InboundHandlerB());<br>p.addLast(“3”, new OutboundHandlerA());<br>p.addLast(“4”, new OutboundHandlerB());<br>p.addLast(“5”, new InboundOutboundHandlerX());<br>其构建的事件链最终如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215730318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但ChannelInboundHandler中的事件是如何传播的呢？ChannelOutboundHandler的事件又是如何传播的呢？</p><p>事件链中的节点对象为AbstractChannelHandlerContext，其类图如下：</p><p><img src="https://img-blog.csdnimg.cn/2020121321581174.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>HeadContext：事件链的头节点。</li><li>TailContext：事件链的尾节点。</li><li>DefaultChannelHandlerContext：用户定义的Handler所在的节点。</li></ul><h3 id="2-2-事件传播"><a href="#2-2-事件传播" class="headerlink" title="2.2 事件传播"></a>2.2 事件传播</h3><p>inbound事件与outbound事件传播机制实现原理相同，只是方向不同，inbound事件的传播从HeadContext开始，沿着next指针进行传播，而outbound事件传播从TailContext开始，沿着prev指针向前传播，故下文重点分析inbound事件传播机制。</p><p>DefaultChannelPipeline有关于ChannelInboundHandler的方法实现如下：<br><img src="https://img-blog.csdnimg.cn/20201213215906969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>所有的入端事件的传播入口都是从head开始传播</strong>。接下来我们以channelRead事件的传播为例，展示inbound的事件的流转。注意：以下观点都是针对NIO的读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline#fireChannelRead(Object msg) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">     AbstractChannelHandlerContext.invokeChannelRead(head, msg);  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先在NIO事件选择器在网络读事件就绪后，会调用底层SocketChanel#read 方法从读缓存中读取字节，在Netty中使用ByteBuf来存储，然后调用DefaultChannelPipeline # fireChannelRead 方法进行事件传播，每个ChannelHandler针对输入进行加工处理，ChannelPipeline因此而得名，有关Netty基于NIO的事件就绪选择实现将在Netty线程模型、IO读写流程部分详细讲解。</p><p>从代码@1处可得知，通过AbstractChannelHandlerContext的静态方法invokerChanelRead，从HeadContext处开始执行，</p><p>AbstractChannelHandlerContext#invokerChanelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, <span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        EventExecutor executor = next.executor();         <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;                                <span class="comment">// @2</span></span><br><span class="line">            next.invokeChannelRead(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;              <span class="comment">// @3</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种写法是Netty处理事件执行的“模板”方法，都是先获取需要执行的线程组(EventLoop),如果当前线程不属于Eventloop，则将任务提交到EventLoop中异步执行，如果在，则直接调用。第一次调用，该next指针为HeadContext，那接下来重点关注一下HeadContext的invokeChannelRead方法。<br>AbstractChannelHandlerContext#invokeChannelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;                                                                            <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);   <span class="comment">// @2</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);                                                                     <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该通道已经成功添加@1，则执行对应的事件@2，否则只是传播事件@3。</p><p>传播事件在AbstractChannelHandlerContext的实现思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext#fireChannelRead</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述就从事件链中按顺序提取inbound类型的处理器，上述代码要最终能结束，那么TailContext必须是Inbound类型的事件处理器。</p><p>从代码@2中执行完对应的事件处理逻辑后，事件如何向下传播呢？如果需要继续将事件传播的话，请调用ChannelInboundHandlerAdapter 对应的传播事件方法，如上例中的 ChannelInboundHandlerAdapter#fireChannelRead，该方法会将事件链继续往下传播，如果在对应的事件处理中继续调用fireChannelRead，则事件传播则停止传播，也就是并不是事件一定会顺着整个调用链到达事件链的尾部TailContext，在实践中请特别重视。</p><p>Netty inbound 事件传播流程图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215946585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述主要分析了inboud事件的传播机制，为了加深理解，我们接下来浏览一下HeadContext、TailContext是如何实现各个事件方法的，这些事件，后续在梳理Netty读写流程时会再详细介绍。</p><h3 id="2-3-源码分析DefaultChannelPipeline-HeadContex"><a href="#2-3-源码分析DefaultChannelPipeline-HeadContex" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$HeadContex"></a>2.3 源码分析DefaultChannelPipeline$HeadContex</h3><h4 id="2-3-1-HeadContext声明与构造方法"><a href="#2-3-1-HeadContext声明与构造方法" class="headerlink" title="2.3.1 HeadContext声明与构造方法"></a>2.3.1 HeadContext声明与构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;    <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;                                                                     <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;                        </span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：HeadContext实现ChannelInboundHandler与ChannelOutboundHandler，故它的inbound与outbound都返回true。<br>代码@2：Unsafe，Netty操作类。</p><h4 id="2-3-2-handlerAdded、handlerRemoved"><a href="#2-3-2-handlerAdded、handlerRemoved" class="headerlink" title="2.3.2 handlerAdded、handlerRemoved"></a>2.3.2 handlerAdded、handlerRemoved</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChanelHandler增加与移除事件处理逻辑：不做任何处理。为什么可以不传播呢？其实上文在讲解addFirst方法时已提到，在添加一个ChannelHandler到事件链时，会根据通道是否被注册，如果未注册，会先阻塞执行，DefaultChannelPipeline会保存一条执行链，等通道被注册后处触发执行，HeadContext作为一个非业务类型的事件处理器，对通道的增加与否无需关注。</p><h4 id="2-3-3-exceptionCaught"><a href="#2-3-3-exceptionCaught" class="headerlink" title="2.3.3 exceptionCaught"></a>2.3.3 exceptionCaught</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道异常处理事件的处理逻辑：HeadContext的选择是自己不关注，直接将异常事件往下传播。</p><h4 id="2-3-4-channelRegistered"><a href="#2-3-4-channelRegistered" class="headerlink" title="2.3.4 channelRegistered"></a>2.3.4 channelRegistered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">            <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">            callHandlerAddedForAllHandlers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通道注册事件处理逻辑：当通道成功注册后，判断是否是第一次注册，如果是第一次注册的话，调用所有的ChannelHandler#handlerAdd事件，因为当通道增加到事件链后，如果该通道还未注册，channelAdd事件不会马上执行，需要等通道注册后才执行，故在这里首先需要执行完挂起（延迟等待的任务）。然后调用fireChannelRegistered沿着事件链传播通道注册成功事件。</p><h4 id="2-3-5-channelUnregistered"><a href="#2-3-5-channelUnregistered" class="headerlink" title="2.3.5 channelUnregistered"></a>2.3.5 channelUnregistered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通道取消注册事件处理逻辑：首先传播事件，然后判断通道的状态，如果是处于关闭状态（通道调用了close方法），则需要移除所有的ChannelHandler。</p><h4 id="2-3-6-channelActive"><a href="#2-3-6-channelActive" class="headerlink" title="2.3.6 channelActive"></a>2.3.6 channelActive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> ctx.fireChannelActive();</span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通道激活事件的处理逻辑（TCP连接建立成功后触发）：首先传播该事件，如果开启自动读机制(autoRead为true)，则调用Channel#read方法，向NIO Selector注册读事件。</p><h4 id="2-3-7-channelInactive"><a href="#2-3-7-channelInactive" class="headerlink" title="2.3.7 channelInactive"></a>2.3.7 channelInactive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelInactive();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通道非激活事件处理逻辑：只传播事件。</p><h4 id="2-3-8-channelRead"><a href="#2-3-8-channelRead" class="headerlink" title="2.3.8 channelRead"></a>2.3.8 channelRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道读事件处理逻辑：向下传播事件，各个编码器、业务处理器将各自处理业务逻辑。</p><h4 id="2-3-9-channelReadComplete"><a href="#2-3-9-channelReadComplete" class="headerlink" title="2.3.9 channelReadComplete"></a>2.3.9 channelReadComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelReadComplete();</span><br><span class="line">readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道读完成事件，首先先传播事件，然后如果开启了自动读取的话，继续注册读事件。</p><h4 id="2-3-10-userEventTriggered"><a href="#2-3-10-userEventTriggered" class="headerlink" title="2.3.10 userEventTriggered"></a>2.3.10 userEventTriggered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireUserEventTriggered(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户自定义事件的处理逻辑：传播事件。</p><h4 id="2-3-11-channelWritabilityChanged"><a href="#2-3-11-channelWritabilityChanged" class="headerlink" title="2.3.11 channelWritabilityChanged"></a>2.3.11 channelWritabilityChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelWritabilityChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道可写状态变更事件的处理逻辑：传播事件。</p><p>接下来介绍HeadContext对于ChannelOutboundHander事件的处理逻辑：</p><h4 id="2-3-12-bind"><a href="#2-3-12-bind" class="headerlink" title="2.3.12 bind"></a>2.3.12 bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">( ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Unsafe实例完成具体的绑定操作，后续会重点分析该方法的实现原理。</p><p>由于HeadContex是outbound事件的尾部事件处理器，而且outbound是用户发送的API调用，其最终目的是希望通过Netty完成具体的网络操作，故HeadContex是离Netty底层机制最近的，到了这里，就意味者“应用程序”层面的定制化介绍，最终需要通过HeadContex直接调用Netty的API来完成具体的动作，故HeadContex关于outbound事件的实现，都是通过调用unsafe去完成具体的动作。故后面的方面就不在一一罗列。</p><h3 id="2-3-源码分析DefaultChannelPipeline-TailContext"><a href="#2-3-源码分析DefaultChannelPipeline-TailContext" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$TailContext"></a>2.3 源码分析DefaultChannelPipeline$TailContext</h3><p>TailContext由于是 inbound事件链的最后一站，故该节点大部分事件都是空实现，其他实现的方法，基本上就是释放一下资源，我们看一下TailContex关于channelRead事件的处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            onUnhandledInboundMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是主动调用ReferenceCountUtil.release(msg)释放资源。</p><p>Netty事件传播机制就讲解到这里了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节将详细分析Netty事件传播机制，即事件链的实现机制。&lt;/p&gt;
&lt;p&gt;本文重点的行文思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详解事件的触发事件&lt;/li&gt;
&lt;li&gt;事件传播机制&lt;/li&gt;
&lt;li&gt;思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="netty4" scheme="http://example.com/categories/netty4/"/>
    
    
    <category term="netty4" scheme="http://example.com/tags/netty4/"/>
    
    <category term="事件传播" scheme="http://example.com/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>java多线程Thread join与CountDownLatch源码分析</title>
    <link href="http://example.com/posts/7da5265a.html"/>
    <id>http://example.com/posts/7da5265a.html</id>
    <published>2020-12-13T13:43:01.000Z</published>
    <updated>2020-12-13T13:50:25.624Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、Thread-join方法详解"><a href="#1、Thread-join方法详解" class="headerlink" title="1、Thread join方法详解"></a>1、Thread join方法详解</h1><p>首先，对于JAVA的一些基础知识，工作年限到了一定时间后，尽量不要一来就百度查询，比如thread join的作用，我们不妨先看一看join方法的源码，先试着自己理解，然后再去查询别人的理解，举一反三，美哉美哉。</p><a id="more"></a><p>join方法的声明与源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">     * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">     * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">     * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，join方法是线程对象的实例方法，并不同于sleep方法。并且被 synchronized关键字被修饰，说明要进入join方法，必须获得线程的对象锁。所以join(long millis)方法，指的是获取对象锁后需要等待的时间，并不是join方法等待的时间。</p><p>join的方法是在a线程中，调用 b.join()方法，实现的语义是，线程a等待线程b执行完毕后，再执行；join方法支持中断。实现的原理是在线程处于激活状态(isActive())方法时，调用 wait 方法或 wait(long milliseconds)方法。下面提供三个测试方法，进一步说明join方法语义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.study.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * t.join学习</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test1();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test2();</span></span><br><span class="line"></span><br><span class="line">        test3();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 join的基本语义，在其他线程执行完毕后，主线程才会结束</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 该测试用例说明：</span></span><br><span class="line"><span class="comment">     * 如果将t1.join 注释掉，则输出基本是</span></span><br><span class="line"><span class="comment">     *     main 线程启动.....</span></span><br><span class="line"><span class="comment">     *     main 线程结束......</span></span><br><span class="line"><span class="comment">     *         1</span></span><br><span class="line"><span class="comment">     *         2</span></span><br><span class="line"><span class="comment">     *         3</span></span><br><span class="line"><span class="comment">     * 如果增加t1.join则，主线程需要等待 t1线程运行结束后，才会退出，输出如下：</span></span><br><span class="line"><span class="comment">     *     main 线程启动.....</span></span><br><span class="line"><span class="comment">     *            1</span></span><br><span class="line"><span class="comment">     *         2</span></span><br><span class="line"><span class="comment">     *         3</span></span><br><span class="line"><span class="comment">     *     main 线程结束......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread1());</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(); <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 t1.join(long miliseconds) 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread2());</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(<span class="number">3000</span>); <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread3(t1));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="comment">//确认t1,t2都在运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            t1.join(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;join方法执行后，经过&quot;</span> + ((end - start) / <span class="number">1000</span>) + <span class="string">&quot;秒结束&quot;</span>); <span class="comment">//这里不是1秒，需要等线程t2执行完毕才能被唤醒，</span></span><br><span class="line">                                                                               <span class="comment">//为什么呢，因为在线程t2中，占用了t1线程的对象锁，t1.join首先需要获取t1的对象锁。所以需要等t2执行完毕，                              </span></span><br><span class="line">                                                                              <span class="comment">//释放锁后才能开始执行join方法。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunThread3</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">synchronized</span>(t) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="2、CountDownLatch源码分析"><a href="#2、CountDownLatch源码分析" class="headerlink" title="2、CountDownLatch源码分析"></a>2、CountDownLatch源码分析</h1><p>CountDownLatch，闭锁，能够实现Thread join 类似的语义，用在如下业务场景，比如协调者（主线程）创建多个线程去并发的完成一件事情，主线程创建并启动线程后，需要等待任务全部运行完毕后，主线程处理相关事情后再退出。</p><p>如下代码是我们经常会看到的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试开始。。&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(  <span class="keyword">new</span> ThreadA()).start();<span class="comment">//处理任务</span></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了防止主线程提早退出，我们一般会让主线程sleep,</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>* <span class="number">1000</span>);  <span class="comment">//这种不准确，实现方法不友好。</span></span><br><span class="line">   </span><br><span class="line">    System.out.println(<span class="string">&quot;测试结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">为了解决上述问题，CountDownLatch 能精确的解决上述问题。</span><br><span class="line">CountDownLatch使用实例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnalA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch cdl;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnalA</span> <span class="params">(CountDownLatch cdl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cdl=cdl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">// 线程运行完毕后，</span></span><br><span class="line">         cdl.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainCls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptException </span>&#123;</span><br><span class="line">        CountDownLatch  cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnalA(cdl) ).start();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//需要等10个线程全部运行完毕后，主线程才结束</span></span><br><span class="line">       cdl.await();<span class="comment">//等10个线程运行完毕后，主线程才会退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-CountDownLatch-方法实现原理"><a href="#2-1-CountDownLatch-方法实现原理" class="headerlink" title="2.1 CountDownLatch 方法实现原理"></a>2.1 CountDownLatch 方法实现原理</h2><p>首先，通过CountDownLatch的构造方法，设置锁的state变量，从分析ReentrantLock,ReentrantReadWriteLock 中我们应该知道state的意义。</p><p>然后await方法,使用获取共享锁的模式，由于state不为，则await方法调用，必然会在CLH队列中增加一个节点，然后线程阻塞。</p><p>countDown方法，每次将state减1，直到state=0时，唤醒线程，awiat方法成功获取锁，方法解除阻塞，继续执行。源码的分析就不做过多的解读，因为如下代码在学习ReentrantLock,ReentrantReadWriterLock锁时已经详细分析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch对tryAcquireSharedd的实现，是 </span><br><span class="line"><span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;  如果getState()的值为<span class="number">0</span>,则不阻塞，直接返回。如果state大于<span class="number">0</span>，则在CLH队列中等待，由于我们在使用的时候，一定是先调用await方法，这样await方法在调用的时候，肯定是获取不到锁的，故在CLH队列中，会是这样的结构  head--&gt;Node[队列尾部，就是代表调用await方法的线程。]</span><br><span class="line"></span><br><span class="line">CountDownLatch的 countDown方法,内部就是调用releaseShared方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123; <span class="comment">//如果 state或减去1之后的值为0，则返回ture,表明可以唤醒由于调用                                                                                  //await方法调用的线程</span></span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、Thread-join方法详解&quot;&gt;&lt;a href=&quot;#1、Thread-join方法详解&quot; class=&quot;headerlink&quot; title=&quot;1、Thread join方法详解&quot;&gt;&lt;/a&gt;1、Thread join方法详解&lt;/h1&gt;&lt;p&gt;首先，对于JAVA的一些基础知识，工作年限到了一定时间后，尽量不要一来就百度查询，比如thread join的作用，我们不妨先看一看join方法的源码，先试着自己理解，然后再去查询别人的理解，举一反三，美哉美哉。&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="join" scheme="http://example.com/tags/join/"/>
    
    <category term="CountDownLatch" scheme="http://example.com/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>java并发容器ConcurrentHashMap源码分析</title>
    <link href="http://example.com/posts/7310f98.html"/>
    <id>http://example.com/posts/7310f98.html</id>
    <published>2020-12-13T13:40:01.000Z</published>
    <updated>2020-12-13T13:50:25.641Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、ConcurrentHashMap-与-HashTable"><a href="#1、ConcurrentHashMap-与-HashTable" class="headerlink" title="1、ConcurrentHashMap 与 HashTable"></a>1、ConcurrentHashMap 与 HashTable</h1><p>HashTable 是 HashMap 的线程安全版本，使用的是 HashTable 的对象锁，同一时刻只能有一个线程 新增元素，获取元素。锁等待多，并发度低。而 ConcurrentHashMap 采用的是锁分段机制，就是用多把锁，让每把锁管理一部分数据。怎么实现的呢？引入了段(Segment)数据结构。</p><p>我们不妨来回忆一下HashMap、HashTable 的数据结构</p><p><img src="https://img-blog.csdn.net/20161129121630568?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>结合下文对ConcurrentHashMap的分析，可以得知ConcurrentHashMap的数据结构如下，其实就是可以简单的认为，ConcurrentHashMap就是 HashMap[] 数组，就是一个数组，数组元素是一个一个的 HashMap。</p><p><img src="https://img-blog.csdn.net/20161129121705356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><a id="more"></a><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>为了更好的理解ConcurrentHashMap，最好首先阅读如下几篇文章：</p><ul><li>HashMap源码分析 <a href="http://blog.csdn.net/prestigeding/article/details/52861420">http://blog.csdn.net/prestigeding/article/details/52861420</a></li><li>使用Unsafe根据内存地址与偏移量访问数组元素方法：<a href="http://blog.csdn.net/prestigeding/article/details/52980801">http://blog.csdn.net/prestigeding/article/details/52980801</a></li><li>ReentrantLock锁分析：<a href="http://blog.csdn.net/prestigeding/article/details/53084883">http://blog.csdn.net/prestigeding/article/details/53084883</a></li></ul><h1 id="2、ConcurrentHashMap-详解"><a href="#2、ConcurrentHashMap-详解" class="headerlink" title="2、ConcurrentHashMap 详解"></a>2、ConcurrentHashMap 详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> java.util.Map&#125; providing additional atomic</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;putIfAbsent&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt;, and &lt;tt&gt;replace&lt;/tt&gt; methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Memory consistency effects: As with other concurrent</span></span><br><span class="line"><span class="comment"> * collections, actions in a thread prior to placing an object into a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ConcurrentMap&#125; as a key or value</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * actions subsequent to the access or removal of that object from</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> ConcurrentMap&#125; in another thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If the specified key is not already associated</span></span><br><span class="line"><span class="comment">     * with a value, associate it with the given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (!map.containsKey(key))</span></span><br><span class="line"><span class="comment">     *       return map.put(key, value);</span></span><br><span class="line"><span class="comment">     *   else</span></span><br><span class="line"><span class="comment">     *       return map.get(key);&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with the specified key, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with the key,</span></span><br><span class="line"><span class="comment">     *         if the implementation supports null values.)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the entry for a key only if currently mapped to a given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key) &amp;&amp; map.get(key).equals(value)) &#123;</span></span><br><span class="line"><span class="comment">     *       map.remove(key);</span></span><br><span class="line"><span class="comment">     *       return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else return false;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value expected to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the value was removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the key or value is of an inappropriate</span></span><br><span class="line"><span class="comment">     *         type for this map</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the entry for a key only if currently mapped to a given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key) &amp;&amp; map.get(key).equals(oldValue)) &#123;</span></span><br><span class="line"><span class="comment">     *       map.put(key, newValue);</span></span><br><span class="line"><span class="comment">     *       return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else return false;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue value expected to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the value was replaced</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of a specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if a specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of a specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the entry for a key only if currently mapped to some value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key)) &#123;</span></span><br><span class="line"><span class="comment">     *       return map.put(key, value);</span></span><br><span class="line"><span class="comment">     *   &#125; else return null;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with the specified key, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with the key,</span></span><br><span class="line"><span class="comment">     *         if the implementation supports null values.)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-ConcurrentHashMap构造方法与数据结构分析"><a href="#2-1-ConcurrentHashMap构造方法与数据结构分析" class="headerlink" title="2.1 ConcurrentHashMap构造方法与数据结构分析"></a>2.1 ConcurrentHashMap构造方法与数据结构分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new, empty map with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity, load factor and concurrency level.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">     * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">     * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">     * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment">     * updating threads. The implementation performs internal sizing</span></span><br><span class="line"><span class="comment">     * to try to accommodate this many threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment">     * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment">     * nonpositive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;                               <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;                                                                                          <span class="comment">//@2 start</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;                                                              <span class="comment">//@2 end</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">// 每个 segment 内部容里</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1 concurrencyLevel，含义，并发级别，并发度，在键不冲突的情况下，最多允许多少个线程同时访问数据不需要阻塞（理想情况下），我们应该知道，ConcurrentHashMap 的基本实现原理就是引入Segment 数据结构，将锁的粒度细化到Segment, 也就是说，如果多个线程，同时操作多个 key,如果这些 key，分布在不同的 Segment, 那这些线程的操作互不影响，当然不需要加锁，提高性能。所以 concurrencyLevel，就是要求告诉 ConcurrentHashMap, 我需要这么过个线程同时访问你而不产生锁冲突。</p><p>代码@2，ssize，该变量的值等于ConcurrentHashMap 中 segment 的长度，也就是 Segment[] 的长度。该值取决于concurrencyLevel, 其实就是小于concurrencyLevel 的最大的2的幂，比如concurrencyLevel= 16,那 ssize=16,如果 concurrencyLevel = 12, ssize=8，因为ssize的长度为2的幂。</p><p>变量shift的值，看出来了没，其实就是 ssize 2 ^ shift,其实就是表示ssize需要的二进制位。</p><p>segmentMask、segmentShift ，这两个属性在该表达式中使用：(h &gt;&gt;&gt; segmentShift) &amp; segmentMask)，很明显，就是用来算Segment[]数组中的下标来的。意图segmentShift = 32 - sshift，也就是利用hash的高位与代表（ssize-1）来定位下标。// 如果默认，初始容量16,那么ssize=16, sshift=4 定位端 hash 无符号向右移多少28位，（总共32位），那就是使原本32-29位参与运算（高位）</p><p>变量cap,就是每个Segment中HashEntity[]的长度，大于【初始容量/segment长度】的最小2的幂。</p><p>分析到这里，ConcurrentHashMap就构建成功了，我们先重点关注一下 Segment 的数据结构。</p><p>Segment 段的内部数据结构如下：</p><ul><li>类的声明：static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</li><li>数据结构：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">// 内部键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;  <span class="comment">// 元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;     <span class="comment">// 结构发生变化的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">// 扩容时的阔值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;     <span class="comment">// 扩容因子，主要影响threshold，影响什么时候扩容</span></span><br></pre></td></tr></table></figure><p>对上述结构，是否似曾相识，对了，就是它，HashMap；每个 Segment 其实就是一个 HashMap; 还有一个很关键点：Segment继承自 ReentrantLock, 也就是 Segment 本身就是一把锁。</p><h2 id="2-2-public-V-put-K-key-V-value-源码分析"><a href="#2-2-public-V-put-K-key-V-value-源码分析" class="headerlink" title="2.2  public V put(K key, V value) 源码分析"></a>2.2  public V put(K key, V value) 源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)                                      </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;   <span class="comment">//@2</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck in ensureSegment</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment  @3</span></span><br><span class="line">            s = ensureSegment(j);                                      <span class="comment">//@4</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);                   <span class="comment">//@5</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1，表明 ConcurrentHashMap不支持value为空的键值对。</p><p>代码@2，计算该key对应的Segment的位置（数组下标），并发包中获取数组元素的方式，采用的是UNSAFE直接操作内存的方式，而不是典型的  Segment[] a = new Segment[16],  第j个元素的值为  a[j]。如果需要详细了解UNSAFE操作数组元素的原理，请查看  另一篇博客(AtomicIntegerArray 源码分析)</p><p>比如一个Integer[]中，每个int是32位，占4个字节，那数组中第3个位置的开始字节是多少呢？=(3-1) &lt;&lt; 2,也就是说SHIFT的值为元素中长度的幂。怎么获取每个元素在数组中长度（字节为单位）= UNSAFE.arrayIndexScale,</p><p>而 UNSAFE.arrayBaseOffset,返回的是，第一个数据元素相对于对象起始地址的便宜量，该部分的详解，请参考我的技术博客【<a href="http://blog.csdn.net/prestigeding/article/details/52980801%E3%80%91">http://blog.csdn.net/prestigeding/article/details/52980801】</a></p><p>代码@3，就是获取j下标的segment对象。相当于  if(  (s == segments[j])== null  )</p><p>代码@4，我们将目光移到 ensureSegment方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment">     * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">        Segment&lt;K,V&gt; seg;</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">            <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">            <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">            <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">            <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">                Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">                <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                       == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法，主要是确保segment槽的k位置的Segment不为空，如果为空，初始化。</p><p>代码@5，代码@4初始化k位置的segment后，将键值对加入到segment,接下重点看一下Segment的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);   <span class="comment">// @1</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);      <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;                         <span class="comment">// @3</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;                                                     <span class="comment">// @4           </span></span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||                                          </span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;      <span class="comment">//@5</span></span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;                                                                   <span class="comment">//@6                                                        </span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法，实现思路其实和HashMap一样，就是要在Segment的HashEntity[] table的指定位置加入新的Node,如果在位置k的位置不为空，此时，说明该位置发生了hash冲突，这是需要先遍历整个链，看是否有相等的key,如果key相等，则替换该值，如果没有，则将新加入的节点的next指针指向 table[k],然后将node加入到k位置。但是，由于ConcurrentHashMap是支持多个线程同时访问的，对于单个Segment的操作，需要加锁。</p><p>代码@1，首先尝试获取锁，如果成功获取锁，则继续添加元素，如果获取锁失败，后面重点分析。</p><p>代码@2，获取该key所对应的table[]中的下标。根据该元素是否为空，有两种操作，如果为空，说明没有发生冲突，也就是走代码@6分支，就是将新创建的节点的节点放入table[k]处，当然，此时需要判断是否需要进行rehash操作（ConcurrentHashMap的是否需要rehash,就是判断阔值）。</p><p>代码@4，就是循环判断table[k]的链条中，是否有key与待操作key相等，如果相等，直接替换就好。由于@3开始，其实就是整个put方法，会在锁保护中。</p><p>上述过程，应该很好理解，所以，现在重点关注两个方法，一是scanAndLockForPut，二是rehash(比较好奇，是否与HashMap相同，应该是一样的吧，呵呵)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment">         * acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment">         * return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment">         * methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment">         * traversal speed doesn&#x27;t matter, we might as well help warm</span></span><br><span class="line"><span class="comment">         * up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                    e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                    retries = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在没有成功获取锁的情况下，先不急于阻塞，而是乐观的估计获取锁的线程操作的key与当前操作的key没关系，那我该干嘛就干嘛，自旋尝试获取锁（尝试MAX_SCAN_RETRIES，如果未成功获取锁）尝试超过最大尝试次数，为了性能考虑，该线程阻塞，参加代码@2。</p><p>@3，每隔一次，检查一下 Segment HashEntity[] table 处k的位置的元素是否发生变化，如果发生变化，则重试次数设置为-1，继续尝试获取锁。该方法如果在阻塞在lock()方法，时，一旦获取锁，则进入到final V put(K key, int hash, V value, boolean onlyIfAbsent) 方法中，进行常规的put方法（与HashMap操作类似。）</p><p>接下来重点看一下代码@7，如果当前segment中容量大于阔值，并小于允许的最大长度时，需要进行rehash,下面分析一下rehash源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment">         * given node to new table</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Reclassify nodes in each list to new table.  Because we</span></span><br><span class="line"><span class="comment">             * are using power-of-two expansion, the elements from</span></span><br><span class="line"><span class="comment">             * each bin must either stay at same index, or move with a</span></span><br><span class="line"><span class="comment">             * power of two offset. We eliminate unnecessary node</span></span><br><span class="line"><span class="comment">             * creation by catching cases where old nodes can be</span></span><br><span class="line"><span class="comment">             * reused because their next fields won&#x27;t change.</span></span><br><span class="line"><span class="comment">             * Statistically, at the default threshold, only about</span></span><br><span class="line"><span class="comment">             * one-sixth of them need cloning when a table</span></span><br><span class="line"><span class="comment">             * doubles. The nodes they replace will be garbage</span></span><br><span class="line"><span class="comment">             * collectable as soon as they are no longer referenced by</span></span><br><span class="line"><span class="comment">             * any reader thread that may be in the midst of</span></span><br><span class="line"><span class="comment">             * concurrently traversing table. Entry accesses use plain</span></span><br><span class="line"><span class="comment">             * array indexing because they are followed by volatile</span></span><br><span class="line"><span class="comment">             * table write.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">                (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="keyword">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTable[lastIdx] = lastRun;</span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                            <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在理解了HashMap的rehash方法后，再来看该方法，应该能很好的理解，故不做重复讲解了。</p><h3 id="2-2-2-public-V-putIfAbsent-K-key-V-value"><a href="#2-2-2-public-V-putIfAbsent-K-key-V-value" class="headerlink" title="2.2.2 public V putIfAbsent(K key, V value)"></a>2.2.2 public V putIfAbsent(K key, V value)</h3><p>该方法的语义是，如果存在key，则直接返回key关联的value,如果key不存在，则加入该键值对，并返回null；该步骤是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法与put方法的实现基本相同，唯一不同的是，对已经存在key时，put方法是直接覆盖旧值，而putIfAbsent是，返回旧值。</p><h3 id="2-2-3-public-void-putAll-Map-m"><a href="#2-2-3-public-void-putAll-Map-m" class="headerlink" title="2.2.3 public void putAll(Map m)"></a>2.2.3 public void putAll(Map m)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接将传人的Map类型的参数，遍历，调用put方法。</p><p>看过了put函数，我们将目标转向到get方法中，瞧一瞧get相关方法的实现：</p><h3 id="2-2-4-public-V-get-Object-key-源码分析"><a href="#2-2-4-public-V-get-Object-key-源码分析" class="headerlink" title="2.2.4 public V get(Object key)源码分析"></a>2.2.4 public V get(Object key)源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> key.equals(k)&#125;,</span></span><br><span class="line"><span class="comment">     * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上文中可以看到，get方法并没有加锁，只是根据key的hash，然后算出Segment槽的位置，不是直接根据下标去获取Segment，也不是直接根据下标去Segment 的 HashEntity[] tab中去获取元素，而是使用了 UNSAFE.getObjectVolatile方法，直接操作内存，并使用volatile方式获取，最大程度保证可见性。有人或许有疑问，为什么get方法不加读锁，阻止其他写入请求呢？其实这样做意义并不大，ConcurrentHashMap的是一个容器，数据存储，提供基本的 put,get操作，对单一一个get请求加锁，没什么意义，因为get方法并不会改变ConcurrentHashMap的内部结构，在当前线程获取到key中的值，然后其他线程删除了该key,这在业务场景上本身就是正常不过的操作。所以get方法并不需要加锁。</p><p>2.3 浏览源码，发现无论是replace方法，还是remove方法等操作内部等都和HashMap相似，因为Segment就是一个带锁的HashMap。所以，接下来，我们可以这样思考，put,replace,remove这些方法比HashMap效率高，因为提供了并发度，那这些获取全局的属性的方法呢，比如keys,size等这些方法，性能又是如何呢？我们将目光转向size，keys等遍历方法。</p><h3 id="2-3-1-public-int-size方法"><a href="#2-3-1-public-int-size方法" class="headerlink" title="2.3.1 public int size方法"></a>2.3.1 public int size方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.  If the</span></span><br><span class="line"><span class="comment">     * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法的核心实现原理：从上文的解读，我想大家应该已经了解每一个Segment就是一个HashMap,HashMap中有两个变量，modCount，表示数据结构发生变化次数，比如put一个未在HashMap中包含的key,比如remove,比如clear方法，每调用一次上述方法，modCount就加1，也就是影响size属性的操作，都会将modeCount加一；另一个变量size，记录HashMap中键值对的个数。那ConcurrentHashMap的size方法，如果结构没有发生改变，只需将各个Segment的size相加，就可以得到ConcurrentHashMap的size,然并卯，在相加的过程其他线程如果有改变Segment内部的结构的话，导致size不准确，该方法的实现办法，是先乐观的尝试计算相加的过程最多三次，最少两次，如果前后两次的modCount一样，就说明在计算size的过程中，其他线程并没有改变ConcurrentHashMap的结构没有变化，则可以直接将size返回，结束该方法的调用，如果有变化，则需要依次对所有Segment申请加锁操作，只有获取全部锁后，然后对每个segment的size相加，然后是否锁，并返回size值。</p><p>代码@1,如果重试次数达到 (RETRIES_BEFORE_LOCK +１　,默认为2)次数后，说明需要加锁才能计算。</p><p>代码@2，对Segment相加计算size</p><p>代码@3，就是实现，判断连续两次计算出的modCount相等，说明该size值正确，否则，继续尝试，获取去请求锁。</p><h3 id="2-3-2-public-boolean-isEmpty-方法源码解读"><a href="#2-3-2-public-boolean-isEmpty-方法源码解读" class="headerlink" title="2.3.2 public boolean isEmpty() 方法源码解读"></a>2.3.2 public boolean isEmpty() 方法源码解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Sum per-segment modCounts to avoid mis-reporting when</span></span><br><span class="line"><span class="comment">         * elements are concurrently added and removed in one segment</span></span><br><span class="line"><span class="comment">         * while checking another, in which case the table was never</span></span><br><span class="line"><span class="comment">         * actually empty at any point. (The sum ensures accuracy up</span></span><br><span class="line"><span class="comment">         * through at least 1&lt;&lt;31 per-segment modifications before</span></span><br><span class="line"><span class="comment">         * recheck.)  Methods size() and containsValue() use similar</span></span><br><span class="line"><span class="comment">         * constructions for stability checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sum += seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    sum -= seg.modCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法的核心实现原理：就是遍历有所有的segment，一旦发现有存在size不等于0的segment，则返回false；如果发现所有的segment的size为0，则再次遍历，如果两次遍历时 modCount一样，则返回true,否则返回false。</p><p>大家再看看如下方法：</p><h3 id="2-3-3-public-boolean-containsKey-Object-key"><a href="#2-3-3-public-boolean-containsKey-Object-key" class="headerlink" title="2.3.3 public boolean containsKey(Object key)"></a>2.3.3 public boolean containsKey(Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if the specified object is a key in this table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key   possible key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object</span></span><br><span class="line"><span class="comment">     *         is a key in this table, as determined by the</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;equals&lt;/tt&gt; method; &lt;tt&gt;false&lt;/tt&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// same as get() except no need for volatile value read</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-public-boolean-containsValue-Object-value"><a href="#2-3-4-public-boolean-containsValue-Object-value" class="headerlink" title="2.3.4 public boolean containsValue(Object value)"></a>2.3.4 public boolean containsValue(Object value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">   * specified value. Note: This method requires a full internal</span></span><br><span class="line"><span class="comment">   * traversal of the hash table, and so is much slower than</span></span><br><span class="line"><span class="comment">   * method &lt;tt&gt;containsKey&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">   *         specified value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified value is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Same idea as size()</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">      <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                      ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">long</span> hashSum = <span class="number">0L</span>;</span><br><span class="line">              <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                  HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">                  Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                  <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (tab = seg.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tab.length; i++) &#123;</span><br><span class="line">                          HashEntry&lt;K,V&gt; e;</span><br><span class="line">                          <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                              V v = e.value;</span><br><span class="line">                              <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)) &#123;</span><br><span class="line">                                  found = <span class="keyword">true</span>;</span><br><span class="line">                                  <span class="keyword">break</span> outer;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      sum += seg.modCount;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (retries &gt; <span class="number">0</span> &amp;&amp; sum == last)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              last = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                  segmentAt(segments, j).unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> found;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet-遍历元素方法。"><a href="#2-3-5-public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet-遍历元素方法。" class="headerlink" title="2.3.5 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 遍历元素方法。"></a>2.3.5 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 遍历元素方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            V v = ConcurrentHashMap.<span class="keyword">this</span>.get(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; v.equals(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.remove(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; e = <span class="keyword">super</span>.nextEntry();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WriteThroughEntry(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextSegmentIndex;</span><br><span class="line">        <span class="keyword">int</span> nextTableIndex;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] currentTable;</span><br><span class="line">        HashEntry&lt;K, V&gt; nextEntry;</span><br><span class="line">        HashEntry&lt;K, V&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            nextSegmentIndex = segments.length - <span class="number">1</span>;</span><br><span class="line">            nextTableIndex = -<span class="number">1</span>;</span><br><span class="line">            advance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set nextEntry to first node of next non-empty table</span></span><br><span class="line"><span class="comment">         * (in backwards order, to simplify checks).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;       <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextTableIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((nextEntry = entryAt(currentTable,</span><br><span class="line">                                             nextTableIndex--)) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nextSegmentIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, nextSegmentIndex--);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (currentTable = seg.table) != <span class="keyword">null</span>)</span><br><span class="line">                        nextTableIndex = currentTable.length - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;     <span class="comment">// @2</span></span><br><span class="line">            HashEntry&lt;K,V&gt; e = nextEntry;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            lastReturned = e; <span class="comment">// cannot assign until after null check</span></span><br><span class="line">            <span class="keyword">if</span> ((nextEntry = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                advance();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">            lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteThroughEntry</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractMap</span>.<span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        WriteThroughEntry(K k, V v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set our entry&#x27;s value and write through to the map. The</span></span><br><span class="line"><span class="comment">         * value to return is somewhat arbitrary here. Since a</span></span><br><span class="line"><span class="comment">         * WriteThroughEntry does not necessarily track asynchronous</span></span><br><span class="line"><span class="comment">         * changes, the most recent &quot;previous&quot; value could be</span></span><br><span class="line"><span class="comment">         * different from what we return (or could even have been</span></span><br><span class="line"><span class="comment">         * removed in which case the put will re-establish). We do not</span></span><br><span class="line"><span class="comment">         * and cannot guarantee more.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            V v = <span class="keyword">super</span>.setValue(value);</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.put(getKey(), value);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码主要关注两点：第一是遍历元素的方法；第二是调用该迭代器的size,isEmpty等方法。</p><p>代码@1，advance，该方法主要是从segments[]数组中的最后一个元素开始，找出segment中HashEntity[] table数组中最后一个元素开始遍历，找到一个不为空nextEntity,这里返回的nextEntity,就是 table[]数组中的元素，不包括链表中的HashEntity，链表中的HashEntity遍历在代码@2 nextEntry 方法中，实现真的挺优雅的。</p><p>第二个特点是，调用迭代器的size、contains，isEmpty等方法，都是对ConcurrentHashMap对应方法的调用。</p><p>最后，通过上述的分析，我想对ConcurrentHashMap做一个简单的总结：</p><ol><li><p>结合上述源码分析，我们可以清楚的认为，一个Segment就是一个与HashMap相同的结构，当然每个Segment就是一把锁，该类的核心思想，就是通过对key的第一次hash,定位的不是以前的HashEntity,而是一个Segemnt,然后对该key限定在该Segment中执行，，这样可以同时允许多个线程向ConcurrentHashMap同时添加元素（当然，要分散到不同的Segment类，故提供了并发度。）</p></li><li><p>ConcurrentHashMap是一个并发容器，所谓的并发容器并不是说在使用过程中一定不需要加锁，并发容器能提    供的保证是多个线程同时访问该容器，同时调用会改变内部结构的方法时，比如put方法时，不会破坏内部结构    以至于不能提供服务或提供错误服务（数据视图）。怎么理解并不是一定不要加锁这句话，我举一个例子，比如我们用ConcurrentHashMap来存储数据，完成如下操作1、第一步，设置一个key 为”status”:1,然后经过复杂的逻辑处理，由存入一个金额 key为amount,值为10； 伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap a &#x3D; new ConcurrentHashMap();</span><br><span class="line">   </span><br><span class="line">     逻辑代码</span><br><span class="line">   </span><br><span class="line">     void eval(参数 ...) &#123;</span><br><span class="line">   </span><br><span class="line">           a.put(&quot;status&quot;,1);</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;经过计算</span><br><span class="line">   </span><br><span class="line">           a.put(&quot;amount&quot;: 10);</span><br><span class="line">   </span><br><span class="line">          &#x2F;&#x2F;付款</span><br><span class="line">   </span><br><span class="line">         if(  a.get(&quot;status&quot;)&#x3D;&#x3D;1  ) &#123;</span><br><span class="line">   </span><br><span class="line">          &#x2F;&#x2F;执行付款操作</span><br><span class="line">   </span><br><span class="line">         &#125; </span><br><span class="line">   </span><br><span class="line">     &#125;  </span><br></pre></td></tr></table></figure><p>从上面的代码，如果多个线程执行eval方法，肯定会有问题。所以，还是需要加锁，说白了，ConcurrentHashMap只对单个方法负责，比如对 put 方法负责，只是对调用一次put方法，保证该操作，不会受到其他线程的影响。</p></li><li><p>ConcurrentHash采取如下方法从Segment[] segments,HashEntity[]  table,数组中获取元素，其准确实施性依次增强。</p></li></ol><ul><li>segment[下标],table[下标]</li><li>使用UNSAFE根据便宜量直接操作内存方式，使用(voliate方式)</li><li>重试一定次数后，加锁。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、ConcurrentHashMap-与-HashTable&quot;&gt;&lt;a href=&quot;#1、ConcurrentHashMap-与-HashTable&quot; class=&quot;headerlink&quot; title=&quot;1、ConcurrentHashMap 与 HashTable&quot;&gt;&lt;/a&gt;1、ConcurrentHashMap 与 HashTable&lt;/h1&gt;&lt;p&gt;HashTable 是 HashMap 的线程安全版本，使用的是 HashTable 的对象锁，同一时刻只能有一个线程 新增元素，获取元素。锁等待多，并发度低。而 ConcurrentHashMap 采用的是锁分段机制，就是用多把锁，让每把锁管理一部分数据。怎么实现的呢？引入了段(Segment)数据结构。&lt;/p&gt;
&lt;p&gt;我们不妨来回忆一下HashMap、HashTable 的数据结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161129121630568?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;img&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;点击并拖拽以移动&quot;&gt;&lt;/p&gt;
&lt;p&gt;结合下文对ConcurrentHashMap的分析，可以得知ConcurrentHashMap的数据结构如下，其实就是可以简单的认为，ConcurrentHashMap就是 HashMap[] 数组，就是一个数组，数组元素是一个一个的 HashMap。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161129121705356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;img&quot;&gt;</summary>
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="并发容器" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    <category term="ConcurrentHashMap" scheme="http://example.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁ReentrantReadWriteLock读写锁源码分析</title>
    <link href="http://example.com/posts/9ba20a53.html"/>
    <id>http://example.com/posts/9ba20a53.html</id>
    <published>2020-12-13T13:38:01.000Z</published>
    <updated>2020-12-13T13:50:25.641Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、ReentrantReadWriterLock-基础"><a href="#1、ReentrantReadWriterLock-基础" class="headerlink" title="1、ReentrantReadWriterLock 基础"></a>1、ReentrantReadWriterLock 基础</h1><p>所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。</p><p>java.util.concurrent.locks中关于多写锁的接口：ReadWriteLock。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提一个问题，是否觉得 ReentrantReadWriteLock 会实现 Lock 接口吗？与 ReentrantLock 有什么关系？</p><a id="more"></a><p>答案是否定的，ReentrantReadWriterLock 通过两个内部类实现 Lock 接口，分别是 ReadLock,WriterLock 类。与 ReentrantLock一样，ReentrantReadWriterLock 同样使用自己的内部类Sync（继承AbstractQueuedSynchronizer）实现CLH算法。为了方便对读写锁获取机制的了解，先介绍一下Sync内部类中几个属性，采用了位运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">         * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">         * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">         * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>首先ReentrantReadWriterLock使用一个32位的int类型来表示锁被占用的线程数（ReentrantLock中的state）,用所以，采取的办法是，高16位用来表示读锁占有的线程数量，用低16位表示写锁被同一个线程申请的次数。</p><ul><li>SHARED_SHIFT，表示读锁占用的位数，常量16</li><li>SHARED_UNIT，  增加一个读锁，按照上述设计，就相当于增加 SHARED_UNIT；</li><li>MAX_COUNT   ，表示申请读锁最大的线程数量，为65535</li><li>EXCLUSIVE_MASK  :表示计算写锁的具体值时，该值为 15个1,用 getState &amp; EXCLUSIVE_MASK算出写锁的线程数，大于1表示重入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>举例说明，比如，现在当前，申请读锁的线程数为13个，写锁一个，那state怎么表示？</p><p>上文说过，用一个32位的int类型的高16位表示读锁线程数，13的二进制为 1101,那state的二进制表示为</p><p>00000000 00001101 00000000 00000001，十进制数为 851969， 接下在具体获取锁时，需要根据这个 851968 这个值得出上文中的 13 与 1。要算成13，只需要将state 无符号向左移位16位置，得出00000000 00001101，就出13，根据851969要算成低16位置，只需要用该00000000 00001101 00000000 00000001 &amp; 111111111111111（15位），就可以得出00000001,就是利用了1&amp;1得1,1&amp;0得0这个技巧。</p><p>移位元素，如果一个数值向左移(&lt;)一位，在没越界（超过该类型表示的最大值）的情况下，想当于操作数 * 2</p><p>如果一个数值向右(&gt;) 移动移位，在没有越界的情况下，想到于操作数 除以2。</p><p>然后再关注如下几个与线程本地变量相关的属性：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">         * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">         * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The hold count of the last thread to successfully acquire</span></span><br><span class="line"><span class="comment">         * readLock. This saves ThreadLocal lookup in the common case</span></span><br><span class="line"><span class="comment">         * where the next thread to release is the last one to</span></span><br><span class="line"><span class="comment">         * acquire. This is non-volatile since it is just used</span></span><br><span class="line"><span class="comment">         * as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Can outlive the Thread for which it is caching the read</span></span><br><span class="line"><span class="comment">         * hold count, but avoids garbage retention by not retaining a</span></span><br><span class="line"><span class="comment">         * reference to the Thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">         * model&#x27;s final field and out-of-thin-air guarantees.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * firstReader is the first thread to have acquired the read lock.</span></span><br><span class="line"><span class="comment">         * firstReaderHoldCount is firstReader&#x27;s hold count.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;More precisely, firstReader is the unique thread that last</span></span><br><span class="line"><span class="comment">         * changed the shared count from 0 to 1, and has not released the</span></span><br><span class="line"><span class="comment">         * read lock since then; null if there is no such thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Cannot cause garbage retention unless the thread terminated</span></span><br><span class="line"><span class="comment">         * without relinquishing its read locks, since tryReleaseShared</span></span><br><span class="line"><span class="comment">         * sets it to null.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">         * model&#x27;s out-of-thin-air guarantees for references.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This allows tracking of read holds for uncontended read</span></span><br><span class="line"><span class="comment">         * locks to be very cheap.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p>上述这4个变量，其实就是完成一件事情，将获取读锁的线程放入线程本地变量(ThreadLocal)，方便从整个上 下文，根据当前线程获取持有锁的次数信息。其实 firstReader,firstReaderHoldCount ,cachedHoldCounter 这三个变量就是为readHolds变量服务的，是一个优化手段，尽量减少直接使用readHolds.get方法的次数，firstReader与firstReadHoldCount保存第一个获取读锁的线程，也就是readHolds中并不会保存第一个获取读锁的线程；cachedHoldCounter 缓存的是最后一个获取线程的HolderCount信息，该变量主要是在如果当前线程多次获取读锁时，减少从readHolds中获取HoldCounter的次数。请结合如下代码理解上述观点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    firstReader = current;</span><br><span class="line">    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">    firstReaderHoldCount++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">        readHolds.set(rh);</span><br><span class="line">    rh.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、ReentrantReadWriterLock源码分析"><a href="#2、ReentrantReadWriterLock源码分析" class="headerlink" title="2、ReentrantReadWriterLock源码分析"></a>2、ReentrantReadWriterLock源码分析</h2><h2 id="2-1-ReadLock-源码分析"><a href="#2-1-ReadLock-源码分析" class="headerlink" title="2.1 ReadLock 源码分析"></a>2.1 ReadLock 源码分析</h2><h3 id="2-1-1-lock方法"><a href="#2-1-1-lock方法" class="headerlink" title="2.1.1 lock方法"></a>2.1.1 lock方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Acquires the read lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">         * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">         * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">         * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>sync.acquireShared方法存在于AbstractQueuedSynchronizer类中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    <span class="comment">//@1</span></span><br><span class="line">            doAcquireShared(arg);           <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据常识，具体获取锁的过程在子类中实现，果不其然，tryAcquireShared方法在ReentrantReadWriterLock的Sync类中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();    <span class="comment">//@1 start</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;                                                     <span class="comment">// @1 end</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;                          </span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;                                      <span class="comment">//@21                               </span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;  <span class="comment">//@22</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// @23</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);      <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>尝试获取共享锁代码解读：</p><p>@1 start–end ，如果有线程已经抢占了写锁，并且不是当前线程，则直接返回-1，通过排队获取锁。</p><p>@2,如果线程不需要阻塞，并且获取读锁的线程数没有超过最大值，并且使用 CAS更新共享锁线程数量成功的话；表示成获取读锁，然后进行内部变量的相关更新操作；先关注一下，成功获取读锁后，内部变量的更新操作：</p><p>@21,如果r=0, 表示，当前线程为第一个获取读锁的线程</p><p>@22,如果第一个获取读锁的对象为当前对象，将firstReaderHoldCount 加一</p><p>@23，成功获取锁后，如果不是第一个获取多锁的线程，将该线程持有锁的次数信息，放入线程本地变量中，方便在整个请求上下文（请求锁、释放锁等过程中）使用持有锁次数信息。</p><p>@3 在讲解代码@3之前，我们先重点分析@2处的第一个条件，是否需要阻塞方法：readerShouldBlock，在具体的子类中，现在查看的是NonfairSync中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">             * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">             * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">             * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">             * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">             * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();   <span class="comment">//该方法，具体又是在 AbstractQueuedSynchronizer中</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment">     * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment">     * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment">     * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment">     * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法如果头节点不为空，并头节点的下一个节点不为空，并且不是共享模式【独占模式，写锁】、并且线程不为空。则返回true,说明有当前申请读锁的线程占有写锁，并有其他写锁在申请。为什么要判断head节点的下一个节点不为空，或是thread不为空呢？因为第一个节点head节点是当前持有写锁的线程，也就是当前申请读锁的线程，这里，也就是锁降级的关键所在，如果占有的写锁不是当前线程，那线程申请读锁会直接失败。</p><p>现在继续回到@3，讲解如果第一次尝试获取读锁失败后，该如何处理。首先，进入该方法的条件如下：</p><ul><li>没有写锁被占用时，尝试通过一次CAS去获取锁时，更新失败（说明有其他读锁在申请）。</li><li>当前线程占有写锁，并且没有有其他写锁在当前线程的下一个节点等待获取写锁。；其实如果是这种情况，除非当前线程占有锁的下个线程取消，否则进入fullTryAcquireShared方法也无法获取锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;                                     <span class="comment">//@31</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;                             <span class="comment">//@32</span></span><br><span class="line">                    <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;                              <span class="comment">//@33</span></span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;                                                              <span class="comment">//@34</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId()) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)                           </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;     <span class="comment">// @35</span></span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码@31,首先再次判断，如果当前线程不是写锁的持有者，直接返回-1，结束尝试获取读锁，需要排队去申请读锁。</p><p>代码@32，如果需要阻塞，说明除了当前线程持有写锁外，还有其他线程已经排队在申请写锁，故，即使申请读锁的线程已经持有写锁（写锁内部再次申请读锁，俗称锁降级）还是会失败，因为有其他线程也在申请写锁，此时，只能结束本次申请读锁的请求，转而去排队，否则，将造成死锁。代码@34，就是从readHolds中移除当前线程的持有数，然后返回-1，结束尝试获取锁步骤（结束tryAcquireShared 方法）然后去排队获取。</p><p>代码@33，因为，如果当前线程是第一个获取了写锁，那其他线程无法申请写锁（该部分在分析完，读写锁的队列机制后，才回来做更详细的解答。）</p><p>代码@35,表示成功获取读锁，后续就是更新readHolds等内部变量，该部分在上文中已有讲解。如果是通过@35尝试获取锁成功，这就是写锁内部–》再次申请读锁（锁降级）的原理。</p><p>至此，完成尝试获取锁步骤 tryAcquireShared 方法，我们再次回到 acquireShared，如果返回-1,那么需要排队申请,具体请看 doAcquireShared(arg);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    <span class="comment">//@1</span></span><br><span class="line">            doAcquireShared(arg);           <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);   <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// @2,开始自旋重试</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// @3</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;                                   <span class="comment">// @4</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);         </span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);    <span class="comment">//@5</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())                                              <span class="comment">// @6</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取共享锁解读：</p><p>代码@1，在队列尾部增加一个节点。锁模式为共享模式。</p><p>代码@3，获取该节点的前置节点。</p><p>代码@4，如果该节点的前置节点为head(头部)，为什么前置节点是head时，可以再次尝试呢？在讲解ReentrantLock时，也讲过，head节点的初始化在第一次产生锁争用时初始化，刚开始初始化的head节点是不代表线程的，故可以尝试获取锁。如果获取失败，则将进入到shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法中，线程阻塞，等待被唤醒。</p><p>重点分析一下获取锁后的操作：setHeadAndPropagate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;   <span class="comment">// @1</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())    <span class="comment">// @2</span></span><br><span class="line">                doReleaseShared();          <span class="comment">//@3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signal successor and ensure</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;   <span class="comment">//@4</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;   <span class="comment">//@5</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))   <span class="comment">//@6</span></span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed      //@7</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>释放共享锁的步骤：</p><p>代码@1,如果读锁（共享锁）获取成功，或头部节点为空，或头节点取消，或刚获取读锁的线程的下一个节点为空，或在节点的下个节点也在申请读锁，则在CLH队列中传播下去唤醒线程，怎么理解这个传播呢，就是只要获取成功到读锁，那就要传播到下一个节点（如果一下个节点继续是读锁的申请，只要成功获取，就再下一个节点，直到队列尾部或为写锁的申请，停止传播）。具体请看doReleaseShared方法。</p><p>代码@4，从队列的头部开始遍历每一个节点。</p><p>代码@5，如果节点状态为 Node.SIGNAL,将状态设置为0，设置成功，唤醒线程。为什么会设置不成功，可能改节点被取消；还有一种情况就是有多个线程在运行该代码段，这就是PROPAGATE的含义吧，传播，请看代码@7的理解。</p><p>代码@6，如果状态为0，则设置为Node.PROPAGATE，设置为传播，该值然后会在什么时候变化呢？在判断该节点的下一个节点是否需要阻塞时，会判断，如果状态不是Node.SIGNAL或取消状态，为了保险起见，会将前置节点状态设置为Node.SIGNAL，然后再次判断，是否需要阻塞。</p><p>代码@7，如果处理过一次 unparkSuccessor 方法后，头节点没有发生变化，就退出该方法，那head在什么时候会改变呢？当然在是抢占锁成功的时候，head节点代表获取锁的节点。一旦获取锁成功，则又会进入setHeadAndPropagate方法，当然又会触发doReleaseShared方法，传播特性应该就是表现在这里吧。再想一下，同一时间，可以有多个多线程占有锁，那在锁释放时，写锁的释放比较简单，就是从头部节点下的第一个非取消节点，唤醒线程即可，为了在释放读锁的上下文环境中获取代表读锁的线程，将信息存入在 readHolds ThreadLocal变量中。</p><p>到这里为止，读锁的申请就讲解完毕了，先给出如下流程图：</p><p><img src="https://img-blog.csdn.net/20161122154102536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>​                                    尝试获取读锁过程</p><p>从队列中获取读锁的流程如下：</p><h3 id="2-1-2-ReadLock-的-unlock方法详解"><a href="#2-1-2-ReadLock-的-unlock方法详解" class="headerlink" title="  2.1.2 ReadLock 的 unlock方法详解"></a><img src="https://img-blog.csdn.net/20161122154203111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">  2.1.2 ReadLock 的 unlock方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer的  realseShared方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantReadWriterLock.Sync tryReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; </span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;                               <span class="comment">// @1 start               </span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;                                                            <span class="comment">// @1 end</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;                                                               <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">AbstractQueuedSynchronizer的doReleaseShared</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signal successor and ensure</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>锁的释放，比较简单，代码@1，主要是将当前线程所持有的锁的数量信息得到（从firstReader或cachedHoldCounter，或readHolds中获取 ），然后将数量减少1,如果持有数为1，则直接将该线程变量从readHolds ThreadLocal变量中移除，避免垃圾堆积。</p><p>代码@2，就是在无限循环中将共享锁的数量减少一，在释放锁阶段，只有当所有的读锁，写锁被占有，才会去执行doReleaseShared 方法。</p><h2 id="2-2-WriterLock-源码分析"><a href="#2-2-WriterLock-源码分析" class="headerlink" title="2.2 WriterLock 源码分析"></a>2.2 WriterLock 源码分析</h2><h3 id="2-2-1-lock方法详解"><a href="#2-2-1-lock方法详解" class="headerlink" title="2.2.1 lock方法详解"></a>2.2.1 lock方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">对上述代码是不是似曾相识，对了，在学习ReentrantLock时候，看到的一样，acquire是在AbstractQueuedSynchronizer中，关键是在 tryAcquire方法，是在不同的子类中实现的。那我们将目光移到ReentrantReadWriterLock.Sync中</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;                                   <span class="comment">// @1</span></span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())                <span class="comment">//@2</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)              </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);                                                             <span class="comment">//@3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||                                                               </span><br><span class="line">                !compareAndSetState(c, c + acquires))                                   <span class="comment">//@4</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);                                             <span class="comment">//@5</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码@1,如果锁的state不为0，说明有写锁，或读锁，或两种锁持有。</p><p>代码@2，如果写锁为0，再加上c!=0，说明此时有读锁，自然返回false，表示只能排队去获取写锁；如果写锁不为0，如果持有写锁的线程不为当前线程，自然返回false,排队去获取写锁。</p><p>代码@3，表示，当前线程持有写锁，现在是重入，所以只需要修改锁的额数量即可。</p><p>代码@4，表示，表示通过一次CAS去获取锁的时候失败，说明被别的线程抢去了，也返回false,排队去重试获取锁。</p><p>代码@5，成获取写锁后，将当前线程设置为占有写锁的线程。尝试获取锁方法结束。如果该方法返回false,则进入到acquireQueue方法去排队获取写锁，写锁的获取过程，与ReentrantLock获取方法一样，就不过多的解读了。</p><p>读写锁的实现原理就分析到这了，走过路过的朋友，欢迎拍砖讨论。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、ReentrantReadWriterLock-基础&quot;&gt;&lt;a href=&quot;#1、ReentrantReadWriterLock-基础&quot; class=&quot;headerlink&quot; title=&quot;1、ReentrantReadWriterLock 基础&quot;&gt;&lt;/a&gt;1、ReentrantReadWriterLock 基础&lt;/h1&gt;&lt;p&gt;所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。&lt;/p&gt;
&lt;p&gt;java.util.concurrent.locks中关于多写锁的接口：ReadWriteLock。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReadWriteLock&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Returns the lock used for reading.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the lock used for reading.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Lock &lt;span class=&quot;title&quot;&gt;readLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Returns the lock used for writing.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the lock used for writing.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Lock &lt;span class=&quot;title&quot;&gt;writeLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;提一个问题，是否觉得 ReentrantReadWriteLock 会实现 Lock 接口吗？与 ReentrantLock 有什么关系？&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="读写琐" scheme="http://example.com/tags/%E8%AF%BB%E5%86%99%E7%90%90/"/>
    
    <category term="ReentrantReadWriteLock" scheme="http://example.com/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁ReentrantLock源码分析二之Condition实现原理</title>
    <link href="http://example.com/posts/c82e1c77.html"/>
    <id>http://example.com/posts/c82e1c77.html</id>
    <published>2020-12-13T13:33:01.000Z</published>
    <updated>2020-12-13T13:50:25.632Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、Condition接口一览"><a href="#1、Condition接口一览" class="headerlink" title="1、Condition接口一览"></a>1、Condition接口一览</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Condition 实现的语义为 Object.wait 与 Object.notify。</p><p>关于Condition 的实现类为 AbstractQueuedSynchronizer.ConditionObject 内部类。</p><p>首先在讲解源码之前，我重点罗列出ConditionObject的关键数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node fristWaiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p>从这里看出，每个CondtionObject,都维护着自己的条件等待等待队列，并且是一个双端链表。</p><a id="more"></a><h2 id="1-1-void-await-throws-InterruptedException"><a href="#1-1-void-await-throws-InterruptedException" class="headerlink" title="1.1 void await() throws InterruptedException"></a>1.1 void await() throws InterruptedException</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with</span></span><br><span class="line"><span class="comment">         *      saved state as argument, throwing</span></span><br><span class="line"><span class="comment">         *      IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())    <span class="comment">// @1 </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">            Node node = addConditionWaiter();    <span class="comment">//@2</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);   <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;     <span class="comment">//@4</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)  <span class="comment">// @5</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//@6</span></span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled                                 //@7</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)                                                                            <span class="comment">//@8</span></span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码@1：检测当前线程的中断标记，如果中断位为1，则抛出异常。</p><p>代码@2：添加等待节点。就是一个简单的链表维护节点的操作，具体参照addConditionWaiter讲解。</p><p>代码@3：释放占有的锁，并获取当前锁的state,因为await实现的语意为Object.wait,释放锁并并等待条件的发生。当条件满足后，线程被唤醒后，第一步是需要获取锁，然后在上次await的下一条指令处继续执行。代码3就是实现上述语义的释放锁。</p><p>代码@4：isOnSyncQueue 当前节点是否在同步队列中，如果在同步阻塞队列中，则申请锁，去执行；如果不在同步队列中（在条件队列中），阻塞，等待满足条件，新增的节点，默认在条件队列中(Conditon)。isOnSyncQueue 源码解读在下文中；</p><p>代码@5：线程从条件等待被唤醒,唤醒后，线程要从条件队列移除，进入到同步等待队列，被唤醒有有如下两种情况，一是条件满足，收到singal信号，二是线程被取消（中断），该步骤是从条件队列移除，加入到同步等待队列，返回被唤醒的原因，如果是被中断，需要根据不同模式，处理中断。处理中断，也有两种方式：1.继续设置中断位；2：直接抛出InterruptedException。请看下文关于checkInterruptWhileWaiting的源码解读。</p><p>代码@6：运行到代码6时，说明线程已经结束了释放锁，从条件队列移除，线程运行，在继续执行业务逻辑之前，必须先获取锁。只有成功获取锁后，才会去判断线程的中断标志，才能在中断标志为真时，抛出InterruptException。</p><p>代码@7，执行一些收尾工作，清理整个条件队列：</p><p>代码@8，处理中断，是设置中断位，还是抛出InterruptException。</p><p>那我们先关注一下addConditionWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;     <span class="comment">//@1</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);  <span class="comment">//@2</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>添加条件等待节点，根据链表的特征，直接在尾部节点的nextWaiter指向新建的节点，并将新建的节点设置为整个链表的尾部，首先要知道如下数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object &#123;</span><br><span class="line"></span><br><span class="line">      Node firstWaiter;</span><br><span class="line"></span><br><span class="line">      Node lastWaiter;</span><br><span class="line"></span><br><span class="line">      node &#123;</span><br><span class="line"></span><br><span class="line">           node nextWaiter;</span><br><span class="line"></span><br><span class="line">          该节点承载的业务数据，比如这里的Thread t;等</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道上述结构，其实整个链的数据维护，基本一目了然，自己都可以实现下面的逻辑。</p><p>代码@1,如果最后一个等待节点的状态不是Node.CONDITION,则，则先删除等待链中节点状态不为Node.CONDITION的节点。具体代码分析请参照下文unlinkCancelledWaiters的解读。</p><p>代码@2开始，就是普通链表的节点添加的基本方法。</p><p>清除等待节点方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">         * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">         * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">         * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">         * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">         * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">         * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">         * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">         * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">         * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">         * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">         * storms.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter;  <span class="comment">// </span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;       <span class="comment">//@1</span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = t.nextWaiter;    </span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;  <span class="comment">// @3</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)                      <span class="comment">// @4</span></span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;       <span class="comment">//@5</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)    <span class="comment">// @6</span></span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">// @4</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法的思路为，从第一节点开始，将不等于Node.CONDITION的节点。</p><p>代码@1,设置尾部节点临时变量，用来记录最终的尾部节点。代码@1 第一次循环，是循环第一个节点，如果它的状态为Node.CONDITION, 则该链的头节点保持不变，设置临时尾节点为t,然后进行一个节点的判断，如果节点不为Node.CONDITION, 重置头节点的下一个节点，或尾部节点的下一个节点(@4,@5)。代码@6代表整个循环结束，设置 ConditionObject对象的lastWaiter为trail的值；</p><p>await步骤中，释放锁过程源码解析。释放锁的过程，逻辑为unlock,但该方法，返回当前锁的state,因为释放锁后，该方法在条件没有满足前提下，自身需要阻塞。被唤醒后，需要先尝试获取锁，然后才能执行接下来的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">     * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await，@4步骤中，isOnSyncQueue 源码解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment">     * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)   <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue   // @2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">         * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">         * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">         * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">         * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">         * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1,如果节点的状态为Node.CONDITION 或 node.prev == null,表明该节点在条件队列中，并没有加入同步阻塞队列（同步阻塞队列为申请锁等待的队列），await方法中，新增的节点，默认满足上述条件，所以返回false,表示在条件队列中，等待条件的发生，条件满足之前，当前线程应该阻塞。这里，先预留一个疑问，那node.prev在什么时候会改变呢？</p><p>代码@2,如果node.next不为空，说明在同步阻塞队列中。这个我想毫无疑问。当然也说明next域肯定是在进入同步队列过程中会设置值。</p><p>代码@3, 上面的注释也说的比较清楚，node.prev不为空，但也不在同步队列中，这个是由于CAS可能会失败，为了不丢失信号，从同步队列中再次选择该节点，如果找到则返回true,否则返回false,在这里，我就更加对node.prev在什么时候会设置值感兴趣了，请继续await方法向下看，总有水落石出的时候。</p><p>await @5 checkInterruptWhileWaiting 代码解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">         * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">         * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">         * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;   <span class="comment">// 重新设置中断位，中断由上层处理</span></span><br><span class="line">        <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span>  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;    <span class="comment">// 直接抛出 InterruptedException  0:正常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">         * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">         * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers node, if necessary, to sync queue after a cancelled</span></span><br><span class="line"><span class="comment">     * wait. Returns true if thread was cancelled before being</span></span><br><span class="line"><span class="comment">     * signalled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current the waiting thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node its node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;   <span class="comment">//@1</span></span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we lost out to a signal(), then we can&#x27;t proceed</span></span><br><span class="line"><span class="comment">         * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">         * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">         * spin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点关注@1,首先需要知道一点，如果收到正常的singal()信号而被唤醒的节点【这个再singal方法时重点分析】，状态为Node.SINGAL,不会是Node.CONDITION状态，所以如果代码1compareAndSetWaitStatus设置成功，说明线程是调用了t.interrupt方法而使得LockSupport.park解除阻塞的，然后将该节点加入到同步队列中，使得 while( ! isOnSyncQueue(node)) 的条件为真，结束 await的等待条件触发语义，，进入到 抢占锁阶段。【再次重申Object wait语义，释放当前锁，然后等待条件的触发【条件队列】，，条件发生后，要先重新去抢占锁，获取锁则继续执行，否则阻塞在获取锁【同步队列】】，所以当 线程阻塞在  await 方法时，调用 t.interrupt方法时只是中断条件队列的等待，并不能马上取消执行，马上抛出InterrupterException。</p><p><strong>await方法流程图：</strong></p><h2 id="1-2-signal-方法详解"><a href="#1-2-signal-方法详解" class="headerlink" title=" 1.2 signal()方法详解"></a><img src="https://img-blog.csdn.net/20161114141204119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> 1.2 signal()方法详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">         * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">         * owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())  <span class="comment">//如果当前线程不是锁的持有者，直接抛出异常。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first); <span class="comment">//通知第一个等待者          //@2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">         * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">         * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)   <span class="comment">// @3</span></span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);                          <span class="comment">// @4</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">     * Returns true if successful.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">     * cancelled before signal).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;  <span class="comment">// @5</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))   <span class="comment">//@6</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node p = enq(node);     <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))     <span class="comment">//@8</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>signal的具体实现，是从doSignal方法开始。</p><p>@代码3，首先将要被通知的节点的下一个节点设置为等待队列的head节点，如果当前节点的下一个节点为空，则设在等待队列的尾节点（lastWaiter）设置为空，然后将当前被通知的节点的下一个节点设为空；该步骤核心思想就是将被通知节点移除条件等待队列，然后重新维护条件等待对的firstWaiter和lastWaiter。</p><p>@代码4，!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null，根据后文的解析可以知道，如果被通知节点没有进入到同步阻塞队列(transferForSignal返回false)并且条件等待队列还有不为空的节点，则继续循环通知。</p><p>@代码5，transferForSignal该方法，将被通知的节点放入同步等待队列。</p><p>@代码6，首先判断，尝试将节点状态设置为0,如果设置失败，则说明该节点的状态已经不是Node.CONDITION,进一步说明该节点在没有等到通知信号时，被取消，直接返回false,通知下一个等待者。（回到代码@3,@4）</p><p>@代码7，将节点放入到同步队列中。个人认为信号通知，主要是将节点从条件等待队列移入到同步等待队列，主要是防止sinal信号的丢失。</p><p>@代码8，如果前置节点取消，或者在设置前置节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程，@8设置失败发送的情况也就是前置节点状态发送改变（被取消等），所以直接唤醒被通知节点的线程，也就是说，sinal方法，只有在入队列后，前置节点被取消时，才会执行LockSupport.unpark方法唤醒线程，通常该方法，只是将节点从条件等待队列放入同步队列，然后该方法执行完毕，释放持有的锁。</p><p>整个通知sinal方法的流程如下：</p><p><img src="https://img-blog.csdn.net/20161114141402135?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、Condition接口一览&quot;&gt;&lt;a href=&quot;#1、Condition接口一览&quot; class=&quot;headerlink&quot; title=&quot;1、Condition接口一览&quot;&gt;&lt;/a&gt;1、Condition接口一览&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitUninterruptibly&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitNanos&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; nanosTimeout)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; time, TimeUnit unit)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitUntil&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Date deadline)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signalAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Condition 实现的语义为 Object.wait 与 Object.notify。&lt;/p&gt;
&lt;p&gt;关于Condition 的实现类为 AbstractQueuedSynchronizer.ConditionObject 内部类。&lt;/p&gt;
&lt;p&gt;首先在讲解源码之前，我重点罗列出ConditionObject的关键数据结构：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node fristWaiter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node lastWaiter;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;从这里看出，每个CondtionObject,都维护着自己的条件等待等待队列，并且是一个双端链表。&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Condition" scheme="http://example.com/tags/Condition/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁ReentrantLock源码分析一 可重入支持中断锁的实现原理</title>
    <link href="http://example.com/posts/22168d83.html"/>
    <id>http://example.com/posts/22168d83.html</id>
    <published>2020-12-13T13:08:01.000Z</published>
    <updated>2020-12-13T13:50:25.635Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细介绍 ReentrantLock 的实现原理。</p><p>在进入源码分析之前，我先提出如下观点：希望大家纠正与讨论：</p><ul><li>如果一个节点的状态设置为Node.SIGNAL,则说明它有后继节点，并处于阻塞状态。</li><li>ReentantLock的head节点，如果不为空，在该节点代表的线程为锁的占有者。这是对CLH算法的改进之处。众所周知，CLH算法的head节点为假节点，不代表任何线程。</li><li>ReentantLock几个编码技巧值得借鉴：<ul><li>利用内部类实现功能扩展，使得java.util.concurrent.locks包类数量少，十分清晰。</li><li>利用了模板模式，AbstractQueuedSynchronizer就是锁机制的模板（CLH算法的一个变种）。</li></ul></li></ul><p>本文重点关注如下几个方法的实现：</p><ul><li>lock()  </li><li>unlock()</li><li>lockInterruptibly()</li></ul><p>进入源码分析之前，希望读者带着如下问题边看边想：</p><p>问题1：一个线程用lock方法申请锁而被阻塞后，调用线程的interput方法，会发生什么情况，能中断锁的获取吗？</p><p>问题2：什么是CLH算法，RenntrantLock针对CLH算法做了哪些变化。</p><p>问题3：Node.CANCEL状态的节点在什么时候会删除。</p><a id="more"></a><h1 id="1、ReentrantLock-lock-方法详解"><a href="#1、ReentrantLock-lock-方法详解" class="headerlink" title="1、ReentrantLock#lock 方法详解"></a>1、ReentrantLock#lock 方法详解</h1><p>如下摘录自  ReentrantLock.NonFairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))     <span class="comment">// @1</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1 首先线程请求锁时，第一步，直接通过锁的状态 state, 如果 state 为0，通过 CAS 尝试去获取锁，如果获取，直接返回，这里就是所谓的不公平，先抢占，然后再尝试排队。如果当前锁被占用，则尝试申请锁, 进入代码 @2；</p><p>继续查看 acquire(1)方法，该方法存在于 AbstractQueuedSynchronizer 类，该类是 java.util.concurent.locks 锁的队列机制实现类，基于CLH 算法的变体的基本思想。，附上 AbstractQueuedSynchronizer 的 acquire 方法源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先进入到 tryAcquire(arg)方法，查看获取锁的逻辑，该方法不阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;   <span class="comment">// 说明，该方法在具体的子类中实现。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一路跟踪进来，发现尝试获取锁的代码在 ReentrantLock内部类 Sync 汇总，Sync 是 NonFairSync 和 FairSync 的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is</span></span><br><span class="line"><span class="comment">         * implemented in subclasses, but both need nonfair</span></span><br><span class="line"><span class="comment">         * try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;    <span class="comment">// @1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法，尝试获取锁，如果成功获取锁，则返回true,否则，返回false;</p><p>重点关注 代码@1, 再次查看 锁的 state,该字段，表示该锁被占用的次数，如果为0，表示没有线程持有该锁，如果     大于1，表示同一个线程，多次请求锁；也就是可重入锁的实现原理。</p><p>代码@2：进一步说明可重入锁的实现机制。再次回到上文提到的 AbstractQueuedSynchronizer的 acquire(arg)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果 tryAcquire(arg) 返回 true,则不会执行 acquireQueued，表示成功获取锁，如果 tryAcquire(arg) 返回 false, 说明没有成功获取锁，则加入请求队列中。接着请看 addWaiter (Node.EXCLUSIVE) 方法。</p><p>addWaiter 中涉及的逻辑，就是 CLH 思想的实现，故在 AbstractQueuedSynchronizer 中,源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     * 创建并入队一节点，为当前线程和给定的模式, Node.EXCLUSIVE 独占模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//@1 start</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//@1 end</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码@1,处说，如果当前该锁的尾部节点不为空时，只需要原子性的将新增节点放入原先的尾部，然后更新锁的 tail 属性即可。如果尾部节点不为空，说明有线程已经在该锁上等待，那如果尾部为空，是什么情况呢？尾部为空，表示没有线程持有锁，为什么该获取锁没有成功呢？我们不妨设想一下，该线程在没有执行到 addWaiter 时，尾部不为空，无法获取锁，当执行到 addWaiter 时，别的线程释放了锁，导致尾部为空，可以重新获取锁了；（其实这个就是并发编程的魅力，与 synchronized 关键字不同的机制）；为了解答上述疑问，我们进入到 enq(node) 方法中一探究竟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize                     @1</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用自旋来加入,众所周知，CLH算法，需要初始化一个假的 head 节点，也就是 head 节点并不代表一个等待获取锁的对象，AbstractQueuedSynchronzier 选择初始化 head,tail 的时机为第一次产生锁争用的时候。@1处为初始化head,tail,设置成功后，初始化后，再将新添加的节点放入到队列的尾部，然后该方法会返回原先的尾节点。addWaiter方法执行后，继续回到acquire(args)方法处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来，查看 acquireQueued 方法,addWaiter 方法返回的是代表当前线程的 Node 节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">//  @1</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  parkAndCheckInterrupt()  )   <span class="comment">//@3</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先@1,获取该节点的 node 的上一个节点。</p><p>@2如果node的前节点是head,因为head初始化时，都是假节点，不代表有线程拥有锁，所以，再次尝试获取锁，如果获取锁，则将锁的 head 设置为当前获取锁的线程的 Node，然后返回 false。返回 false, 则代表 if (!tryAcquire(arg) &amp;&amp;  acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 的结果为 false,直接返回，并不需要设置中断标记。如果当前节点不是head的话，则说明该锁被别的线程占用了，那就需要等待其他线程释放该锁，具体，我们看一下shouldParkAfterFailedAcquire，为了更好的理解 shouldParkAfterFailedAcquire, 我们先看一下parkAndCheckInterrupt 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     * 阻塞该线程，然等待唤醒后，会返回 当前线程的中断位；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       该方法，如果返回true,则代表该线程将被阻塞。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">//  @1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)    <span class="comment">// @2</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// @4 start</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);   <span class="comment">//@4 end</span></span><br><span class="line"></span><br><span class="line">            pred.next = node; <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               只有前置节点的状态为 0 或 PROPAGATE,,才能进入到该代码块，表明我们需要一个信号，但暂不挂起线程，调用者需要重                  试一次，确保它不能获取到锁，从而阻塞该线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@1 首先获取前置节点的 waitStatus。</p><p>@2 如果前置节点的waitStatus = Node.SIGNAL,那么当前节点，直接阻塞，说明状态是一个信号，如果前置节点状态为       Node.SIGNAL,那么后续节点应该阻塞的信号量，为什么这么说，情况代码@6,一个节点，新增的时候，为 0 正常。</p><p> @3,ws &gt; 0 ，则代表前置节点已取消。</p><p>@4 处的代码，就是当前 Node 的第一个不为取消状态的前置节点，重构 CLH 队列后，返回 false, 再次进入到 acquireQueued  的无限循环中，又继续 acquireQueued 的流程，继续尝试获取锁，获取锁，或者阻塞。</p><p>@6，如果前置节点为0或 PROPAGATE(可传播)，如果前置节点为0，还没有其他节点通过(prev)来判断该 prev 的后继节点是否需要阻塞过，所以，通过 CAS 设置前置节点为 Node.SIGNAL, 重试获取锁过程，避免不必要的线程阻塞。</p><p>至此，获取锁的过程就结束了，为了直观体现上述获取锁的过程，现给出如下流程图：</p><p><img src="https://img-blog.csdn.net/20161108175842999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="2、ReentrantLock-unlock"><a href="#2、ReentrantLock-unlock" class="headerlink" title="2、ReentrantLock unlock"></a>2、ReentrantLock unlock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码直接进入到AbstractQueuedSynchronzier 的 relase方法。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;  @<span class="number">1</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接看代码 tryRelease(arg)方法：tryRelease 方法，是由具体的子类实现的，故将目光转移到 NonFairSync 类的 tryRelease() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;   <span class="comment">//  @1</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">//@2</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// @3</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);   <span class="comment">//@4</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码@1，首先，计算持有锁的次数=当前被持有锁的次数-减去释放的锁的数量；</p><p>代码@2，判断当前锁的持有线程释放与释放锁的线程是否相同，否则，直接抛出运行时异常</p><p>代码@3，如果释放锁后，占有次数为0，则代表该锁被释放，设置锁的占有线程为null,</p><p>代码@4，设置锁的state,如果返回true,表示锁被释放，如果返回false,表示，锁继续被该线程占有（重入了多次，就需要释放多次）。再次回到release方法，如果tryRelease方法返回true,表示可以释放锁，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;  @<span class="number">1</span></span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)   <span class="comment">// @2</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@2为什么需要判断 h!=null &amp;&amp; h.waitStatus != 0的判断呢？，在讲解获取锁的时候，方法 shouldParkAfterFailedAcquire 中对于代码@6处的讲解，其实不难发现，一个节点在请求锁时，只有当它的前驱节点的waitStatus=Node.SIGNAL时，才会阻塞。如果 head为空，则说明 CLH 队列为空，压根就不会有线程阻塞，故无需执行 unparkSuccessor(h), 同样的道理，如果根节点的waitStatus=0，则说明压根就没有 head 后继节点判断是否要绑定的逻辑，故也没有线程被阻塞这一说。原来一个更重要的原因：改进后的CLH，head如果不为空，该节点代表获取锁的那个线程对于的Node,请看获取锁代码acquireQueued中的代码@2处，如果获得锁，setHead(node);知道这一点，就不难理解为什么在释放锁时调用unparkSuccessor(h)时，参数为head了。</p><p>现在将目光转移到 AbstractQueuedSynchronizer. unparkSuccessor(h)方法中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;  </span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)     <span class="comment">// @1</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  <span class="comment">//@2 start</span></span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125; <span class="comment">// @2 end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// @3</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码@1，目前waitStatus &gt; 0表示取消，等于0表示正常（新建），该步骤主要是   为了保护，避免重复释放。</p><p>代码@2 start-end,此处，主要是从占有锁的节点，往后找，找到第一个没有被取   消的节点，然后唤醒它所代表的线程。这里为什么要从尾部寻址呢？</p><p>代码@3，唤醒线程，释放锁的逻辑代码已经结束，那调用LockSupport.unpark(s.thread)后，会进入到哪呢？此时，请再次进入获取锁代码的 acquireQueue方法和shouldParkAfterFailedAcquire方法，先解读如下：</p><p>当LockSupport.unpark(s.thread)事，那acquireQueued的代码@3处parkAndCheckInterrupt方法会解除阻塞，继续放下执行，进入到 acquireQueued的for循环处：此时会有两种情况</p><ul><li>HEAD –&gt; Node  … &gt; 其中Node 为  LockSupport.unpark 中的 s;</li><li>HEAD –&gt; A Cancel Node –&gt;  Node(s)</li></ul><p>如果为第一种情况，直接进入 @2去尝试获取锁。</p><p>如果为第二种情况，shouldParkAfterFailedAcquire(prev,node) 中的 prev 为一个取消的节点，然后会重构整个 CLH 链表，删除Node 到 head 节点直接的取消节点，使得被唤醒线程的节点的上一个节点为 head,从而满足@2处的条件，进入获取锁方法。至此， lock 方法与 unlock 方法流通畅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">//  @1</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  parkAndCheckInterrupt()  )   <span class="comment">//@3</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">与shouldParkAfterFailedAcquire方法：</span><br><span class="line">  */</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">//  @1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)    <span class="comment">// @2</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// @4 start</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);   <span class="comment">//@4 end</span></span><br><span class="line"></span><br><span class="line">            pred.next = node; <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               只有前置节点的状态为 0 或 PROPAGATE,,才能进入到该代码块，表明我们需要一个信号，但暂不挂起线程，调用者需要重                  试一次，确保它不能获取到锁，从而阻塞该线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了方便大家理解，给出一个简要的释放锁的流程图：</p><p><img src="https://img-blog.csdn.net/20161108180244374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="3、ReentrantLock-lockInterruptibly-源码分析"><a href="#3、ReentrantLock-lockInterruptibly-源码分析" class="headerlink" title="3、ReentrantLock lockInterruptibly 源码分析"></a>3、ReentrantLock lockInterruptibly 源码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>首先先提一个问题： void lock()，通过该方法去获取锁，如果锁被占用，线程阻塞，如果调用被阻塞线程的          interupt()方法，会取消获取锁吗？答案是否定的。</p><p>首先需要知道 LockSupport.park 会响应中断，但不会抛出 InterruptedException。</p><p>接下来，我们就从lockInterruptibly()方法入手，一步一步解析，并分析与lock方法的差异。</p><p>首先进入的是AbstractQueuedSynchronizer的acquireInterruptibly方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, aborting if interrupted.</span></span><br><span class="line"><span class="comment">     * Implemented by first checking interrupt status, then invoking</span></span><br><span class="line"><span class="comment">     * at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;, returning on</span></span><br><span class="line"><span class="comment">     * success.  Otherwise the thread is queued, possibly repeatedly</span></span><br><span class="line"><span class="comment">     * blocking and unblocking, invoking &#123;<span class="doctag">@link</span> #tryAcquire&#125;</span></span><br><span class="line"><span class="comment">     * until success or the thread is interrupted.  This method can be</span></span><br><span class="line"><span class="comment">     * used to implement method &#123;<span class="doctag">@link</span> Lock#lockInterruptibly&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);   <span class="comment">// @1</span></span><br><span class="line">    &#125;</span><br><span class="line">    如果尝试获取锁失败后，进入获取锁并等待锁逻辑，doAcquireInterruptibly</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;              <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">//@3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node); <span class="comment">//@4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个获取锁的逻辑与 lock 方法一样，唯一的区别在于  @3 处，如果 parkAndCheckInterrupt 如果是通过 t.interupt 方法，使LockSupport.park 取消阻塞的话，会抛出 InterruptedException，停止尝试获取锁，然后将添加的节点取消，那重点关注一下cancelAcquire(node); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">        Node pred = node.prev;   </span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  <span class="comment">// @1</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">        <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">        <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">        Node predNext = pred.next; <span class="comment">//@2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">        <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">        <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;   <span class="comment">// @3 </span></span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @4</span></span><br><span class="line">            <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">            <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;   <span class="comment">// @5</span></span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @6</span></span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：此处的目的就是, 设置prev的值为从当前取消节点往head节点方向，第一个未取消节点。并将中间的取消节点脱离这条链。</p><p>代码@2 Node predNext = pred.next;</p><p>代码@3 如果被取消的节点是尾节点的话，那么将pred设置为尾节点，compareAndSetTail(node, pred)，如果设置失败，说明，有别的线程在申请锁，使得尾部节点发生了变化，那这样的话，我当前节点取消的工作，就到此可以结束了；如果设置成功了，既然pred是尾节点，那么再次将pred的next域设置为null;当然也能设置失败，表明又有新的线程在申请说，创建了节点。所以取消操作，也到此结束。</p><p>代码@4，如果取消的节点，不是尾部节点的话，这时，需要维护CLH链，请看代码@5</p><p>代码@5,首先pred不是head节点，接下来判断是否需要设置pred.next = 当前待取消节点的next。如果pred.waitStatus == Node.SIGNAL, 或者试图将 pred.waitStatus = Node.SIGNAL 状态成功，并且pred.thread 的线程不为空；此时进一步判断待取消的节点的 next 不为空，并且状态为非取消的时，将 pred.next 设置为 node.next；该取消节点被删除。</p><p>代码@6，如果pred为head,执行一次唤醒操作。</p><p>处于Node.CANCEL状态节点的删除发生在shouldParkAfterFailedAcquire，一处就发生在cancelAcquire方法。</p><p>本文就介绍到这里了，文章开头部分的问题能解答了没，可以加笔者微信号 ：dingwpmz，共同探讨交流。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细介绍 ReentrantLock 的实现原理。&lt;/p&gt;
&lt;p&gt;在进入源码分析之前，我先提出如下观点：希望大家纠正与讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个节点的状态设置为Node.SIGNAL,则说明它有后继节点，并处于阻塞状态。&lt;/li&gt;
&lt;li&gt;ReentantLock的head节点，如果不为空，在该节点代表的线程为锁的占有者。这是对CLH算法的改进之处。众所周知，CLH算法的head节点为假节点，不代表任何线程。&lt;/li&gt;
&lt;li&gt;ReentantLock几个编码技巧值得借鉴：&lt;ul&gt;
&lt;li&gt;利用内部类实现功能扩展，使得java.util.concurrent.locks包类数量少，十分清晰。&lt;/li&gt;
&lt;li&gt;利用了模板模式，AbstractQueuedSynchronizer就是锁机制的模板（CLH算法的一个变种）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文重点关注如下几个方法的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock()  &lt;/li&gt;
&lt;li&gt;unlock()&lt;/li&gt;
&lt;li&gt;lockInterruptibly()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入源码分析之前，希望读者带着如下问题边看边想：&lt;/p&gt;
&lt;p&gt;问题1：一个线程用lock方法申请锁而被阻塞后，调用线程的interput方法，会发生什么情况，能中断锁的获取吗？&lt;/p&gt;
&lt;p&gt;问题2：什么是CLH算法，RenntrantLock针对CLH算法做了哪些变化。&lt;/p&gt;
&lt;p&gt;问题3：Node.CANCEL状态的节点在什么时候会删除。&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
    <category term="ReentrantLock" scheme="http://example.com/tags/ReentrantLock/"/>
    
    <category term="可重入" scheme="http://example.com/tags/%E5%8F%AF%E9%87%8D%E5%85%A5/"/>
    
    <category term="锁" scheme="http://example.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>AtomicIntegerArray源码分析与感悟.</title>
    <link href="http://example.com/posts/e3c7511d.html"/>
    <id>http://example.com/posts/e3c7511d.html</id>
    <published>2020-12-13T11:53:01.000Z</published>
    <updated>2020-12-13T13:50:25.619Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><a id="more"></a>![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)<p>AtomicIntegerArray，提供了一个原子访问数据中元素方法的一种途径。</p><p>对于这类原子操作，在理解上应该没什么问题，通过AtomitoIntegerArray，我学到如下几个关键点：</p><ul><li>int  sacle = unsafe.arrayIndexScale（int[].class）与  int base = unsafe.arrayBaseOffset(Int[].class);<br>其中 unsafe.arrayBaseOffset 获取该类型的数组，在对象存储时，存放第一个元素的内存地址，相对于数组对象起始地址的内存偏移量。unsafe.arrayIndexSacle(int[].class) 获取该类型的数组中元素的大小，占用多少个字节。</li><li>根据scale ，base 如何准备定位到任意一个下标的地址呢？请查看如下关键代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用于定位元素偏移量的控制值。</p><p>举例说明，int scale = 4;1个int类型，在java中占用4个字节。</p><p>Integer.numberOfLeadingZeros(scale); 返回 scale 高位连续0的个数，得出shift = 2, 而shift在如下方法使用</p><p>得出结论了吧，shift就是 用来定位数组中的内存位置，用来移位用的，每向左移动移位，在不越界的情况下，想当于乘以2。也就是int类型的长度为4，也就是第0个位置是0，第1(i)个位置是4,，第二个(i)位置是8，也就是偏移位置等于  i * 4,也就是  i &lt;&lt; 2;总结出一个乘法转换成移位操作的案例： a * (一个2的幂(n)的数)  =  a &lt;&lt; n; 给出一个指定2的幂的数，怎么算成n,,参照shift的计算方法。 </p><p>附上AtomicIntegerArray 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@code</span> int&#125; array in which elements may be updated atomically.</span></span><br><span class="line"><span class="comment"> * See the &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package</span></span><br><span class="line"><span class="comment"> * specification for description of the properties of atomic</span></span><br><span class="line"><span class="comment"> * variables.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArray</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2862133569453604235L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray of the given length, with all</span></span><br><span class="line"><span class="comment">     * elements initially zero.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray with the same length as, and</span></span><br><span class="line"><span class="comment">     * all elements copied from, the given array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array the array to copy elements from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if array is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">        <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the length of the array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value at position &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, newValue))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * and does not provide ordering guarantees, so is only rarely an</span></span><br><span class="line"><span class="comment">     * appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSet(i, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, current + delta))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">int</span> next = current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current values of array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current values of array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iMax = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            b.append(getRaw(byteOffset(i)));</span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            b.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;vip-container&quot;&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

&lt;p</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁机制-ReentrantLock Condtion准备篇</title>
    <link href="http://example.com/posts/aa807b75.html"/>
    <id>http://example.com/posts/aa807b75.html</id>
    <published>2020-12-13T11:53:01.000Z</published>
    <updated>2020-12-13T13:50:25.625Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>根据网上的说法，jdk并发包中的 Condition await 与 signal 实现了 Object.wait notify 语义。以下总结，是基于Condition await,singal方法的实现原理总结出来的：</p><ul><li>monitorObject.wait，该方法调用必须在临界区中（锁保护的代码段）被调用，线程如果在临界区中调用监视器的wait方法，然后线程会释放占有监视器monitorObject的锁，然后阻塞（等待条件的发生，该线程会保存在monitorObject的条件等待队列，当该线程收到信号或中断被唤醒后，首先需要尝试获取监视器的锁，然后继续执行操作，如果是被中断，需要在获取锁后，才会被中断。）</li><li>monitorObject.notify,该方法调用同样只能在临界区中被调用，锁的释放，在执行完临界区后，才会释放。根据Condition.singal实现机制，首先唤醒，是先将线程从条件等待队列放入到同步阻塞队列，然后执行完临界区代码后，释放锁，其他线程竞争锁。</li></ul><p>为了对Condition await 与 signal 方法有一个直接的了解，现给出一个简单的生产者、消费者测试示例：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.study.concurent.bread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BreadContainerByObject container = <span class="keyword">new</span> BreadContainerByObject();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Producers(container)).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(container)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BreadContainer</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Reentrant Condition实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadContainerByCondition</span> <span class="keyword">implements</span> <span class="title">BreadContainer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition NotFull = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition NotEmpty = lock.newCondition();</span><br><span class="line"><span class="comment">// 面包容器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Bread&gt; breads = <span class="keyword">new</span> ArrayList&lt;Bread&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span>(breads.size() &gt;= MAX ) &#123; <span class="comment">//已经满了</span></span><br><span class="line">NotFull.await();</span><br><span class="line">&#125;</span><br><span class="line">b.setId(num ++);</span><br><span class="line">breads.add(b);</span><br><span class="line"><span class="comment">//放入一个元素后，NotEmpty</span></span><br><span class="line">NotEmpty.signalAll();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span>(breads.isEmpty()) &#123;<span class="comment">//如果为空</span></span><br><span class="line">NotEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line">Bread b = breads.remove(breads.size() -<span class="number">1</span>);</span><br><span class="line">NotFull.signalAll();</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Object.notify Object.wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadContainerByObject</span> <span class="keyword">implements</span> <span class="title">BreadContainer</span></span>&#123;</span><br><span class="line"><span class="comment">// 面包容器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Bread&gt; breads = <span class="keyword">new</span> ArrayList&lt;Bread&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (breads) &#123;</span><br><span class="line"><span class="keyword">while</span>(breads.size() &gt;= MAX) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">breads.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();<span class="comment">//这里不应该 将 InterruptedExcepiton 吞掉</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b.setId(num ++);</span><br><span class="line">breads.add(b);</span><br><span class="line">breads.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Bread b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (breads) &#123;</span><br><span class="line"><span class="keyword">while</span>(breads.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">breads.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();<span class="comment">//这里不应该 将 InterruptedExcepiton 吞掉</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b = breads.remove(breads.size() -<span class="number">1</span>);</span><br><span class="line">breads.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producers</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BreadContainerByObject container;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producers</span><span class="params">(BreadContainerByObject container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.container = container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">b.setFactoryName(Thread.currentThread().getName());</span><br><span class="line">container.put(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BreadContainerByObject container;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BreadContainerByObject container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.container = container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;</span><br><span class="line">Bread b = container.poll();</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了&quot;</span> + b.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String factoryName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;面包:&quot;</span> + (id == <span class="keyword">null</span> ? <span class="number">0</span> : id.intValue()) + <span class="string">&quot;;生产工厂：&quot;</span> + getFactoryName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFactoryName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> factoryName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryName</span><span class="params">(String factoryName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.factoryName = factoryName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Reentrant Condition ,细化了消息通知的粒度，比如使用了当队列中产品时，通过 NotEmpty 条件来唤醒消费者，当队列还有可用的空间存放产品时，使用 NotFull 条件来唤醒生产者，使用两个条件队列，确保被唤醒的线程的准确性，加入到同步队列的节点，在该节点获取到锁后，确实是满足条件的（特别在临界情况的时候)。而Object.wait, Object.notify ,  生产者，消费者在同一个条件队列中排队。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据网上的说法，jdk并发包中的 Condition await 与 signal 实现了 Object.wait notify 语义。以下总结，是基于Condition await,singal方法的实现原理总结出来的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;monitorObject.wait，该方法调用必须在临界区中（锁保护的代码段）被调用，线程如果在临界区中调用监视器的wait方法，然后线程会释放占有监视器monitorObject的锁，然后阻塞（等待条件的发生，该线程会保存在monitorObject的条件等待队列，当该线程收到信号或中断被唤醒后，首先需要尝试获取监视器的锁，然后继续执行操作，如果是被中断，需要在获取锁后，才会被中断。）&lt;/li&gt;
&lt;li&gt;monitorObject.notify,该方法调用同样只能在临界区中被调用，锁的释放，在执行完临界区后，才会释放。根据Condition.singal实现机制，首先唤醒，是先将线程从条件等待队列放入到同步阻塞队列，然后执行完临界区代码后，释放锁，其他线程竞争锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了对Condition await 与 signal 方法有一个直接的了解，现给出一个简单的生产者、消费者测试示例：&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
    <category term="并发琐" scheme="http://example.com/tags/%E5%B9%B6%E5%8F%91%E7%90%90/"/>
    
    <category term="wait" scheme="http://example.com/tags/wait/"/>
    
    <category term="notify" scheme="http://example.com/tags/notify/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列之基础篇-Spring BeanDefinition初探</title>
    <link href="http://example.com/posts/4054ca58.html"/>
    <id>http://example.com/posts/4054ca58.html</id>
    <published>2020-12-13T11:40:01.000Z</published>
    <updated>2020-12-13T13:50:25.623Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>BeanDefinition，顾名思义，是一个对象(Bean)在Spring中描述，其核心类图：<br><img src="https://img-blog.csdn.net/20180528231257873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180528231316723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从类图我们详细了解BeanDefinition。<br>BeanDefinition接口继承自BeanMetadataElement和AttributeAccessor两个接口。<br>BeanMetadataElement：bean元数据，返回该bean的来源。<br>AttributeAccessor：Spring定义的属性访问器，对Bean的属性进行操作的API,例如设置属性、获取属性、判断是否存在该属性，返回bean所有的属性名称等。<br>下面重点分析一下BeanDefinition接口。</p><a id="more"></a><p>属性列表：<br>1）String SCOPE_SINGLETON，bean的作用范围，单例模式<br>2）String SCOPE_PROTOTYPE，bean的作用范围为prototype，在Spring生命周期中，会存在多个，由垃圾回收期管理其生命周期。<br>3）int ROLE_APPLICATION：bean的角色定义，默认，为应用程序定义。<br>4）int ROLE_SUPPORT：bean的角色定义，为应用程序定义的比较大的对象。<br>5）int ROLE_INFRASTRUCTURE：Spring内部定义的Bean对象。<br>核心方法详解：<br>1）void setBeanClassName(String beanClassName) ：该Bean的class name。<br>2）void setScope(String scope)：bean的生命周期，单例还是prototype。<br>3）void setLazyInit(boolean lazyInit)：lazyInit，是否延迟加载，如果设置为true,在需要用到时再初始化。<br>4）void setDependsOn(String… dependsOn)：dependsOn一般用于两个bean之间没有显示依赖，但后一个Bean需要用到前一个Bean执行初始方法后的结果。例如在&lt; bean id=”a” dependsOn=”b”/&gt; 时，在初始化a时首先先初始化b，在销毁b之前会先销毁a。<br>5）void setAutowireCandidate(boolean autowireCandidate)设置该对象是否可以被其他对象自动装配。<br>spring通过配置bean的autowire属性设置自动装配方式：<br>     no：不使用自动装配，必须通过ref元素指定依赖，为autowire默认值。<br>     byName：使用属性名自动装配，如果存在一个与指定属性名相同类型的bean则自动装配，如果有多个，则抛出异常。<br>     byType：根据类型自动状态，如果存在与指定属性类型相同的bean,则自动装配，如果有多个，则抛出异常。<br>     constructor：与byType类似，不同之处在于它使用的是构造器的参数类型。<br>     autodetect：通过bean的自省机制来决定是使用constructor还是byType来进行自动装配。如果有默认构造<br>                       器，则使用byType，否则使用constructor。<br>6）void setPrimary(boolean primary)，如果其他对象按照类型自动装配时发现有多个符合类型的多个实现bean，如果bean的primary属性为true，则以primary为true的优先，当然如果有多个primary为true，则抛出异常。<br>7）void setFactoryBeanName(String factoryBeanName)：设置bean的factoryBeanName。<br>8）void setFactoryMethodName(String factoryMethodName):设置bean工厂的方法名，Spring在实例化Bean对象时支持工厂方法设计模式，在初始化bean时不是通过bean的class发射创建 bean实例，而是根据factoryBeanName反射出工厂的实例，然后调用它的实例方法factoryMethodName来创建bean实例。<br>9）ConstructorArgumentValues getConstructorArgumentValues()：获取bean的构造方法参数。<br>10）MutablePropertyValues getPropertyValues()：获取实例bean的所有属性。<br>11）boolean isSingleton()：是否是单例。<br>12）boolean isPrototype()：是否是非单例。<br>13）boolean isAbstract()：是否是抽象的。</p><p>本文主要是根据BeanDefinition接口了解bean的一些特性,值得引起注意的是：lazy-init、depends-on、autowire-candidate、autowire、primary、factory-bean、factory-method。</p><blockquote><p>注：本文并没有尝试去罗列spring bean标签的全部属性。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;BeanDefinition，顾名思义，是一个对象(Bean)在Spring中描述，其核心类图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180528231257873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180528231316723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;从类图我们详细了解BeanDefinition。&lt;br&gt;BeanDefinition接口继承自BeanMetadataElement和AttributeAccessor两个接口。&lt;br&gt;BeanMetadataElement：bean元数据，返回该bean的来源。&lt;br&gt;AttributeAccessor：Spring定义的属性访问器，对Bean的属性进行操作的API,例如设置属性、获取属性、判断是否存在该属性，返回bean所有的属性名称等。&lt;br&gt;下面重点分析一下BeanDefinition接口。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
    <category term="BeanDefinition" scheme="http://example.com/tags/BeanDefinition/"/>
    
    <category term="内存溢出" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>生产环境JVM内存溢出案例分析</title>
    <link href="http://example.com/posts/81f19d85.html"/>
    <id>http://example.com/posts/81f19d85.html</id>
    <published>2020-12-13T11:40:01.000Z</published>
    <updated>2020-12-13T13:50:25.631Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>如果我们所在公司的业务量比较大，在生产环境经常会出现JVM内存溢出的现象，那我们该如何快速响应，快速定位，快速恢复问题呢？</p><p>本文将通过一个线上环境JVM内存溢出的案例向大家介绍一下处理思路与分析方法。</p><p>案例：架构组接到某项目组反馈，Zabbix监控上显示JMX不可用，请求协助处理。</p><p>分析思路：</p><ul><li><p>JMX不可用，往往是由于垃圾回收时间停顿时间过长、内存溢出等问题引起的。</p></li><li><p>线上故障分析的原则是首先要采取措施快速恢复故障对业务的影响，然后才是采集信息、分析定位问题，并最终给出解决办法。</p></li></ul><p>具体分析过程如下。</p><h2 id="1、如何快速恢复业务"><a href="#1、如何快速恢复业务" class="headerlink" title="1、如何快速恢复业务"></a>1、如何快速恢复业务</h2><p>通常线上的故障会对业务造成重大影响，影响用户体验，故如果线上服务器出现故障，应规避对业务造成影响，但不能简单的重启服务器，因为需要尽可能保留现场，为后续的问题分析打下基础。</p><p>那我们如何快速规避对业务的影响，并能保留现场呢？</p><p>通常的做法是隔离故障服务器。</p><p>通常线上服务器是集群部署，一个好的分布式负载方案会自动剔除故障的机器，从而实现高可用架构，但如果未被剔除，则需要运维人员将故障服务器进行剔除，保留现场进行分析。</p><p>发生内存泄露，通常情况下是由于代码的原因造成的，一般无法立即对代码进行修复，很容易会发送连锁反应造成应用服务器一台一台接连宕机，故障面积会慢慢扩大，针对此种情况，应快速定位发生内存泄露的原因，将该服务进行降级，避免对其他服务造成影响。最简单的降级方法是根据F5(Nginx)转发策略，对该功能定向到一个单独的集群，与其他流量进行隔离，确保其他业务不受牵连，给故障排查、解决提供宝贵的缓冲时间。</p><h3 id="1-1-分析解决问题"><a href="#1-1-分析解决问题" class="headerlink" title="1.1 分析解决问题"></a>1.1 分析解决问题</h3><p>首先可以通过查看日志，确定是哪种内存溢出，堆内存溢出可发生的地方：Java heap space(堆空间)、perm space(持久代)。<br><img src="https://img-blog.csdnimg.cn/20190407211939699.png" alt="在这里插入图片描述"></p><h4 id="1-1-1-收集内存溢出Dump文件"><a href="#1-1-1-收集内存溢出Dump文件" class="headerlink" title="1.1.1 收集内存溢出Dump文件"></a>1.1.1 收集内存溢出Dump文件</h4><p>收集Dump文件有两种方式：</p><ul><li>设置JVM启动参数<br>  -XX:+HeapDumpOnOutOfMemoryError<br>  -XX:HeapDumpPath=/opt/jvmdump</li></ul><p>在每次发生内存溢出时，JVM会自动将堆转储，dump文件存放在-XX:HeapDumpPath指定的路径下。</p><ul><li>使用jmap命令收集<br> 通过jmap -dump:live,format=b,file=/opt/jvm/dump.hprof pid。</li></ul><h4 id="1-1-2-分析Dump文件"><a href="#1-1-2-分析Dump文件" class="headerlink" title="1.1.2 分析Dump文件"></a>1.1.2 分析Dump文件</h4><p>在获取Dump文件后，可以使用工具MAT(MemoryAnalyzer)进行分析，该工具大家可以通过百度自行下载。</p><p>使用MAT打开Dump文件后，首页截图如下：<br><img src="https://img-blog.csdnimg.cn/2019040721211771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>工具按钮介绍：</p><a id="more"></a><p><img src="https://img-blog.csdnimg.cn/20190407212228666.png">：直方图视图，将堆中所有的内存消耗情况统计出来，其如图所示：<br><img src="https://img-blog.csdnimg.cn/20190407212451707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190407212424828.png" alt="在这里插入图片描述">：内存使用树状结构，以线程为维度，树状形式展开，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190407212509381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190407212438288.png" alt="在这里插入图片描述">线程栈，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20190407212535591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20190407212606556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据该图，可以明确，堆的总大小为1.9G，被4个线程全部占据，导致其他线程无法再申请资源，抛出堆内存溢出错误。</p><p>接下来，我通常的做法是直接去看【内存使用树状结构，见上文描述】(以线程为基本维度，查找线程中占用内存的对象)，为后续定位排查提供必要的依据。<br><img src="https://img-blog.csdnimg.cn/20190407212709798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190407212721605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面的截图中可以得出如下关键信息点：</p><ul><li><p>org.apache.ibatis.executor.result.DefaultResultHandler内部持有一个List，其原始为java.util.HashMap，从这个类基本可以看出是与数据库的查询相关，对数据库返回结果的解码并组织成HashMap。</p></li><li><p>这个List中的元素总共有146033个，初步可以判断出是在一次查询中从数据库中一次查询出了太多数据，造成了内存溢出。</p></li></ul><p>由于SQL查询代码中，是用HashMap来接收数据库中的返回字段，无法一时间看出是那个查询，那我们能不能精确找到是哪一个查询，哪一行代码，甚至与哪一条SQL语句呢？</p><p>答案是可以的，我们可以从视图一探究竟。</p><pre><code>温馨提示：视图使用技巧：展开技巧：沿着使用率最高的项一层一层进行展开，直至发现具体占用内存的对象。</code></pre><p>接下来我们从 视图去寻找是哪个方法，哪条SQL语句触发的。</p><p>具体方法：首先完全展开一个线程，从展开图的底部向上寻找：<br>其线程的入口(控制层代码)<br><img src="https://img-blog.csdnimg.cn/20190407212846134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>继续往上查找，要找到SQL语句，应该找到Mybatis处理结果集相关的类，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190407212857266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="加粗样式"><br>然后展开boundSql即能找到SQL语句：<br><img src="https://img-blog.csdnimg.cn/20190407212915357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后鼠标可以放在SQL属性中，右键，可以将SQL语句复制出来。<br><img src="https://img-blog.csdnimg.cn/20190407212928341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于这里涉及到公司的代码机密，故在这里不贴出具体的SQL语句。</p><p>这里根据后面的分析，原来是在做导出功能的时候，没有使用分页对数据进行分页查询，分页写入Excel文件，而是一次将全部数据查询，导致导出功能如果并发数超过4个时，就会将所有内存耗尽。</p><p>解决方案：</p><ul><li><p>首先在运维层面将该请求导入到指定的一台服务器上，是导出任务与其他任务进行隔离，避免对其他重要服务造成影响。</p></li><li><p>项目组对其代码进行修复，可以使用分页查数据，然后分配写入Excel。</p></li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果我们所在公司的业务量比较大，在生产环境经常会出现JVM内存溢出的现象，那我们该如何快速响应，快速定位，快速恢复问题呢？&lt;/p&gt;
&lt;p&gt;本文将通过一个线上环境JVM内存溢出的案例向大家介绍一下处理思路与分析方法。&lt;/p&gt;
&lt;p&gt;案例：架构组接到某项目组反馈，Zabbix监控上显示JMX不可用，请求协助处理。&lt;/p&gt;
&lt;p&gt;分析思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;JMX不可用，往往是由于垃圾回收时间停顿时间过长、内存溢出等问题引起的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线上故障分析的原则是首先要采取措施快速恢复故障对业务的影响，然后才是采集信息、分析定位问题，并最终给出解决办法。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体分析过程如下。&lt;/p&gt;
&lt;h2 id=&quot;1、如何快速恢复业务&quot;&gt;&lt;a href=&quot;#1、如何快速恢复业务&quot; class=&quot;headerlink&quot; title=&quot;1、如何快速恢复业务&quot;&gt;&lt;/a&gt;1、如何快速恢复业务&lt;/h2&gt;&lt;p&gt;通常线上的故障会对业务造成重大影响，影响用户体验，故如果线上服务器出现故障，应规避对业务造成影响，但不能简单的重启服务器，因为需要尽可能保留现场，为后续的问题分析打下基础。&lt;/p&gt;
&lt;p&gt;那我们如何快速规避对业务的影响，并能保留现场呢？&lt;/p&gt;
&lt;p&gt;通常的做法是隔离故障服务器。&lt;/p&gt;
&lt;p&gt;通常线上服务器是集群部署，一个好的分布式负载方案会自动剔除故障的机器，从而实现高可用架构，但如果未被剔除，则需要运维人员将故障服务器进行剔除，保留现场进行分析。&lt;/p&gt;
&lt;p&gt;发生内存泄露，通常情况下是由于代码的原因造成的，一般无法立即对代码进行修复，很容易会发送连锁反应造成应用服务器一台一台接连宕机，故障面积会慢慢扩大，针对此种情况，应快速定位发生内存泄露的原因，将该服务进行降级，避免对其他服务造成影响。最简单的降级方法是根据F5(Nginx)转发策略，对该功能定向到一个单独的集群，与其他流量进行隔离，确保其他业务不受牵连，给故障排查、解决提供宝贵的缓冲时间。&lt;/p&gt;
&lt;h3 id=&quot;1-1-分析解决问题&quot;&gt;&lt;a href=&quot;#1-1-分析解决问题&quot; class=&quot;headerlink&quot; title=&quot;1.1 分析解决问题&quot;&gt;&lt;/a&gt;1.1 分析解决问题&lt;/h3&gt;&lt;p&gt;首先可以通过查看日志，确定是哪种内存溢出，堆内存溢出可发生的地方：Java heap space(堆空间)、perm space(持久代)。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190407211939699.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-1-1-收集内存溢出Dump文件&quot;&gt;&lt;a href=&quot;#1-1-1-收集内存溢出Dump文件&quot; class=&quot;headerlink&quot; title=&quot;1.1.1 收集内存溢出Dump文件&quot;&gt;&lt;/a&gt;1.1.1 收集内存溢出Dump文件&lt;/h4&gt;&lt;p&gt;收集Dump文件有两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置JVM启动参数&lt;br&gt;  -XX:+HeapDumpOnOutOfMemoryError&lt;br&gt;  -XX:HeapDumpPath=/opt/jvmdump&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在每次发生内存溢出时，JVM会自动将堆转储，dump文件存放在-XX:HeapDumpPath指定的路径下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用jmap命令收集&lt;br&gt; 通过jmap -dump:live,format=b,file=/opt/jvm/dump.hprof pid。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;1-1-2-分析Dump文件&quot;&gt;&lt;a href=&quot;#1-1-2-分析Dump文件&quot; class=&quot;headerlink&quot; title=&quot;1.1.2 分析Dump文件&quot;&gt;&lt;/a&gt;1.1.2 分析Dump文件&lt;/h4&gt;&lt;p&gt;在获取Dump文件后，可以使用工具MAT(MemoryAnalyzer)进行分析，该工具大家可以通过百度自行下载。&lt;/p&gt;
&lt;p&gt;使用MAT打开Dump文件后，首页截图如下：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019040721211771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;工具按钮介绍：&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="实战" scheme="http://example.com/tags/%E5%AE%9E%E6%88%98/"/>
    
    <category term="内存溢出" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
    <category term="jvm" scheme="http://example.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>TreeMap之NavigableMap API 学习</title>
    <link href="http://example.com/posts/4757c2d8.html"/>
    <id>http://example.com/posts/4757c2d8.html</id>
    <published>2020-12-13T11:37:01.000Z</published>
    <updated>2020-12-13T13:50:25.623Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文主要学习TreeMap的核心API，下面是测试数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt; Long, Long&gt; treeMap &#x3D; new TreeMap&lt;&gt;();</span><br><span class="line">for(int i &#x3D; 2; i &lt;&#x3D; 20; i &#x3D; i + 2) &#123;</span><br><span class="line">   treeMap.put(new Long(i), new Long(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、K lowerKey(K key) | Map.Entry&lt; K,V&gt; lowerEntry(K key)   </p><p>1）英文注释<br>Returns a key-value mapping associated with the greatest keystrictly less than the given key, or {@code null} if there is no such key.<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626214930370?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>   输出结果：<br>   4<br>   4<br>   null<br>3）中文解释<br>  返回第一个小于该key的键或Entry，不包含指定key。指定key不存在不影响结果，例如测试用例中的不存在键为5的键值对，但还是能返回Key:4，如果没有扎到小于key的键，则返回null。</p><a id="more"></a><p>2、K floorKey(K key) | Map.Entry&lt; K,V&gt; floorEntry(K key)</p><p>1）英文注释<br>Returns a key-value mapping associated with the greatest key less than or equal to the given key, or {@code null} if there is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215016389?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   6<br>   4<br>   null<br>3）中文解释<br>   返回小于等于指定key的键值，与lowerKey的区别是floorKey方法，如果TreeMap中包含指定的key，则返回指定key，否则返回第一个小于指定key的键。</p><p>3、K ceilingKey(K key) | Map.Entry&lt; K,V&gt; ceilingEntry(K key)</p><p>1）英文注释<br>Returns a key-value mapping associated with the least key greater than or equal to the given key, or {@code null} if there is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215110522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   6<br>   6<br>   null<br>3）中文解释<br>   ceiling : 天花板，查找指定key的天花板，也就是说，查找第一个大于等于指定key的可以。</p><p>4、K higherKey(K key) | Map.Entry&lt; K,V&gt; higherEntry(K key)</p><p>1）英文注释<br>Returns a key-value mapping associated with the least key strictly greater than the given key, or {@code null} if there  is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215144375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   8<br>   6<br>   null<br>3）中文解释<br>   返回第一个大于指定key的键，不包含指定key。而ceilingKey包含指定key。</p><p>5、Map.Entry&lt; K,V&gt; firstEntry()、Map.Entry&lt; K,V&gt; lastEntry()、Map.Entry&lt; K,V&gt; pollFirstEntry()、Map.Entry&lt; K,V&gt; pollLastEntry()<br>这四个方法很好理解，这里不做详细讲解。</p><p>6、NavigableMap&lt; K,V&gt; descendingMap()、 NavigableSet&lt; K&gt; descendingKeySet()<br>这两个方法，返回逆序。</p><p>7、NavigableMap&lt; K,V&gt; subMap(K fromKey, boolean fromInclusive,  K toKey,   boolean toInclusive)<br>1）英文注释<br><img src="https://img-blog.csdn.net/20180626215248417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215316903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  输出结果：<br>{4=4, 6=6, 8=8}<br>返回子集合(TreeMap),从fromKey,到toKey，boolean fromInclusive表示是否包含fromKey,boolean toInclusive是否包含toKey。<br>TreeMap#subMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123;</span><br><span class="line">        return subMap(fromKey, true, toKey, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、NavigableMap&lt; K,V&gt; headMap(K toKey, boolean inclusive)<br>1）英文注释<br><img src="https://img-blog.csdn.net/20180626215421299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）中文说明<br>   测试结果省略（推理后，也验证过），根据上面的学习过程，可以推导出，该方法相当于 subMap(firstKey, true, toKey, inclusive)。<br>TreeMap#headMap(Key toKey)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; headMap(K toKey) &#123;</span><br><span class="line">        return headMap(toKey, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、NavigableMap&lt; K,V&gt; tailMap(K fromKey, boolean inclusive)<br>1）英文描述<br><img src="https://img-blog.csdn.net/20180626215518663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）中文解释<br>返回从fromKey到lastKey的子集合，相当于subMap(fromKey,inclusive,lastKey,true)。<br>TreeMap#tailMap(K fromKey) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123;</span><br><span class="line">        return tailMap(fromKey, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要学习TreeMap的核心API，下面是测试数据：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TreeMap&amp;lt; Long, Long&amp;gt; treeMap &amp;#x3D; new TreeMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int i &amp;#x3D; 2; i &amp;lt;&amp;#x3D; 20; i &amp;#x3D; i + 2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   treeMap.put(new Long(i), new Long(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1、K lowerKey(K key) | Map.Entry&amp;lt; K,V&amp;gt; lowerEntry(K key)   &lt;/p&gt;
&lt;p&gt;1）英文注释&lt;br&gt;Returns a key-value mapping associated with the greatest keystrictly less than the given key, or {@code null} if there is no such key.&lt;br&gt;2）测试结果&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180626214930370?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;   输出结果：&lt;br&gt;   4&lt;br&gt;   4&lt;br&gt;   null&lt;br&gt;3）中文解释&lt;br&gt;  返回第一个小于该key的键或Entry，不包含指定key。指定key不存在不影响结果，例如测试用例中的不存在键为5的键值对，但还是能返回Key:4，如果没有扎到小于key的键，则返回null。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="TreepMap" scheme="http://example.com/tags/TreepMap/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务治理之灰度发布方案（版本发布控制影响范围）</title>
    <link href="http://example.com/posts/6bc72b05.html"/>
    <id>http://example.com/posts/6bc72b05.html</id>
    <published>2020-12-13T11:30:01.000Z</published>
    <updated>2020-12-13T13:50:25.621Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、方案背景"><a href="#1、方案背景" class="headerlink" title="1、方案背景"></a>1、方案背景</h2><p>背景：基于Dubbo服务的治理，是否可以支持业务级别的灰度发布、是否基于业务参数的路由转发。例如以GIS为例，当发布一个新版本时，是否可以以按照解析地址或合作伙伴来区分，版本发布之初，只希望地址为：广东省的解析请求发送到新版本，而其他的地址请求还是使用旧版；或者根据合作伙伴例如UCP(优享寄)的请求转发到新版本服务器，其他合作伙伴还是转发到旧版，达成业务级别的灰度发布，控制新版本的影响范围。例如OMS系统，可以根据合作伙伴，将重量级客户的请求转发到单独的服务器集群，确保其高可用。<br>本文将对上述议题结合Dubbo提供的功能，提出设计方案。</p><h2 id="2、方案理论基础"><a href="#2、方案理论基础" class="headerlink" title="2、方案理论基础"></a>2、方案理论基础</h2><p>Dubbo的服务调用原理图：<br><img src="https://img-blog.csdn.net/20181015123333422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>客户端在发起RPC服务调用之前，在客户端首先从服务器列表中选择一个服务调用者，包含如下关键角色：</p><a id="more"></a><p>1、Directory<br>服务的动态发现，通常基于注册中心进行服务的动态注册与发现，其具体实现类为RegistryDirectory。<br>2、Router<br>路由实现，其含义是根据Directory发现的所有服务提供者列表中，进行路由选择，也就是根据一定的路由规则选择合适的服务提供者，为Directory发现的服务提供者列表子集，可以基于Condition或脚本（默认为JS脚本，其实现类为ScriptRouter）。<br>3、LoadBalance<br>负载均衡机制，其作用主要是根据负载均衡算法（随机、轮询）<br>等算法，从（Directory–&gt;Router）中返回的服务提供者列表中选择一个服务提供者，进行本次的RPC服务调用。<br>4、Cluster<br>集群（容错机制），就是当从服务提供者列表中按照负载均衡算法选择一个服务提供者，进行RPC服务调用后，发送了异常后的策略，例如failover(重试)、failfast(快速失败)等。<br>服务的灰度发布，其目标是希望根据请求，某些请求走新版本服务器，某些请求走旧版本服务器，其本质就是路由机制，即通过一定的条件来缩小服务的服务提供者列表，正好与Dubbo的Router相吻合。<br>有关于Dubbo的Router机制，请参考官方文档第【46、47、48】页，如果想从源码的角度了解其实现机制，请参考博文：<a href="https://blog.csdn.net/prestigeding/article/details/80848594">https://blog.csdn.net/prestigeding/article/details/80848594</a><br>有了理论支持，下文将根据上述理论进行实战。</p><h2 id="3、方案具体实现示例"><a href="#3、方案具体实现示例" class="headerlink" title="3、方案具体实现示例"></a>3、方案具体实现示例</h2><p>本示例代码需要完成的任务是，对DemoService#createUser服务，其用户机构ID(orgId)为1的走新版本（当前服务提取者列表的最后一台服务器），其他的请求走所有的服务器（除最后一台服务器）。<br> <img src="https://img-blog.csdn.net/20181015123609793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20181015123700316?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>由于是需要基于请求参数，本文给出基于JS脚本的路由机制，首先，当前版本的dubbo-admin可以后台页面维护基于条件表达式的路由规则，其界面如下：<br> <img src="https://img-blog.csdn.net/20181015123744903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdn.net/20181015123836904?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>备注：并且当前dubbo-admin版本，并不支持基于JS表达式的路由规则，如果手动建立基于表达式的路由规则，其页面将无法列出路由表达式，其界面如下：<br><img src="https://img-blog.csdn.net/20181015123902592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="3-1-JS脚本"><a href="#3-1-JS脚本" class="headerlink" title="3.1 JS脚本"></a>3.1 JS脚本</h3><p>各个项目，各个服务需要根据自身的需求，定义如下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * DemoService router，针对不同的方法，可能需要各自提供，主要是参数的获取，不同的过滤规则</span><br><span class="line"> * 针对参数进行路由过滤</span><br><span class="line"> * </span><br><span class="line"> * 本示例针对 DemoSerivce# ResponseResult createUser(User user) 方法，根据user的orgId进行路由选择</span><br><span class="line"> * @param invokers</span><br><span class="line"> * @param invocation</span><br><span class="line"> * @param context</span><br><span class="line"> * @returns</span><br><span class="line"> *&#x2F;</span><br><span class="line">function demoService_createUser_router(invokers, invocation, context) &#123;</span><br><span class="line">if(invokers &#x3D;&#x3D; null || invokers.size() &lt; 1) &#123;</span><br><span class="line">return invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!&quot;createUser&quot;.equals(invocation.getMethodName())) &#123; &#x2F;&#x2F; 如果方法不匹配，默认无条件通过该路由规则</span><br><span class="line">return invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var availableInvokers &#x3D; new java.util.ArrayList(invokers.size());</span><br><span class="line">for (var i&#x3D;0;i&lt;invokers.size(); i++) &#123;    &#x2F;&#x2F; 先选择可用的服务提供者列表</span><br><span class="line">if(invokers.get(i).isAvailable()) &#123;</span><br><span class="line">availableInvokers.add(invokers.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var invArguments &#x3D; invocation.getArguments();</span><br><span class="line">if(invArguments &#x3D;&#x3D; null || invArguments.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 如果参数为空，无法根据参数进行路由选择</span><br><span class="line">return availableInvokers; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取需要进行路由的参数，这里使用第一个参数 ，这里各自根据各自的业务 进行获取，本实例默认使用第一个参数</span><br><span class="line">var firstArgument &#x3D; invArguments[0];</span><br><span class="line">var orgId &#x3D; firstArgument &#x3D;&#x3D; null ? &quot;&quot; : firstArgument.getOrgId();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(orgId &#x3D;&#x3D; 1 || orgId &#x3D;&#x3D; &quot;1&quot;) &#123; &#x2F;&#x2F; 如果orgId &#x3D;&#x3D; 1 ，只走最后一个节点，其余的走其他节点</span><br><span class="line">var selectInvokers &#x3D; new java.util.ArrayList(1);</span><br><span class="line">selectInvokers.add(availableInvokers.get(availableInvokers.size()-1));</span><br><span class="line">return selectInvokers;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">var selectInvokers &#x3D; new java.util.ArrayList(availableInvokers.size()-1);</span><br><span class="line">for(var i&#x3D;0;i&lt;availableInvokers.size()-1; i++) &#123;</span><br><span class="line">selectInvokers.add(availableInvokers.get(i));</span><br><span class="line">&#125;</span><br><span class="line">return selectInvokers;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-向注册中心注册JS脚本路由规则"><a href="#3-2-向注册中心注册JS脚本路由规则" class="headerlink" title="3.2 向注册中心注册JS脚本路由规则"></a>3.2 向注册中心注册JS脚本路由规则</h3><p>上文已经说明，目前的dubbo-admin不支持在界面上注册路由规则，现给出基于JAVA代码来编写注册程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">URL registryUrl &#x3D; URL.valueOf(&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;);</span><br><span class="line">    ZookeeperRegistryFactory zookeeperRegistryFactory &#x3D; new </span><br><span class="line">                       ZookeeperRegistryFactory();</span><br><span class="line">   zookeeperRegistryFactory.setZookeeperTransporter(new </span><br><span class="line">        CuratorZookeeperTransporter());</span><br><span class="line">   Registry zookeeperRegistry &#x3D; (ZookeeperRegistry) </span><br><span class="line">             zookeeperRegistryFactory.createRegistry(registryUrl);</span><br><span class="line">   URL routerURL &#x3D; </span><br><span class="line">          URL.valueOf(&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.alibaba.dubbo.demo.Demo</span><br><span class="line">                Service?category&#x3D;routers&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;fo</span><br><span class="line">                rce&#x3D;false&amp;name&#x3D;demoService_createUser_router&amp;priority&#x3D;</span><br><span class="line">          0&amp;runtime&#x3D;true&quot;);</span><br><span class="line">   routerURL &#x3D; routerURL.addParameter(&quot;rule&quot;, </span><br><span class="line">   URL.encode(get_demoService_createUser_router()));</span><br><span class="line">   zookeeperRegistry.register(routerURL);     &#x2F;&#x2F; 注册</span><br><span class="line">   &#x2F;&#x2F; zookeeperRegistry.unregister(routerURL); &#x2F;&#x2F; 取消注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦运行上述代码，将会动态注册URL，服务提供者无需重启，下次服务调用后会自动生效（其背后原理是基于注册中心的动态发现）。<br>上述示例代码，我已经在本地环境，已能成功运行，并达到预期效果，公司项目需要根据自身的特点，特别服务方法的参数（例如合作伙伴ID的获取方式），以及路由需求来定制编写其路由脚本（js脚本）。</p><h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><p>上述展示了Dubbo服务基于业务灰度发布的方案，以及基于合作伙伴的服务隔离机制（根据服务调用业务参数来决定服务调用者的筛选）。主要是展示了基于脚步的路由规则，其条件表达式的路由规则请参考其Demo，其核心理论支持是Dubbo提供的Router，在进行负载均衡前，根据路由规则对服务提供者列表进行筛选。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、方案背景&quot;&gt;&lt;a href=&quot;#1、方案背景&quot; class=&quot;headerlink&quot; title=&quot;1、方案背景&quot;&gt;&lt;/a&gt;1、方案背景&lt;/h2&gt;&lt;p&gt;背景：基于Dubbo服务的治理，是否可以支持业务级别的灰度发布、是否基于业务参数的路由转发。例如以GIS为例，当发布一个新版本时，是否可以以按照解析地址或合作伙伴来区分，版本发布之初，只希望地址为：广东省的解析请求发送到新版本，而其他的地址请求还是使用旧版；或者根据合作伙伴例如UCP(优享寄)的请求转发到新版本服务器，其他合作伙伴还是转发到旧版，达成业务级别的灰度发布，控制新版本的影响范围。例如OMS系统，可以根据合作伙伴，将重量级客户的请求转发到单独的服务器集群，确保其高可用。&lt;br&gt;本文将对上述议题结合Dubbo提供的功能，提出设计方案。&lt;/p&gt;
&lt;h2 id=&quot;2、方案理论基础&quot;&gt;&lt;a href=&quot;#2、方案理论基础&quot; class=&quot;headerlink&quot; title=&quot;2、方案理论基础&quot;&gt;&lt;/a&gt;2、方案理论基础&lt;/h2&gt;&lt;p&gt;Dubbo的服务调用原理图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181015123333422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;客户端在发起RPC服务调用之前，在客户端首先从服务器列表中选择一个服务调用者，包含如下关键角色：&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="灰度发布" scheme="http://example.com/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    
    <category term="router" scheme="http://example.com/tags/router/"/>
    
    <category term="路由" scheme="http://example.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo 泛化调用与泛化实现原理</title>
    <link href="http://example.com/posts/5f7d793b.html"/>
    <id>http://example.com/posts/5f7d793b.html</id>
    <published>2020-12-13T11:30:01.000Z</published>
    <updated>2020-12-13T13:50:25.637Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><ul><li>本文将重点分析Dubbo的两个重要特性：泛化调用与泛化实现。<br> 1、泛化引用：<br> <img src="https://img-blog.csdn.net/20181005211034328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> 通常是服务调用方没有引入API包，也就不包含接口中的实体类，故服务调用方只能提供Map形式的数据，由服务提供者根据Map转化成对应的实体。<br> 2、泛化实现<br> <img src="https://img-blog.csdn.net/20181005211118267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> 泛化实现，是指服务提供者未引入API包，也就不包含接口用于传输数据的实体类，故客户端发起调用前，需要将mode转化为Map。<br> 从上面分析，其实所谓的泛化本质上就是Map与Bean的转换。</li></ul><a id="more"></a><h2 id="3、源码分析客户端用于泛化调用的过滤器GenericImplFilter"><a href="#3、源码分析客户端用于泛化调用的过滤器GenericImplFilter" class="headerlink" title="3、源码分析客户端用于泛化调用的过滤器GenericImplFilter"></a>3、源码分析客户端用于泛化调用的过滤器GenericImplFilter</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        String generic &#x3D; invoker.getUrl().getParameter(Constants.GENERIC_KEY);</span><br><span class="line">        if (ProtocolUtils.isGeneric(generic)                                                                                  &#x2F;&#x2F; @1</span><br><span class="line">                &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName())</span><br><span class="line">                &amp;&amp; invocation instanceof RpcInvocation) &#123;</span><br><span class="line">            RpcInvocation invocation2 &#x3D; (RpcInvocation) invocation;</span><br><span class="line">            String methodName &#x3D; invocation2.getMethodName();</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes &#x3D; invocation2.getParameterTypes();</span><br><span class="line">            Object[] arguments &#x3D; invocation2.getArguments();</span><br><span class="line"></span><br><span class="line">            String[] types &#x3D; new String[parameterTypes.length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                types[i] &#x3D; ReflectUtils.getName(parameterTypes[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object[] args;</span><br><span class="line">            if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                args &#x3D; new Object[arguments.length];</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    args[i] &#x3D; JavaBeanSerializeUtil.serialize(arguments[i], JavaBeanAccessor.METHOD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                args &#x3D; PojoUtils.generalize(arguments);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            invocation2.setMethodName(Constants.$INVOKE);</span><br><span class="line">            invocation2.setParameterTypes(GENERIC_PARAMETER_TYPES);</span><br><span class="line">            invocation2.setArguments(new Object[]&#123;methodName, types, args&#125;);</span><br><span class="line">            Result result &#x3D; invoker.invoke(invocation2);</span><br><span class="line"></span><br><span class="line">            if (!result.hasException()) &#123;</span><br><span class="line">                Object value &#x3D; result.getValue();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Method method &#x3D; invoker.getInterface().getMethod(methodName, parameterTypes);</span><br><span class="line">                    if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            return new RpcResult(value);</span><br><span class="line">                        &#125; else if (value instanceof JavaBeanDescriptor) &#123;</span><br><span class="line">                            return new RpcResult(JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) value));</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RpcException(</span><br><span class="line">                                    &quot;The type of result value is &quot; +</span><br><span class="line">                                            value.getClass().getName() +</span><br><span class="line">                                            &quot; other than &quot; +</span><br><span class="line">                                            JavaBeanDescriptor.class.getName() +</span><br><span class="line">                                            &quot;, and the result is &quot; +</span><br><span class="line">                                            value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return new RpcResult(PojoUtils.realize(value, method.getReturnType(), method.getGenericReturnType()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    throw new RpcException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (result.getException() instanceof GenericException) &#123;</span><br><span class="line">                GenericException exception &#x3D; (GenericException) result.getException();</span><br><span class="line">                try &#123;</span><br><span class="line">                    String className &#x3D; exception.getExceptionClass();</span><br><span class="line">                    Class&lt;?&gt; clazz &#x3D; ReflectUtils.forName(className);</span><br><span class="line">                    Throwable targetException &#x3D; null;</span><br><span class="line">                    Throwable lastException &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        targetException &#x3D; (Throwable) clazz.newInstance();</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        lastException &#x3D; e;</span><br><span class="line">                        for (Constructor&lt;?&gt; constructor : clazz.getConstructors()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                targetException &#x3D; (Throwable) constructor.newInstance(new Object[constructor.getParameterTypes().length]);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125; catch (Throwable e1) &#123;</span><br><span class="line">                                lastException &#x3D; e1;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (targetException !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Field field &#x3D; Throwable.class.getDeclaredField(&quot;detailMessage&quot;);</span><br><span class="line">                            if (!field.isAccessible()) &#123;</span><br><span class="line">                                field.setAccessible(true);</span><br><span class="line">                            &#125;</span><br><span class="line">                            field.set(targetException, exception.getExceptionMessage());</span><br><span class="line">                        &#125; catch (Throwable e) &#123;</span><br><span class="line">                            logger.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result &#x3D; new RpcResult(targetException);</span><br><span class="line">                    &#125; else if (lastException !&#x3D; null) &#123;</span><br><span class="line">                        throw lastException;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    throw new RpcException(&quot;Can not deserialize exception &quot; + exception.getExceptionClass() + &quot;, message: &quot; + exception.getExceptionMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (invocation.getMethodName().equals(Constants.$INVOKE)                             &#x2F;&#x2F; @2</span><br><span class="line">                &amp;&amp; invocation.getArguments() !&#x3D; null</span><br><span class="line">                &amp;&amp; invocation.getArguments().length &#x3D;&#x3D; 3</span><br><span class="line">                &amp;&amp; ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line"></span><br><span class="line">            Object[] args &#x3D; (Object[]) invocation.getArguments()[2];</span><br><span class="line">            if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;</span><br><span class="line"></span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    if (!(byte[].class &#x3D;&#x3D; arg.getClass())) &#123;</span><br><span class="line">                        error(byte[].class.getName(), arg.getClass().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    if (!(arg instanceof JavaBeanDescriptor)) &#123;</span><br><span class="line">                        error(JavaBeanDescriptor.class.getName(), arg.getClass().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ((RpcInvocation) invocation).setAttachment(</span><br><span class="line">                    Constants.GENERIC_KEY, invoker.getUrl().getParameter(Constants.GENERIC_KEY));</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：该分支是泛化实现，如果是泛化实现，则根据generic的值进行序列化，然后调用$invoke方法，因为服务端实现为泛化实现，所有的服务提供者实现GenericeServer#$invoker方法，其实现方式就是将Bean转换成Map。这些细节将在服务端GenericFilter序列中详细讲解。</p><p>代码@2：泛化引用，调用方是直接通过GenericService#$invoke方法进行调用，以此来区分是泛化调用还是泛化引用，那不经要问，为什么invoker.getUrl().getParameter(Constants.GENERIC_KEY)中获取的generic参数到底是&lt; dubbo:service/&gt;中配置的还是&lt; dubbo:reference/&gt;中配置的呢？其实不难理解：</p><ol><li>dubbo:servcie未配置而dubbo:reference配置了，则代表的是消费端的，必然是泛化引用。</li><li>dubbo:servcie配置而dubbo:reference未配置了，则代表的是服务端的，必然是泛化实现。</li><li>如果两者都配置了，generic以消费端为主。消费端参数与服务端参数的合并在服务发现时，注册中心首先会将服务提供者的URL通知消费端，然后消费端会使用当前的配置与服务提供者URL中的配置进行合并，如遇到相同参数，则消费端覆盖服务端。</li></ol><blockquote><p>注：这里我就不深入去探讨其实现细节，因为这部分在下文源码分析GenericFilter时会详细介绍Map与Bean转换的细节，包含是否序列化，之所以这里没有细说，主要是因为我先看的是GenericFilter。</p></blockquote><h2 id="4、源码分析泛化引用-GenericFilter（服务提供者）"><a href="#4、源码分析泛化引用-GenericFilter（服务提供者）" class="headerlink" title="4、源码分析泛化引用 GenericFilter（服务提供者）"></a>4、源码分析泛化引用 GenericFilter（服务提供者）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">@Activate(group &#x3D; Constants.PROVIDER, order &#x3D; -20000)</span><br><span class="line">public class GenericFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        if (inv.getMethodName().equals(Constants.$INVOKE)</span><br><span class="line">                &amp;&amp; inv.getArguments() !&#x3D; null</span><br><span class="line">                &amp;&amp; inv.getArguments().length &#x3D;&#x3D; 3</span><br><span class="line">                &amp;&amp; !ProtocolUtils.isGeneric(invoker.getUrl().getParameter(Constants.GENERIC_KEY))) &#123;       &#x2F;&#x2F; @1</span><br><span class="line">            String name &#x3D; ((String) inv.getArguments()[0]).trim();</span><br><span class="line">            String[] types &#x3D; (String[]) inv.getArguments()[1];</span><br><span class="line">            Object[] args &#x3D; (Object[]) inv.getArguments()[2];</span><br><span class="line">            try &#123;</span><br><span class="line">                Method method &#x3D; ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types);             &#x2F;&#x2F; @2</span><br><span class="line">                Class&lt;?&gt;[] params &#x3D; method.getParameterTypes();</span><br><span class="line">                if (args &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    args &#x3D; new Object[params.length];</span><br><span class="line">                &#125;</span><br><span class="line">                String generic &#x3D; inv.getAttachment(Constants.GENERIC_KEY);</span><br><span class="line">                if (StringUtils.isEmpty(generic)</span><br><span class="line">                        || ProtocolUtils.isDefaultGenericSerialization(generic)) &#123;                                                             &#x2F;&#x2F; @3</span><br><span class="line">                    args &#x3D; PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br><span class="line">                &#125; else if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;                                                             &#x2F;&#x2F; @4</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                        if (byte[].class &#x3D;&#x3D; args[i].getClass()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                UnsafeByteArrayInputStream is &#x3D; new UnsafeByteArrayInputStream((byte[]) args[i]);</span><br><span class="line">                                args[i] &#x3D; ExtensionLoader.getExtensionLoader(Serialization.class)</span><br><span class="line">                                        .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA)</span><br><span class="line">                                        .deserialize(null, is).readObject();</span><br><span class="line">                            &#125; catch (Exception e) &#123;</span><br><span class="line">                                throw new RpcException(&quot;Deserialize argument [&quot; + (i + 1) + &quot;] failed.&quot;, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RpcException(</span><br><span class="line">                                    &quot;Generic serialization [&quot; +</span><br><span class="line">                                            Constants.GENERIC_SERIALIZATION_NATIVE_JAVA +</span><br><span class="line">                                            &quot;] only support message type &quot; +</span><br><span class="line">                                            byte[].class +</span><br><span class="line">                                            &quot; and your message type is &quot; +</span><br><span class="line">                                            args[i].getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;                                                 &#x2F;&#x2F; @5</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                        if (args[i] instanceof JavaBeanDescriptor) &#123;</span><br><span class="line">                            args[i] &#x3D; JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) args[i]);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RpcException(</span><br><span class="line">                                    &quot;Generic serialization [&quot; +</span><br><span class="line">                                            Constants.GENERIC_SERIALIZATION_BEAN +</span><br><span class="line">                                            &quot;] only support message type &quot; +</span><br><span class="line">                                            JavaBeanDescriptor.class.getName() +</span><br><span class="line">                                            &quot; and your message type is &quot; +</span><br><span class="line">                                            args[i].getClass().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Result result &#x3D; invoker.invoke(new RpcInvocation(method, args, inv.getAttachments()));    &#x2F;&#x2F; @6</span><br><span class="line">                if (result.hasException()</span><br><span class="line">                        &amp;&amp; !(result.getException() instanceof GenericException)) &#123;</span><br><span class="line">                    return new RpcResult(new GenericException(result.getException()));</span><br><span class="line">                &#125;</span><br><span class="line">                if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;                                                        &#x2F;&#x2F; @7</span><br><span class="line">                    try &#123;</span><br><span class="line">                        UnsafeByteArrayOutputStream os &#x3D; new UnsafeByteArrayOutputStream(512);</span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Serialization.class)</span><br><span class="line">                                .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA)</span><br><span class="line">                                .serialize(null, os).writeObject(result.getValue());</span><br><span class="line">                        return new RpcResult(os.toByteArray());</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        throw new RpcException(&quot;Serialize result failed.&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                    return new RpcResult(JavaBeanSerializeUtil.serialize(result.getValue(), JavaBeanAccessor.METHOD));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return new RpcResult(PojoUtils.generalize(result.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                throw new RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                throw new RpcException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(inv);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果方法名为$invoker，并且只有3个参数，并且服务端实现为非返回实现，则认为本次服务调用时客户端泛化引用服务端，客户端的泛化调用，需要将请求参数反序列化为该接口真实的pojo对象。<br>代码@2：根据接口名（API类）、方法名、方法参数类型列表，根据反射机制获取对应的方法。<br>代码@3：处理普通的泛化引用调用，即处理&lt;dubbo:referecnce generic=”true”  …/&gt;,只需要将参数列表Object[]反序列化为pojo即可，具体的反序列化为PojoUtils#realize,其实现原理如下：<br>在JAVA的世界中，pojo通常用map来表示，也就是一个Map可以用来表示一个对象的值，那从一个Map如果序列化一个对象呢？其关键的要素是要在Map中保留该对象的类路径名。例如现在有这样一个对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">private Team team;</span><br><span class="line">&#x2F;&#x2F;省略get set方法</span><br><span class="line">&#125;</span><br><span class="line">public class Team &#123;</span><br><span class="line">private int id;</span><br><span class="line">private String name;</span><br><span class="line">&#x2F;&#x2F; 省略其他属性与set get方法</span><br><span class="line">&#125;</span><br><span class="line">用Map表示Student为：</span><br><span class="line">&#123;</span><br><span class="line">“class”:&quot;somepackeage.Student&quot;,</span><br><span class="line">&quot;id&quot;:1,</span><br><span class="line">&quot;name&quot;:&quot;dingw&quot;,</span><br><span class="line">&quot;team&quot;:</span><br><span class="line">&#123;</span><br><span class="line">&quot;class&quot; : &quot;somepackage.Team&quot;,</span><br><span class="line">&quot;id&quot;:2,</span><br><span class="line">&quot;name&quot;:&quot;t&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是通过class来标识该Map需要反序列化的pojo类型。<br>代码@4：处理&lt; dubbo:reference generic=”nativejava” /&gt; 启用泛化引用，并使用nativejava序列化参数，在服务端这边通过nativejava反序列化参数成pojo对象。<br>代码@5：处理&lt; dubbo:reference generic=”bean” /&gt; 启用泛化引用，并使用javabean序列化参数，在服务端这边通过javabean反序列化参数成pojo对象。<br>代码@6：序列化API方法中声明的类型，构建new RpcInvocation(method, args, inv.getAttachments())调用环境，继续调用后续过滤器。<br>代码@7：处理执行结果，如果是nativejava或bean，则需要对返回结果序列化，如果是generic=true，则使用PojoUtils.generalize序列化，也即将pojo序列化为Map。<br>泛化调用与泛化引用，就介绍到这里了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;本文将重点分析Dubbo的两个重要特性：泛化调用与泛化实现。&lt;br&gt; 1、泛化引用：&lt;br&gt; &lt;img src=&quot;https://img-blog.csdn.net/20181005211034328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt; 通常是服务调用方没有引入API包，也就不包含接口中的实体类，故服务调用方只能提供Map形式的数据，由服务提供者根据Map转化成对应的实体。&lt;br&gt; 2、泛化实现&lt;br&gt; &lt;img src=&quot;https://img-blog.csdn.net/20181005211118267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt; 泛化实现，是指服务提供者未引入API包，也就不包含接口用于传输数据的实体类，故客户端发起调用前，需要将mode转化为Map。&lt;br&gt; 从上面分析，其实所谓的泛化本质上就是Map与Bean的转换。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="泛化调用" scheme="http://example.com/tags/%E6%B3%9B%E5%8C%96%E8%B0%83%E7%94%A8/"/>
    
    <category term="泛化实现" scheme="http://example.com/tags/%E6%B3%9B%E5%8C%96%E5%AE%9E%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo tps过滤器器实现原理</title>
    <link href="http://example.com/posts/b3d9d24a.html"/>
    <id>http://example.com/posts/b3d9d24a.html</id>
    <published>2020-12-13T11:28:01.000Z</published>
    <updated>2020-12-13T13:50:25.626Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将重点分析一下dubbo限流的另外一个方式，tps过滤器。<br>@Activate(group = Constants.PROVIDER, value = Constants.TPS_LIMIT_RATE_KEY)</p><ul><li>过滤器作用<br>服务调用tps过滤器</li><li>使用场景<br>对Dubbo服务提供者实现限流(tps)。</li><li>阻断条件<br>当服务调用者超过其TPS时，直接返回rpc exception。<br>接下来从源码的角度分析Tps过滤器的实现机制。</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class TpsLimitFilter implements Filter &#123;</span><br><span class="line">    private final TPSLimiter tpsLimiter &#x3D; new DefaultTPSLimiter();</span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (!tpsLimiter.isAllowable(invoker.getUrl(), invocation)) &#123;  </span><br><span class="line">            throw new RpcException(</span><br><span class="line">                    &quot;Failed to invoke service &quot;  +  invoker.getInterface().getName() +  &quot;.&quot; + invocation.getMethodName() + &quot; because exceed max service tps.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tps limit 生效的条件是，服务提供者的url中包含了tps=””这个属性，还可以通过&lt;dubbo:parameter=”tps.interval” value=”60000”/&gt;来设置TPS的统计时长，默认为1分钟，表示如果在1分钟之内的调用次数超过配置的tps，则阻断本次RPC服务调用。<br>其TPS控制代码主要由DefaultTPSLimiter实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultTPSLimiter implements TPSLimiter &#123;</span><br><span class="line">    private final ConcurrentMap&lt;String, StatItem&gt; stats &#x3D; new ConcurrentHashMap&lt;String, StatItem&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAllowable(URL url, Invocation invocation) &#123;</span><br><span class="line">        int rate &#x3D; url.getParameter(Constants.TPS_LIMIT_RATE_KEY, -1);    &#x2F;&#x2F; @1</span><br><span class="line">        long interval &#x3D; url.getParameter(Constants.TPS_LIMIT_INTERVAL_KEY,</span><br><span class="line">                Constants.DEFAULT_TPS_LIMIT_INTERVAL);                         </span><br><span class="line">        String serviceKey &#x3D; url.getServiceKey();                                            &#x2F;&#x2F; @2</span><br><span class="line">        if (rate &gt; 0) &#123;</span><br><span class="line">            StatItem statItem &#x3D; stats.get(serviceKey);</span><br><span class="line">            if (statItem &#x3D;&#x3D; null) &#123;</span><br><span class="line">                stats.putIfAbsent(serviceKey,</span><br><span class="line">                        new StatItem(serviceKey, rate, interval));</span><br><span class="line">                statItem &#x3D; stats.get(serviceKey);</span><br><span class="line">            &#125;</span><br><span class="line">            return statItem.isAllowable();                                                     &#x2F;&#x2F; @3</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            StatItem statItem &#x3D; stats.get(serviceKey);</span><br><span class="line">            if (statItem !&#x3D; null) &#123;</span><br><span class="line">                stats.remove(serviceKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：获取服务提供者url中的参数tps、tps.interval属性。<br>代码@2：获取服务key，并创建或获取对应的StatItem。<br>代码@3：调用StatItem的isAllowable()方法来判断是否可用。<br>StatItem#isAllowable</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAllowable() &#123;</span><br><span class="line">        long now &#x3D; System.currentTimeMillis();</span><br><span class="line">        if (now &gt; lastResetTime + interval) &#123;    &#x2F;&#x2F; @1</span><br><span class="line">            token.set(rate);</span><br><span class="line">            lastResetTime &#x3D; now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int value &#x3D; token.get();   </span><br><span class="line">        boolean flag &#x3D; false;</span><br><span class="line">        while (value &gt; 0 &amp;&amp; !flag) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">            flag &#x3D; token.compareAndSet(value, value - 1);  </span><br><span class="line">            value &#x3D; token.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该类的核心思想：是漏桶算法。<br>代码@1：如果当前时间大于（上一次刷新时间+统计间隔），重新复位token为rate，表示重新生成一批token。<br>代码@2：每使用一次，消耗一个token，如果能成功消耗一个token则返回true，如果没有可消耗的token，则直接返回false。</p><p>Tps过滤器的实现原理其实比较简单，大家可以从这里体会到ConcurrentHashMap、漏桶算法的简易实现。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将重点分析一下dubbo限流的另外一个方式，tps过滤器。&lt;br&gt;@Activate(group = Constants.PROVIDER, value = Constants.TPS_LIMIT_RATE_KEY)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤器作用&lt;br&gt;服务调用tps过滤器&lt;/li&gt;
&lt;li&gt;使用场景&lt;br&gt;对Dubbo服务提供者实现限流(tps)。&lt;/li&gt;
&lt;li&gt;阻断条件&lt;br&gt;当服务调用者超过其TPS时，直接返回rpc exception。&lt;br&gt;接下来从源码的角度分析Tps过滤器的实现机制。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="execute" scheme="http://example.com/tags/execute/"/>
    
    <category term="active" scheme="http://example.com/tags/active/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo服务提供者、服务消费者并发度控制机制</title>
    <link href="http://example.com/posts/1ea63fb8.html"/>
    <id>http://example.com/posts/1ea63fb8.html</id>
    <published>2020-12-13T11:25:01.000Z</published>
    <updated>2020-12-13T13:50:25.628Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细分析&lt; dubbo:service executes=””/&gt;与&lt; dubbo:reference actives = “”/&gt;的实现机制，深入探讨Dubbo自身的保护机制。</p><h2 id="1、源码分析ExecuteLimitFilter"><a href="#1、源码分析ExecuteLimitFilter" class="headerlink" title="1、源码分析ExecuteLimitFilter"></a>1、源码分析ExecuteLimitFilter</h2><p>@Activate(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY )</p><ul><li>过滤器作用<br>服务调用方并发度控制。</li><li>使用场景<br>对Dubbo服务提供者实现的一种保护机制，控制每个服务的最大并发度。</li><li>阻断条件<br>当服务调用超过允许的并发度后，直接抛出RpcException异常。<br>接下来源码分析ExecuteLimitFilter的实现细节。</li></ul><a id="more"></a><p>ExecuteLimitFilter#invoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();</span><br><span class="line">        String methodName &#x3D; invocation.getMethodName();</span><br><span class="line">        Semaphore executesLimit &#x3D; null;</span><br><span class="line">        boolean acquireResult &#x3D; false;</span><br><span class="line">        int max &#x3D; url.getMethodParameter(methodName, Constants.EXECUTES_KEY, 0);      &#x2F;&#x2F; @1</span><br><span class="line">        if (max &gt; 0) &#123;</span><br><span class="line">            RpcStatus count &#x3D; RpcStatus.getStatus(url, invocation.getMethodName());             &#x2F;&#x2F; @2</span><br><span class="line">            executesLimit &#x3D; count.getSemaphore(max);                                                              &#x2F;&#x2F; @3</span><br><span class="line">            if(executesLimit !&#x3D; null &amp;&amp; !(acquireResult &#x3D; executesLimit.tryAcquire())) &#123;              &#x2F;&#x2F; @4</span><br><span class="line">                throw new RpcException(&quot;Failed to invoke method &quot; + invocation.getMethodName() + &quot; in provider &quot; + url + &quot;, cause: The service using threads </span><br><span class="line">                      greater than &lt;dubbo:service executes&#x3D;\&quot;&quot; + max + &quot;\&quot; &#x2F;&gt; limited.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean isSuccess &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            Result result &#x3D; invoker.invoke(invocation);                 &#x2F;&#x2F; @5</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            isSuccess &#x3D; false;</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RpcException(&quot;unexpected exception when ExecuteLimitFilter&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(acquireResult) &#123;                                   &#x2F;&#x2F; @6</span><br><span class="line">                executesLimit.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：从服务提供者列表中获取参数executes的值，如果该值小于等于0，表示不启用并发度控制，直接沿着调用链进行调用。</p><p>代码@2：根据服务提供者url和服务调用方法名，获取RpcStatus。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static RpcStatus getStatus(URL url, String methodName) &#123;</span><br><span class="line">        String uri &#x3D; url.toIdentityString();      </span><br><span class="line">        ConcurrentMap&lt;String, RpcStatus&gt; map &#x3D; METHOD_STATISTICS.get(uri);         </span><br><span class="line">        if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">            METHOD_STATISTICS.putIfAbsent(uri, new ConcurrentHashMap&lt;String, RpcStatus&gt;());    </span><br><span class="line">            map &#x3D; METHOD_STATISTICS.get(uri);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcStatus status &#x3D; map.get(methodName);          &#x2F;</span><br><span class="line">        if (status &#x3D;&#x3D; null) &#123;</span><br><span class="line">            map.putIfAbsent(methodName, new RpcStatus());</span><br><span class="line">            status &#x3D; map.get(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里是并发容器ConcurrentHashMap的经典使用，从 这里可以看出ConcurrentMap&lt; String, ConcurrentMap&lt; String, RpcStatus&gt;&gt; METHOD_STATISTICS的存储结构为 {  服务提供者URL唯一字符串：{方法名：RpcStatus} }。</p><p>代码@3：根据服务提供者配置的最大并发度，创建该服务该方法对应的信号量对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public Semaphore getSemaphore(int maxThreadNum) &#123;</span><br><span class="line">        if(maxThreadNum &lt;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (executesLimit &#x3D;&#x3D; null || executesPermits !&#x3D; maxThreadNum) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (executesLimit &#x3D;&#x3D; null || executesPermits !&#x3D; maxThreadNum) &#123;</span><br><span class="line">                    executesLimit &#x3D; new Semaphore(maxThreadNum);</span><br><span class="line">                    executesPermits &#x3D; maxThreadNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return executesLimit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>使用了双重检测来创建executesLimit 信号量。</p><p>代码@4：如果获取不到锁，并不会阻塞等待，而是直接抛出RpcException,服务端的策略是快速抛出异常，供服务调用方（消费者）根据集群策略进行执行，例如重试其他服务提供者。</p><p>代码@5：执行真实的服务调用。</p><p>代码@6：如果成功申请到信号量，在服务调用结束后，释放信号量。<br>总结：&lt; dubbo:service executes=””/&gt;的含义是，针对每个服务每个方法的最大并发度。如果超过该值，则直接抛出RpcException。</p><h2 id="2、源码分析ActiveLimitFilter"><a href="#2、源码分析ActiveLimitFilter" class="headerlink" title="2、源码分析ActiveLimitFilter"></a>2、源码分析ActiveLimitFilter</h2><p>@Activate(group = Constants.CONSUMER, value = Constants.ACTIVES_KEY )</p><ul><li>过滤器作用<br>消费端调用服务的并发控制。</li><li>使用场景<br>控制同一个消费端对服务端某一服务的并发调用度，通常该值应该小于&lt; dubbo:service executes=””/&gt;</li><li>阻断条件<br>非阻断，但如果超过允许的并发度会阻塞，超过超时时间后将不再调用服务，而是直接抛出超时。</li></ul><p>源码分析ActiveLimitFilter的实现原理：<br>ActiveLimitFilter#invoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();</span><br><span class="line">        String methodName &#x3D; invocation.getMethodName();</span><br><span class="line">        int max &#x3D; invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, 0);    &#x2F;&#x2F; @1</span><br><span class="line">        RpcStatus count &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());           &#x2F;&#x2F; @2</span><br><span class="line">        if (max &gt; 0) &#123;                                          </span><br><span class="line">            long timeout &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, 0);   &#x2F;&#x2F; @3</span><br><span class="line">            long start &#x3D; System.currentTimeMillis();</span><br><span class="line">            long remain &#x3D; timeout;</span><br><span class="line">            int active &#x3D; count.getActive();                                                                                                                                          &#x2F;&#x2F; @4</span><br><span class="line">            if (active &gt;&#x3D; max) &#123;                                                                                                                                                          &#x2F;&#x2F; @5</span><br><span class="line">                synchronized (count) &#123;                                                                                                                                                                      </span><br><span class="line">                    while ((active &#x3D; count.getActive()) &gt;&#x3D; max) &#123;                                                                                                     </span><br><span class="line">                        try &#123;</span><br><span class="line">                            count.wait(remain);                                                                                                                                      </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        long elapsed &#x3D; System.currentTimeMillis() - start;                               </span><br><span class="line">                        remain &#x3D; timeout - elapsed;</span><br><span class="line">                        if (remain &lt;&#x3D; 0) &#123;                                                                                                                                             &#x2F;&#x2F; @6</span><br><span class="line">                            throw new RpcException(&quot;Waiting concurrent invoke timeout in client-side for service:  &quot;</span><br><span class="line">                                    + invoker.getInterface().getName() + &quot;, method: &quot;</span><br><span class="line">                                    + invocation.getMethodName() + &quot;, elapsed: &quot; + elapsed</span><br><span class="line">                                    + &quot;, timeout: &quot; + timeout + &quot;. concurrent invokes: &quot; + active</span><br><span class="line">                                    + &quot;. max concurrent invoke limit: &quot; + max);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">            RpcStatus.beginCount(url, methodName);        &#x2F;&#x2F; @7</span><br><span class="line">            try &#123;</span><br><span class="line">                Result result &#x3D; invoker.invoke(invocation);     &#x2F;&#x2F; @8</span><br><span class="line">                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);    &#x2F;&#x2F; @9</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (RuntimeException t) &#123;</span><br><span class="line">                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);</span><br><span class="line">                throw t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (max &gt; 0) &#123;</span><br><span class="line">                synchronized (count) &#123;</span><br><span class="line">                    count.notify();     &#x2F;&#x2F; @10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：从Invoker中获取消息端URL中的配置的actives参数，为什么从Invoker中获取的Url是消费端的Url呢？这是因为在消费端根据服务提供者URL创建调用Invoker时，会用服务提供者URL，然后合并消费端的配置属性，其优先级 -D &gt; 消费端 &gt; 服务端。其代码位于：、<br>RegistryDirectory#toInvokers<br>URL url = mergeUrl(providerUrl);</p><p>代码@2：根据服务提供者URL和调用服务提供者方法，获取RpcStatus。</p><p>代码@3：获取接口调用的超时时间，默认为1s。</p><p>代码@4：获取当前消费者，针对特定服务，特定方法的并发调用度，active值。</p><p>代码@5：如果当前的并发 调用大于等于允许的最大值，则针对该RpcStatus申请锁，并调用其wait(timeout)进行等待，也就是在接口调用超时时间内，还是未被唤醒，则直接抛出超时异常。</p><p>代码@6：判断被唤醒的原因是因为等待超时，还是由于调用结束，释放了”名额“，如果是超时唤醒，则直接抛出异常。</p><p>代码@7：在一次服务调用前，先将 服务名+方法名对应的RpcStatus的active加一。</p><p>代码@8：执行RPC服务调用。</p><p>代码@9：记录成功调用或失败调用，并将active减一。</p><p>代码@10：最终成功执行，如果开启了actives机制(dubbo:referecnce actives=””)时，唤醒等待者。</p><blockquote><p>总结：&lt; dubbo:reference actives=””/&gt; 是控制消费端对 单个服务提供者单个服务允许调用的最大并发度。该值的取值不应该大于&lt; dubbo:service executes=””/&gt;的值，并且如果消费者机器的配置，如果性能不尽相同，不建议对该值进行设置。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细分析&amp;lt; dubbo:service executes=””/&amp;gt;与&amp;lt; dubbo:reference actives = “”/&amp;gt;的实现机制，深入探讨Dubbo自身的保护机制。&lt;/p&gt;
&lt;h2 id=&quot;1、源码分析ExecuteLimitFilter&quot;&gt;&lt;a href=&quot;#1、源码分析ExecuteLimitFilter&quot; class=&quot;headerlink&quot; title=&quot;1、源码分析ExecuteLimitFilter&quot;&gt;&lt;/a&gt;1、源码分析ExecuteLimitFilter&lt;/h2&gt;&lt;p&gt;@Activate(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY )&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤器作用&lt;br&gt;服务调用方并发度控制。&lt;/li&gt;
&lt;li&gt;使用场景&lt;br&gt;对Dubbo服务提供者实现的一种保护机制，控制每个服务的最大并发度。&lt;/li&gt;
&lt;li&gt;阻断条件&lt;br&gt;当服务调用超过允许的并发度后，直接抛出RpcException异常。&lt;br&gt;接下来源码分析ExecuteLimitFilter的实现细节。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="execute" scheme="http://example.com/tags/execute/"/>
    
    <category term="active" scheme="http://example.com/tags/active/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo异步调用与事件回调机制</title>
    <link href="http://example.com/posts/70022ae6.html"/>
    <id>http://example.com/posts/70022ae6.html</id>
    <published>2020-12-13T11:23:01.000Z</published>
    <updated>2020-12-13T13:50:25.628Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>谈到服务调用日志，大家恐怕第一想到就是如果开启了这个参数，会影响性能。那真实的情况是怎么样了？性能损耗到底有多大呢？在实践中我们如何使用该功能呢？本文将详细分析Dubbo accesslog实现原理。<br>AccessLogFilter概述</p><ul><li>过滤器作用<br>记录调用日志。</li><li>使用场景<br>记录服务提供者端调用日志。</li><li>阻断条件<br>非阻断过滤器。</li></ul><p>接下来源码分析accesslog参数的实现原理。<br><img src="https://img-blog.csdn.net/20180909221922266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><a id="more"></a><h2 id="1、核心字段说明"><a href="#1、核心字段说明" class="headerlink" title="1、核心字段说明"></a>1、核心字段说明</h2><ul><li>LOG_MAX_BUFFER：积累最大的日志容量，默认为5000条，如果积压在队列中的待处理日志超过该值，则直接丢弃。</li><li>LOG_OUTPUT_INTERVAL：日志写出的调度频率，默认为5s。</li><li>ConcurrentMap&lt; String, Set&lt; String&gt;&gt; logQueue：日志容器。</li><li>ScheduledExecutorService logScheduled：写出日志调度器，默认为2个线程，线程名称为：Dubbo-Access-Log。</li></ul><h2 id="2、invoke方法源码分析"><a href="#2、invoke方法源码分析" class="headerlink" title="2、invoke方法源码分析"></a>2、invoke方法源码分析</h2><p>AccessLogFilter#invoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String accesslog &#x3D; invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);    </span><br><span class="line">            if (ConfigUtils.isNotEmpty(accesslog)) &#123;    &#x2F;&#x2F; @1                                                       </span><br><span class="line">                RpcContext context &#x3D; RpcContext.getContext();</span><br><span class="line">                String serviceName &#x3D; invoker.getInterface().getName();</span><br><span class="line">                String version &#x3D; invoker.getUrl().getParameter(Constants.VERSION_KEY);</span><br><span class="line">                String group &#x3D; invoker.getUrl().getParameter(Constants.GROUP_KEY);</span><br><span class="line">                StringBuilder sn &#x3D; new StringBuilder();         &#x2F;&#x2F; @2 start</span><br><span class="line">                sn.append(&quot;[&quot;).append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(&quot;] </span><br><span class="line">                       &quot;).append(context.getRemoteHost()).append(&quot;:&quot;).append(context.getRemotePort())</span><br><span class="line">                        .append(&quot; -&gt; &quot;).append(context.getLocalHost()).append(&quot;:&quot;).append(context.getLocalPort())</span><br><span class="line">                        .append(&quot; - &quot;);</span><br><span class="line">                if (null !&#x3D; group &amp;&amp; group.length() &gt; 0) &#123;</span><br><span class="line">                    sn.append(group).append(&quot;&#x2F;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(serviceName);</span><br><span class="line">                if (null !&#x3D; version &amp;&amp; version.length() &gt; 0) &#123;</span><br><span class="line">                    sn.append(&quot;:&quot;).append(version);</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(&quot; &quot;);</span><br><span class="line">                sn.append(inv.getMethodName());</span><br><span class="line">                sn.append(&quot;(&quot;);</span><br><span class="line">                Class&lt;?&gt;[] types &#x3D; inv.getParameterTypes();</span><br><span class="line">                if (types !&#x3D; null &amp;&amp; types.length &gt; 0) &#123;</span><br><span class="line">                    boolean first &#x3D; true;</span><br><span class="line">                    for (Class&lt;?&gt; type : types) &#123;</span><br><span class="line">                        if (first) &#123;</span><br><span class="line">                            first &#x3D; false;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            sn.append(&quot;,&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        sn.append(type.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(&quot;) &quot;);</span><br><span class="line">                Object[] args &#x3D; inv.getArguments();</span><br><span class="line">                if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                    sn.append(JSON.toJSONString(args));</span><br><span class="line">                &#125;</span><br><span class="line">                String msg &#x3D; sn.toString();</span><br><span class="line">                if (ConfigUtils.isDefault(accesslog)) &#123;         &#x2F;&#x2F; @2</span><br><span class="line">                    LoggerFactory.getLogger(ACCESS_LOG_KEY + &quot;.&quot; + invoker.getInterface().getName()).info(msg);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    log(accesslog, msg);                              &#x2F;&#x2F; @3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(&quot;Exception in AcessLogFilter of service(&quot; + invoker + &quot; -&gt; &quot; + inv + &quot;)&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(inv);                                 &#x2F;&#x2F; @4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先从服务提供者URL中获取accesslog参数，如果存在该参数并且不为空，则进入服务调用日志，如果未配置，则直接进入下一个过滤器。</p><p>代码@2：组装服务调用日志，其内容：<br>[服务调用时间，精确到时分秒] + 消费者IP:消费者PORT +  –&gt; 服务提供者IP:服务提供者端口 +  “服务提供者group/“(可选) + serviceName(interface name) + “:version”(可选) + methodName( + 参数类型列表）+  参数值(json格式的字符串) 。</p><p>代码@3：如果accesslog=”true”，则使用info级别的日志输出；如果是配置的是日志路径的话，则异步写入文件。<br>接下来分析一下log方法，写入日志文件的具体实现：<br>AccessLogFilter#log</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void log(String accesslog, String logmessage) &#123;</span><br><span class="line">        init();     &#x2F;&#x2F; @1</span><br><span class="line">        Set&lt;String&gt; logSet &#x3D; logQueue.get(accesslog);                                            &#x2F;&#x2F; @2 start</span><br><span class="line">        if (logSet &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet&lt;String&gt;());</span><br><span class="line">            logSet &#x3D; logQueue.get(accesslog);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSet.size() &lt; LOG_MAX_BUFFER) &#123;                                                   &#x2F;&#x2F; @2 end</span><br><span class="line">            logSet.add(logmessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：授权通过init方法启动定时任务，已间隔5s,延迟5s后执行第一次调度，具体的任务实现为LogTask。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">        if (logFuture &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (logScheduled) &#123;</span><br><span class="line">                if (logFuture &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    logFuture &#x3D; logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, </span><br><span class="line">                           TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@2：以文件路径名accesslog为键，从logQueue中获取，如果当前处理的长度大于LOG_MAX_BUFFER固定为5000条，则丢弃。由于存储日志的容器为ConcurrentHashSet<String>，则日志记录是乱序的。<br>具体异步记录日志的任务实现为AccessLogFilter$LogTask。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">private class LogTask implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (logQueue !&#x3D; null &amp;&amp; logQueue.size() &gt; 0) &#123;</span><br><span class="line">                    for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : logQueue.entrySet()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            String accesslog &#x3D; entry.getKey();</span><br><span class="line">                            Set&lt;String&gt; logSet &#x3D; entry.getValue();</span><br><span class="line">                            File file &#x3D; new File(accesslog);              </span><br><span class="line">                            File dir &#x3D; file.getParentFile();  </span><br><span class="line">                            if (null !&#x3D; dir &amp;&amp; !dir.exists()) &#123;</span><br><span class="line">                                dir.mkdirs();</span><br><span class="line">                            &#125;     &#x2F;&#x2F; @1</span><br><span class="line">                            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(&quot;Append log to &quot; + accesslog);</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (file.exists()) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">                                String now &#x3D; new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date());</span><br><span class="line">                                String last &#x3D; new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified()));</span><br><span class="line">                                if (!now.equals(last)) &#123;</span><br><span class="line">                                    File archive &#x3D; new File(file.getAbsolutePath() + &quot;.&quot; + last);</span><br><span class="line">                                    file.renameTo(archive);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            FileWriter writer &#x3D; new FileWriter(file, true);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                for (Iterator&lt;String&gt; iterator &#x3D; logSet.iterator();</span><br><span class="line">                                     iterator.hasNext();</span><br><span class="line">                                     iterator.remove()) &#123;</span><br><span class="line">                                    writer.write(iterator.next());</span><br><span class="line">                                    writer.write(&quot;\r\n&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                                writer.flush();</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                writer.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：从这里可以看出accesslog配置的是具体的日志文件全路径，例如d:/logs/accesslog.log。</p><p>代码@2：如果文件存在，则需要判断该文件的最后修改时间与当前日期是否相同，如果不同，则首先将文件重新命名为前一天的日期，然后再创建一个新的accesslog文件，也就是accesslog文件的布局是一天一个文件。</p><p>accesslog 调用日志记录就分析到这里，我们思考一下开启该参数对服务提供者的性能影响。</p><ul><li>accesslog=”true”,其实现为通过log4j等日志组件，使用info级别将调用日志输出，该方法对服务调用者的影响还是比较大，不建议这样使用。</li><li>accesslog=”日志文件路径”，该方式，dubbo使用的是异步记录日志的方式，开启额外的信息，主要是需要组织日志内容，耗费一定的CPU资源，但对服务的响应整体性能损耗还是不会起到恶劣的影响。默认情况下，还是不建议开启，但是如果线上服务器有BUG，需要通过调用日志来拍错的话，也可以在不重启服务提供者的情况下开启，开启方法利用Dubbo的配置覆盖机制，该部分的内容详情请参考作者的另一篇博客：源码分析Dubbo配置规则机制（override协议）：<a href="https://blog.csdn.net/prestigeding/article/details/80795708">https://blog.csdn.net/prestigeding/article/details/80795708</a> 。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;谈到服务调用日志，大家恐怕第一想到就是如果开启了这个参数，会影响性能。那真实的情况是怎么样了？性能损耗到底有多大呢？在实践中我们如何使用该功能呢？本文将详细分析Dubbo accesslog实现原理。&lt;br&gt;AccessLogFilter概述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤器作用&lt;br&gt;记录调用日志。&lt;/li&gt;
&lt;li&gt;使用场景&lt;br&gt;记录服务提供者端调用日志。&lt;/li&gt;
&lt;li&gt;阻断条件&lt;br&gt;非阻断过滤器。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来源码分析accesslog参数的实现原理。&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180909221922266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="异步调用" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo异步调用与事件回调机制</title>
    <link href="http://example.com/posts/70022ae6.html"/>
    <id>http://example.com/posts/70022ae6.html</id>
    <published>2020-12-13T11:11:01.000Z</published>
    <updated>2020-12-13T13:50:25.626Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细分析Dubbo服务异步调用与事件回调机制。</p><h2 id="1、异步调用与事件回调机制"><a href="#1、异步调用与事件回调机制" class="headerlink" title="1、异步调用与事件回调机制"></a>1、异步调用与事件回调机制</h2><h3 id="1-1-异步回调"><a href="#1-1-异步回调" class="headerlink" title="1.1 异步回调"></a>1.1 异步回调</h3><p><img src="https://img-blog.csdn.net/20180906120834523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906120855286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><a id="more"></a><h3 id="1-2-事件回调"><a href="#1-2-事件回调" class="headerlink" title="1.2 事件回调"></a>1.2 事件回调</h3><p><img src="https://img-blog.csdn.net/20180906120921491?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906120940317?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906120956173?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906121011994?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><h2 id="2、源码分析异步调用与事件回调机制"><a href="#2、源码分析异步调用与事件回调机制" class="headerlink" title="2、源码分析异步调用与事件回调机制"></a>2、源码分析异步调用与事件回调机制</h2><p>在Dubbo中，引入特定的过滤器FutureFilter来处理异步调用相关的逻辑，其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Activate(group &#x3D; Constants.CONSUMER)</span><br><span class="line">public class FutureFilter implements Filter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>group=CONSUMER说明该过滤器属于消费端过滤器。<br>接下来从从invoke方法详细分析其实现逻辑。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public Result invoke(final Invoker&lt;?&gt; invoker, final Invocation invocation) throws RpcException &#123;</span><br><span class="line">        final boolean isAsync &#x3D; RpcUtils.isAsync(invoker.getUrl(), invocation);     &#x2F;&#x2F; @1</span><br><span class="line">        fireInvokeCallback(invoker, invocation);                                                     &#x2F;&#x2F; @2</span><br><span class="line">        &#x2F;&#x2F; need to configure if there&#39;s return value before the invocation in order to help invoker to judge if it&#39;s</span><br><span class="line">        &#x2F;&#x2F; necessary to return future.</span><br><span class="line">        Result result &#x3D; invoker.invoke(invocation);                                                 &#x2F;&#x2F; @3</span><br><span class="line">        if (isAsync) &#123;</span><br><span class="line">            asyncCallback(invoker, invocation);                                                       &#x2F;&#x2F; @4</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            syncCallback(invoker, invocation, result);                                              &#x2F;&#x2F; @5</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先从URL中获取是否是异步调用标志，其配置属性为&lt; dubbo:service async=””/&gt;获取其子标签&lt; dubbo:method async=””/&gt;。<br>代码@2：同步调用oninvoke事件,执行invoke方法之前的事件。<br>代码@3：继续沿着调用链调用,最终会到具体的协议Invoker，例如DubboInvoker，发生具体的服务调用，跟踪一下同步、异步调用的实现细节。<br>代码@4：如果调用方式是异步模式，则异步调用onreturn或onthrow事件。<br>代码@5：如果调用方式是同步模式，则同步调用onreturn或onthrow事件。</p><h3 id="2-1-源码分析FutureFilter-fireInvokeCallback"><a href="#2-1-源码分析FutureFilter-fireInvokeCallback" class="headerlink" title="2.1 源码分析FutureFilter#fireInvokeCallback"></a>2.1 源码分析FutureFilter#fireInvokeCallback</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">private void fireInvokeCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation) &#123;</span><br><span class="line">        final Method onInvokeMethod &#x3D; (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), </span><br><span class="line">Constants.ON_INVOKE_METHOD_KEY));      &#x2F;&#x2F; @1</span><br><span class="line">        final Object onInvokeInst &#x3D; StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), </span><br><span class="line">Constants.ON_INVOKE_INSTANCE_KEY));   &#x2F;&#x2F; @2</span><br><span class="line">        if (onInvokeMethod &#x3D;&#x3D; null &amp;&amp; onInvokeInst &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @3</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (onInvokeMethod &#x3D;&#x3D; null || onInvokeInst &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">            throw new IllegalStateException(&quot;service:&quot; + invoker.getUrl().getServiceKey() + &quot; has a onreturn callback config , but no such &quot; + (onInvokeMethod &#x3D;&#x3D; null ? &quot;method&quot; : </span><br><span class="line">                         &quot;instance&quot;) + &quot; found. url:&quot; + invoker.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!onInvokeMethod.isAccessible()) &#123;</span><br><span class="line">            onInvokeMethod.setAccessible(true);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] params &#x3D; invocation.getArguments();</span><br><span class="line">        try &#123;</span><br><span class="line">            onInvokeMethod.invoke(onInvokeInst, params);        &#x2F;&#x2F; @5</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            fireThrowCallback(invoker, invocation, e.getTargetException());    &#x2F;&#x2F; @6</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            fireThrowCallback(invoker, invocation, e);                         &#x2F;&#x2F; @7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：StaticContext.getSystemContext()中根据key:serviceKey + “.” + method + “.” + “oninvoke.method” 获取配置的oninvoke.method方法名。其中serviceKey为[group]/interface:[version]，其中group与version可能为空，忽略。</p><p>代码@2：同样根据key:serviceKey + “.” + method + “.” + “oninvoke.instance” 从StaticContext.getSystemContext()获取oninvoke.method方法所在的实例名对象，也就是说该调用哪个对象的oninvoke.method指定的方法。这里就有一个疑问，这些数据是在什么时候存入StaticContext中的呢？下文会详细分析。</p><p>代码@3、@4：主要检测&lt; dubbo:method oninvoke=””/&gt;配置的正确性，其正确的配置方式如下：“实例名.方法名”，例如：<br><img src="https://img-blog.csdn.net/20180906121257970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><p>代码@5：根据发射机制，调用oninvoke中指定的实例的指定方法，注意，这里传入的参数为调用远程RPC服务的参数。</p><blockquote><p>注意：从这里可以看出，如果要实现事件通知，也即在调用远程RPC服务之前，之后、抛出异常时执行回调函数，该回调事件的方法的参数列表需要与被调用服务的参数列表一致。</p></blockquote><p>代码@6、@7，如果在执行调用前方法(oninvoke)事件方法失败，则会同步调用onthrow中定义的方法（如有定义）。关于dubbo:method oninvoke属性的解析以及在什么时候会向StaticContext.getSystemContext()中添加信息，将在下文统一介绍。</p><h3 id="2-2-源码分析DubboInvoker关于同步异步调用处理"><a href="#2-2-源码分析DubboInvoker关于同步异步调用处理" class="headerlink" title="2.2 源码分析DubboInvoker关于同步异步调用处理"></a>2.2 源码分析DubboInvoker关于同步异步调用处理</h3><p>在上文提到FutureFilter#invoke中的第三步调用invoker.invoker方法时，我们应该会有兴趣了解一下真实的invoker是如何处理同步、异步请求的。<br>我们以dubbo协议DubboInvoker来重点分析一下其实现原理：<br>DubboInvoker#doInvoke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            boolean isAsync &#x3D; RpcUtils.isAsync(getUrl(), invocation);            &#x2F;&#x2F; @1</span><br><span class="line">            boolean isOneway &#x3D; RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            int timeout &#x3D; getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            if (isOneway) &#123;</span><br><span class="line">                boolean isSent &#x3D; getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);</span><br><span class="line">                currentClient.send(inv, isSent);                                             &#x2F;&#x2F; @2</span><br><span class="line">                RpcContext.getContext().setFuture(null);</span><br><span class="line">                return new RpcResult();</span><br><span class="line">            &#125; else if (isAsync) &#123;</span><br><span class="line">                ResponseFuture future &#x3D; currentClient.request(inv, timeout);                 &#x2F;&#x2F; @3</span><br><span class="line">                RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                return new RpcResult();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                RpcContext.getContext().setFuture(null);     &#x2F;&#x2F; @4</span><br><span class="line">                return (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (TimeoutException e) &#123;</span><br><span class="line">            throw new RpcException(RpcException.TIMEOUT_EXCEPTION, &quot;Invoke remote method timeout. method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125; catch (RemotingException e) &#123;</span><br><span class="line">            throw new RpcException(RpcException.NETWORK_EXCEPTION, &quot;Failed to invoke remote method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先获取async属性，如果为true表示异步请求，如果配置了return=”false”表示调用模式为oneway，只发调用，不关注其调用结果。</p><p>代码@2：处理oneway的情况。如果设置了sent=true，表示等待网络数据发出才返回，如果sent=false，只是将待发送数据发到IO写缓存区就返回。</p><p>代码@3：处理异步的情况，代码@4处理同步调用的情况，细看其实都是通过调用网络客户端client的request,最终调用HeaderExchangeChannel#request方法：<br><img src="https://img-blog.csdn.net/20180906121506329?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>这里是通过Future模式来实现异步调用的，同步调用也是通过异步调用来实现，只是同步调用发起后，直接调用future#get的方法来同步等待结果的返回，而异步调用只返回Future Response，在用户需要关心其结果时才调用get方法。</p><h3 id="2-3-源码分析asyncCallback与syncCallback"><a href="#2-3-源码分析asyncCallback与syncCallback" class="headerlink" title="2.3 源码分析asyncCallback与syncCallback"></a>2.3 源码分析asyncCallback与syncCallback</h3><p>前面介绍了方法执行之前oninvoker事件的调用分析，接下来分析RPC服务调用完成后，onreturn和onthrow方法的调用逻辑。异步回调与同步回调的区别就是调用onreturn (fireReturnCallback) 和onthrow(fireThrowCallback)调用的地方不同，如果是同步调用，也就是在完成RPC服务调用后，立即调用相关的回调方法，如果是异步调用的话，RPC服务完成后，通过Future模式异步执行。</p><p>其实关于onreturn、onthrow属性的解析，执行与oninvoker属性的解析完全一样，再这里也就不重复介绍了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细分析Dubbo服务异步调用与事件回调机制。&lt;/p&gt;
&lt;h2 id=&quot;1、异步调用与事件回调机制&quot;&gt;&lt;a href=&quot;#1、异步调用与事件回调机制&quot; class=&quot;headerlink&quot; title=&quot;1、异步调用与事件回调机制&quot;&gt;&lt;/a&gt;1、异步调用与事件回调机制&lt;/h2&gt;&lt;h3 id=&quot;1-1-异步回调&quot;&gt;&lt;a href=&quot;#1-1-异步回调&quot; class=&quot;headerlink&quot; title=&quot;1.1 异步回调&quot;&gt;&lt;/a&gt;1.1 异步回调&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180906120834523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180906120855286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="异步调用" scheme="http://example.com/tags/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo监控中心实现原理</title>
    <link href="http://example.com/posts/4fb5ca23.html"/>
    <id>http://example.com/posts/4fb5ca23.html</id>
    <published>2020-12-13T11:11:01.000Z</published>
    <updated>2020-12-13T13:50:25.639Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>Dubbo监控的实现基本原理就是在服务调用时收集服务调用并发度、服务响应时间，然后以一定频率向监控中心汇报统计数据。</p><h2 id="1、源码分析MonitorFilter过滤器"><a href="#1、源码分析MonitorFilter过滤器" class="headerlink" title="1、源码分析MonitorFilter过滤器"></a>1、源码分析MonitorFilter过滤器</h2><ul><li>过滤器作用<br>监控过滤器，向监控中心汇报服务调用数据。</li><li>使用场景<br>搭建监控中心监控Dubbo服务调用。</li><li>阻断条件<br>非阻断过滤器。</li></ul><a id="more"></a><h3 id="1-1-MonitorFilter声明"><a href="#1-1-MonitorFilter声明" class="headerlink" title="1.1 MonitorFilter声明"></a>1.1 MonitorFilter声明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * MonitorFilter. (SPI, Singleton, ThreadSafe)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Activate(group &#x3D; &#123;Constants.PROVIDER, Constants.CONSUMER&#125;)</span><br><span class="line">public class MonitorFilter implements Filter &#123;</span><br><span class="line">     &#x2F;&#x2F; 省略具体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：MonitorFilter会在生产者、消费者两端生效。</p><h3 id="1-2-getConcurrent方法详解"><a href="#1-2-getConcurrent方法详解" class="headerlink" title="1.2 getConcurrent方法详解"></a>1.2 getConcurrent方法详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; concurrent counter</span><br><span class="line">    private AtomicInteger getConcurrent(Invoker&lt;?&gt; invoker, Invocation invocation) &#123;</span><br><span class="line">        String key &#x3D; invoker.getInterface().getName() + &quot;.&quot; + invocation.getMethodName();    &#x2F;&#x2F; @1</span><br><span class="line">        AtomicInteger concurrent &#x3D; concurrents.get(key);                     </span><br><span class="line">        if (concurrent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            concurrents.putIfAbsent(key, new AtomicInteger());                                                  &#x2F;&#x2F; @2</span><br><span class="line">            concurrent &#x3D; concurrents.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return concurrent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>主要是获取当前调用服务的调用次数计算器。<br>代码@1：使用的是ConcurrentMap&lt; String, AtomicInteger &gt;作为缓存容器，其key为：interfaceName + “.” + methodName。<br>代码@2：如果是第一次调用，则创建AtomicInteger，否则返回原先的计数器。</p><h3 id="1-3-invoker方法详解"><a href="#1-3-invoker方法详解" class="headerlink" title="1.3 invoker方法详解"></a>1.3 invoker方法详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (invoker.getUrl().hasParameter(Constants.MONITOR_KEY)) &#123;      &#x2F;&#x2F; @1</span><br><span class="line">            RpcContext context &#x3D; RpcContext.getContext(); &#x2F;&#x2F; provider must fetch context before invoke() gets called              &#x2F;&#x2F; @2</span><br><span class="line">            String remoteHost &#x3D; context.getRemoteHost();</span><br><span class="line">            long start &#x3D; System.currentTimeMillis(); &#x2F;&#x2F; record start timestamp                       </span><br><span class="line">            getConcurrent(invoker, invocation).incrementAndGet(); &#x2F;&#x2F; count up                                                &#x2F;&#x2F; @3</span><br><span class="line">            try &#123;</span><br><span class="line">                Result result &#x3D; invoker.invoke(invocation); &#x2F;&#x2F; proceed invocation chain                                       &#x2F;&#x2F; @4</span><br><span class="line">                collect(invoker, invocation, result, remoteHost, start, false);                                                        &#x2F;&#x2F; @5</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (RpcException e) &#123;</span><br><span class="line">                collect(invoker, invocation, null, remoteHost, start, true);                                                            &#x2F;&#x2F; @6</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                getConcurrent(invoker, invocation).decrementAndGet(); &#x2F;&#x2F; count down                                     &#x2F;&#x2F; @7</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return invoker.invoke(invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果url中存在monitor,则设置了监控中心，收集调用信息。<br>代码@2：获取本次服务调用的上下文环境。<br>代码@3：服务调用并发次数增加1，（非服务调用总次数，而是当前服务的并发调用）。<br>代码@4：执行方法之前先记录当前时间，然后调用下一个过滤器，直到真实服务被调用。<br>代码@5：调用collect方法收集调用信息。<br>代码@6：如果调用发送RPC异常，则收集错误信息。<br>代码@7：一次服务调用结束，并发次数减一。<br>接下来分析一下collect方法。</p><h3 id="1-4-invoker方法详解"><a href="#1-4-invoker方法详解" class="headerlink" title="1.4 invoker方法详解"></a>1.4 invoker方法详解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; collect info</span><br><span class="line">    private void collect(Invoker&lt;?&gt; invoker, Invocation invocation, Result result, String remoteHost, long start, boolean error) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; ---- service statistics ----                                                                                                                                                      &#x2F;&#x2F; @2 start</span><br><span class="line">            long elapsed &#x3D; System.currentTimeMillis() - start; &#x2F;&#x2F; invocation cost                                                   </span><br><span class="line">            int concurrent &#x3D; getConcurrent(invoker, invocation).get(); &#x2F;&#x2F; current concurrent count</span><br><span class="line">            String application &#x3D; invoker.getUrl().getParameter(Constants.APPLICATION_KEY);</span><br><span class="line">            String service &#x3D; invoker.getInterface().getName(); &#x2F;&#x2F; service name</span><br><span class="line">            String method &#x3D; RpcUtils.getMethodName(invocation); &#x2F;&#x2F; method name</span><br><span class="line">            String group &#x3D; invoker.getUrl().getParameter(Constants.GROUP_KEY);</span><br><span class="line">            String version &#x3D; invoker.getUrl().getParameter(Constants.VERSION_KEY);</span><br><span class="line">            URL url &#x3D; invoker.getUrl().getUrlParameter(Constants.MONITOR_KEY);                                                                             &#x2F;&#x2F; @2 end</span><br><span class="line">            Monitor monitor &#x3D; monitorFactory.getMonitor(url);                                                                                                     &#x2F;&#x2F; @3</span><br><span class="line">            if (monitor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            int localPort;</span><br><span class="line">            String remoteKey;</span><br><span class="line">            String remoteValue;</span><br><span class="line">            if (Constants.CONSUMER_SIDE.equals(invoker.getUrl().getParameter(Constants.SIDE_KEY))) &#123;                  &#x2F;&#x2F; @4</span><br><span class="line">                &#x2F;&#x2F; ---- for service consumer ----</span><br><span class="line">                localPort &#x3D; 0;</span><br><span class="line">                remoteKey &#x3D; MonitorService.PROVIDER;</span><br><span class="line">                remoteValue &#x3D; invoker.getUrl().getAddress();</span><br><span class="line">            &#125; else &#123;                                                                                                                                                               &#x2F;&#x2F; @5</span><br><span class="line">                &#x2F;&#x2F; ---- for service provider ----</span><br><span class="line">                localPort &#x3D; invoker.getUrl().getPort();</span><br><span class="line">                remoteKey &#x3D; MonitorService.CONSUMER;</span><br><span class="line">                remoteValue &#x3D; remoteHost;</span><br><span class="line">            &#125;</span><br><span class="line">            String input &#x3D; &quot;&quot;, output &#x3D; &quot;&quot;;</span><br><span class="line">            if (invocation.getAttachment(Constants.INPUT_KEY) !&#x3D; null) &#123;                                                                       &#x2F;&#x2F; @6</span><br><span class="line">                input &#x3D; invocation.getAttachment(Constants.INPUT_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            if (result !&#x3D; null &amp;&amp; result.getAttachment(Constants.OUTPUT_KEY) !&#x3D; null) &#123;                                               &#x2F;&#x2F; @7</span><br><span class="line">                output &#x3D; result.getAttachment(Constants.OUTPUT_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            monitor.collect(new URL(Constants.COUNT_PROTOCOL,                                                                          &#x2F;&#x2F; @8</span><br><span class="line">                    NetUtils.getLocalHost(), localPort,</span><br><span class="line">                    service + &quot;&#x2F;&quot; + method,</span><br><span class="line">                    MonitorService.APPLICATION, application,</span><br><span class="line">                    MonitorService.INTERFACE, service,</span><br><span class="line">                    MonitorService.METHOD, method,</span><br><span class="line">                    remoteKey, remoteValue,</span><br><span class="line">                    error ? MonitorService.FAILURE : MonitorService.SUCCESS, &quot;1&quot;,</span><br><span class="line">                    MonitorService.ELAPSED, String.valueOf(elapsed),</span><br><span class="line">                    MonitorService.CONCURRENT, String.valueOf(concurrent),</span><br><span class="line">                    Constants.INPUT_KEY, input,</span><br><span class="line">                    Constants.OUTPUT_KEY, output,</span><br><span class="line">                    Constants.GROUP_KEY, group,</span><br><span class="line">                    Constants.VERSION_KEY, version));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(&quot;Failed to monitor count service &quot; + invoker.getUrl() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数说明。</p><ul><li>Invoker&lt; ? &gt; invoker<br>服务调用Invoker。</li><li>Invocation invocation<br>本次服务调用信息</li><li>Result result<br>执行结果</li><li>String remoteHost<br>调用者host信息。</li><li>long start<br>服务开始调用时间。</li><li>boolean error<br>是否发生错误。</li></ul><p>代码@2：统计基础信息字段说明：</p><ul><li>elapsed ：服务调用时长。</li><li>concurrent ：当前并发度。（当前服务并发调用次数）。</li><li>application ：服务归属应用名。</li><li>service ：服务名。</li><li>method ：方法名。</li><li>group ：服务所属组。</li><li>version ：服务版本号</li><li>URL url：监控中心url。</li></ul><p>代码@3：根据监控中心获取监控中心实现类，这是监控中心实现扩展点，默认使用com.alibaba.dubbo.monitor.dubbo.DubboMonitor。</p><p>代码@4：如果是消费端，由于Monitor在消费端与服务端都会生效：</p><ul><li>localPort ：本地端口设置为0；</li><li>remoteKey：MonitorService.PROVIDER，表示为服务端。</li><li>remoteValue：为invoker.getUrl().getAddress()，其值为（注册中心地址）或服务提供者地址（客户端直连服务端）。</li></ul><p>代码@5：如果为服务端：</p><ul><li>localPort ：为服务端的服务端口号。</li><li>remoteKey：MonitorService.CONSUMER，表示远端为服务消费者。</li><li>remoteValue：消费者host(ip:port)。</li></ul><p>代码@6：获取本次服务调用请求包的字节数，在服务端解码时会在RpcContext中。</p><p>代码@7：获取本次服务调用响应包的字节数，在服务端对响应包编码时会写入，具体代码请参考DubboCountCodec类。</p><p>代码@8：调用monitor#collect收集调用信息，Monitor默认实现为DubboMonitor。使用的协议为count://localhost:localPort/service/method?application=applicationName&amp;remoteKey=remoteValue&amp;success|failure=1&amp;elapsed=调用开销&amp;concurrent=并发调用次数&amp;input=入参字节数&amp;output=响应字节数&amp;group=服务所属组&amp;version=版本。</p><h2 id="2、源码分析DubboMonitor实现原理"><a href="#2、源码分析DubboMonitor实现原理" class="headerlink" title="2、源码分析DubboMonitor实现原理"></a>2、源码分析DubboMonitor实现原理</h2><p>Dubbo中默认的Monitor监控实现类为DubboMonitor：<br><img src="https://img-blog.csdn.net/20180831120406607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>核心属性介绍：</p><ul><li><p>private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3, new NamedThreadFactory(“DubboMonitorSendTimer”,<br>true))：定时调度线程池，使用3个线程的线程池，线程名称以DubboMonitorSendTimer。</p></li><li><p>private final ScheduledFuture&lt; ? &gt; sendFuture：调度任务future。<br>private final Invoker&lt; MonitorService &gt; monitorInvoker：监控调度Invoker，Dubbo中的监控中心会作为服务提供者暴露服务，服务提供者，服务消费者可以通过注册中心订阅服务，通过该Invoker向监控中心汇报调用统计数据，也就是一次上报就是一次Dubbo RPC服务调用，其实现类为DubboInvoker，也就是可以通过该Invoker使用dubbo协议调用远程Monitor服务。</p></li><li><p>private final MonitorService monitorService：对monitorInvoker的proxy代理，主要是对toString、hashcode、equals无需通过RPC向MonitorServer服务提供者发起调<br> 用。主要是通过AbstractProxyFactory#getProxy创建，默认子类为JavassistProxyFactory，动态代理的InvokerHandler为：<br>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler#invoke。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        String methodName &#x3D; method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">        if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">            return method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return invoker.equals(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(new RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>private final long monitorInterval：向监控中心汇报的频率，也就是调用MonitorService RPC服务的调用频率，默认为1分钟。</p></li><li><p>private final ConcurrentMap&lt; Statistics, AtomicReference&lt; long[]&gt;&gt; statisticsMap：统计信息Map。</p></li></ul><h3 id="2-1-构造函数分析"><a href="#2-1-构造函数分析" class="headerlink" title="2.1 构造函数分析"></a>2.1 构造函数分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public DubboMonitor(Invoker&lt;MonitorService&gt; monitorInvoker, MonitorService monitorService) &#123;</span><br><span class="line">        this.monitorInvoker &#x3D; monitorInvoker;</span><br><span class="line">        this.monitorService &#x3D; monitorService;</span><br><span class="line">        this.monitorInterval &#x3D; monitorInvoker.getUrl().getPositiveParameter(&quot;interval&quot;, 60000);      &#x2F;&#x2F; @1 </span><br><span class="line">        &#x2F;&#x2F; collect timer for collecting statistics data</span><br><span class="line">        sendFuture &#x3D; scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;      &#x2F;&#x2F; @2</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; collect data</span><br><span class="line">                try &#123;</span><br><span class="line">                    send();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Unexpected error occur at send statistic, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, monitorInterval, monitorInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1，从url参数中获取interval属性，如果为空，默认为60000，代表60S。<br>代码@2：启动定时调度任务，默认60S的间隔执行send()方法，向监控中心汇报服务调用统计数据。</p><h3 id="2-2-collect-收集统计信息方法"><a href="#2-2-collect-收集统计信息方法" class="headerlink" title="2.2 collect 收集统计信息方法"></a>2.2 collect 收集统计信息方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public void collect(URL url) &#123;</span><br><span class="line">        &#x2F;&#x2F; data to collect from url</span><br><span class="line">        int success &#x3D; url.getParameter(MonitorService.SUCCESS, 0);</span><br><span class="line">        int failure &#x3D; url.getParameter(MonitorService.FAILURE, 0);</span><br><span class="line">        int input &#x3D; url.getParameter(MonitorService.INPUT, 0);</span><br><span class="line">        int output &#x3D; url.getParameter(MonitorService.OUTPUT, 0);</span><br><span class="line">        int elapsed &#x3D; url.getParameter(MonitorService.ELAPSED, 0);</span><br><span class="line">        int concurrent &#x3D; url.getParameter(MonitorService.CONCURRENT, 0);</span><br><span class="line">        &#x2F;&#x2F; init atomic reference</span><br><span class="line">        Statistics statistics &#x3D; new Statistics(url);</span><br><span class="line">        AtomicReference&lt;long[]&gt; reference &#x3D; statisticsMap.get(statistics);</span><br><span class="line">        if (reference &#x3D;&#x3D; null) &#123;</span><br><span class="line">            statisticsMap.putIfAbsent(statistics, new AtomicReference&lt;long[]&gt;());</span><br><span class="line">            reference &#x3D; statisticsMap.get(statistics);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; use CompareAndSet to sum</span><br><span class="line">        long[] current;</span><br><span class="line">        long[] update &#x3D; new long[LENGTH];</span><br><span class="line">        do &#123;</span><br><span class="line">            current &#x3D; reference.get();</span><br><span class="line">            if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">                update[0] &#x3D; success;</span><br><span class="line">                update[1] &#x3D; failure;</span><br><span class="line">                update[2] &#x3D; input;</span><br><span class="line">                update[3] &#x3D; output;</span><br><span class="line">                update[4] &#x3D; elapsed;</span><br><span class="line">                update[5] &#x3D; concurrent;</span><br><span class="line">                update[6] &#x3D; input;</span><br><span class="line">                update[7] &#x3D; output;</span><br><span class="line">                update[8] &#x3D; elapsed;</span><br><span class="line">                update[9] &#x3D; concurrent;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                update[0] &#x3D; current[0] + success;</span><br><span class="line">                update[1] &#x3D; current[1] + failure;</span><br><span class="line">                update[2] &#x3D; current[2] + input;</span><br><span class="line">                update[3] &#x3D; current[3] + output;</span><br><span class="line">                update[4] &#x3D; current[4] + elapsed;</span><br><span class="line">                update[5] &#x3D; (current[5] + concurrent) &#x2F; 2;</span><br><span class="line">                update[6] &#x3D; current[6] &gt; input ? current[6] : input;</span><br><span class="line">                update[7] &#x3D; current[7] &gt; output ? current[7] : output;</span><br><span class="line">                update[8] &#x3D; current[8] &gt; elapsed ? current[8] : elapsed;</span><br><span class="line">                update[9] &#x3D; current[9] &gt; concurrent ? current[9] : concurrent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (!reference.compareAndSet(current, update));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>收集的信息主要是10个字段<br>update[0] ：调用成功的次数<br>update[1] ：调用失败的次数<br>update[2] ：总调用流量（请求包的总大小）。<br>update[3] ：总响应流量（响应包的总大小）。<br>update[4] ：总响应时长（总服务调用开销）。<br>update[5] ：一次收集周期的平均TPS。<br>update[6] ：最大请求包大小。<br>update[7] ：最大响应包大小。<br>update[8] ：最大响应时间。<br>update[9] ：最大TPS。</p><h3 id="2-3-send方法"><a href="#2-3-send方法" class="headerlink" title="2.3 send方法"></a>2.3 send方法</h3><p>通过monitorService，最终通过monitorInvoker去调用RPC服务向监控中心汇报数据。接下来看一下监控中心的具体实现。</p><h2 id="3、Dubbo监控中心实现原理"><a href="#3、Dubbo监控中心实现原理" class="headerlink" title="3、Dubbo监控中心实现原理"></a>3、Dubbo监控中心实现原理</h2><p>Dubbo官方提供了简易版本的监控中心，其项目为dubbo-ops:dubbo-monitor-simple。该项目是个spring-boot项目，启动后可以看到后台管理界面。<br>该项目服务提供者文件如下：<br><img src="https://img-blog.csdn.net/20180831121101811?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从中可以看出，监控中心服务提供者实现类为SimpleMonitorService，其实现接口为MonitorService。<br>接下来重点分析SimpleMonitorService监控中心的实现，关注如下两个点：<br>1、监控数据持久化。<br>2、监控报表生成逻辑。<br>核心属性说明：</p><ul><li>ScheduledExecutorService scheduledExecutorService：定时调度线程，将监控数据写入饼图的定时任务，固定1个线程。</li><li>Thread writeThread：监控数据持久化线程。</li><li>BlockingQueue&lt; URL &gt; queue：持久化数据任务阻塞队列。</li><li>String statisticsDirectory = “statistics”：数据持久化目录，SimpleMonitorService将数据持久化到磁盘文件。该值指定目录名称。</li><li>String chartsDirectory = “charts”：饼图存储目录。</li><li>private volatile boolean running = true：持久化数据线程是否处于运行状态。</li></ul><h3 id="3-1-SimpleMonitorService构造函数"><a href="#3-1-SimpleMonitorService构造函数" class="headerlink" title="3.1 SimpleMonitorService构造函数"></a>3.1 SimpleMonitorService构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public SimpleMonitorService() &#123;</span><br><span class="line">        queue &#x3D; new LinkedBlockingQueue&lt;URL&gt;(Integer.parseInt(ConfigUtils.getProperty(&quot;dubbo.monitor.queue&quot;, &quot;100000&quot;)));    &#x2F;&#x2F; @1</span><br><span class="line">        writeThread &#x3D; new Thread(new Runnable() &#123;                      &#x2F;&#x2F; @2 start</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (running) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        write(); &#x2F;&#x2F; write statistics</span><br><span class="line">                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                        logger.error(&quot;Unexpected error occur at write stat log, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(5000); &#x2F;&#x2F; retry after 5 secs</span><br><span class="line">                        &#125; catch (Throwable t2) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        writeThread.setDaemon(true);</span><br><span class="line">        writeThread.setName(&quot;DubboMonitorAsyncWriteLogThread&quot;);    </span><br><span class="line">        writeThread.start();                                                                        &#x2F;&#x2F; @2 end</span><br><span class="line">        chartFuture &#x3D; scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    draw(); &#x2F;&#x2F; draw chart</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Unexpected error occur at draw stat chart, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1, 300, TimeUnit.SECONDS);     &#x2F;&#x2F; @3</span><br><span class="line">        statisticsDirectory &#x3D; ConfigUtils.getProperty(&quot;dubbo.statistics.directory&quot;);</span><br><span class="line">        chartsDirectory &#x3D; ConfigUtils.getProperty(&quot;dubbo.charts.directory&quot;);  &#x2F;&#x2F; @4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：创建有界阻塞队列LinkedBlockingQueue，容量默认为100000个，可通过配置参数dubbo.monitor.queue改变默认值，如果队列中已挤压未被处理，后续监控数据将被默认丢弃。<br>代码@2：创建持久化监控数据线程，名称为DubboMonitorAsyncWriteLogThread，其使命是从LinkedBlockingQueue中获取监控原始数据，如果队列中没数据则被阻塞，然后写入文件中。<br>代码@3：开启定时调度任务，已每个5分钟的频率，根据持久化的监控数据，生成饼图。<br>代码@4：获取数据持久化目录与饼图存放目录。</p><h3 id="3-2-SimpleMonitorService-write"><a href="#3-2-SimpleMonitorService-write" class="headerlink" title="3.2 SimpleMonitorService#write"></a>3.2 SimpleMonitorService#write</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">private void write() throws Exception &#123;</span><br><span class="line">        URL statistics &#x3D; queue.take();</span><br><span class="line">        if (POISON_PROTOCOL.equals(statistics.getProtocol())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String timestamp &#x3D; statistics.getParameter(Constants.TIMESTAMP_KEY);</span><br><span class="line">        Date now;</span><br><span class="line">        if (timestamp &#x3D;&#x3D; null || timestamp.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            now &#x3D; new Date();</span><br><span class="line">        &#125; else if (timestamp.length() &#x3D;&#x3D; &quot;yyyyMMddHHmmss&quot;.length()) &#123;</span><br><span class="line">            now &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).parse(timestamp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            now &#x3D; new Date(Long.parseLong(timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        String day &#x3D; new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(now);</span><br><span class="line">        SimpleDateFormat format &#x3D; new SimpleDateFormat(&quot;HHmm&quot;);</span><br><span class="line">        for (String key : types) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String type;</span><br><span class="line">                String consumer;</span><br><span class="line">                String provider;</span><br><span class="line">                if (statistics.hasParameter(PROVIDER)) &#123;</span><br><span class="line">                    type &#x3D; CONSUMER;</span><br><span class="line">                    consumer &#x3D; statistics.getHost();</span><br><span class="line">                    provider &#x3D; statistics.getParameter(PROVIDER);</span><br><span class="line">                    int i &#x3D; provider.indexOf(&#39;:&#39;);</span><br><span class="line">                    if (i &gt; 0) &#123;</span><br><span class="line">                        provider &#x3D; provider.substring(0, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    type &#x3D; PROVIDER;</span><br><span class="line">                    consumer &#x3D; statistics.getParameter(CONSUMER);</span><br><span class="line">                    int i &#x3D; consumer &#x3D;&#x3D; null ? -1 : consumer.indexOf(&#39;:&#39;);</span><br><span class="line">                    if (i &gt; 0) &#123;</span><br><span class="line">                        consumer &#x3D; consumer.substring(0, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    provider &#x3D; statistics.getHost();</span><br><span class="line">                &#125;</span><br><span class="line">                String filename &#x3D; statisticsDirectory</span><br><span class="line">                        + &quot;&#x2F;&quot; + day</span><br><span class="line">                        + &quot;&#x2F;&quot; + statistics.getServiceInterface()</span><br><span class="line">                        + &quot;&#x2F;&quot; + statistics.getParameter(METHOD)</span><br><span class="line">                        + &quot;&#x2F;&quot; + consumer</span><br><span class="line">                        + &quot;&#x2F;&quot; + provider</span><br><span class="line">                        + &quot;&#x2F;&quot; + type + &quot;.&quot; + key;</span><br><span class="line">                File file &#x3D; new File(filename);</span><br><span class="line">                File dir &#x3D; file.getParentFile();</span><br><span class="line">                if (dir !&#x3D; null &amp;&amp; !dir.exists()) &#123;</span><br><span class="line">                    dir.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                FileWriter writer &#x3D; new FileWriter(file, true);</span><br><span class="line">                try &#123;</span><br><span class="line">                    writer.write(format.format(now) + &quot; &quot; + statistics.getParameter(key, 0) + &quot;\n&quot;);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.error(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>数据存储在物理磁盘上，其文件为为：”${dubbo.statistics.directory} /${day}/${interfacename}/${method}/${consumer}/ ${provider}/[consume|provider]/key”，<br>key:{SUCCESS, FAILURE, ELAPSED, CONCURRENT, MAX_ELAPSED, MAX_CONCURRENT},分别调用成功次数、调用失败次数、调用开销（响应时间），TPS、最大响应时间，最大TPS。其文件存储如下：<br><img src="https://img-blog.csdn.net/20180831122010384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>以provider.concurrent为例，说明一下其内容：<br><img src="https://img-blog.csdn.net/20180831122045595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>其内容组织方式为：时间（时分：采集的值）。</p><h3 id="3-3-draw"><a href="#3-3-draw" class="headerlink" title="3.3 draw"></a>3.3 draw</h3><p>根据持久化的数据，在特定的目录下创建饼图，创建饼图方法createChart，具体使用JFreeChart相关类图，在这里就不细细讲解了，感兴趣的朋友可以百度查询相关用法。</p><h2 id="3-4-监控中心使用效果一览"><a href="#3-4-监控中心使用效果一览" class="headerlink" title="3.4 监控中心使用效果一览"></a>3.4 监控中心使用效果一览</h2><h3 id="3-4-1-应用一览表"><a href="#3-4-1-应用一览表" class="headerlink" title="3.4.1 应用一览表"></a>3.4.1 应用一览表</h3><p>这个功能可以描述系统与系统的关联关系。<br><img src="https://img-blog.csdn.net/20180831122140555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>表格字段说明：<br>1、Application Name：应用名称<br>2、Providers：该应用包含的服务提供者信息，点击进去可以查看具体的服务提供者URL。<br>3、Consumers(1)：该应用包含的服务消费者信息，点击进去可以查看具体的服务消费者URL。<br>4、Depends On：该应用依懒的应用。<br><img src="https://img-blog.csdn.net/20180831122232257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>5、Used By：该应用被依懒的应用。<br><img src="https://img-blog.csdn.net/20180831122309186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>3.4.2服务一览表<br><img src="https://img-blog.csdn.net/20180831122512794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>表格字段说明：<br>Service Name：服务名。<br>Application：服务所属应用名。<br>Providers：服务提供者信息，点击进去，可以看到详细的服务提供者信息。<br><img src="https://img-blog.csdn.net/20180831122619913?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Consumers：该服务的消费者信息。<br><img src="https://img-blog.csdn.net/20180831122656831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Statistics：表格统计信息<br><img src="https://img-blog.csdn.net/20180831122730268?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Charts：饼图统计信息<br><img src="https://img-blog.csdn.net/20180831122810968?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>饼图统计信息，主要从两个维度展示:QPS(接口每秒请求数)、平均响应时间（包含最大，最小响应时间）。</p><h3 id="3-4-3、-Dubbo简易监控中心使用方法"><a href="#3-4-3、-Dubbo简易监控中心使用方法" class="headerlink" title="3.4.3、 Dubbo简易监控中心使用方法"></a>3.4.3、 Dubbo简易监控中心使用方法</h3><p>1、安装Dubbo简易监控中心<br>从github dubbo仓库中下载dubbo-simple-monitor即可。<br>2、应用程序如何使用Dubbo监控中心<br>成功安装完监控中心还只是第一步，为了监控中心能收集服务调用信息，需要在Dubbo服务提、Dubbo消费者供者所在的应用的dubbo配置文件中加上如下内容：<br>&lt; dubbo:monitor protocol=”registry” /&gt;，表示从注册中心发现监控中心的地址，并将服务调用信息提交到监控中心。<br>服务提供者默认以一分钟的频率（可配置）调用监控中心的dubbo服务，向监控中心上报服务调用信息。监控中心宕机，并不影响消费者，服务提供者的正常工作。<br>如果要配置其调用频率，可通过如下配置，默认建议保持一分钟的频率，甚至更小，这个频率设置低点，对整个服务器的压力不会增加更大</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; dubbo:monitor protocol&#x3D;&quot;registry&quot;&gt;</span><br><span class="line">&lt;dubbo:parameter key &#x3D; &quot;interval&quot; value&#x3D;&quot;60000&quot;&gt; &lt;!-- 单位为毫秒--&gt;</span><br><span class="line">&lt;&#x2F; dubbo:monitor&gt;</span><br></pre></td></tr></table></figure><p>注：Dubbo监控中心，服务提供者、服务消费者都可以单独按需配置。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;Dubbo监控的实现基本原理就是在服务调用时收集服务调用并发度、服务响应时间，然后以一定频率向监控中心汇报统计数据。&lt;/p&gt;
&lt;h2 id=&quot;1、源码分析MonitorFilter过滤器&quot;&gt;&lt;a href=&quot;#1、源码分析MonitorFilter过滤器&quot; class=&quot;headerlink&quot; title=&quot;1、源码分析MonitorFilter过滤器&quot;&gt;&lt;/a&gt;1、源码分析MonitorFilter过滤器&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;过滤器作用&lt;br&gt;监控过滤器，向监控中心汇报服务调用数据。&lt;/li&gt;
&lt;li&gt;使用场景&lt;br&gt;搭建监控中心监控Dubbo服务调用。&lt;/li&gt;
&lt;li&gt;阻断条件&lt;br&gt;非阻断过滤器。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="监控中心" scheme="http://example.com/tags/%E7%9B%91%E6%8E%A7%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Filter机制概述</title>
    <link href="http://example.com/posts/a061d56c.html"/>
    <id>http://example.com/posts/a061d56c.html</id>
    <published>2020-12-13T11:10:01.000Z</published>
    <updated>2020-12-13T13:50:25.620Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo&#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter</span><br><span class="line">generic&#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter</span><br><span class="line">genericimpl&#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter</span><br><span class="line">token&#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter</span><br><span class="line">accesslog&#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter</span><br><span class="line">activelimit&#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span><br><span class="line">classloader&#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</span><br><span class="line">context&#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter</span><br><span class="line">consumercontext&#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter</span><br><span class="line">exception&#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br><span class="line">executelimit&#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span><br><span class="line">deprecated&#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter</span><br><span class="line">compatible&#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter</span><br><span class="line">timeout&#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter</span><br></pre></td></tr></table></figure><p>以其中一个来说明一下Filter的定义要素：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * EchoInvokerFilter</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Activate(group &#x3D; Constants.PROVIDER, order &#x3D; -110000)    &#x2F;&#x2F; @2</span><br><span class="line">public class EchoFilter implements Filter &#123;                                 &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        if (inv.getMethodName().equals(Constants.$ECHO) &amp;&amp; inv.getArguments() !&#x3D; null &amp;&amp; inv.getArguments().length &#x3D;&#x3D; 1)</span><br><span class="line">            return new RpcResult(inv.getArguments()[0]);</span><br><span class="line">        return invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：实现com.alibaba.dubbo.rpc.Filter接口。</p><p>代码@2：添加Activate，其注解含义如下：</p><ul><li><p>group： 所属组，String[],例如消费端、服务端。<br>value String[]，如果指定该值，只有当消费者或服务提供者URL中包含属性名为value的键值对，该过滤器才处于激活状态。</p></li><li><p>before：String[]，用于指定执行顺序，before指定的过滤器在该过滤器之前执行。</p></li><li><p>after：string[]，用于指定执行顺序，after指定的过滤器在该过滤器之后执行。</p></li><li><p>order：用户指定顺序，值越小，越先执行。<br>除了支持默认的过滤器外，Dubbo还支持自定义Filter，可以通过service.filter指定过滤器，多个用英文逗号隔开，其配置方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service ......&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure><p>当然，可以为所有服务提供者设置共用过滤器，其指定方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider ...&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:provider&gt;</span><br></pre></td></tr></table></figure><p>消费端自定义过滤器的key为reference.filter，其使用方法在&lt; dubbo:reference/&gt;标签或&lt; dubbo:consumer/&gt;标签下定义属性。关于自定义Filter的解析代码如下：<br>ExtensionLoader#getActivateExtension</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String key, String group) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        String value &#x3D; url.getParameter(key);                                                 &#x2F;&#x2F; @2</span><br><span class="line">        return getActivateExtension(url, value &#x3D;&#x3D; null || value.length() &#x3D;&#x3D; 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), group);    &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数说明。</p><ul><li>URL url：服务提供者或服务消费者url。</li><li>String key：过滤器属性key，服务提供者固定为:service.filter，服务消费者固定为reference.filter。</li><li>String group：服务提供者或服务消费者。</li></ul><p>代码@2：从url中获取配置的自定义filter。</p><p>代码@3：如果value不为空，则将字符串调用split转换为数组，然后调用getActivateExtension方法，获取符合条件的过滤器。</p><p>ExtensionLoader#getActivateExtension</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) &#123;</span><br><span class="line">        List&lt;T&gt; exts &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; names &#x3D; values &#x3D;&#x3D; null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);</span><br><span class="line">        if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">            getExtensionClasses();                                                                                                            &#x2F;&#x2F; @2</span><br><span class="line">            for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">                String name &#x3D; entry.getKey();</span><br><span class="line">                Activate activate &#x3D; entry.getValue();</span><br><span class="line">                if (isMatchGroup(group, activate.group())) &#123;                                                                        &#x2F;&#x2F; @3</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    if (!names.contains(name)</span><br><span class="line">                            &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)                    &#x2F;&#x2F; @4      </span><br><span class="line">                            &amp;&amp; isActive(activate, url)) &#123;                                                                                      &#x2F;&#x2F; @5</span><br><span class="line">                        exts.add(ext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; usrs &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.size(); i++) &#123;                                                                                           &#x2F;&#x2F; @6</span><br><span class="line">            String name &#x3D; names.get(i);</span><br><span class="line">            if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                    &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">                if (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    if (!usrs.isEmpty()) &#123;</span><br><span class="line">                        exts.addAll(0, usrs);</span><br><span class="line">                        usrs.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    usrs.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!usrs.isEmpty()) &#123;</span><br><span class="line">            exts.addAll(usrs);</span><br><span class="line">        &#125;</span><br><span class="line">        return exts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果配置的service.filter或referecnce.filter包含了-default，表示禁用系统默认提供的一系列过滤器。</p><p>代码@2：如果不禁用系统默认过滤器链，则首先加载所有默认过滤器。</p><p>代码@3：根据group刷选出适配的过滤器。</p><p>代码@4：也可以对单个filter进行禁用，其方法是-过滤器名称的方式。例如如想禁用AccessLogFilter，则可以通过-accesslog方式禁用。-key,key为/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中定义的key。</p><p>代码@5：判断过滤器是否激活，其逻辑是如果Filter上的@Activate注解value值不为空，则需要判断url中是否包含键为value的属性对，存在则启用，不存在则不启用。</p><p>代码@6：加载用户自定义的Filter，也即是service.filter或reference.filter指定的过滤器。<br>综上所述，Dubbo提供了过滤器机制，在真实服务被调用前提供扩展点。Filter机制就简单介绍到这里了，从下文开始会重点分析Dubbo服务提供的核心Filter。</p><p>如果需要自定过滤器，需要在自定的工程中META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中注册。</p><p>本文就介绍到这里了，从下篇开始将会根据Dubbo的功能特性来详细分析其实现过程，其本质都是各种Dubbo 过滤器器。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo&amp;#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;generic&amp;#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;genericimpl&amp;#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;token&amp;#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;accesslog&amp;#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;activelimit&amp;#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classloader&amp;#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;context&amp;#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumercontext&amp;#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exception&amp;#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executelimit&amp;#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deprecated&amp;#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compatible&amp;#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeout&amp;#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以其中一个来说明一下Filter的定义要素：&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="Filter" scheme="http://example.com/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>源码分析Dubbo服务调用-服务提供者如何处理请求命令与再谈Invoker</title>
    <link href="http://example.com/posts/fd487dee.html"/>
    <id>http://example.com/posts/fd487dee.html</id>
    <published>2020-12-13T11:05:01.000Z</published>
    <updated>2020-12-13T13:50:25.638Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将重点剖析服务调用流程，也就是消费端通过网络发起RPC服务调用时，服务提供者是如何进行服务请求响应的。</p><h2 id="1、源码分析Dubbo服务调用流程"><a href="#1、源码分析Dubbo服务调用流程" class="headerlink" title="1、源码分析Dubbo服务调用流程"></a>1、源码分析Dubbo服务调用流程</h2><p>了解过Netty网络编程的童鞋们应该知道，netty的命令处理基于ChannelHandler（事件处理链），编码、网络传输、解码、处理等，下面是关于NettyServer的初始化过程，该部分在<a href="https://blog.csdn.net/prestigeding/article/details/81165691">《源码分析Dubbo网络通信篇NettyServer、HeaderExchangeServer》</a>时已经讲过，本节先做一个简单的回顾：<br><img src="https://img-blog.csdn.net/20180821120924239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p><a id="more"></a><p>根据服务暴露的协议，本文以dubbo协议为例：首先通过DubboProtocol通过export暴露服务时，会尝试创建关于该协议的Server服务器,服务器按ip:port进行缓存，本文重点关注ChannelHandler的包装链条，首先看一下NettyServer创建时关于Handler的绑定，代码如下：<br>NettyServer#doOpen</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);</span><br><span class="line">channels &#x3D; nettyHandler.getChannels();</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-365</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-379</span><br><span class="line">&#x2F;&#x2F; final Timer timer &#x3D; new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ChannelPipeline getPipeline() &#123;</span><br><span class="line">         NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">         ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">         pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());    &#x2F;&#x2F; @start</span><br><span class="line">         pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());    </span><br><span class="line">         pipeline.addLast(&quot;handler&quot;, nettyHandler);                  &#x2F;&#x2F; @end</span><br><span class="line">         return pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>可以看出，传入Netty框架的事件处理Handler主要是3个：1、解码器；2、编码器；3、业务类NettyHandler。也就是说当服务端(Server)的读事件就绪后，进行网络读写后，会将二进制流传入解码器(Decoder)，解码出一个一个的RPC请求，然后针对每一个RPC请求，交给NettyHandler相关事件处理方法去处理，在这里传入NettyHandler的ChannelHandler为NettyServer,以网络读命令为例，最终将调用NettyServer的父类AbstractPeer的received方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void received(Channel ch, Object msg) throws RemotingException &#123;</span><br><span class="line">     if (closed) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     handler.received(ch, msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>那AbstractPeer中的ChannelHandler又是“何许人也”，是通过调用NettyServer(URL url, ChannelHandler handler)中传入的，结合上图中NettyServer的构建流程，可以追溯其流程如下：</p><ol><li>DubboProtocol#createServer<br>server = Exchangers.bind(url, requestHandler);       // @1, requestHandler，为最原始的ChannelHandler，接下来整个过程都是对该handler的包装。</li><li>HeaderExchanger#bind<br>return new HeaderExchangeServer(Transporters.bind(url, new<br>DecodeHandler(new HeaderExchangeHandler(handler))));其包装顺序为 DecodeHandler 》HeaderExchangeHandler 》(DubboProtocol#requestHandler)</li><li>NettyTransporter#bind</li><li>NettyServer构造函数<br>super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));这里主要包装的是事件的派发Handler，例如AllChannelHandler、ExecutionChannelHandler【Dispatch】业务Handler最终的包装顺序为：事件派发模型handler[AllChannelHandler] 》DecodeHandler 》HeaderExchangeHandler 》 DubboProtocol#requestHandler(最终的业务Handler)。结合网络Netty的处理Handler，服务端事件Handler的处理为：DubboCodec2(解码器) 》 事件派发模型handler[AllChannelHandler] 》DecodeHandler 》 HeaderExchangeHandler》 DubboProtocol#requestHandler(最终的业务Handler)。<br>上述Handler都在前面的章节中详细介绍了，接下来重点分析服务调用流程，自然需要从DubboProtocol$requestHandler入手。<br>DubboProtocol$requestHandler#recive<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">     if (message instanceof Invocation) &#123;</span><br><span class="line">          reply((ExchangeChannel) channel, message);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">          super.received(channel, message);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>如果是服务调用，就进入到reply方法中，否则调用父类进行请求响应。<br>DubboProtocol$requestHandler#reply<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line">     if (message instanceof Invocation) &#123;</span><br><span class="line">          Invocation inv &#x3D; (Invocation) message;                                                &#x2F;&#x2F; @1</span><br><span class="line">          Invoker&lt;?&gt; invoker &#x3D; getInvoker(channel, inv);                                   &#x2F;&#x2F; @2</span><br><span class="line">          &#x2F;&#x2F; need to consider backward-compatibility if it&#39;s a callback</span><br><span class="line">          if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                String methodsStr &#x3D; invoker.getUrl().getParameters().get(&quot;methods&quot;);</span><br><span class="line">                boolean hasMethod &#x3D; false;</span><br><span class="line">                if (methodsStr &#x3D;&#x3D; null || methodsStr.indexOf(&quot;,&quot;) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                      hasMethod &#x3D; inv.getMethodName().equals(methodsStr);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                     String[] methods &#x3D; methodsStr.split(&quot;,&quot;);</span><br><span class="line">                     for (String method : methods) &#123;</span><br><span class="line">                          if (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                             hasMethod &#x3D; true;</span><br><span class="line">                             break;</span><br><span class="line">                           &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               if (!hasMethod) &#123;</span><br><span class="line">                   logger.warn(new IllegalStateException(&quot;The methodName &quot; + inv.getMethodName()</span><br><span class="line">                                + &quot; not found in callback service interface ,invoke will be ignored.&quot;</span><br><span class="line">                                + &quot; please update the api interface. url is:&quot;</span><br><span class="line">                                + invoker.getUrl()) + &quot; ,invocation is :&quot; + inv);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">         return invoker.invoke(inv);                    &#x2F;&#x2F; @3</span><br><span class="line">   &#125;</span><br><span class="line">  throw new RemotingException(channel, &quot;Unsupported request: &quot;</span><br><span class="line">                    + (message &#x3D;&#x3D; null ? null : (message.getClass().getName() + &quot;: &quot; + message))</span><br><span class="line">                    + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>代码@1：获取服务调用信息，例如调用服务类名(interface)、服务方法名、参数类型，参数值。<br>代码@2：获取调用者Invoker。<br>代码@3：调用Invoker，执行具体的方法调用。<br>上述过程非常简单，但其关键点在于Invoker，那这个Invoker到底是什么呢？<br>回顾一下我们在讲解：<a href="https://blog.csdn.net/prestigeding/article/details/80536385">Dubbo服务提供者启动流程</a>中已提到Invoker，在本篇中我们再次对该文进行补充说明。</li></ol><h2 id="2、再谈Dubbo服务提供者暴露服务（Invoker）"><a href="#2、再谈Dubbo服务提供者暴露服务（Invoker）" class="headerlink" title="2、再谈Dubbo服务提供者暴露服务（Invoker）"></a>2、再谈Dubbo服务提供者暴露服务（Invoker）</h2><h3 id="2-1-服务提供者视角看Invoker"><a href="#2-1-服务提供者视角看Invoker" class="headerlink" title="2.1 服务提供者视角看Invoker"></a>2.1 服务提供者视角看Invoker</h3><p>我们应该记得，服务提供者在暴露服务时(export)会创建Invoker，其代码片段如下：<br>ServiceConfig#doExportUrlsFor1Protocol</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">if (registryURLs !&#x3D; null &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">      for (URL registryURL : registryURLs) &#123;</span><br><span class="line">          url &#x3D; url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">          URL monitorUrl &#x3D; loadMonitor(registryURL);</span><br><span class="line">          if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">              url &#x3D; url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">          &#125;</span><br><span class="line">          if (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">          &#125;</span><br><span class="line">          Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));  &#x2F;&#x2F; @1</span><br><span class="line">          DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);     &#x2F;&#x2F; @2</span><br><span class="line">          Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);    &#x2F;&#x2F; @3</span><br><span class="line">          exporters.add(exporter);</span><br><span class="line">       &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">      DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line">      Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);</span><br><span class="line">      exporters.add(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据&lt;dubbo:service ref = “interfaceImpl” interface = “”  /&gt; 首先获取ref的代理对象，真正的服务实现类proxy，然后通过proxyFactory【JavassistProxyFactory、JdkProxyFactory】创建最原始的Invoker，即AbstractProxyInvoker，使用的是匿名实现类，即提供反射方式进行方法的调用。<br><img src="https://img-blog.csdn.net/20180821122113242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从abstract Object doInvoker(T proxy, String methodName, Class&lt; ? &gt;[] parameterTypes, Object[] arguments) 可以最终是通过对象发射方式进行方法调用。</p><p>代码@2：首先使用DelegateProviderMetaDataInvoker对AbstractProxyInvoker进行包装，主要是将ServerConfig对象与Invoker一起保存。</p><p>代码@3：根据具体协议对服务端Invoker进行导出（继续包装）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;export&#x3D;dubbo%3A%2F%2F192.168.56.1%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.56.1%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D14360%26qos.port%3D22222%26side%3Dprovider%26stub%3Dcom.alibaba.dubbo.demo.provider.DemoServiceStub%26timestamp%3D1533944510702&amp;pid&#x3D;14360&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1533944510687</span><br></pre></td></tr></table></figure><p>协议前缀:registry，故根据SPI机制，具体的协议为RegistryProtocol。<br>registry=zookeeper ：代表注册中心使用zookeeper，在连接注册中心时根据该值进行策略选择。export= dubbo://…   :  根据export，在服务端按照协议启动对应的服务端程序，该协议注意指定请求包的二进制协议，例如协议头和协议体。</p><p>按照registry协议，应该会直接调用RegistryProtocol#export，但我们忽略了Dubbo的另一机制，该部分也是在<a href="https://blog.csdn.net/prestigeding/article/details/80536385">服务提供者启动流程</a>中被遗漏。Dubbo为了对服务调用进行包装，采用了过滤器Filter 链模式，在AbstractProxyInvoker调用之前，先执行一系列的过滤器Filter，Dubbo协议默认的协议层面的过滤器代理实现为：com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper,SPI定义文件见：<br>dubbo-rpc-api/src/main/resources/METAINF/dubbo/internal/com.alibaba.dubbo.rpc.Pr<br>otocol：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">filter&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock&#x3D;com.alibaba.dubbo.rpc.support.MockProtocol</span><br></pre></td></tr></table></figure><p>ProtocolFilterWrapper#export</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">     if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">     &#125;</span><br><span class="line">     return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));    &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果协议为registry，则直接调用RegistryProtocol#expoert完成协议导出，协议为registry其含义是通过注册中心暴露，最终会根据expoert，调用具体的协议进行服务暴露，最终会再次进入该方法。<br>代码@2：如果为具体协议，例如dubbo等，则通过buildInvokerChain构建Invoker链。<br>ProtocolFilterWrapper#buildInvokerChain</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123;</span><br><span class="line">        Invoker&lt;T&gt; last &#x3D; invoker;</span><br><span class="line">        List&lt;Filter&gt; filters &#x3D; ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);    &#x2F;&#x2F; @1</span><br><span class="line">        if (!filters.isEmpty()) &#123;</span><br><span class="line">            for (int i &#x3D; filters.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                final Filter filter &#x3D; filters.get(i);</span><br><span class="line">                final Invoker&lt;T&gt; next &#x3D; last;</span><br><span class="line">                last &#x3D; new Invoker&lt;T&gt;() &#123;       &#x2F;&#x2F; @2</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public Class&lt;T&gt; getInterface() &#123;</span><br><span class="line">                        return invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public URL getUrl() &#123;</span><br><span class="line">                        return invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean isAvailable() &#123;</span><br><span class="line">                        return invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">                        return filter.invoke(next, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void destroy() &#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public String toString() &#123;</span><br><span class="line">                        return invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：加载系统配置的所有Filer，并根据作用对象（服务提供者、服务消费者），返回合适的Filter链表。、</p><p>代码@2：根据Filter构建Invoker链。<br>Dubbo默认提供的Filter在dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中定义，其内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo&#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter</span><br><span class="line">generic&#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter</span><br><span class="line">genericimpl&#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter</span><br><span class="line">token&#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter</span><br><span class="line">accesslog&#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter</span><br><span class="line">activelimit&#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span><br><span class="line">classloader&#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</span><br><span class="line">context&#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter</span><br><span class="line">consumercontext&#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter</span><br><span class="line">exception&#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br><span class="line">executelimit&#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span><br><span class="line">deprecated&#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter</span><br><span class="line">compatible&#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter</span><br><span class="line">timeout&#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter</span><br></pre></td></tr></table></figure><p>当然这些过滤器并不全是服务提供者端的，每个过滤器通过@Activate注解来定义属于服务端还是消费端。<br>Dubbo还为服务暴露(export)和服务引用(reference)提供了事件回调通知，其实现与Filter类似，其实现类为：com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper,其事件只是在服务expoert、或服务reference时执行，与调用执行的Filter不一样，因为是针对服务暴露与服务引用的事件。<br>DubboCodec2(解码器) 》 事件派发模型handler[AllChannelHandler] 》 DecodeHandler  》  HeaderExchangeHandler 》 DubboProtocol#requestHandler(最终的业务Handler) 》Filter Chain 》AbstractProxyInvoker(JavassistProxyFactory#getInvoker),通过反射进行服务端方法调用。</p><h3 id="2-2-从消费端的视角看Invoker"><a href="#2-2-从消费端的视角看Invoker" class="headerlink" title="2.2 从消费端的视角看Invoker"></a>2.2 从消费端的视角看Invoker</h3><p>从消费者的视角看Invoker，即我们常说的服务调用器，结合集群容错功能的Invoker,服务调用的门面（同一封装），例如DubboInvoker，根据dubbo协议，封装服务调用请求并通过网络向服务器发送请求包。其主要子类为AbstractInvoker、AbstractClusterInvoker（集群模式）。消费端服务发起请求时，同样会被ProtocolFilterWrapper拦截，引入调用链（获取消费端的Filter Chain）。关于消费端的Invoker，请大家参考如下两篇博文：<br><a href="https://blog.csdn.net/prestigeding/article/details/80963998">Dubbo集群容错模式</a><br><a href="https://blog.csdn.net/prestigeding/article/details/80642774">Dubbo Invoker概述</a><br><a href="https://blog.csdn.net/prestigeding/article/details/80621535">Dubbo消费者启动流程</a></p><p>综上所述，服务端的Invoker职责通过反射机制，根据服务名、方法名、参数调用方法完成服务端的响应，其类主要为com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker，客户端的Invoker职责主要是按照协议组织请求包，通过网络发送服务调用请求，其代表为AbstractInvoker、AbstractClusterInvoker。<br>服务调用的整体流程就介绍到这里了，从下一篇开始，将重点分析Dubbo Filter机制。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将重点剖析服务调用流程，也就是消费端通过网络发起RPC服务调用时，服务提供者是如何进行服务请求响应的。&lt;/p&gt;
&lt;h2 id=&quot;1、源码分析Dubbo服务调用流程&quot;&gt;&lt;a href=&quot;#1、源码分析Dubbo服务调用流程&quot; class=&quot;headerlink&quot; title=&quot;1、源码分析Dubbo服务调用流程&quot;&gt;&lt;/a&gt;1、源码分析Dubbo服务调用流程&lt;/h2&gt;&lt;p&gt;了解过Netty网络编程的童鞋们应该知道，netty的命令处理基于ChannelHandler（事件处理链），编码、网络传输、解码、处理等，下面是关于NettyServer的初始化过程，该部分在&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/81165691&quot;&gt;《源码分析Dubbo网络通信篇NettyServer、HeaderExchangeServer》&lt;/a&gt;时已经讲过，本节先做一个简单的回顾：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180821120924239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="http://example.com/categories/dubbo/"/>
    
    
    <category term="源码" scheme="http://example.com/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="http://example.com/tags/dubbo/"/>
    
    <category term="invoker" scheme="http://example.com/tags/invoker/"/>
    
  </entry>
  
</feed>
