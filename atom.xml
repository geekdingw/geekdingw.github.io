<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>中间件兴趣圈</title>
  
  <subtitle>关注微信公众号「中间件兴趣圈」，第一时间获取最新干货！</subtitle>
  <link href="https://www.codingw.net/atom.xml" rel="self"/>
  
  <link href="https://www.codingw.net/"/>
  <updated>2021-01-10T12:42:22.088Z</updated>
  <id>https://www.codingw.net/</id>
  
  <author>
    <name>中间件兴趣圈</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试官:Netty的线程模型可不是Reactor这么简单</title>
    <link href="https://www.codingw.net/posts/4ec081f3.html"/>
    <id>https://www.codingw.net/posts/4ec081f3.html</id>
    <published>2021-01-10T12:38:01.000Z</published>
    <updated>2021-01-10T12:42:22.088Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>笔者看来Netty的内核主要包括如下图三个部分：<br><img src="https://img-blog.csdnimg.cn/20210109203705225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其各个核心模块主要的职责如下：</p><ul><li><p>内存管理<br>主要提高高效的内存管理，包含内存分配，内存回收。</p></li><li><p>网通通道<br>复制网络通信，例如实现对NIO、OIO等底层JAVA API 的封装，简化网络编程模型。</p></li><li><p>线程模型</p><p>提供高效的线程协作模型。</p></li></ul><p>大家不妨回想一下在以往的面试的过程中，面试官通常会问：<strong>Netty 的线程模型是什么？</strong></p><p><strong>主从多 Reactor 模型</strong>，相信大家都能脱口而出，然后呢？就没有然后了？</p><p>线程模型在网络通信中主要解决什么样的问题？在 Netty 中又是如何解决的，Netty 的线程模型为什么如此高效？请容我慢慢道来。</p><blockquote><p>温馨提示：为了保证文章观点的严谨性，将探究领域锁定在：Netty NIO 相关。</p></blockquote><a id="more"></a><h2 id="1、主从多-Reactor-模型"><a href="#1、主从多-Reactor-模型" class="headerlink" title="1、主从多 Reactor 模型"></a>1、主从多 Reactor 模型</h2><p>主从多 Reactor 模型是业界一种非常经典的线程编程模型，其原理图如下所示：<br><img src="https://img-blog.csdnimg.cn/20210109203728396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们首先简单介绍一下上图中涉及的几个重要角色：</p><ul><li><p>Acceptor </p><p>请求接收者，在实践时其职责类似服务器，并不真正负责连接请求的建立，而只将其请求委托 Main Reactor 线程池来实现，起到一个转发的作用。</p></li><li><p>Main Reactor<br>主 Reactor 线程组，主要<strong>负责连接事件</strong>，并将<strong>IO读写请求转发到 SubReactor 线程池</strong>。当然在一些需要对客户端进行权限控制等场景下，权限校验的职责可以放到 Main Reactor 线程池，即 <strong>Main Reactor 也可以注册通道的读写事件</strong>，读取客户端权限校验相关的数据包，执行权限验证，权限验证通过后再将2通道注册到IO线程。</p></li><li><p>Sub Reactor<br>Main Reactor 通常监听客户端连接后会将通道的读写转发到 Sub Reactor 线程池中一个线程(负载均衡)，负责数据的读写。在 NIO 中 通常注册通道的读(OP_READ)、写事件(OP_WRITE)。</p></li></ul><p>为了更加深刻的理解主从 Reactor 模型，我们来看一下网络通讯一般会包含哪些关键动作：<br><img src="https://img-blog.csdnimg.cn/20210109203831368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>一个网络交互通常的几个步骤如下：</p><ul><li>服务端启动，并在特定端口上监听，例如 web 应用的 80端口。</li><li>客户端发起TCP的三次握手，与服务端建立连接，这里以 NIO 为例，连接成功建立后会创建NioSocketChannel对象。</li><li>服务端通过 NioSocketChannel 从网卡中<strong>读取数据</strong>。</li><li>服务端根据<strong>通信协议</strong>从二进制流中<strong>解码</strong>出一个个请求。</li><li>根据请求，<strong>执行对应的业务操作</strong>，例如 Dubbo 服务端接受一个查询用户ID为1的用户信息。</li><li>将业务执行结果返回到客户端，通常涉及到<strong>协议编码、压缩</strong>等。</li></ul><p><strong>线程模型需要解决的问题</strong>：连接监听、网络读写、编码、解码、业务执行这些操作步骤如何运用<strong>多线程编程</strong>，提升性能。</p><p>主从多Reactor模型是如何解决上面的问题呢？</p><ol><li><p>连接建立（OP_ACCEPT）由 Main Reactor 线程池负责，创建NioSocketChannel后，将其转发给SubReactor。</p></li><li><p>SubReactor 线程池主要<strong>负责网络的读写</strong>（从网络中读字节流、将字节流发送到网络中），即注册OP_READ、OP_WRITE，并且<strong>同一个通道会绑定一个SubReactor线程</strong>。</p></li><li><p>编码、解码、业务执行，则具体情况具体分析</p><p>通常<strong>编码、解码会放在IO线程中执行，而业务逻辑的执行通常会采用额外的线程池</strong>，但不是绝对的，一个好的框架通常会使用参数来进行定制化选择，例如 ping、pong 这种心跳包，直接在 IO 线程中执行，无需再转发到业务线程池，避免线程切换开销。</p></li></ol><blockquote><p>温馨提示：在网络编程中，通常将用于网络读写的线程称为IO线程。</p></blockquote><h2 id="2、Netty-的线程模型"><a href="#2、Netty-的线程模型" class="headerlink" title="2、Netty 的线程模型"></a>2、Netty 的线程模型</h2><p>Netty的线程模型是基于主从多Reactor模型。<br><img src="https://img-blog.csdnimg.cn/2021010920401035.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Netty 中网络的连接事件(OP_ACCEPT)由Main Reactor 线程组实现，<strong>即 Boss Group，通常只需设置一个线程</strong>。</p><p>网络的<strong>读写</strong>操作由 Work Group ( Sub Reactor) 线程组来实现，线程的个数默认为 2 * CPU Core，<strong>一个 Channel 绑定到其中一个 Work 线程，一个 Work 线程中可以绑定多个 Channel</strong>。</p><p>在 Netty 中编码、解码等操作会被封装成一个一个事件处理器(ChannelHandler)，那这些 Handler 是在IO线程池中执行？</p><p>默认情况下ChannelHandler 是在 IO 线程中执行，那如何改变默认行为呢？其关键代码如下：<br><img src="https://img-blog.csdnimg.cn/20210109204026244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>关键点</strong>：在将事件处理器添加到事件链时可以指定在哪个线程池中执行，如果不指定则为<strong>IO线程</strong>中执行。</p><p>面试官：<strong>通常业务操作会专门开辟一个线程池，那业务处理完成之后，如何将响应结果通过 IO 线程写入到网卡中呢？</strong><br><img src="https://img-blog.csdnimg.cn/20210109204041129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>业务线程调用 Channel 对象的 write 方法并不会立即写入网络，只是将数据放入一个待写入队列(缓存区)，然后IO线程每次执行事件选择后，会从待写入缓存区中获取写入任务，将数据真正写入到网络中，数据到达网卡之前会经过一系列的 Channel Handler(Netty事件传播机制)，最终写入网卡。</p><p>最后再来介绍一下 Netty 中 IO 线程的大体工作流程。<br><img src="https://img-blog.csdnimg.cn/20210109204102599.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>IO线程处理的关键点：</p><ul><li>每一IO线程在执行上述操作时是串行执行的，即注册在一个 Selector(事件选择器)中的所有通道，<strong>同一时间只有一个通道的事件被处理。</strong>这也是为什么NIO应对大文件传输时不具备优势的根本原因。</li><li>IO 线程在处理完所有就绪事件后，还会从任务队列(Task Queue)获取任务，例如上文中提到的业务线程在执行完业务后需要将返回结果写入网络，<strong>Netty 中所有的网络读写操作只能在IO线程中真正获得运行</strong>，故业务线程需要将带写入的响应结果封装成 Task，放入到 IO 线程任务队列中。</li></ul><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>回到到主题，如果我们在面试过程中碰到面试官提问“Netty 的线程模型是什么？”时，我们应该可以从容应对了。</p><p>我觉得可以从如下几个方面进行展开。</p><ol><li>Netty 的线程模型基于主从多Reactor模型。通常由一个线程负责处理OP_ACCEPT事件，拥有 CPU 核数的两倍的IO线程处理读写事件。</li><li>一个通道的IO操作会绑定在一个IO线程中，而一个IO线程可以注册多个通道。</li><li>在一个网络通信中通常会包含网络数据读写，编码、解码、业务处理。默认情况下编码、解码等操作会在IO线程中运行，但也可以指定其他线程池。</li><li>通常业务处理会单独开启业务线程池，但也可以进一步细化，例如心跳包可以直接在IO线程中处理，而需要再转发给业务线程池，避免线程切换。</li><li>在一个IO线程中所有通道的事件是<strong>串行处理</strong>的。</li></ol><hr><p>更多文章请关注[中间件兴趣圈]，回复【专栏】获取12个JAVA主流源码分析专栏；回复[PDF]可获取海量学习资料，助力职场。</p><p><img src="https://img-blog.csdnimg.cn/20210110203438586.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者看来Netty的内核主要包括如下图三个部分：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210109203705225.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其各个核心模块主要的职责如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;内存管理&lt;br&gt;主要提高高效的内存管理，包含内存分配，内存回收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网通通道&lt;br&gt;复制网络通信，例如实现对NIO、OIO等底层JAVA API 的封装，简化网络编程模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;线程模型&lt;/p&gt;
&lt;p&gt;提供高效的线程协作模型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;大家不妨回想一下在以往的面试的过程中，面试官通常会问：&lt;strong&gt;Netty 的线程模型是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主从多 Reactor 模型&lt;/strong&gt;，相信大家都能脱口而出，然后呢？就没有然后了？&lt;/p&gt;
&lt;p&gt;线程模型在网络通信中主要解决什么样的问题？在 Netty 中又是如何解决的，Netty 的线程模型为什么如此高效？请容我慢慢道来。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：为了保证文章观点的严谨性，将探究领域锁定在：Netty NIO 相关。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="netty" scheme="https://www.codingw.net/categories/netty/"/>
    
    
    <category term="Netty" scheme="https://www.codingw.net/tags/Netty/"/>
    
    <category term="面试" scheme="https://www.codingw.net/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>一文揭晓通信协议设计的奥妙，直接“秒杀“面试官</title>
    <link href="https://www.codingw.net/posts/ff6cd24b.html"/>
    <id>https://www.codingw.net/posts/ff6cd24b.html</id>
    <published>2021-01-03T14:20:39.000Z</published>
    <updated>2021-01-03T14:28:26.943Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上一篇详细介绍了Netty的编解码的基本实现原理，本节将重点探讨网络编程中一种非常通用的协议设计方法论：<strong>协议头 + 消息体</strong>。</p><p>所谓的通信协议就是通信双方共同遵循的一种“约定”，用于通信发送方将内容按照“通信协议”所规定的格式组装成<strong>“二进制流”</strong>，通信接收方按照“通信协议”所规定的格式正确的从二进制流中解码出一个个原始请求。</p><p><strong>那通信协议如何设计呢？</strong></p><a id="more"></a><h2 id="1、通用的协议设计方法论"><a href="#1、通用的协议设计方法论" class="headerlink" title="1、通用的协议设计方法论"></a>1、通用的协议设计方法论</h2><p>在网络编程中，流行这一种经典的协议设计方法论：协议头 + 消息体。<br><img src="https://img-blog.csdnimg.cn/2021010315133342.png#pic_center" alt="在这里插入图片描述">其设计的关键点如下：</p><ul><li><strong>协议头的长度是固定的</strong>，通常为<strong>识别</strong>出<strong>一个业务的最小长度</strong>。</li><li>协议头中会包含一个<strong>长度字段</strong>，用来标识一个完整包的长度，用来表示长度字段的字节位数直接决定了一个包的最大长度，长度字段通常被设计为4个字节。</li><li>消息体中存储业务数据，例如如果是一个Dubbo协议，那消息体中可能会包含请求参数、调用的服务名等，而且字符串类的存储通常会采取字段长度、字段内容的组织方式。</li></ul><p>为了有一个更直观的展示，我以一个简单的RPC通信场景为例，实现类似Dubbo服务的远程服务调用，其通信协议可以简单设置成下图所示：<br><img src="https://img-blog.csdnimg.cn/2021010315383066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>基于 Header + Boby 的通信协议设计模式后，通信接受方就能很好的从二进制流中非常容易的解码出一条一条原始的请求数据包，解码的基本套路如下(<strong>在面试中面试官非常喜欢问的“粘包”问题的破解之道</strong>)</p><ul><li>首先判断<strong>累积缓存区</strong>中是否存在一个<strong>完整的Head头部</strong>，例如上述示例中，一个包的Header的长度为6个字节，那首先判断累积缓存中可读字节数是否大于等于6，<strong>如果不足6个字节，跳过本次处理，等待更多数据到达累积缓存区</strong>。</li><li>尝试将头部6个字节读取，并且<strong>提取长度字段中存储的数值</strong>，即包长度，然后判断累积缓存区中可读字节数大于等于整个包的长度，<strong>如果累积缓存区不包含一个完整的数据包，则跳过本次处理，等待更多数据到达累积缓存区。</strong></li><li>如果包含一个完整的包，则按照通信协议的格式按序读取相关的内容。</li></ul><p>正是因为这种设计理念非常通用，Netty 对上述协议设计进行了统一封装：LengthFieldBasedFrameDecoder 闪亮登场了，<strong>接下来我们来看看Netty是如何进行封装的，揭晓更多的实现细节，让大家做到理论与实践相结合。</strong></p><h2 id="2、LengthFieldBasedFrameDecoder-详解"><a href="#2、LengthFieldBasedFrameDecoder-详解" class="headerlink" title="2、LengthFieldBasedFrameDecoder 详解"></a>2、LengthFieldBasedFrameDecoder 详解</h2><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p><img src="https://img-blog.csdnimg.cn/20210103161101564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来对其核心属性进行一个详细的解读：</p><ul><li>ByteOrder byteOrder<br>字节序列，Netty默认使用大端序列（主要是针对int、long等数值类型），所谓的大端序列，通常可以这样理解，接收端收到的字节流的顺序是从数值类型的高字节。</li><li>int maxFrameLength<br>一条消息最大的长度。</li><li>int lengthFieldOffset<br>代表长度字段的开始偏移量。</li><li>int lengthFieldLength<br>代表长度字段占用的字节长度。</li><li>int lengthFieldEndOffset<br>代表长度字段的结束偏移量，等于lengthFieldOffset + lengthFieldLength。</li><li>int lengthAdjustment<br>长度适配适配值。该值表示协议中长度字段与消息体字段直接的距离。</li><li>int initialBytesToStrip<br>跳过一个包中前面多少个字节不处理，<strong>通常是将协议头部跳过，只将消息体中内容传输到下游时使用</strong>。</li><li>boolean failFast<br>是否快速失败。</li><li> boolean discardingTooLongFrame<br>是否吞没（跳过）大帧包。</li><li>long tooLongFrameLength<br>当前在处理吞没大包的实际大小。</li><li>long bytesToDiscard</li></ul><p><strong>下一次解码之前，需要先忽略的字节数</strong>，当遇到超过maxFrameLength的包时使用。</p><p>上面的属性如果不太好理解，没关系，**因为本节的最后会有两张图勾画出协议的全貌(用图示的方式勾画出各个属性的位置与含义)**。</p><h4 id="2-2-decode-方法详解"><a href="#2-2-decode-方法详解" class="headerlink" title="2.2 decode 方法详解"></a>2.2 decode 方法详解</h4><p>接下来我们来看一下其decode方法，通过阅读源码的方法来理解其内部的工作原理。</p><p>LengthFieldBasedFrameDecoder#decode<br><img src="https://img-blog.csdnimg.cn/20210103162758778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：跳过无效数据包的处理逻辑。如果<strong>discardingTooLongFrame</strong>为true，表示正在处理<strong>大于**</strong>maxFrameLength<strong>的包，需要跳过这个超长的包，不对其解码，由于数据是陆续到达累积缓存区，并不能一次跳过整个无效包，故需引入 bytesToDiscard 变量，用于记录本次能跳过的字节，当 bytesToDiscard 为 0后表示一个无效包已全部跳过，需要处理正常数据包，此时discardingTooLongFrame 会重置为 false。<br><img src="https://img-blog.csdnimg.cn/20210103163914626.png" alt="LengthFieldBasedFrameDecoder#decode"><br>Step2：</strong>如果累积缓冲区的可读字节大小小于length字段的结束偏移量<strong>，返回null，结束解码，说明该累积缓存区中的数据还不完整。<br><img src="https://img-blog.csdnimg.cn/20210103164503153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step3：尝试从累积缓存区中获取包的长度。其中表示 lengthFiedlOffset 表示长度字段的其实偏移量，在结合长度字段的长度 lengthFieldLength ，再结合字节序列</strong>（大端序列、小端序列）**。<br><img src="https://img-blog.csdnimg.cn/2021010316591174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step4：这里是包长度超过协议允许的最大包长度时的处理逻辑，再这里大家先姑且跳过 lengthAdjustment 属性的含义。</p><ul><li>如果当前累积缓存区中的可读字节大于 frameLength，大于当前包的长度，可以通过调用 skipBytes 方法跳过这包。</li><li>如果当前累积缓存区的可读自己小于 frmaeLength，需要分多次跳过，故先将累积区中的数据全部跳过，然后通过 bytesToDiscard 记录还需要跳过的字节数。</li></ul><p><img src="https://img-blog.csdnimg.cn/20210103173012169.png#pic_center" alt="在这里插入图片描述"><br>Step5：<strong>如果累积缓存区中的数据不包含一个完整的包，返回null，结束本次解码，等待更多的数据包到到来。</strong><br><img src="https://img-blog.csdnimg.cn/20210103174100193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step6：通过 ByteBuf 的 slince 方法，提取一个完整的包长度，解码出完整的数据包，完成一个数据包解码。</p><h4 id="2-3-图解-LengthFieldBasedFrame-协议"><a href="#2-3-图解-LengthFieldBasedFrame-协议" class="headerlink" title="2.3 图解 LengthFieldBasedFrame 协议"></a>2.3 图解 LengthFieldBasedFrame 协议</h4><p>在Netty 的 LengthFieldBasedFrameDecoder 中有一个 lengthAdjustment 属性，可以是正数，也可以是负数，其使用的代码片段如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameLength += lengthAdjustment + lengthFieldEndOffset</span><br></pre></td></tr></table></figure><p>lengthAdjustment 长度调整字段，可以为正数，也可以为负数，主要的作用是 长度字段中的值是否包含 Header 长度本身，严格意义上来说应该是包含 长度字段之前的字节序列。</p><p>1、lengthAdjustment &gt; 0<br><img src="https://img-blog.csdnimg.cn/20210103210634448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2、lengthAdjustment &lt; 0<br>在大多数情况下，length字段表示消息正文的长度，但是有些协议，其长度表示的是整个消息的长度，故Netty为了适配这种情况，可以通过 lengthAdjustment 设置为负数，来调节数据帧的大小。<br><img src="https://img-blog.csdnimg.cn/20210103211439214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>总结</strong>：lengthAdjustment 的出现是Netty<strong>为了适配现有的协议而设计出来的字段</strong>，即 Netty LengthFieldBasedFrameDecoder 是为了i给 header + body ，并且基于长度字段的协议一种通用的解决方案，可以通过 lengthAdjustment 来准确表示数据帧(业务数据的长度)，这里是一种<strong>逆向思维</strong>。</p><h2 id="3、协议设计子类的最佳实践"><a href="#3、协议设计子类的最佳实践" class="headerlink" title="3、协议设计子类的最佳实践"></a>3、协议设计子类的最佳实践</h2><p><strong>最佳实践：</strong> LengthFieldBasedFrameDecoder 的 decode 方法的职责是从二进制流中解码出一个完整的数据包，其返回类型还是 ByteBuf，故自定义的编码解码器的 decode 方法就是先调用父类的 decode 方法 得到 ByteBuf ，然后对 ByteBuf 中的数据解码出对象。</p><p>即 LengthFieldBasedFrameDecoder 并不负责将 ByteBuf 转换为协议对象，而是从二进制流中解码出一个数据帧，而将ByteBuf 转换为协议对象的职责由其子类实现，通常的编码风格如下：<br><img src="https://img-blog.csdnimg.cn/20210103212109895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><hr><p>更多文章建议关注『中间件兴趣圈』，回复【专栏】获取12个JAVA主流中间件源码剖析，并包含大量实战案例、架构设计理念；回复【PDF】可获取海量学习资料，助力突破职场瓶颈。</p><p><img src="https://img-blog.csdnimg.cn/20201231115902671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇详细介绍了Netty的编解码的基本实现原理，本节将重点探讨网络编程中一种非常通用的协议设计方法论：&lt;strong&gt;协议头 + 消息体&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所谓的通信协议就是通信双方共同遵循的一种“约定”，用于通信发送方将内容按照“通信协议”所规定的格式组装成&lt;strong&gt;“二进制流”&lt;/strong&gt;，通信接收方按照“通信协议”所规定的格式正确的从二进制流中解码出一个个原始请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那通信协议如何设计呢？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="netty" scheme="https://www.codingw.net/categories/netty/"/>
    
    <category term="网络编程" scheme="https://www.codingw.net/categories/netty/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    <category term="通讯协议" scheme="https://www.codingw.net/categories/netty/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>图文并茂剖析Netty编解码以及背后的设计理念</title>
    <link href="https://www.codingw.net/posts/cd43c662.html"/>
    <id>https://www.codingw.net/posts/cd43c662.html</id>
    <published>2020-12-31T04:06:35.000Z</published>
    <updated>2020-12-31T04:04:23.223Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文主要介绍网络通信中与通信息息相关的重要部分：通信协议的底层实现原理：<strong>编码与解码</strong>。</p><blockquote><p>温馨提示：源码分析或许比较枯燥，在浏览的过程中建议重点关注<strong>黑色</strong>字体与<strong>流程图</strong>，是<strong>根据源码进行的提炼</strong>，突出源码背后的<strong>设计理念</strong>。</p></blockquote><a id="more"></a><h2 id="1、Netty4编码解码概述"><a href="#1、Netty4编码解码概述" class="headerlink" title="1、Netty4编码解码概述"></a>1、Netty4编码解码概述</h2><p>Netty中定义的编码解码器核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20201230195200318.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Decoder(解码器) 继承自 Inbound 事件处理器，而Encoder(编码器)继承自Outbound事件处理器。</strong></p><p>其实不难理解，以服务端接收请求、返回响应结果的视角来看这个问题：</p><p>当服务端通过网络IO接收到字节序列时，从底层网络套接字中将字节流读取到接受缓存区(ByteBuf)，服务端的职责首先需要从<strong>二进制流中解码</strong>出一个<strong>完整的请求</strong>，然后“读懂请求”的含义进行对应的业务逻辑处理，处理完毕后首先需要将响应结果(通常为JSON字符串)<strong>编码成二级制流</strong>，通过网络进行传递，客户端收到二进制流后同样进行解码。</p><p><strong>解码</strong>：针对的是输入，故继承 InBound 入端事件。<br><strong>编码</strong>：针对的是输出，故继承 OutBound 出端事件。</p><p>了解了上述基本点后，接下来对上述核心类一一做个介绍：</p><ul><li>ByteToMessageDecoder<br>解码器，将字节流解码成消息(message)。</li><li>MessageToByteEncoder<br>编码器，将消息(message)编码成字节流。</li><li>MessageToMessageEncoder<br>编码器,将消息编码成”另一种消息“，更通用，”另一种消息“由泛型指定。</li><li>MessageToMessageDecoder<br>解码器，将消息解码成“另一种消息”，更通用，“另一种消息”由泛型指定。</li></ul><p>下面介绍Netty4<strong>自带的协议解码器</strong>，是<strong>ByteToMessageDecoder</strong>的子类。</p><ul><li>LineBasedFrameDecoder<br>基于换行符的分隔符，使用\n或\r\n分隔符来标志一个字节序列的结束。</li><li>DelimiterBasedFrameDecoder<br>基于自定义的分隔符，使用定义的分隔符来标志一个字节序列的结束。</li><li>FixedLengthFrameDecoder<br>固定长度的编码器。在实际使用时，如果单条消息不足定义的长度，通常需要人为填充。</li><li>LengthFieldBasedFrameDecoder<br>基于长度字段的协议，通过指定一个长度字段，该字段的存储字节固定，例如3个字节或4个字节等，然后该字段中存储消息的长度，这样在解码时可以非常方便的判断一条消息的长度，这是一个非常经典的client-server协议格式，下面会对其进行详细解读。</li></ul><h2 id="2、源码分析解码器实现原理"><a href="#2、源码分析解码器实现原理" class="headerlink" title="2、源码分析解码器实现原理"></a>2、源码分析解码器实现原理</h2><p>ByteToMessageDecoder 是 Netty 解码器实现的基类，典型的模板设计模式。</p><p><strong>解码器引入的目的</strong>是为了<strong>解决网络编程中的“粘包问题”</strong>，网络传输基于字节流，客户端多个线程通过一条长连接向服务端发送多个请求，服务端在处理命令之前如何正确拆解出一条完整的请求信息呢？</p><p>例如客户端A的三个线程t1、t2、t3 使用同一条连接(类比Dubbo客户端)发送了3个请求，内容分别为 A, BCD, E 。</p><p>服务端基于NIO来处理，当请求陆续到达服务端的接受缓存区，NIO 读事件触发，可能第一次网络读，从网络中读取的内容为AB字节序列(包含第一个请求包全部，第二个请求包部分)，紧接着再读取CDE序列，如果服务端每接受到一部分数据就当成一个完整的请求去处理的话，明显与客户端原始请求存在差别。</p><p>故为了解决服务端、客户端能对同一个字节流具有相同的理解语义，所谓的<strong>通信协议</strong>因此诞生了，通俗一点就是客户端、服务端如果界定一个完整请求包。</p><p>最常见的几种协议：</p><ul><li>每一行一个数据包，即在每一个请求包最后以 /r/n 结尾</li><li>固定长度，请求内容不足使用特殊字符填充</li><li>协议头 + 协议体 ，其中协议头定长，并且内部会含有一个表示包长度的字段。</li></ul><blockquote><p>上述具体协议，将在下篇文章中如何定制私有化协议(编码解码)</p></blockquote><p>接下来将通过阅读源码的方式探究Netty中解码的实现原理，<strong>并总结其核心设计关键点</strong>。</p><p>ByteToMessageDecoder Netty 网络解码器的模板父类， Netty 的扩展是基于事件链机制，即解码器实现的是 InBound 事件处理器。</p><p><strong>在阅读解码器实现原理的同时，大家可以关注一个解码器实现的事件方法，再次感悟一下不同场景应该选用实现哪个事件方法。</strong></p><h4 id="2-1-channelRead"><a href="#2-1-channelRead" class="headerlink" title="2.1 channelRead"></a>2.1 channelRead</h4><p>通道读时间，Netty底层通过Nio Socket 读取到的字节序列后通过传播 channelRead 事件，让上层的事件处理器对接受到的数据进行处理，解码器的职责就是从二进制流中解码出一条条消息。</p><p>其处理的代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201230214650227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上面的实现要点如下：<br>代码@1：对待处理数据类型进行判断，如果是ByteBuf，则尝试从流中解码请求，如果不是合适的类型，直接调用ctx.fireChannelRead 方法继续向事件链进行传播。</p><p>代码@2：构造CodecOutputList out对象，用来存储经过该解码器解码出来的的消息，其内部数据结构为List。</p><p>代码@3：如果该解码器中的接收缓冲区(累积缓存区)为空，表示第一次接码消息，设置 first 为 true，并直接将接收到的数据设置为接收缓存区。</p><p>代码@4：如果当前累积缓存区不为空，需要计算累积缓存区是否能容纳当前接收到的数据，如果无法存储，则需要对累积缓存区进行扩容，<strong>扩容的套路就是先申请一个容量大的缓存区，然后将原先的累积缓存区中的数据复制到新的缓存区，然后释放旧的缓存区。</strong></p><p>代码@5：调用callDecode方法对累积缓存区中的数据，进行尝试解码，将解码后的结果存放在out对象中(稍后会对该方法详细进行讲解)。</p><p>在调用完用户自定义的协议解码后，<strong>开始进行资源的回收逻辑</strong>。</p><p>代码@6：如果累积缓存区不为空，并且读写缓存区中所有的数据已全部处理，重置numReads与累积缓存区cumulation。</p><p>代码@7：如果 numReads 超过 discardAfterReads，需要对累积缓存去进行压缩</p><p><strong>设计目的：主要是避免内存泄漏，节省内存空间。 numReads 表示的含义是对累积缓存区解码的次数，如果多次解码都未全部将累积缓存区全部处理完成，当新的数据到达累积缓存区，极大可能需要进行扩容，从而造成累积缓存区的膨胀，如果不丢弃已处理的数据，及时释放内存空间，避免扩容，否则会导致累积缓存区无限扩容，内存资源得到极大的消耗。</strong></p><p>代码@8：将解码后的请求继续向事件链进行传播，例如业务处理器，业务处理器可以基于请求对象进行编码的根本原因就是首先进入的解码器，解码出一个一个请求后，业务处理器根据请求进行对应的业务逻辑处理。</p><p>代码@9：处理完后，对out结果list对象进行回收，这里使用了Netty的对象缓存机制（对象池）。</p><p>接下来探究一下 callDecode 的核心实现逻辑：<br><img src="https://img-blog.csdnimg.cn/20201230225925317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>该方法的实现要点如下：<br>代码@1：首先对参数进行一个详细介绍：</p><ul><li>ChannelHandlerContext ctx：事件处理器链当前处理器的上下文环境。</li><li>ByteBuf in：累积缓存区。</li><li>List&lt; Object &gt; out：解码后的结果列表。</li></ul><p>代码@2： while (in.isReadable()) ，NIO读取经典写法，判断读缓存区是否还有可读字节，从@3到@8都是对该缓存区的处理。</p><p>代码@3：由于这里处于一个循环中，一次循环后如果out解码结果列表不为空，<strong>会立即将解码后的请求</strong>通过调用 fireChannelRead 向后面的事件处理其传播。</p><p>代码@4：oldInputLength，当前累积缓存区可读大小。</p><p>代码@5：decode 该方法是一个抽象方法，尝试从累积缓存区中解码出完整的请求，由具体的<strong>协议实现类</strong>去实现。</p><p>代码@6,7：如果累积缓存区中不包含一条完整的请求，本次解码结束，等待更多数据到达接受缓存区(<strong>下一次读事件触发，继续通过网络读API从Socket中读取字节流</strong>)。</p><p>代码@8：如果singleDecode=true，表示不支持多次解码，故跳出。</p><p>为了加深理解上述流程，Netty 解码器的核心实现流程如下：<br><img src="https://img-blog.csdnimg.cn/20201230231134883.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="2-3-channelReadComplete-事件"><a href="#2-3-channelReadComplete-事件" class="headerlink" title="2.3 channelReadComplete 事件"></a>2.3 channelReadComplete 事件</h4><p>通道读完成事件，这是每一次读就绪事件处理完成后，会传播该事件。<br><img src="https://img-blog.csdnimg.cn/20201230231746117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在每一次读处理完成后，Netty为了保证累积缓存区不至于浪费空间，进行一次压缩，其设计理念在上文已提到。</p><h4 id="2-4-channelInactive事件"><a href="#2-4-channelInactive事件" class="headerlink" title="2.4 channelInactive事件"></a>2.4 channelInactive事件</h4><p>通道在非激活状态时会触发该事件。<br><img src="https://img-blog.csdnimg.cn/20201230232436368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：尝试通过调用 channelInputClosed方法最后尝试进行解码。<br>代码@2：如果累积缓存区不为空，释放累积缓存区。<br>代码@3：传播一次通道读事件。<br>代码@4：如果代码@1在通道非激活时还解码到新数据了，则传播一次通道完成度事件。<br>代码@5：根据callChannelInactive参数，决定是否传播通道非激活事件。<br><img src="https://img-blog.csdnimg.cn/20201230232809664.png#pic_center" alt="在这里插入图片描述"><br>代码@1：如果累积缓冲区不为空，则调用callDecode方法，对累积缓存区进行解码，因为累积缓存区中的数据的读取已经和底层网络通道无关了，通道关闭后，该部分数据还是要尽量处理。</p><p>代码@2：再解码一次，由于这个方法，是直接调用抽象方法decode，最终解码的结果放在out中，解码后，如果有消息，最终还会触发一次通道读事件和通道读完成事件。</p><h4 id="2-5-handlerRemoved-事件"><a href="#2-5-handlerRemoved-事件" class="headerlink" title="2.5 handlerRemoved 事件"></a>2.5 handlerRemoved 事件</h4><p>handlerRemoved事件，该事件的触发有两种情况：</p><ul><li>在调用handlerAdd事件失败后，接着调用handlerRemoved事件。</li><li>在通道关闭后，DefaultChannelPipeline 的 HeadContext 的 channelUnregistered 中传播完通道事件取消注册事件后，会销毁注册在该通道上的事件注册器，此时也会触发handlerRemoved事件。</li></ul><p><img src="https://img-blog.csdnimg.cn/20201230233351223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从实现来看，也非常简单，就是将累积缓存区中未处理的数据传播到其下游的事件处理器，传播之后再从事件链中移除，体现了其“高度负责”的一面。</p><p><strong>对于解码的核心设计理念再做一个总结：</strong></p><ul><li>引入累积缓存区，存储从网络底层接受的数据。</li><li>对累积缓存区中的数据尝试解码，如果能解码出一条请求，就解码并将数据传入到后续处理器。</li><li>如果累积缓存区中不包含一条完整的消息，则结束本次解码，等待后续更多的数据到达缓存区。</li></ul><p><strong>那问题又来了，如何判别累积缓存区中是否包含一条完整的消息呢？如何进行协议的设计呢？</strong></p><p><strong>此部分内容将在下文：如何使用Netty设计一款通信协议。</strong></p><h2 id="3、源码分析编码器实现原理"><a href="#3、源码分析编码器实现原理" class="headerlink" title="3、源码分析编码器实现原理"></a>3、源码分析编码器实现原理</h2><p>Netty将消息(请求对象、响应结果) 按特定格式转换为二进制流。<br>MessageToByteEncoder的核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20201230234244975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其核心属性如下：</p><ul><li>private final TypeParameterMatcher matcher<br>参数类型匹配器，其实就是匹配MessageToByteEncoder的泛型参数。</li><li>private final boolean preferDirect<br>在解码时，是否倾向与使用堆外内存。</li></ul><p>MessageToByteEncoder是outbound处理器，只需 wrtie 事件做处理。<br><img src="https://img-blog.csdnimg.cn/2020123023464832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：如果待处理的对象类型符合该编码器期待的类型，则对数据进行编码，否则直接调用ctx.write方法@6，传播write事件。<br>代码@2：根据是否使用堆外内存，使用内存分配器分配堆内存或堆外内存， 其bufer默认的大小为256字节。<br>代码@3：根据协议将数据编码到ByteBuf中，由协议设计者去实现。<br>代码@4：<strong>对输入参数进行回收</strong>。<strong>因为经过该方法的处理，已经将输入参数转换为其他形式的数据，该数据的生命周期结束了</strong>，尝试回收(引用计数法)。<br>代码@5：如果byteBuf可读，则将这些数据传播到下一个事件处理器处理。<br>代码@7：对内存进行回收。</p><hr><p>更多文章建议关注『中间件兴趣圈』，获取12个JAVA主流中间件源码剖析，并包含大量实战案例、架构设计理念。</p><p><img src="https://img-blog.csdnimg.cn/20201231115902671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍网络通信中与通信息息相关的重要部分：通信协议的底层实现原理：&lt;strong&gt;编码与解码&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：源码分析或许比较枯燥，在浏览的过程中建议重点关注&lt;strong&gt;黑色&lt;/strong&gt;字体与&lt;strong&gt;流程图&lt;/strong&gt;，是&lt;strong&gt;根据源码进行的提炼&lt;/strong&gt;，突出源码背后的&lt;strong&gt;设计理念&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="netty4" scheme="https://www.codingw.net/categories/netty4/"/>
    
    
    <category term="netty" scheme="https://www.codingw.net/tags/netty/"/>
    
    <category term="编码" scheme="https://www.codingw.net/tags/%E7%BC%96%E7%A0%81/"/>
    
    <category term="通信协议" scheme="https://www.codingw.net/tags/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>从年末生产故障解锁RocketMQ集群部署最佳实践</title>
    <link href="https://www.codingw.net/posts/8956924f.html"/>
    <id>https://www.codingw.net/posts/8956924f.html</id>
    <published>2020-12-27T02:06:35.000Z</published>
    <updated>2020-12-27T02:18:22.267Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>笔者比较“悲催”，临近年末由笔者维护的生产MQ集群中的一台物理机内存故障导致操作系统异常重启，持续10分钟中出现众多的应用发送客户端出现发送消息超时，导致事故并定性为S1，笔者的“年终奖”。。。</p><h2 id="1、故障描述"><a href="#1、故障描述" class="headerlink" title="1、故障描述"></a>1、故障描述</h2><p>RocketMQ 集群采取的部署架构为2主2从，其部署架构如下图所示：<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传<br><img src="https://img-blog.csdnimg.cn/20201227093130257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其部署架构中一个非常明显的特点是一台物理机上分别部署了 nameserver，broker 两个进程。</p><p>其中一台机器(192.168.3.100)的内存出现故障，导致机器重启，但Linux操作系统由于重启需要自检等因素，整个重启过程竟然持续了将近10分钟，客户端的发送超时持续10分钟，这显然是不能接受的！！！</p><p>RocketMQ的高可用设计何在？接下来我们将详细介绍其分析过程。</p><a id="more"></a><h2 id="2、故障分析"><a href="#2、故障分析" class="headerlink" title="2、故障分析"></a>2、故障分析</h2><p>当得知一台机器故障导致故障持续10分钟，我的第一反应是不应该呀，因为 RocketMQ 集群是分布式部署架构，天然支持故障发现与故障恢复，消息发送客户端能自动感知 Broker 异常的的时间绝对不会超过10分钟，那故障又是怎么发生的呢？</p><p>首先我们先来回顾一下RocketMQ的路由注册与发现机制。</p><h4 id="2-1-RocketMQ路由注册与剔除机制"><a href="#2-1-RocketMQ路由注册与剔除机制" class="headerlink" title="2.1 RocketMQ路由注册与剔除机制"></a>2.1 RocketMQ路由注册与剔除机制</h4><p><img src="https://img-blog.csdnimg.cn/20201227093154348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其路由注册、剔除机制说明如下：</p><ul><li>集群中所有Broker每隔30s向集群中所有的NameServer发送心跳包，注册Topic路由信息。</li><li>NameServer在收到Broker端的心跳包时首先会更新路由表，并记录收到心跳包的时间。</li><li>NameServer会启动一个定时任务每10s会扫描Broker，如果Nameserver连续120s未收到Broker的心跳包，会判定Broker已下线，将从路由表中将该Broker移除。</li><li>如果Nameserver与Broker端的长连接断开，NameServer会立即感知Broker下线并从路由表中将该Broker移除。</li><li>消息客户端(消息发送者、消息消费者)在任意时刻只会和其中一台NameServer建立连接，并每隔30s向NameServer查询路由信息，如果查询到结果会更新发送者的本地路由信息。</li></ul><p>从上述的路由注册、剔除机制来看，当一台Broker服务器宕机，消息发送者感知路由信息发生变化需要的时间是多长呢？</p><p>分如下两种情况分别讨论：</p><ul><li>NameServer与Broker服务器TCP连接断开，此时NameServer能立即感知路由信息变化，将其从路由表中移除，从而消息发送端应该在30s左右就能感知路由发送变化，在此30s内在发送端会出现消息发送失败,但结合发送规避机制，并不会对发送方带来重大故障，可接受。</li><li>如果NameServer与Broker服务器的TCP连接未断开，但Broker已无法提供服务(例如假死)，此时NameServer需要120s才能感知Broker宕机，此时消息发送端最多需要150s才能感知其路由信息的变化。</li></ul><p><strong>但问题来了，为什么在生产实际过程中一台Broker由于内存故障重启,10分钟后重启成功后业务才恢复，即业务才真正感知Broker宕机呢？</strong></p><p>既然出现了，我们就需要对其进行分析，给出解决方案，避免不会在生产环境出现同类型的错误。</p><h4 id="2-2-故障排查经过"><a href="#2-2-故障排查经过" class="headerlink" title="2.2 故障排查经过"></a>2.2 故障排查经过</h4><p>先查询客户端的日志(/home/{user}/logs/rocketmqlogs/rocketmq_client.log)，从中可以看到从客户端第一次报消息发送超时的时间是14:44，其日志输出如下：<br><img src="https://img-blog.csdnimg.cn/2020122709322326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>由于192.168.3.100机器内存故障，故首先去查看该集群中其他nameserver中的日志，看正常机器中的NameServer感知broker-a故障的时长，其日志如下所示：<br><img src="https://img-blog.csdnimg.cn/20201227093237477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从中可以看出192.138.3.101的nameserver基本在2分钟左右才感知其宕机，即虽然机器在重启，但可能由于操作系统要做硬件自检等其他原因，TCP连接并未断开，故nameserver在120s后才感知其宕机，从路由信息表中将该broker移除，那按照路由剔除机制，客户端应该在150秒的时间内感知其变化，那为什么没感知呢？</p><p>继续查看客户端路由信息，查看客户端感知路由信息发生变化的时间点，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093255965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从客户端日志来看，客户端在14:53:46才感知其变化，这又是为什么呢？</p><p><strong>原来客户端在更新路由信息时报超时异常，其截图如下所示：</strong>：<br><img src="https://img-blog.csdnimg.cn/20201227093317856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从发生故障到故障恢复期间，客户端一直尝试从已发生故障的NameServer去更新路由信息，但一直返回超时，这样就导致了客户端一直无法获取最新的路由信息，故一直无法感知已宕机的Broker。</p><p><strong>从日志分析来看，到目前来说就比较明朗了，客户端之所有没有在120s之内感知其路由信息的变化，是因为客户端一直尝试从已宕机的nameserver去更新路由信息，但由于一直无法请求成功，故客户端的缓存路由信息一直无法得到更新，造成了上面的现象</strong></p><p>那问题来了，按照我们对RocketMQ的认识，NameServer宕机，客户端会自动去从nameserver列表中选择下一个nameserver，<strong>那为什么这里并没有发生nameserver切换</strong>，而是等到14:53才切换呢？</p><p>接下来我们将目光投向NameServer的切换代码，其代码片段如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093337453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中的几个关键分析如下：</p><ul><li>客户端能通过缓存中的连接发送RPC请求的前提条件是channel的isActive方法返回true，即底层TCP连接处于激活状态。</li><li>在客户端向服务端发起RPC请求时，如果出现非超时类异常，会执行closeChannel方法，该方法会关闭连接并从连接缓存表中移除，这个非常关键，因为在切换NameServer时如果缓存中存在连接并连接处于激活状态，就不会切换nameserver。</li><li>如果发送RPC超时，rocketmq会根据clientCloseSocketIfTimeout参数来决定是否关闭连接，但遗憾的是该参数默认为false，并且并未提供修改的入口。</li></ul><p>那问题分析到这里，已经非常明了，由于机器内存故障触发重启并且重启前需要自检等因素，造成nameserver,broker无法再处理请求但底层TCP连接并未断开，导致发生超时错误，但客户端并不会关闭与故障机器nameserver的TCP连接，导致无法切换，等到机器重新启动后，TCP连接断开，故障机器重启完成后感知路由信息变化，故障恢复。</p><p><strong>经过上面的问题分析，其故障原因如下</strong>：<br>192.168.3.100机器在内存故障后重启，整个重启耗时10分钟，并且在重启过程中TCP连接未断开，192.168.3.101 nameserver在故障发送时2分钟左右才感知路由变化，但部分客户端时连接192.168.3.100的nameserver，客户端尝试从该nameserver查询路由信息，但一直返回超时，<strong>由于没有关闭连接，导致客户端并不会切换到</strong>3.101的nameserver，直到客户端与nameserver的TCP连接断开后，切换到另外一个3.101的nameserver，故障在指定时间内得以恢复。</p><p><strong>根本原因：其实是nameserver的假死导致路由信息无法更新。</strong></p><h2 id="3、最佳实践"><a href="#3、最佳实践" class="headerlink" title="3、最佳实践"></a>3、最佳实践</h2><p>经过上面的故障，个人觉得nameserver不应该与broker部署在一起，如果nameserver与broker并不部署在一起，上面的问题能得到有效避免，其部署架构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093642967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这样的部署架构如果面对上面的故障，Broker假死的情况，能有效避免吗？答案是可以的。</strong></p><p>如果192.168.3.100的broker假死，那么3.110,3.111的nameserver都能在2分钟内感知broker-a宕机，然后客户端能成功从nameserver处获得最新的路由信息，如果nameserver假死，出现超时错误，只要broker不宕机，则通过缓存，还是能正常工作的，<strong>但如果nanmeserver,broker一起假死，则上述架构还是无法规避上面的问题</strong>。</p><p><strong>故本次的最佳实践主要包含如下两条</strong>：<br>1、nameserver与broker一定要分开部署，进行隔离。<br>2、nameserver与客户端的连接，应该在超时后，关闭连接，触发nameserver漂移，需要修改源码。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;笔者比较“悲催”，临近年末由笔者维护的生产MQ集群中的一台物理机内存故障导致操作系统异常重启，持续10分钟中出现众多的应用发送客户端出现发送消息超时，导致事故并定性为S1，笔者的“年终奖”。。。&lt;/p&gt;
&lt;h2 id=&quot;1、故障描述&quot;&gt;&lt;a href=&quot;#1、故障描述&quot; class=&quot;headerlink&quot; title=&quot;1、故障描述&quot;&gt;&lt;/a&gt;1、故障描述&lt;/h2&gt;&lt;p&gt;RocketMQ 集群采取的部署架构为2主2从，其部署架构如下图所示：&lt;br&gt;[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227093130257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;其部署架构中一个非常明显的特点是一台物理机上分别部署了 nameserver，broker 两个进程。&lt;/p&gt;
&lt;p&gt;其中一台机器(192.168.3.100)的内存出现故障，导致机器重启，但Linux操作系统由于重启需要自检等因素，整个重启过程竟然持续了将近10分钟，客户端的发送超时持续10分钟，这显然是不能接受的！！！&lt;/p&gt;
&lt;p&gt;RocketMQ的高可用设计何在？接下来我们将详细介绍其分析过程。&lt;/p&gt;</summary>
    
    
    
    <category term="RocketMQ" scheme="https://www.codingw.net/categories/RocketMQ/"/>
    
    <category term="故障分析" scheme="https://www.codingw.net/categories/RocketMQ/%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90/"/>
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/tags/rocketmq/"/>
    
    <category term="故障" scheme="https://www.codingw.net/tags/%E6%95%85%E9%9A%9C/"/>
    
    <category term="假死" scheme="https://www.codingw.net/tags/%E5%81%87%E6%AD%BB/"/>
    
    <category term="集群部署" scheme="https://www.codingw.net/tags/%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>源码阅读方法、误区与三种境界</title>
    <link href="https://www.codingw.net/posts/5cfc78e.html"/>
    <id>https://www.codingw.net/posts/5cfc78e.html</id>
    <published>2020-12-20T10:31:26.000Z</published>
    <updated>2020-12-20T10:32:50.588Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>在技术职场中普遍存在如下几种现象：</p><ul><li>对待工作中所使用的技术<strong>不需要阅读源码</strong>，只需在开发过程中能够熟练运用就行</li><li>看源码太费时间，而且容易忘记，如果从实际使用过程中出现的问题出发，针对性的阅读源码，其学习效率会更高效，所以平时无需看源码。</li></ul><p>对此我有着不同的理解，容我慢慢道来。</p><p>本文将从如下4个角度进行剖析：</p><ol><li>源码阅读的必要性</li><li>源码阅读技巧</li><li>源码阅读的三种境界</li><li>源码阅读的误区</li></ol><a id="more"></a><h2 id="1、源码阅读必要性"><a href="#1、源码阅读必要性" class="headerlink" title="1、源码阅读必要性"></a>1、源码阅读必要性</h2><h4 id="1-1-通用型基础技术应该深入源码研究"><a href="#1-1-通用型基础技术应该深入源码研究" class="headerlink" title="1.1 通用型基础技术应该深入源码研究"></a>1.1 通用型基础技术应该深入源码研究</h4><p>在 JAVA 领域中笔者认为通用型基础技术包含 JAVA 集合、Java并发(JUC)。这类技术是项目中使用的高频技术，在合适的场景中选用合适的数据结构、选用合适的线程并发模型、合理控制锁粒度等都能显著提高应用程序的可用性、健壮性。</p><p>通用型技术正因为其具有普遍性，横向对比更具代表性，职场面试时的可辨别性非常高，<strong>如何在高样本中突出自己就显得极为必要，通过阅读源码，深刻理解其内部原理成为我们的不二法宝。</strong></p><p>当然通过阅读源码并不是知晓原理的唯一方法，但作为一个名程序员、直面代码，亲自感受代码的魅力或许来的更加直接。</p><h4 id="1-2-重点领域应深入源码研究"><a href="#1-2-重点领域应深入源码研究" class="headerlink" title="1.2 重点领域应深入源码研究"></a>1.2 重点领域应深入源码研究</h4><p>为了提高辨识度作为职场的我们应该打造自己的专属标签，即<strong>“亮点”</strong>。通常情况我们应该选择在日常工作中使用的技术，在积累了丰富的使用经验、线上故障排查经验的前提下，应该深入研究其源码，成体系掌握该技术，从而对其更具掌控性，做到提前预判线上问题，规避大量线上故障，提升稳定性，助力业务降本增效。</p><p>例如笔者所在公司在微服务、消息中间件领域分别采用了 Dubbo、RocketMQ，并且笔者有幸参与到这项技术栈的运用与运维，积累了丰富的使用经验，为此笔者为了突出在这两个领域的优势，详细阅读其源码，并作成专栏发布在『中间件兴趣圈』公众号与CSDN等知识分享平台，由于是成体系剖析的原因被出版社相中，邀请出书，《RocketMQ技术内幕》一书就在这样的背景中应运而生，<strong>从而成为笔者职业技能中非常亮眼的标签，助力职场</strong>。</p><p><strong>源码阅读确实很重要，但一定需要成体系研究</strong>，大部分人认为<strong>在处理问题时再根据具体问题去看源码，会更有针对性，觉得没必要成体系看</strong>。</p><p>不可否认这有其正确性的一面，从问题本身出发，看源码效率更快，“投入产出比”更高，随着遇到的问题越来越多，对该技术理解也会越来越深，这个其实就是我们通常讲的<strong>“经验”</strong>。我觉得大部分情况下是可取的，<strong>这个过程其实是一个被动的过程</strong>，并且如果生产环节由于并发不高等因素，可能一年、两年也不会出现一两次故障，这样就会造成经验的积累会非常慢，从而使得工作了4、5年的朋友其竞争力还不如工作2,3年的重要原因，<strong>所以我的观点是如果是想打造成自己的专属亮点的话，我们还是需要主动通过阅读其源码，成体系掌握其设计理念、实现原理，更好的打造自己的专属亮点。</strong></p><h2 id="2、如何阅读源码"><a href="#2、如何阅读源码" class="headerlink" title="2、如何阅读源码"></a>2、如何阅读源码</h2><p>既然阅读源码非常有必要，那如何阅读源码呢？笔者根据多年的源码阅读经验整理了如下方法论：</p><ol><li>了解这款中间件的使用场景、以及架构设计中将承担的责任。</li><li>寻找官方文档，从整体上把握这款中间件的设计理念。</li><li>搭建自己的开发调试环境，运行官方提供Demo示例，为后续深入研究打下基础。</li><li>先主干流程再分支流程，注意切割，逐个击破。</li><li>阅读源码过程中带着思考与质疑思维。</li></ol><p>理解了其使用场景后，结合官方文档，尝试理解该中间件需要解决的问题、并思考如何解决，思考过程中并不一定要求我们想出一个具体的答案，只是在真正步入源码阅读时能更快感悟其代码含义。</p><p>当然在阅读源码的<strong>过程中可能会到难题</strong>，遇到无法理解作者的实现意图，特别是遇到一些自己不太熟悉的编程方式(例如位运算)，此时通常有<strong>两种解决方案</strong>：</p><ol><li>通过DEBUG，结合运行时数据，方便对代码的理解。</li><li>从易到难，可以先尝试阅读一下JAVA集合框架的源码，提炼出一套自己的源码研究方法论。</li></ol><p><strong>源码阅读其实最难的不是代码本身</strong>，也不是无法理解其设计理念，<strong>最难的是坚持</strong>，故在这里借用笔者的座右铭与大家共勉：越努力越幸运，唯有坚持不懈。</p><h2 id="3、源码阅读的三层境界"><a href="#3、源码阅读的三层境界" class="headerlink" title="3、源码阅读的三层境界"></a>3、源码阅读的三层境界</h2><p>接下来我想再结合笔者4年源码阅读的历程，谈谈我对源码阅读的一些更深层次的理解，介绍一下笔者在各个阶段阅读源码所处的状态。</p><ol><li>源码阅读的初级阶段<br>笔者的老粉丝们应该能感觉到笔者初期的源码阅读文章，基本上是<strong>记流水账</strong>,其最直观的表现现象是对源码一样一行加注释，只关注底层实现细节，但并未形成更高层次认知，对其设计理念并未提炼与深度领悟。 </li><li>能提问、思考、并提炼<br>随着技术类文章的持续分享，笔者认识了很多大牛、发现与大牛交流的时候，一开始并不会说细节，而是讲设计理念，这就要求我们在<strong>阅读源码的时候多思考</strong>，并反问自己如果需要自己实现的话我们该如何着手，如何设计，带着疑问去研究源码，通过对比，思考，会对其背后的理念有了更深刻的理解。</li><li>思考、质疑、验证<br>其实无论是哪个开源框架都会存在BUG或者实现并不合理的地方，如果大家在阅读源码的时候能够思考并开始质疑其不合理性，并能通过验证证明自己的观点，然后与官方取得联系，交流，建Isuue，共同促进社区的发展，说明我们的能力、思考得到了极大的提升。</li></ol><p>关于这一点，可以参考笔者对 Sentinel 对应熔断实现机制进行的质疑与思考过程。</p><p><a href="https://mp.weixin.qq.com/s/4HrfIfwszrW-q2BUcVwlhw">从Sentinel Dubbo 适配器看限流与熔断（实战思考篇）</a></p><h2 id="4、源码阅读误区"><a href="#4、源码阅读误区" class="headerlink" title="4、源码阅读误区"></a>4、源码阅读误区</h2><p><strong>源码阅读是手段，但一定不是目的。</strong></p><p>我在面试过程中发现好多候选者在谈到某一项技术时，首先不是介绍其原理，而是一下子具体到某个类啥的，这些类是如何如何工作等等，其实这是不太妥当的，源码阅读的目的是主要是深入理解其设计理念、工作机制，方便我们在实际使用过程中对其成体系的认识，加强对它的驾驭能力，做到提前规避风险。</p><p>其次源码阅读<strong>非常不建议</strong>一上来就直接DEBUG。如果一开始就使用DEBUG，很容易会迷失在代码的各个分支中，<strong>缺乏全局视角</strong>，从而变得没有头绪，极大的增加了源码理解的难度，很容易让我们半途而废。</p><p><strong>最后学习一门技术并一定要深入源码</strong>，特别是非主流，非重点打造的领域。对于此类我们通常只需根据阅读官方文档，了解其使用场景、能解决什么问题，理解其设计理念、工作机制，灵活运用解决具体问题即可。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>源码阅读并不是目的，只是手段。对于通用型基础技术诸如JAVA集合、并发、需重点打造为亮点的领域建议大家阅读其源码，成体系深入细节掌握其工作机制，增强其驾驭能力，拥有提前规避风险的能力。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;在技术职场中普遍存在如下几种现象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对待工作中所使用的技术&lt;strong&gt;不需要阅读源码&lt;/strong&gt;，只需在开发过程中能够熟练运用就行&lt;/li&gt;
&lt;li&gt;看源码太费时间，而且容易忘记，如果从实际使用过程中出现的问题出发，针对性的阅读源码，其学习效率会更高效，所以平时无需看源码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对此我有着不同的理解，容我慢慢道来。&lt;/p&gt;
&lt;p&gt;本文将从如下4个角度进行剖析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源码阅读的必要性&lt;/li&gt;
&lt;li&gt;源码阅读技巧&lt;/li&gt;
&lt;li&gt;源码阅读的三种境界&lt;/li&gt;
&lt;li&gt;源码阅读的误区&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="源码" scheme="https://www.codingw.net/categories/%E6%BA%90%E7%A0%81/"/>
    
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="阅读" scheme="https://www.codingw.net/tags/%E9%98%85%E8%AF%BB/"/>
    
    <category term="源码分享" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB/"/>
    
    <category term="源码阅读" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    
    <category term="技巧" scheme="https://www.codingw.net/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Netty4 事件处理传播机制</title>
    <link href="https://www.codingw.net/posts/be152999.html"/>
    <id>https://www.codingw.net/posts/be152999.html</id>
    <published>2020-12-19T14:11:01.000Z</published>
    <updated>2020-12-24T10:12:35.186Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本节将详细分析Netty事件传播机制，即事件链的实现机制。</p><p>本文重点的行文思路：</p><ul><li>详解事件的触发事件</li><li>事件传播机制</li><li>思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？</li></ul><a id="more"></a><p>Netty4的事件链核心类如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215532749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下先详细介绍上述核心类的核心方法。<br>1、ChannelPipeline<br>“Channel流水线”，即Channel管道（事件处理链），其主要核心方法包括如下三类。<br><strong>添加类操作</strong></p><ul><li>ChannelPipeline addFirst(String name, ChannelHandler handler)</li><li>ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler)</li><li>ChannelPipeline addFirst(ChannelHandler… handlers)</li><li>ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler… handlers)</li><li>ChannelPipeline addLast(String name, ChannelHandler handler)</li><li>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler)</li><li>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler)</li></ul><p>其中省略了addLast、addBefore、addAfter的其他重载方法，模式为addFirst类似。在这里着重讲解一下各个参数的含义。</p><ul><li>EventExecutorGroup group<br>ChannelHandler执行的线程组EventLoop，如果为空，则ChannelHandler在Channel所注册的EventLoop。</li><li>String name<br>ChannelHandler的名称，DefaultChannelPipeline会避免因重名而修改ChannelHandler的名称。</li></ul><p><strong>ChannelHandler的增删改查</strong></p><ul><li>ChannelPipeline remove(ChannelHandler handler)<br>ChannelHandler removeFirst()<br>省略其他API，此类API其实能反映出ChannelPipeline内部是一个双链表结构。</li></ul><p><strong>入端(inbound)事件传播</strong></p><ul><li>ChannelPipeline fireChannelRegistered()</li><li>ChannelPipeline fireChannelUnregistered()</li><li>ChannelPipeline fireChannelActive()</li><li>ChannelPipeline fireChannelInactive()</li><li>ChannelPipeline fireExceptionCaught(Throwable cause)</li><li>ChannelPipeline fireUserEventTriggered(Object event)</li><li>ChannelPipeline fireChannelRead(Object msg)</li><li>ChannelPipeline fireChannelReadComplete()</li><li>ChannelPipeline fireChannelWritabilityChanged()<br>不难看出，此类API方法名 fire + ChannelInboundHandler 中的方法。特别注意的是fireChannelRead(Object msg)的参数为通过网络SocketChannel#read一次读取的字节数组（ByteBuf），跟随着事件处理器一步一步的处理。</li></ul><p><strong>出端(outbound)事件传播</strong></p><ul><li>ChannelFuture bind(SocketAddress localAddress)</li><li>ChannelFuture connect(SocketAddress remoteAddress)</li><li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)</li><li>ChannelFuture disconnect()</li><li>ChannelFuture close()</li><li>ChannelFuture deregister()</li><li>ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise)</li><li>ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise)</li><li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</li><li>ChannelFuture disconnect(ChannelPromise promise)</li><li>ChannelFuture close(ChannelPromise promise)</li><li>ChannelFuture deregister(ChannelPromise promise)</li><li>ChannelPipeline read()</li><li>ChannelFuture write(Object msg)</li><li>ChannelFuture write(Object msg, ChannelPromise promise)</li><li>ChannelPipeline flush()</li><li>ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)</li><li>ChannelFuture writeAndFlush(Object msg)<br>不难看出，上述方法为ChannelOutboundHandler的方法。</li></ul><h2 id="2、DefaultChannelPipeline"><a href="#2、DefaultChannelPipeline" class="headerlink" title="2、DefaultChannelPipeline"></a>2、DefaultChannelPipeline</h2><p>ChannelPipeline的简单类图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215634424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合head、taill与下面的构造函数可知DefaultChannelPipeline的结构是其双链表，其中head、tail为双链表的首尾节点，并且其引用不能更改，其中节点（Node）实现为AbstractChannelHandlerContext，其内部必然定义两个属性prev与next，分别代表前一个节点与下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从这里看一个Channel对应一个ChannelPipeline。</p><h3 id="2-1-事件链构建"><a href="#2-1-事件链构建" class="headerlink" title="2.1 事件链构建"></a>2.1 事件链构建</h3><p>本节将以addFirst方法为例展示ChannelPipeline事件链的维护实现。<br>DefaultChannelPipeline#addFirst</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addFirst(<span class="keyword">null</span>, name, handler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>内部调用其重载方法。接下来重点分析该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;     <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);                                                                                                                        <span class="comment">// @2</span></span><br><span class="line">            name = filterName(name, handler);</span><br><span class="line">            newCtx = newContext(group, name, handler);                                                                                         <span class="comment">// @3</span></span><br><span class="line">            addFirst0(newCtx);                                                                                                                                   <span class="comment">// @4                                   </span></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;                                                                                                                                        <span class="comment">// @5</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;                                                                                                                  <span class="comment">// @6</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);                                                                                                                    <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先对参数简单说明一下：</p><ul><li>EventExecutorGroup group：指定ChannelHandler在哪个事件选择器中执行(EventLoopGroup)，如果为空，表示在Channel注册的事件轮询器中执行。</li><li>String name：ChannelHandler名称。</li><li>ChannelHandler channelHandler：待添加的事件处理器。</li></ul><p>代码@2：检查是否重复添加，声明为Shareable的ChannelHandler允许重复添加。</p><p>代码@3：使用AbstractChannelHandlerContext类包装ChannelHandler，即双链表结构的Node类为AbstractChannelHandlerContext。</p><p>代码@4：将AbstractChannelHandlerContext调用addFirst0添加到双链表的“第一条”，其实是添加到双链表头结点(HeaderContext)的next值执行该节点。</p><p>代码@5-代码@7都是处理handerAdd事件，如果通道还未注册，handerAdd事件会“挂起”，也就是需要等待通道被注册后才执行，其实现思路也是构建PendingHandlerCallback链，DefaultChannelPipeline内部持有该链的头节点，待通道注册后，顺序触发handlerAdd事件的传播。</p><p>接下来看一下addFirst0的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext nextCtx = head.next;    </span><br><span class="line">        newCtx.prev = head;                                                        </span><br><span class="line">        newCtx.next = nextCtx;                                                  </span><br><span class="line">        head.next = newCtx;                                                       </span><br><span class="line">        nextCtx.prev = newCtx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里就是典型的链表操作过程。<br>如果使用如下代码构建事件链，那事件是如何传播的呢？<br>p.addLast(“1”, new InboundHandlerA());<br>p.addLast(“2”, new InboundHandlerB());<br>p.addLast(“3”, new OutboundHandlerA());<br>p.addLast(“4”, new OutboundHandlerB());<br>p.addLast(“5”, new InboundOutboundHandlerX());<br>其构建的事件链最终如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215730318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但ChannelInboundHandler中的事件是如何传播的呢？ChannelOutboundHandler的事件又是如何传播的呢？</p><p>事件链中的节点对象为AbstractChannelHandlerContext，其类图如下：</p><p><img src="https://img-blog.csdnimg.cn/2020121321581174.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><ul><li>HeadContext：事件链的头节点。</li><li>TailContext：事件链的尾节点。</li><li>DefaultChannelHandlerContext：用户定义的Handler所在的节点。</li></ul><h3 id="2-2-事件传播"><a href="#2-2-事件传播" class="headerlink" title="2.2 事件传播"></a>2.2 事件传播</h3><p>inbound事件与outbound事件传播机制实现原理相同，只是方向不同，inbound事件的传播从HeadContext开始，沿着next指针进行传播，而outbound事件传播从TailContext开始，沿着prev指针向前传播，故下文重点分析inbound事件传播机制。</p><p>DefaultChannelPipeline有关于ChannelInboundHandler的方法实现如下：<br><img src="https://img-blog.csdnimg.cn/20201213215906969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>所有的入端事件的传播入口都是从head开始传播</strong>。接下来我们以channelRead事件的传播为例，展示inbound的事件的流转。注意：以下观点都是针对NIO的读取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelPipeline#fireChannelRead(Object msg) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">     AbstractChannelHandlerContext.invokeChannelRead(head, msg);  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先在NIO事件选择器在网络读事件就绪后，会调用底层SocketChanel#read 方法从读缓存中读取字节，在Netty中使用ByteBuf来存储，然后调用DefaultChannelPipeline # fireChannelRead 方法进行事件传播，每个ChannelHandler针对输入进行加工处理，ChannelPipeline因此而得名，有关Netty基于NIO的事件就绪选择实现将在Netty线程模型、IO读写流程部分详细讲解。</p><p>从代码@1处可得知，通过AbstractChannelHandlerContext的静态方法invokerChanelRead，从HeadContext处开始执行，</p><p>AbstractChannelHandlerContext#invokerChanelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, <span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        EventExecutor executor = next.executor();         <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;                                <span class="comment">// @2</span></span><br><span class="line">            next.invokeChannelRead(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;              <span class="comment">// @3</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种写法是Netty处理事件执行的“模板”方法，都是先获取需要执行的线程组(EventLoop),如果当前线程不属于Eventloop，则将任务提交到EventLoop中异步执行，如果在，则直接调用。第一次调用，该next指针为HeadContext，那接下来重点关注一下HeadContext的invokeChannelRead方法。<br>AbstractChannelHandlerContext#invokeChannelRead</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;                                                                            <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);   <span class="comment">// @2</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);                                                                     <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果该通道已经成功添加@1，则执行对应的事件@2，否则只是传播事件@3。</p><p>传播事件在AbstractChannelHandlerContext的实现思路如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext#fireChannelRead</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述就从事件链中按顺序提取inbound类型的处理器，上述代码要最终能结束，那么TailContext必须是Inbound类型的事件处理器。</p><p>从代码@2中执行完对应的事件处理逻辑后，事件如何向下传播呢？如果需要继续将事件传播的话，请调用ChannelInboundHandlerAdapter 对应的传播事件方法，如上例中的 ChannelInboundHandlerAdapter#fireChannelRead，该方法会将事件链继续往下传播，如果在对应的事件处理中继续调用fireChannelRead，则事件传播则停止传播，也就是并不是事件一定会顺着整个调用链到达事件链的尾部TailContext，在实践中请特别重视。</p><p>Netty inbound 事件传播流程图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215946585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述主要分析了inboud事件的传播机制，为了加深理解，我们接下来浏览一下HeadContext、TailContext是如何实现各个事件方法的，这些事件，后续在梳理Netty读写流程时会再详细介绍。</p><h3 id="2-3-源码分析DefaultChannelPipeline-HeadContex"><a href="#2-3-源码分析DefaultChannelPipeline-HeadContex" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$HeadContex"></a>2.3 源码分析DefaultChannelPipeline$HeadContex</h3><h4 id="2-3-1-HeadContext声明与构造方法"><a href="#2-3-1-HeadContext声明与构造方法" class="headerlink" title="2.3.1 HeadContext声明与构造方法"></a>2.3.1 HeadContext声明与构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;    <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;                                                                     <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;                        </span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：HeadContext实现ChannelInboundHandler与ChannelOutboundHandler，故它的inbound与outbound都返回true。<br>代码@2：Unsafe，Netty操作类。</p><h4 id="2-3-2-handlerAdded、handlerRemoved"><a href="#2-3-2-handlerAdded、handlerRemoved" class="headerlink" title="2.3.2 handlerAdded、handlerRemoved"></a>2.3.2 handlerAdded、handlerRemoved</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ChanelHandler增加与移除事件处理逻辑：不做任何处理。为什么可以不传播呢？其实上文在讲解addFirst方法时已提到，在添加一个ChannelHandler到事件链时，会根据通道是否被注册，如果未注册，会先阻塞执行，DefaultChannelPipeline会保存一条执行链，等通道被注册后处触发执行，HeadContext作为一个非业务类型的事件处理器，对通道的增加与否无需关注。</p><h4 id="2-3-3-exceptionCaught"><a href="#2-3-3-exceptionCaught" class="headerlink" title="2.3.3 exceptionCaught"></a>2.3.3 exceptionCaught</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道异常处理事件的处理逻辑：HeadContext的选择是自己不关注，直接将异常事件往下传播。</p><h4 id="2-3-4-channelRegistered"><a href="#2-3-4-channelRegistered" class="headerlink" title="2.3.4 channelRegistered"></a>2.3.4 channelRegistered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">            <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">            callHandlerAddedForAllHandlers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通道注册事件处理逻辑：当通道成功注册后，判断是否是第一次注册，如果是第一次注册的话，调用所有的ChannelHandler#handlerAdd事件，因为当通道增加到事件链后，如果该通道还未注册，channelAdd事件不会马上执行，需要等通道注册后才执行，故在这里首先需要执行完挂起（延迟等待的任务）。然后调用fireChannelRegistered沿着事件链传播通道注册成功事件。</p><h4 id="2-3-5-channelUnregistered"><a href="#2-3-5-channelUnregistered" class="headerlink" title="2.3.5 channelUnregistered"></a>2.3.5 channelUnregistered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>通道取消注册事件处理逻辑：首先传播事件，然后判断通道的状态，如果是处于关闭状态（通道调用了close方法），则需要移除所有的ChannelHandler。</p><h4 id="2-3-6-channelActive"><a href="#2-3-6-channelActive" class="headerlink" title="2.3.6 channelActive"></a>2.3.6 channelActive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> ctx.fireChannelActive();</span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通道激活事件的处理逻辑（TCP连接建立成功后触发）：首先传播该事件，如果开启自动读机制(autoRead为true)，则调用Channel#read方法，向NIO Selector注册读事件。</p><h4 id="2-3-7-channelInactive"><a href="#2-3-7-channelInactive" class="headerlink" title="2.3.7 channelInactive"></a>2.3.7 channelInactive</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelInactive();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通道非激活事件处理逻辑：只传播事件。</p><h4 id="2-3-8-channelRead"><a href="#2-3-8-channelRead" class="headerlink" title="2.3.8 channelRead"></a>2.3.8 channelRead</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道读事件处理逻辑：向下传播事件，各个编码器、业务处理器将各自处理业务逻辑。</p><h4 id="2-3-9-channelReadComplete"><a href="#2-3-9-channelReadComplete" class="headerlink" title="2.3.9 channelReadComplete"></a>2.3.9 channelReadComplete</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelReadComplete();</span><br><span class="line">readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道读完成事件，首先先传播事件，然后如果开启了自动读取的话，继续注册读事件。</p><h4 id="2-3-10-userEventTriggered"><a href="#2-3-10-userEventTriggered" class="headerlink" title="2.3.10 userEventTriggered"></a>2.3.10 userEventTriggered</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireUserEventTriggered(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户自定义事件的处理逻辑：传播事件。</p><h4 id="2-3-11-channelWritabilityChanged"><a href="#2-3-11-channelWritabilityChanged" class="headerlink" title="2.3.11 channelWritabilityChanged"></a>2.3.11 channelWritabilityChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelWritabilityChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通道可写状态变更事件的处理逻辑：传播事件。</p><p>接下来介绍HeadContext对于ChannelOutboundHander事件的处理逻辑：</p><h4 id="2-3-12-bind"><a href="#2-3-12-bind" class="headerlink" title="2.3.12 bind"></a>2.3.12 bind</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">( ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Unsafe实例完成具体的绑定操作，后续会重点分析该方法的实现原理。</p><p>由于HeadContex是outbound事件的尾部事件处理器，而且outbound是用户发送的API调用，其最终目的是希望通过Netty完成具体的网络操作，故HeadContex是离Netty底层机制最近的，到了这里，就意味者“应用程序”层面的定制化介绍，最终需要通过HeadContex直接调用Netty的API来完成具体的动作，故HeadContex关于outbound事件的实现，都是通过调用unsafe去完成具体的动作。故后面的方面就不在一一罗列。</p><h3 id="2-3-源码分析DefaultChannelPipeline-TailContext"><a href="#2-3-源码分析DefaultChannelPipeline-TailContext" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$TailContext"></a>2.3 源码分析DefaultChannelPipeline$TailContext</h3><p>TailContext由于是 inbound事件链的最后一站，故该节点大部分事件都是空实现，其他实现的方法，基本上就是释放一下资源，我们看一下TailContex关于channelRead事件的处理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            onUnhandledInboundMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后就是主动调用ReferenceCountUtil.release(msg)释放资源。</p><p>Netty事件传播机制就讲解到这里了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本节将详细分析Netty事件传播机制，即事件链的实现机制。&lt;/p&gt;
&lt;p&gt;本文重点的行文思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;详解事件的触发事件&lt;/li&gt;
&lt;li&gt;事件传播机制&lt;/li&gt;
&lt;li&gt;思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="netty4" scheme="https://www.codingw.net/categories/netty4/"/>
    
    
    <category term="netty4" scheme="https://www.codingw.net/tags/netty4/"/>
    
    <category term="事件传播" scheme="https://www.codingw.net/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>源码分析RateLimiter SmoothWarmingUp 实现原理(文末附流程图)</title>
    <link href="https://www.codingw.net/posts/6c0cb4a9.html"/>
    <id>https://www.codingw.net/posts/6c0cb4a9.html</id>
    <published>2020-12-18T14:53:35.000Z</published>
    <updated>2020-12-24T10:12:48.764Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>上一篇详细介绍了 <a href="https://blog.csdn.net/prestigeding/article/details/105027563">SmoothBursty</a> 的实现原理，本文将介绍带有预热机制的限速器实现原理。</p><h2 id="1、类图"><a href="#1、类图" class="headerlink" title="1、类图"></a>1、类图</h2><p><img src="https://img-blog.csdnimg.cn/20200329155128855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上文也详细介绍了 RateLimiter 相关的类图，本文就不详细介绍。</p><h2 id="2、SmoothWarmingUp-创建流程"><a href="#2、SmoothWarmingUp-创建流程" class="headerlink" title="2、SmoothWarmingUp 创建流程"></a>2、SmoothWarmingUp 创建流程</h2><p>创建 SmoothWarmingUp 限速器的入口为 RateLimiter 的 create 方法，其代码如下：<br>RateLimiter#create</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    checkArgument(warmupPeriod &gt;= <span class="number">0</span>, <span class="string">&quot;warmupPeriod must not be negative: %s&quot;</span>, warmupPeriod);</span><br><span class="line">    <span class="keyword">return</span> create(</span><br><span class="line">        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先先来看一下参数列表：</p><ul><li>double permitsPerSecond<br>每秒发放许可数量，即所谓的QPS。</li><li>long warmupPeriod<br>设置预热时间。</li><li>TimeUnit unit<br>warmupPeriod 的时间单位。</li></ul><p>代码@2：调用内部的重载方法创建 SmoothWarmingUp 。</p><a id="more"></a><p>RateLimiter#create</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">( SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit, <span class="keyword">double</span> coldFactor)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);  <span class="comment">// @1</span></span><br><span class="line">    rateLimiter.setRate(permitsPerSecond); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 SmoothWarmingUp 两个主要步骤分别是调用其构造方法首先创建 SmoothWarmingUp 实例，然后调用其 setRate 方法进行初始化速率。这里先突出 coldFactor，默认为 3.0，该属性的作用将在下文详细介绍。</p><p>我们先来重点探讨一下 setRate 方法的实现。最终会调用其父类 SmoothRateLimiter 的doSetRate 方法。</p><p>SmoothRateLimiter#doSetRate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1 </span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;   </span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;   <span class="comment">// @2</span></span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);  <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：基于当前时间重置 SmoothRateLimiter 内部的 storedPermits(已存储的许可数量) 与 nextFreeTicketMicros(下一次可以免费获取许可的时间) 值，所谓的免费指的是无需等待就可以获取设定速率的许可，该方法对理解限流许可的产生非常关键，稍后详细介绍。</p><p>代码@2：根据QPS算出一个稳定的获取1个许可的时间。以一秒发放5个许可，即限速为5QPS，那发放一个许可的世界间隔为 200ms，stableIntervalMicros 变量是以微妙为单位。</p><p>代码@4：调用 SmoothRateLimiter 的抽象方法 doSetRate 设置速率，这里会调用 SmoothWarmingUp 的 doSetRate 方法。</p><p>在介绍 SmoothWarmingUp 的 doSetRate 方法之前，我们先来看一下 resync 方法的实现。</p><p>SmoothRateLimiter#resync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;  <span class="comment">// @1 </span></span><br><span class="line">      <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();  <span class="comment">// @2</span></span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);    <span class="comment">// @3</span></span><br><span class="line">      nextFreeTicketMicros = nowMicros;   <span class="comment">// @4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果当前已启动时间大于nextFreeTicketMicros（下一次可以免费获取许可的时间），则需要重新计算许可，即又可以向许可池中添加许可。</p><p>代码@2：根据当前时间可增加的许可数量，由于 SmoothWarmingUp 实现了预热机制，平均生成一个许可的时间并不是固定不变的。具体由 coolDownIntervalMicros 方法实现，稍候详细介绍。</p><p>代码@3：计算当前可用的许可，将新增的这些许可添加到许可池，但不会超过其最大值。</p><p>代码@4：更新下一次可增加计算许可的时间。 </p><p>SmoothWarmingUp#coolDownIntervalMicros</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">coolDownIntervalMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的实现其实简单，用生成这些许可的总时间除以现在已经生成的许可数，即可得到当前时间点平均一个许可的生成时间。</p><ol><li><p>接下来重点探讨 SmoothWarmingUp 的 doSetRate 方法。<br>为了方便理解 SmoothWarmingUp doSetRate 方法，我根据 SmoothWarmingUp 类的注释，结合代码，给出如下示例图：<br><img src="https://img-blog.csdnimg.cn/20200329155338150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先我们先来根据 SmoothWarmingUp 的相关注释来理解一下上述这张图的几个要点。</p><ul><li>图中有两个阴影面积，一个用 stable，另外一个warm up period。在预热算法中，这两个阴影面积的关系与冷却因子相关。</li><li>冷却因子 coldFactor 表示的含义为 coldIntervalMicros 与  stableIntervalMicros 的比值。</li><li>warm up period 阴影面积 与 stable 阴影面积的比值等于 (coldIntervalMicros -  stableIntervalMicros ) / stableIntervalMicros ，例如 SmoothWarmingUp 固定的冷却因子为3，那么 coldIntervalMicros 与 stableIntervalMicros 的比值为 3，那  (coldIntervalMicros -  stableIntervalMicros ) / stableIntervalMicros 则为 2。</li><li>在预热算法中与数学中的积分相关（笔者对这方面的数学知识一窍不通），故这里只展示结论，而不做推导，阴影 WARM UP PERIOD 的面积等于 warmupPeriod,那阴影stable的面积等于 warmupPeriod/2。</li><li>存在如下等式 warmupPeriod/2 = thresholdPermits * stableIntervalMicros (长方形的面积)</li><li>同样存在如下等式 warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits) （梯形面积，(上底 + 下底 * 高 / 2) ）</li></ul><p>有了上述基本知识，我们再来看一下代码。</p><p>SmoothWarmingUp#doSetRate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = maxPermits;</span><br><span class="line">    <span class="keyword">double</span> coldIntervalMicros = stableIntervalMicros * coldFactor;                <span class="comment">// @1</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;    <span class="comment">// @2</span></span><br><span class="line">    maxPermits =</span><br><span class="line">          thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);   <span class="comment">// @3</span></span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);  <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;    <span class="comment">// @5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据冷却因子(coldFactor)来计算冷却间隔(单位为微秒)，等于冷却因子与 stableIntervalMicros 的乘积。从这里我们可以得出如下几个基本的概念。冷却因子 coldFactor 为 冷却间隔与稳定间隔的比例。</p><p>代码@2：通过  warmupPeriod/2 = thresholdPermits * stableIntervalMicros 等式，求出 thresholdPermits 的值。</p><p>代码@3：根据  warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)  表示可求出 maxPermits 的数量。</p><p>代码@4：斜率，表示的是从 stableIntervalMicros 到 coldIntervalMicros 这段时间，许可数量从 thresholdPermits 变为 maxPermits 的增长速率。</p><p>代码@5：根据 maxPermits 更新当前存储的许可，即当前剩余可消耗的许可数量。</p><h2 id="3、SmoothWarmingUp-acquire-流程"><a href="#3、SmoothWarmingUp-acquire-流程" class="headerlink" title="3、SmoothWarmingUp acquire 流程"></a>3、SmoothWarmingUp acquire 流程</h2><p>首先 acquire 的定义在其父类，这里是典型的模板模式，由其父类定义基本流程，由具体的子类实现其特定功能。RateLimiter 中的 acquire 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);    <span class="comment">// @1</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);   <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据当前剩余的许可与本次申请的许可来判断本次申请需要等待的时长，如果返回0则表示无需等待。</p><p>代码@2：如果需要等待的时间不为0，表示触发限速，睡眠指定时间后唤醒。</p><p>代码@3：返回本次申请等待的时长。</p><p>接下来重点介绍 reserve 方法的实现原理。</p><p>RateLimiter#reserve</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inal <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;  <span class="comment">// @1</span></span><br><span class="line">      <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros()); <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：限速器主要维护的重要数据字段(storedPermits)，对其进行维护时都需要先获取锁。</p><p>代码@2：调用内部方法 reserveAndGetWaitLength 来计算需要等待时间。</p><p>继续跟踪 reserveAndGetWaitLength 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：根据当前拥有的许可数量、当前时间判断待申请许可最早能得到满足的最早时间，用momentAvailable 表示。</p><p>代码@2：然后计算 momentAvailable 与 nowMicros 的差值与0做比较，得出需要等待的时间。</p><p>继续跟踪 reserveEarliestAvailable方法，该方法在 RateLimiter 中一个抽象方法，具体实现在其子类 SmoothRateLimiter 中。</p><p>SmoothRateLimiter#reserveEarliestAvailable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend; <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);  <span class="comment">// @4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);  <span class="comment">// @5</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;    <span class="comment">// @6</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：在尝试申请许可之前，先根据当前时间即发放许可速率更新 storedPermits 与 nextFreeTicketMicros（下一次可以免费获取许可的时间）。</p><p>代码@2：计算本次能从 storedPermits 中消耗的许可数量，取需要申请的许可数量与当前可用的许可数量的最小值，用 storedPermitsToSpend 表示。</p><p>代码@3：如果需要申请的许可数量(requiredPermits)大于当前剩余许可数量(storedPermits)，则还需要等待新的许可生成，用freshPermits 表示，即如果该值大于0，则表示本次申请需要阻塞一定时间。</p><p>代码@4：计算本次申请需要等待的时间，等待的时间由两部分组成，一部分是由 storedPermitsToWaitTime 方法返回的，另外一部分以稳定速率生成需要的许可，其需要时间为 freshPermits * stableIntervalMicros,稍后我们详细分析一下 storedPermitsToWaitTime 方法的实现。</p><p>代码@5：更新 nextFreeTicketMicros 为当前时间加上需要等待的时间。</p><p>代码@6：更新 storedPermits 的值，即减少本次已消耗的许可数量。</p><p>代码@7：请注意这里返回的 returnValue 的值，并没有包含由于剩余许可需要等待创建新许可的时间，即允许一定的突发流量，故本次计算需要的等待时间将对下一次请求生效。</p><p>接下来重点探讨一下 SmoothWarmingUp 的 storedPermitsToWaitTime 方法。</p><p>SmoothWarmingUp#SmoothWarmingUp </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line"><span class="keyword">double</span> availablePermitsAboveThreshold = storedPermits - thresholdPermits;   <span class="comment">// @2</span></span><br><span class="line"><span class="keyword">long</span> micros = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;  <span class="comment">// @3</span></span><br><span class="line"><span class="keyword">double</span> permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);  <span class="comment">// @31 </span></span><br><span class="line">                <span class="comment">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class="line">                <span class="keyword">double</span> length = permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">                     + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);             <span class="comment">// @32</span></span><br><span class="line">                micros = (<span class="keyword">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);                                                      <span class="comment">// @33</span></span><br><span class="line">                permitsToTake -= permitsAboveThresholdToTake;                                                                          <span class="comment">// @34</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">        micros += (stableIntervalMicros * permitsToTake);   <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先介绍其两个参数的含义：</p><ul><li>double storedPermits<br>当前存储的许可数量。</li><li>double permitsToTake<br>本次申请需要的许可数量。</li></ul><p>代码@2：availablePermitsAboveThreshold ，当前超出 thresholdPermits 的许可个数，如果超过 thresholdPermits ，申请许可将来源于超过的部分，只有其不足后，才会从 thresholdPermits 中申请，这部分的详细逻辑见代码@3。</p><p>代码@3：如果当前存储的许可数量超过了稳定许可 thresholdPermits，即存在预热的许可数量的申请逻辑，其实现关键点如下：</p><ul><li>获取本次从预热区间申请的许可数量。</li><li>从预热区间获取一个许可的时间其算法有点晦涩难懂，具体实现为@32~@34。</li></ul><p>代码@4：从稳定区间获取一个许可的时间，就容易理解，为固定的 stableIntervalMicros 。</p><blockquote><p>温馨提示：从预热区间计算获取多个许可的算法，与 slope 有关，笔者并未完成感悟，但至少我们需要明白的是，从 剩余许可(storedPermits)中申请许可时，优先消耗(大于thresholdPermits 的许可，即消耗 (thresholdPermits ~ maxPermit ) 之间的许可)。</p></blockquote><p>SmoothWarmingUp 的 acquire 流程就介绍到这里了。</p><h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>SmoothWarmingUp 的 acquire 的流程与 SmoothBursty 类似，故其流程图与下图通用，主要的区别生成一个许可的时间有变化，主要是提供了预热机制。<br><img src="https://img-blog.csdnimg.cn/20200329155751536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p></li></ol></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;上一篇详细介绍了 &lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/105027563&quot;&gt;SmoothBursty&lt;/a&gt; 的实现原理，本文将介绍带有预热机制的限速器实现原理。&lt;/p&gt;
&lt;h2 id=&quot;1、类图&quot;&gt;&lt;a href=&quot;#1、类图&quot; class=&quot;headerlink&quot; title=&quot;1、类图&quot;&gt;&lt;/a&gt;1、类图&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200329155128855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;从上文也详细介绍了 RateLimiter 相关的类图，本文就不详细介绍。&lt;/p&gt;
&lt;h2 id=&quot;2、SmoothWarmingUp-创建流程&quot;&gt;&lt;a href=&quot;#2、SmoothWarmingUp-创建流程&quot; class=&quot;headerlink&quot; title=&quot;2、SmoothWarmingUp 创建流程&quot;&gt;&lt;/a&gt;2、SmoothWarmingUp 创建流程&lt;/h2&gt;&lt;p&gt;创建 SmoothWarmingUp 限速器的入口为 RateLimiter 的 create 方法，其代码如下：&lt;br&gt;RateLimiter#create&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; RateLimiter &lt;span class=&quot;title&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;double&lt;/span&gt; permitsPerSecond, &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; warmupPeriod, TimeUnit unit)&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;span class=&quot;comment&quot;&gt;// @1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    checkArgument(warmupPeriod &amp;gt;= &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&amp;quot;warmupPeriod must not be negative: %s&amp;quot;&lt;/span&gt;, warmupPeriod);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; create(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, &lt;span class=&quot;number&quot;&gt;3.0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;代码@1：首先先来看一下参数列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;double permitsPerSecond&lt;br&gt;每秒发放许可数量，即所谓的QPS。&lt;/li&gt;
&lt;li&gt;long warmupPeriod&lt;br&gt;设置预热时间。&lt;/li&gt;
&lt;li&gt;TimeUnit unit&lt;br&gt;warmupPeriod 的时间单位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;代码@2：调用内部的重载方法创建 SmoothWarmingUp 。&lt;/p&gt;</summary>
    
    
    
    <category term="sentinel" scheme="https://www.codingw.net/categories/sentinel/"/>
    
    
    <category term="sentinel" scheme="https://www.codingw.net/tags/sentinel/"/>
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="SmoothWarmingUp" scheme="https://www.codingw.net/tags/SmoothWarmingUp/"/>
    
    <category term="coldFactor" scheme="https://www.codingw.net/tags/coldFactor/"/>
    
  </entry>
  
  <entry>
    <title>源码分析RocketMQ ACL实现机制</title>
    <link href="https://www.codingw.net/posts/a6ee7996.html"/>
    <id>https://www.codingw.net/posts/a6ee7996.html</id>
    <published>2020-12-17T14:20:35.000Z</published>
    <updated>2020-12-24T10:13:02.005Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>有关RocketMQ ACL的使用请查看上一篇<a href="https://blog.csdn.net/prestigeding/article/details/94317946">《RocketMQ ACL使用指南》</a>，本文从源码的角度，分析一下RocketMQ ACL的实现原理。</p><blockquote><p>备注：RocketMQ在4.4.0时引入了ACL机制，本文代码基于RocketMQ4.5.0版本。</p></blockquote><p>根据RocketMQ ACL使用手册，我们应该首先看一下Broker服务器在开启ACL机制时如何加载配置文件，并如何工作的。</p><a id="more"></a><h2 id="1、BrokerController-initialAcl"><a href="#1、BrokerController-initialAcl" class="headerlink" title="1、BrokerController#initialAcl"></a>1、BrokerController#initialAcl</h2><p>Broker端ACL的入口代码为：BrokerController#initialAcl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialAcl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerConfig.isAclEnable()) &#123;                           <span class="comment">// @1</span></span><br><span class="line">        log.info(<span class="string">&quot;The broker dose not enable acl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;AccessValidator&gt; accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (accessValidators == <span class="keyword">null</span> || accessValidators.isEmpty()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;The broker dose not load the AccessValidator&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AccessValidator accessValidator: accessValidators) &#123;                       <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">final</span> AccessValidator validator = accessValidator;</span><br><span class="line">        <span class="keyword">this</span>.registerServerRPCHook(<span class="keyword">new</span> RPCHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//Do not catch the exception</span></span><br><span class="line">                validator.validate(validator.parse(request, remoteAddr));                         <span class="comment">// @4</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterResponse</span><span class="params">(String remoteAddr, RemotingCommand request, RemotingCommand response)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本方法的实现共4个关键点。<br>代码@1：首先判断Broker是否开启了acl，通过配置参数aclEnable指定，默认为false。</p><p>代码@2：使用类似SPI机制，加载配置的AccessValidator,该方法返回一个列表，其实现逻辑时读取META-INF/service/org.apache.rocketmq.acl.AccessValidator文件中配置的访问验证器，默认配置内容如下：<br><img src="https://img-blog.csdnimg.cn/20190707120439720.png" alt="在这里插入图片描述"><br>代码@3：遍历配置的访问验证器(AccessValidator),并向Broker处理服务器注册钩子函数，RPCHook的doBeforeRequest方法会在服务端接收到请求，将其请求解码后，执行处理请求之前被调用;RPCHook的doAfterResponse方法会在处理完请求后，将结果返回之前被调用，其调用如图所示：<br><img src="https://img-blog.csdnimg.cn/20190707120505807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码@4：在RPCHook#doBeforeRequest方法中调用AccessValidator#validate, 在真实处理命令之前，先执行ACL的验证逻辑，如果拥有该操作的执行权限，则放行，否则抛出AclException。</p><p>接下来，我们将重点放到Broker默认实现的访问验证器：PlainAccessValidator。</p><h2 id="2、PlainAccessValidator"><a href="#2、PlainAccessValidator" class="headerlink" title="2、PlainAccessValidator"></a>2、PlainAccessValidator</h2><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190707120530560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ul><li>AccessValidator<br>访问验证器接口，主要定义两个接口。<br>1）AccessResource parse(RemotingCommand request, String remoteAddr)<br>从请求头中解析本次请求对应的访问资源，即本次请求需要的访问权限。<br>2）void validate(AccessResource accessResource)<br>根据本次需要访问的权限，与请求用户拥有的权限进行对比验证，判断是拥有权限，如果没有访问该操作的权限，则抛出异常，否则放行。</li><li>PlainAccessValidator<br>RocketMQ默认提供的基于yml配置格式的访问验证器。</li></ul><p>接下来我们重点看一下PlainAccessValidator的parse方法与validate方法的实现细节。在讲解该方法之前，我们首先认识一下RocketMQ封装访问资源的PlainAccessResource。</p><h4 id="2-1-2-PlainAccessResource类图"><a href="#2-1-2-PlainAccessResource类图" class="headerlink" title="2.1.2 PlainAccessResource类图"></a>2.1.2 PlainAccessResource类图</h4><p><img src="https://img-blog.csdnimg.cn/20190707120741119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们对其属性一一做个介绍：</p><ul><li>private String accessKey<br>访问Key，用户名。</li><li>private String secretKey<br>用户密码。</li><li>private String whiteRemoteAddress<br>远程IP地址白名单。</li><li>private boolean admin<br>是否是管理员角色。</li><li>private byte defaultTopicPerm = 1<br>默认topic访问权限，即如果没有配置topic的权限，则Topic默认的访问权限为1，表示为DENY。</li><li>private byte defaultGroupPerm = 1<br>默认的消费组访问权限，默认为DENY。</li><li>private Map&lt;String, Byte&gt; resourcePermMap<br>资源需要的访问权限映射表。</li><li>private RemoteAddressStrategy remoteAddressStrategy<br>远程IP地址验证策略。</li><li>private int requestCode<br>当前请求的requestCode。</li><li>private byte[] content<br>请求头与请求体的内容。</li><li>private String signature<br>签名字符串，这是通常的套路，在客户端时，首先将请求参数排序，然后使用secretKey生成签名字符串，服务端重复这个步骤，然后对比签名字符串，如果相同，则认为登录成功，否则失败。</li><li>private String secretToken<br>密钥token。</li><li>private String recognition<br>目前作用未知，代码中目前未被使用。</li></ul><h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlainAccessValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aclPlugEngine = <span class="keyword">new</span> PlainPermissionLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造函数，直接创建PlainPermissionLoader对象，从命名上来看，应该是触发acl规则的加载，即解析plain_acl.yml，接下来会重点探讨，即acl启动流程之配置文件的解析。</p><h3 id="2-3-parse方法"><a href="#2-3-parse方法" class="headerlink" title="2.3 parse方法"></a>2.3 parse方法</h3><p>该方法的作用就是从请求命令中解析出本次访问所需要的访问权限，最终构建AccessResource对象，为后续的校验权限做准备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PlainAccessResource accessResource = <span class="keyword">new</span> PlainAccessResource();</span><br><span class="line"><span class="keyword">if</span> (remoteAddr != <span class="keyword">null</span> &amp;&amp; remoteAddr.contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：首先创建PlainAccessResource，从远程地址中提取出远程访问IP地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getExtFields() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(<span class="string">&quot;request&#x27;s extFields value is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">accessResource.setRequestCode(request.getCode());</span><br><span class="line">accessResource.setAccessKey(request.getExtFields().get(SessionCredentials.ACCESS_KEY));</span><br><span class="line">accessResource.setSignature(request.getExtFields().get(SessionCredentials.SIGNATURE));</span><br><span class="line">accessResource.setSecretToken(request.getExtFields().get(SessionCredentials.SECURITY_TOKEN));</span><br></pre></td></tr></table></figure><p>Step2：如果请求头中的扩展字段为空，则抛出异常，如果不为空，则从请求头中读取requestCode、accessKey(请求用户名)、签名字符串(signature)、secretToken。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.SEND_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.PUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.SEND_MESSAGE_V2:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;b&quot;</span>), Permission.PUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;originTopic&quot;</span>), Permission.PUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(<span class="string">&quot;group&quot;</span>)), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.PULL_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(<span class="string">&quot;consumerGroup&quot;</span>)), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.QUERY_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.HEART_BEAT:</span><br><span class="line">                    HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class);</span><br><span class="line">                    <span class="keyword">for</span> (ConsumerData data : heartbeatData.getConsumerDataSet()) &#123;</span><br><span class="line">                        accessResource.addResourceAndPerm(getRetryTopic(data.getGroupName()), Permission.SUB);</span><br><span class="line">                        <span class="keyword">for</span> (SubscriptionData subscriptionData : data.getSubscriptionDataSet()) &#123;</span><br><span class="line">                            accessResource.addResourceAndPerm(subscriptionData.getTopic(), Permission.SUB);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.UNREGISTER_CLIENT:</span><br><span class="line">                    <span class="keyword">final</span> UnregisterClientRequestHeader unregisterClientRequestHeader =</span><br><span class="line">                        (UnregisterClientRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(UnregisterClientRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(unregisterClientRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.GET_CONSUMER_LIST_BY_GROUP:</span><br><span class="line">                    <span class="keyword">final</span> GetConsumerListByGroupRequestHeader getConsumerListByGroupRequestHeader =</span><br><span class="line">                        (GetConsumerListByGroupRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(GetConsumerListByGroupRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(getConsumerListByGroupRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.UPDATE_CONSUMER_OFFSET:</span><br><span class="line">                    <span class="keyword">final</span> UpdateConsumerOffsetRequestHeader updateConsumerOffsetRequestHeader =</span><br><span class="line">                        (UpdateConsumerOffsetRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(UpdateConsumerOffsetRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(updateConsumerOffsetRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(updateConsumerOffsetRequestHeader.getTopic(), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AclException(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Step3：根据请求命令，设置本次请求需要拥有的权限，上述代码比较简单，就是从请求中得出本次操作的Topic、消息组名称，为了方便区分topic与消费组，消费组使用消费者对应的重试主题，当成资源的Key，从这里也可以看出，当前版本需要进行ACL权限验证的请求命令如下：</p><ul><li>SEND_MESSAGE</li><li>SEND_MESSAGE_V2</li><li>CONSUMER_SEND_MSG_BACK</li><li>PULL_MESSAGE</li><li>QUERY_MESSAGE</li><li>HEART_BEAT</li><li>UNREGISTER_CLIENT</li><li>GET_CONSUMER_LIST_BY_GROUP</li><li>UPDATE_CONSUMER_OFFSET</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Content</span></span><br><span class="line">SortedMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : request.getExtFields().entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SessionCredentials.SIGNATURE.equals(entry.getKey())) &#123;</span><br><span class="line">        map.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">accessResource.setContent(AclUtils.combineRequestContent(request, map));</span><br><span class="line"><span class="keyword">return</span> accessResource;</span><br></pre></td></tr></table></figure><p>Step4：对扩展字段进行排序，便于生成签名字符串，然后将扩展字段与请求体(body)写入content字段。完成从请求头中解析出本次请求需要验证的权限。</p><h3 id="2-4-validate-方法"><a href="#2-4-validate-方法" class="headerlink" title="2.4 validate 方法"></a>2.4 validate 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(AccessResource accessResource)</span> </span>&#123;</span><br><span class="line">    aclPlugEngine.validate((PlainAccessResource) accessResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>验证权限，即根据本次请求需要的权限与当前用户所拥有的权限进行对比，如果符合，则正常执行；否则抛出AclException。</p><p>为了揭开配置文件的解析与验证，我们将目光投入到PlainPermissionLoader。</p><h2 id="3、PlainPermissionLoader"><a href="#3、PlainPermissionLoader" class="headerlink" title="3、PlainPermissionLoader"></a>3、PlainPermissionLoader</h2><p>该类的主要职责：加载权限，即解析acl主要配置文件plain_acl.yml。</p><h3 id="3-1-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190707121053922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面对其核心属性与核心方法一一介绍：</p><ul><li>DEFAULT_PLAIN_ACL_FILE<br>默认acl配置文件名称，默认值为conf/plain_acl.yml。</li><li>String fileName<br>acl配置文件名称，默认为DEFAULT_PLAIN_ACL_FILE ,可以通过系统参数-Drocketmq.acl.plain.file=fileName指定。</li><li>Map&lt;String, PlainAccessResource&gt; plainAccessResourceMap<br>解析出来的权限配置映射表，以用户名为键。</li><li>RemoteAddressStrategyFactory remoteAddressStrategyFactory<br>远程IP解析策略工厂，用于解析白名单IP地址。</li><li>boolean isWatchStart<br>是否开启了文件监听，即自动监听plain_acl.yml文件，一旦该文件改变，可在不重启服务器的情况下自动生效。</li><li>public PlainPermissionLoader()<br>构造方法。</li><li>public void load()<br>加载配置文件。</li><li>public void validate(PlainAccessResource plainAccessResource)<br>验证是否有权限访问待访问资源。</li></ul><h3 id="3-2-PlainPermissionLoader构造方法"><a href="#3-2-PlainPermissionLoader构造方法" class="headerlink" title="3.2 PlainPermissionLoader构造方法"></a>3.2 PlainPermissionLoader构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlainPermissionLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    load();</span><br><span class="line">    watch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在构造方法中调用load与watch方法。</p><h3 id="3-3-load"><a href="#3-3-load" class="headerlink" title="3.3 load"></a>3.3 load</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, PlainAccessResource&gt; plainAccessResourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;RemoteAddressStrategy&gt; globalWhiteRemoteAddressStrategy = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String path = fileHome + File.separator + fileName;</span><br><span class="line">JSONObject plainAclConfData = AclUtils.getYamlDataObject(path,JSONObject.class);</span><br></pre></td></tr></table></figure><p>Step1：初始化plainAccessResourceMap(用户配置的访问资源，即权限容器)、globalWhiteRemoteAddressStrategy：全局IP白名单访问策略。配置文件，默认为${ROCKETMQ_HOME}/conf/plain_acl.yml。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSONArray globalWhiteRemoteAddressesList = plainAclConfData.getJSONArray(<span class="string">&quot;globalWhiteRemoteAddresses&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (globalWhiteRemoteAddressesList != <span class="keyword">null</span> &amp;&amp; !globalWhiteRemoteAddressesList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; globalWhiteRemoteAddressesList.size(); i++) &#123;</span><br><span class="line">        globalWhiteRemoteAddressStrategy.add(remoteAddressStrategyFactory.</span><br><span class="line">        getRemoteAddressStrategy(globalWhiteRemoteAddressesList.getString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step2：globalWhiteRemoteAddresses：全局白名单，类型为数组。根据配置的规则，使用remoteAddressStrategyFactory获取一个访问策略，下文会重点介绍其配置规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JSONArray accounts = plainAclConfData.getJSONArray(<span class="string">&quot;accounts&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (accounts != <span class="keyword">null</span> &amp;&amp; !accounts.isEmpty()) &#123;</span><br><span class="line">    List&lt;PlainAccessConfig&gt; plainAccessConfigList = accounts.toJavaList(PlainAccessConfig.class);</span><br><span class="line">    <span class="keyword">for</span> (PlainAccessConfig plainAccessConfig : plainAccessConfigList) &#123;</span><br><span class="line">        PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);</span><br><span class="line">        plainAccessResourceMap.put(plainAccessResource.getAccessKey(),plainAccessResource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy;</span><br><span class="line"><span class="keyword">this</span>.plainAccessResourceMap = plainAccessResourceMap;</span><br></pre></td></tr></table></figure><p>Step3：解析plain_acl.yml文件中的另外一个根元素accounts，用户定义的权限信息。从PlainAccessConfig的定义来看，accounts标签下支持如下标签：</p><ul><li>accessKey</li><li>secretKey</li><li>whiteRemoteAddress</li><li>admin</li><li>defaultTopicPerm</li><li>defaultGroupPerm</li><li>topicPerms</li><li>groupPerms<br>上述标签的说明，请参考：:<a href="https://blog.csdn.net/prestigeding/article/details/94317946">《RocketMQ ACL使用指南》</a> 。具体的解析过程比较容易，就不再细说。</li></ul><p>load方法主要完成acl配置文件的解析，将用户定义的权限加载到内存中。</p><h3 id="3-4-watch"><a href="#3-4-watch" class="headerlink" title="3.4 watch"></a>3.4 watch</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String watchFilePath = fileHome + fileName;</span><br><span class="line">        FileWatchService fileWatchService = <span class="keyword">new</span> FileWatchService(<span class="keyword">new</span> String[] &#123;watchFilePath&#125;, <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;   </span><br><span class="line">                    log.info(<span class="string">&quot;The plain acl yml changed, reload the context&quot;</span>);</span><br><span class="line">                    load();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        fileWatchService.start();</span><br><span class="line">        log.info(<span class="string">&quot;Succeed to start AclWatcherService&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.isWatchStart = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Failed to start AclWatcherService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听器，默认以500ms的频率判断文件的内容是否变化。在文件内容发生变化后调用load()方法，重新加载配置文件。那FileWatchService是如何判断两个文件的内容发生了变化呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FileWatchService#hash</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">hash</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    Path path = Paths.get(filePath);</span><br><span class="line">    md.update(Files.readAllBytes(path));</span><br><span class="line">    <span class="keyword">byte</span>[] hash = md.digest();</span><br><span class="line">    <span class="keyword">return</span> UtilAll.bytes2string(hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取文件md5签名来做对比，这里为什么不在启动时先记录上一次文件的修改时间，然后先判断其修改时间是否变化，再判断其内容是否真正发生变化。</p><h3 id="3-5-validate"><a href="#3-5-validate" class="headerlink" title="3.5 validate"></a>3.5 validate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check the global white remote addr</span></span><br><span class="line"><span class="keyword">for</span> (RemoteAddressStrategy remoteAddressStrategy : globalWhiteRemoteAddressStrategy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddressStrategy.match(plainAccessResource)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step1：首先使用全局白名单对资源进行验证，只要一个规则匹配，则返回，表示认证成功。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (plainAccessResource.getAccessKey() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No accessKey is configured&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!plainAccessResourceMap.containsKey(plainAccessResource.getAccessKey())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No acl config for %s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br><span class="line">Step2：如果请求信息中，没有设置用户名，则抛出未配置AccessKey异常；如果Broker中并为配置该用户的配置信息，则抛出AclException。</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the white addr for accesskey</span></span><br><span class="line">PlainAccessResource ownedAccess = plainAccessResourceMap.get(plainAccessResource.getAccessKey());</span><br><span class="line"><span class="keyword">if</span> (ownedAccess.getRemoteAddressStrategy().match(plainAccessResource)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step3：如果用户配置的白名单与待访问资源规则匹配的话，则直接发认证通过。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check the signature</span></span><br><span class="line">String signature = AclUtils.calSignature(plainAccessResource.getContent(), ownedAccess.getSecretKey());</span><br><span class="line"><span class="keyword">if</span> (!signature.equals(plainAccessResource.getSignature())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Check signature failed for accessKey=%s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step4：验证签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkPerm(plainAccessResource, ownedAccess);</span><br></pre></td></tr></table></figure><p>Step5：调用checkPerm方法，验证需要的权限与拥有的权限是否匹配。</p><h4 id="3-5-1-checkPerm"><a href="#3-5-1-checkPerm" class="headerlink" title="3.5.1 checkPerm"></a>3.5.1 checkPerm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Permission.needAdminPerm(needCheckedAccess.getRequestCode()) &amp;&amp; !ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Need admin permission for request code=%d, but accessKey=%s is not&quot;</span>, needCheckedAccess.getRequestCode(), ownedAccess.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step6：如果当前的请求命令属于必须是Admin用户才能访问的权限，并且当前用户并不是管理员角色，则抛出异常，如下命令需要admin角色才能进行的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Byte&gt; needCheckedPermMap = needCheckedAccess.getResourcePermMap();</span><br><span class="line">Map&lt;String, Byte&gt; ownedPermMap = ownedAccess.getResourcePermMap();</span><br><span class="line"><span class="keyword">if</span> (needCheckedPermMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If the needCheckedPermMap is null,then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> &amp;&amp; ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="comment">// If the ownedPermMap is null and it is an admin user, then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step7：如果该请求不需要进行权限验证，则通过认证，如果当前用户的角色是管理员，并且没有配置用户权限，则认证通过，返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Byte&gt; needCheckedEntry : needCheckedPermMap.entrySet()) &#123;</span><br><span class="line">    String resource = needCheckedEntry.getKey();</span><br><span class="line">    Byte neededPerm = needCheckedEntry.getValue();</span><br><span class="line">    <span class="keyword">boolean</span> isGroup = PlainAccessResource.isRetryTopic(resource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> || !ownedPermMap.containsKey(resource)) &#123;</span><br><span class="line">        <span class="comment">// Check the default perm</span></span><br><span class="line">        <span class="keyword">byte</span> ownedPerm = isGroup ? ownedAccess.getDefaultGroupPerm() : ownedAccess.getDefaultTopicPerm();</span><br><span class="line">        <span class="keyword">if</span> (!Permission.checkPermission(neededPerm, ownedPerm)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No default permission for %s&quot;</span>, PlainAccessResource.printStr(resource, isGroup)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Permission.checkPermission(neededPerm, ownedPermMap.get(resource))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No default permission for %s&quot;</span>, PlainAccessResource.printStr(resource, isGroup)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Step8：遍历需要权限与拥有的权限进行对比，如果配置对应的权限，则判断是否匹配；如果未配置权限，则判断默认权限时是否允许，不允许，则抛出AclException。</p><p>验证逻辑就介绍到这里了，下面给出其匹配流程图：<br><img src="https://img-blog.csdnimg.cn/20190707121507431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述阐述了从Broker服务器启动、加载acl配置文件流程、动态监听配置文件、服务端权限验证流程，接下来我们看一下客户端关于ACL需要处理的事情。</p><h2 id="4、AclClientRPCHook"><a href="#4、AclClientRPCHook" class="headerlink" title="4、AclClientRPCHook"></a>4、AclClientRPCHook</h2><p>回顾一下，我们引入ACL机制后，客户端的代码示例如下：<br><img src="https://img-blog.csdnimg.cn/20190707121547164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其在创建DefaultMQProducer时，注册AclClientRPCHook钩子，会在向服务端发送远程命令前后执行其钩子函数，接下来我们重点分析一下AclClientRPCHook。</p><h3 id="4-1-doBeforeRequest"><a href="#4-1-doBeforeRequest" class="headerlink" title="4.1 doBeforeRequest"></a>4.1 doBeforeRequest</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] total = AclUtils.combineRequestContent(request,</span><br><span class="line">           parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken()));   <span class="comment">// @1</span></span><br><span class="line">    String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey());                                                      <span class="comment">// @2</span></span><br><span class="line">    request.addExtField(SIGNATURE, signature);                                                                                                               <span class="comment">// @3</span></span><br><span class="line">    request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());         </span><br><span class="line">    <span class="comment">// The SecurityToken value is unneccessary,user can choose this one.</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCredentials.getSecurityToken() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：将Request请求参数进行排序，并加入accessKey。</p><p>代码@2：对排好序的请参数，使用用户配置的密码生成签名，并最近到扩展字段Signature，然后服务端也会按照相同的算法生成Signature，如果相同，则表示签名验证成功(类似于实现登录的效果)。</p><p>代码@3：将Signature、AccessKey等加入到请求头的扩展字段中，服务端拿到这些元数据，结合请求头中的信息，根据配置的权限，进行权限校验。</p><p>关于ACL客户端生成签名是一种通用套路，就不在细讲了。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;有关RocketMQ ACL的使用请查看上一篇&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/94317946&quot;&gt;《RocketMQ ACL使用指南》&lt;/a&gt;，本文从源码的角度，分析一下RocketMQ ACL的实现原理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;备注：RocketMQ在4.4.0时引入了ACL机制，本文代码基于RocketMQ4.5.0版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据RocketMQ ACL使用手册，我们应该首先看一下Broker服务器在开启ACL机制时如何加载配置文件，并如何工作的。&lt;/p&gt;</summary>
    
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/tags/rocketmq/"/>
    
    <category term="acl" scheme="https://www.codingw.net/tags/acl/"/>
    
  </entry>
  
  <entry>
    <title>源码分析RocketMQ消息轨迹</title>
    <link href="https://www.codingw.net/posts/e8f03b64.html"/>
    <id>https://www.codingw.net/posts/e8f03b64.html</id>
    <published>2020-12-15T14:01:35.000Z</published>
    <updated>2020-12-24T10:13:11.732Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文沿着<a href="https://blog.csdn.net/prestigeding/article/details/95922489">《RocketMQ消息轨迹-设计篇》</a>的思路，从如下3个方面对其源码进行解读：</p><ol><li>发送消息轨迹</li><li>消息轨迹格式</li><li>存储消息轨迹数据</li></ol><h2 id="1、发送消息轨迹流程"><a href="#1、发送消息轨迹流程" class="headerlink" title="1、发送消息轨迹流程"></a>1、发送消息轨迹流程</h2><p>首先我们来看一下在消息发送端如何启用消息轨迹，示例代码如下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>,<span class="keyword">true</span>);      <span class="comment">// @1</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    SendResult sendResult = producer.send(msg);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上述代码可以看出其关键点是在创建DefaultMQProducer时指定开启消息轨迹跟踪。我们不妨浏览一下DefaultMQProducer与启用消息轨迹相关的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, <span class="keyword">boolean</span> enableMsgTrace)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br></pre></td></tr></table></figure><p>参数如下：</p><ul><li>String producerGroup<br>生产者所属组名。</li><li>boolean enableMsgTrace<br>是否开启跟踪消息轨迹，默认为false。</li><li>String customizedTraceTopic<br>如果开启消息轨迹跟踪，用来存储消息轨迹数据所属的主题名称，默认为：RMQ_SYS_TRACE_TOPIC。</li></ul><h3 id="1-1-DefaultMQProducer构造函数"><a href="#1-1-DefaultMQProducer构造函数" class="headerlink" title="1.1 DefaultMQProducer构造函数"></a>1.1 DefaultMQProducer构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook, <span class="keyword">boolean</span> enableMsgTrace,<span class="keyword">final</span> String customizedTraceTopic)</span> </span>&#123;      <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">    defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">    <span class="comment">//if client open the message trace feature</span></span><br><span class="line">    <span class="keyword">if</span> (enableMsgTrace) &#123;                                                                                                                                                                                            <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AsyncTraceDispatcher dispatcher = <span class="keyword">new</span> AsyncTraceDispatcher(customizedTraceTopic, rpcHook);                                                         </span><br><span class="line">            dispatcher.setHostProducer(<span class="keyword">this</span>.getDefaultMQProducerImpl());</span><br><span class="line">            traceDispatcher = dispatcher;</span><br><span class="line">            <span class="keyword">this</span>.getDefaultMQProducerImpl().registerSendMessageHook(</span><br><span class="line">                <span class="keyword">new</span> SendMessageTraceHookImpl(traceDispatcher));                                                                                                                             <span class="comment">// @3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;system mqtrace hook init failed ,maybe can&#x27;t send msg trace data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：首先介绍一下其局部变量。</p><ul><li>String producerGroup<br>生产者所属组。</li><li>RPCHook rpcHook<br>生产者发送钩子函数。</li><li>boolean enableMsgTrace<br>是否开启消息轨迹跟踪。</li><li>String customizedTraceTopic<br>定制用于存储消息轨迹的数据。</li></ul><p>代码@2：用来构建AsyncTraceDispatcher，看其名：异步转发消息轨迹数据，稍后重点关注。</p><p>代码@3：构建SendMessageTraceHookImpl对象，并使用AsyncTraceDispatcher用来异步转发。</p><h3 id="1-2-SendMessageTraceHookImpl钩子函数"><a href="#1-2-SendMessageTraceHookImpl钩子函数" class="headerlink" title="1.2 SendMessageTraceHookImpl钩子函数"></a>1.2 SendMessageTraceHookImpl钩子函数</h3><h4 id="1-2-1-SendMessageTraceHookImpl类图"><a href="#1-2-1-SendMessageTraceHookImpl类图" class="headerlink" title="1.2.1 SendMessageTraceHookImpl类图"></a>1.2.1 SendMessageTraceHookImpl类图</h4><p><img src="https://img-blog.csdnimg.cn/20190803203518449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol><li>SendMessageHook<br>消息发送钩子函数，用于在消息发送之前、发送之后执行一定的业务逻辑，是记录消息轨迹的最佳扩展点。</li><li>TraceDispatcher<br>消息轨迹转发处理器，其默认实现类AsyncTraceDispatcher，异步实现消息轨迹数据的发送。下面对其属性做一个简单的介绍：<ul><li>int queueSize<br>异步转发，队列长度，默认为2048，当前版本不能修改。</li><li>int batchSize<br>批量消息条数，消息轨迹一次消息发送请求包含的数据条数，默认为100，当前版本不能修改。</li><li>int maxMsgSize<br>消息轨迹一次发送的最大消息大小，默认为128K，当前版本不能修改。</li><li>DefaultMQProducer traceProducer<br>  用来发送消息轨迹的消息发送者。</li><li>ThreadPoolExecutor traceExecuter<br>线程池，用来异步执行消息发送。</li><li>AtomicLong discardCount<br>记录丢弃的消息个数。</li><li>Thread worker<br>woker线程，主要负责从追加队列中获取一批待发送的消息轨迹数据，提交到线程池中执行。</li><li>ArrayBlockingQueue&lt; TraceContext&gt; traceContextQueue<br>消息轨迹TraceContext队列，用来存放待发送到服务端的消息。</li><li>ArrayBlockingQueue&lt; Runnable&gt; appenderQueue<br>线程池内部队列，默认长度1024。</li><li>DefaultMQPushConsumerImpl hostConsumer<br>消费者信息，记录消息消费时的轨迹信息。</li><li>String traceTopicName<br>用于跟踪消息轨迹的topic名称。</li></ul></li></ol><h4 id="1-2-2-源码分析SendMessageTraceHookImpl"><a href="#1-2-2-源码分析SendMessageTraceHookImpl" class="headerlink" title="1.2.2 源码分析SendMessageTraceHookImpl"></a>1.2.2 源码分析SendMessageTraceHookImpl</h4><h5 id="1-2-2-1-sendMessageBefore"><a href="#1-2-2-1-sendMessageBefore" class="headerlink" title="1.2.2.1 sendMessageBefore"></a>1.2.2.1 sendMessageBefore</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(SendMessageContext context)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//if it is message trace data,then it doesn&#x27;t recorded</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || context.getMessage().getTopic().startsWith(((AsyncTraceDispatcher) localDispatcher).getTraceTopicName())) &#123;   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//build the context content of TuxeTraceContext</span></span><br><span class="line">    TraceContext tuxeContext = <span class="keyword">new</span> TraceContext();</span><br><span class="line">    tuxeContext.setTraceBeans(<span class="keyword">new</span> ArrayList&lt;TraceBean&gt;(<span class="number">1</span>));</span><br><span class="line">    context.setMqTraceContext(tuxeContext);</span><br><span class="line">    tuxeContext.setTraceType(TraceType.Pub);</span><br><span class="line">    tuxeContext.setGroupName(context.getProducerGroup());                                                                                                                       <span class="comment">// @2</span></span><br><span class="line">    <span class="comment">//build the data bean object of message trace</span></span><br><span class="line">    TraceBean traceBean = <span class="keyword">new</span> TraceBean();                                                                                                                                                <span class="comment">// @3</span></span><br><span class="line">    traceBean.setTopic(context.getMessage().getTopic());</span><br><span class="line">    traceBean.setTags(context.getMessage().getTags());</span><br><span class="line">    traceBean.setKeys(context.getMessage().getKeys());</span><br><span class="line">    traceBean.setStoreHost(context.getBrokerAddr());</span><br><span class="line">    traceBean.setBodyLength(context.getMessage().getBody().length);</span><br><span class="line">    traceBean.setMsgType(context.getMsgType());</span><br><span class="line">    tuxeContext.getTraceBeans().add(traceBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果topic主题为消息轨迹的Topic，直接返回。</p><p>代码@2：在消息发送上下文中，设置用来跟踪消息轨迹的上下环境，里面主要包含一个TraceBean集合、追踪类型（TraceType.Pub）与生产者所属的组。</p><p>代码@3：构建一条跟踪消息，用TraceBean来表示，记录原消息的topic、tags、keys、发送到broker地址、消息体长度等消息。</p><p>从上文看出，sendMessageBefore主要的用途就是在消息发送的时候，先准备一部分消息跟踪日志，存储在发送上下文环境中，此时并不会发送消息轨迹数据。</p><h5 id="1-2-2-2-sendMessageAfter"><a href="#1-2-2-2-sendMessageAfter" class="headerlink" title="1.2.2.2 sendMessageAfter"></a>1.2.2.2 sendMessageAfter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(SendMessageContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if it is message trace data,then it doesn&#x27;t recorded</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || context.getMessage().getTopic().startsWith(((AsyncTraceDispatcher) localDispatcher).getTraceTopicName())     <span class="comment">// @1</span></span><br><span class="line">        || context.getMqTraceContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult().getRegionId() == <span class="keyword">null</span></span><br><span class="line">        || !context.getSendResult().isTraceOn()) &#123;</span><br><span class="line">        <span class="comment">// if switch is false,skip it</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TraceContext tuxeContext = (TraceContext) context.getMqTraceContext();</span><br><span class="line">    TraceBean traceBean = tuxeContext.getTraceBeans().get(<span class="number">0</span>);                                                                                                <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">int</span> costTime = (<span class="keyword">int</span>) ((System.currentTimeMillis() - tuxeContext.getTimeStamp()) / tuxeContext.getTraceBeans().size());     <span class="comment">// @3</span></span><br><span class="line">    tuxeContext.setCostTime(costTime);                                                                                                                                      <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult().getSendStatus().equals(SendStatus.SEND_OK)) &#123;                                                                    </span><br><span class="line">        tuxeContext.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tuxeContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tuxeContext.setRegionId(context.getSendResult().getRegionId());                                                                                      </span><br><span class="line">    traceBean.setMsgId(context.getSendResult().getMsgId());</span><br><span class="line">    traceBean.setOffsetMsgId(context.getSendResult().getOffsetMsgId());</span><br><span class="line">    traceBean.setStoreTime(tuxeContext.getTimeStamp() + costTime / <span class="number">2</span>);</span><br><span class="line">    localDispatcher.append(tuxeContext);                                                                                                                                   <span class="comment">// @5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果topic主题为消息轨迹的Topic，直接返回。</p><p>代码@2：从MqTraceContext中获取跟踪的TraceBean，虽然设计成List结构体，但在消息发送场景，这里的数据永远只有一条，及时是批量发送也不例外。</p><p>代码@3：获取消息发送到收到响应结果的耗时。</p><p>代码@4：设置costTime(耗时)、success(是否发送成功)、regionId(发送到broker所在的分区)、msgId(消息ID，全局唯一)、offsetMsgId(消息物理偏移量，如果是批量消息，则是最后一条消息的物理偏移量)、storeTime，这里使用的是(客户端发送时间 + 二分之一的耗时)来表示消息的存储时间，这里是一个估值。</p><p>代码@5：将需要跟踪的信息通过TraceDispatcher转发到Broker服务器。其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> Object ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = traceContextQueue.offer((TraceContext) ctx);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;buffer full&quot;</span> + discardCount.incrementAndGet() + <span class="string">&quot; ,context is &quot;</span> + ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里一个非常关键的点是offer方法的使用，当队列无法容纳新的元素时会立即返回false，并不会阻塞。</p><p>接下来将目光转向TraceDispatcher的实现。</p><h3 id="1-3-TraceDispatcher实现原理"><a href="#1-3-TraceDispatcher实现原理" class="headerlink" title="1.3 TraceDispatcher实现原理"></a>1.3 TraceDispatcher实现原理</h3><p>TraceDispatcher，用于客户端消息轨迹数据转发到Broker，其默认实现类：AsyncTraceDispatcher。</p><h4 id="1-3-1-TraceDispatcher构造函数"><a href="#1-3-1-TraceDispatcher构造函数" class="headerlink" title="1.3.1 TraceDispatcher构造函数"></a>1.3.1 TraceDispatcher构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTraceDispatcher</span><span class="params">(String traceTopicName, RPCHook rpcHook)</span> <span class="keyword">throws</span> MQClientException </span>&#123;    </span><br><span class="line">    <span class="comment">// queueSize is greater than or equal to the n power of 2 of value</span></span><br><span class="line">    <span class="keyword">this</span>.queueSize = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">this</span>.batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.maxMsgSize = <span class="number">128000</span>;                                        </span><br><span class="line">    <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);         </span><br><span class="line">    <span class="keyword">this</span>.traceContextQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;TraceContext&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">this</span>.appenderQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueSize);</span><br><span class="line">    <span class="keyword">if</span> (!UtilAll.isBlank(traceTopicName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.traceTopicName = traceTopicName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.traceTopicName = MixAll.RMQ_SYS_TRACE_TOPIC;</span><br><span class="line">    &#125;                   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.traceExecuter = <span class="keyword">new</span> ThreadPoolExecutor(<span class="comment">// :</span></span><br><span class="line">        <span class="number">10</span>, <span class="comment">//</span></span><br><span class="line">        <span class="number">20</span>, <span class="comment">//</span></span><br><span class="line">        <span class="number">1000</span> * <span class="number">60</span>, <span class="comment">//</span></span><br><span class="line">        TimeUnit.MILLISECONDS, <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.appenderQueue, <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">&quot;MQTraceSendThread_&quot;</span>));</span><br><span class="line">    traceProducer = getAndCreateTraceProducer(rpcHook);      <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：初始化核心属性，该版本这些值都是“固化”的，用户无法修改。</p><ul><li>queueSize<br>队列长度，默认为2048，异步线程池能够积压的消息轨迹数量。</li><li>batchSize<br>一次向Broker批量发送的消息条数，默认为100.</li><li>maxMsgSize<br>向Broker汇报消息轨迹时，消息体的总大小不能超过该值，默认为128k。</li><li>discardCount<br>整个运行过程中，丢弃的消息轨迹数据，这里要说明一点的是，如果消息TPS发送过大，异步转发线程处理不过来时，会主动丢弃消息轨迹数据。</li><li>traceContextQueue<br>traceContext积压队列，客户端(消息发送、消息消费者)在收到处理结果后，将消息轨迹提交到噶队列中，则会立即返回。</li><li>appenderQueue<br>提交到Broker线程池中队列。</li><li>traceTopicName<br>用于接收消息轨迹的Topic，默认为RMQ_SYS_TRANS_HALF_TOPIC。</li><li>traceExecuter<br>用于发送到Broker服务的异步线程池，核心线程数默认为10，最大线程池为20，队列堆积长度2048，线程名称：MQTraceSendThread_。、</li><li>traceProducer<br>发送消息轨迹的Producer。</li></ul><p>代码@2：调用getAndCreateTraceProducer方法创建用于发送消息轨迹的Producer(消息发送者)，下面详细介绍一下其实现。</p><h4 id="1-3-2-getAndCreateTraceProducer详解"><a href="#1-3-2-getAndCreateTraceProducer详解" class="headerlink" title="1.3.2 getAndCreateTraceProducer详解"></a>1.3.2 getAndCreateTraceProducer详解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefaultMQProducer <span class="title">getAndCreateTraceProducer</span><span class="params">(RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        DefaultMQProducer traceProducerInstance = <span class="keyword">this</span>.traceProducer;</span><br><span class="line">        <span class="keyword">if</span> (traceProducerInstance == <span class="keyword">null</span>) &#123;  <span class="comment">//@1</span></span><br><span class="line">            traceProducerInstance = <span class="keyword">new</span> DefaultMQProducer(rpcHook);</span><br><span class="line">            traceProducerInstance.setProducerGroup(TraceConstants.GROUP_NAME);</span><br><span class="line">            traceProducerInstance.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">            traceProducerInstance.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// The max size of message is 128K</span></span><br><span class="line">            traceProducerInstance.setMaxMessageSize(maxMsgSize - <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traceProducerInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果还未建立发送者，则创建用于发送消息轨迹的消息发送者，其GroupName为：_INNER_TRACE_PRODUCER，消息发送超时时间5s，最大允许发送消息大小118K。</p><h4 id="1-3-3-start"><a href="#1-3-3-start" class="headerlink" title="1.3.3 start"></a>1.3.3 start</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nameSrvAddr)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;     <span class="comment">// @1</span></span><br><span class="line">        traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">        traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">&quot;_&quot;</span> + nameSrvAddr);</span><br><span class="line">        traceProducer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AsyncRunnable(), <span class="string">&quot;MQ-AsyncTraceDispatcher-Thread-&quot;</span> + dispatcherId);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.worker.start();                                                                                   </span><br><span class="line">    <span class="keyword">this</span>.registerShutDownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始启动，其调用的时机为启动DefaultMQProducer时，如果启用跟踪消息轨迹，则调用之。</p><p>代码@1：如果用于发送消息轨迹的发送者没有启动，则设置nameserver地址，并启动着。</p><p>代码@2：启动一个线程，用于执行AsyncRunnable任务，接下来将重点介绍。</p><h4 id="1-3-4-AsyncRunnable"><a href="#1-3-4-AsyncRunnable" class="headerlink" title="1.3.4 AsyncRunnable"></a>1.3.4 AsyncRunnable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">boolean</span> stopped;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            List&lt;TraceContext&gt; contexts = <span class="keyword">new</span> ArrayList&lt;TraceContext&gt;(batchSize);     <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">                TraceContext context = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//get trace data element from blocking Queue — traceContextQueue</span></span><br><span class="line">                    context = traceContextQueue.poll(<span class="number">5</span>, TimeUnit.MILLISECONDS);        <span class="comment">// @2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    contexts.add(context);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (contexts.size() &gt; <span class="number">0</span>) &#123;                                                                               :</span><br><span class="line">                AsyncAppenderRequest request = <span class="keyword">new</span> AsyncAppenderRequest(contexts);  <span class="comment">// @3</span></span><br><span class="line">                traceExecuter.submit(request);                                                               </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AsyncTraceDispatcher.<span class="keyword">this</span>.stopped) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stopped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：构建待提交消息跟踪Bean，每次最多发送batchSize，默认为100条。</p><p>代码@2：从traceContextQueue中取出一个待提交的TraceContext，设置超时时间为5s，即如何该队列中没有待提交的TraceContext，则最多等待5s。</p><p>代码@3：向线程池中提交任务AsyncAppenderRequest。</p><h4 id="1-3-5-AsyncAppenderRequest-sendTraceData"><a href="#1-3-5-AsyncAppenderRequest-sendTraceData" class="headerlink" title="1.3.5 AsyncAppenderRequest#sendTraceData"></a>1.3.5 AsyncAppenderRequest#sendTraceData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTraceData</span><span class="params">(List&lt;TraceContext&gt; contextList)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;TraceTransferBean&gt;&gt; transBeanMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;TraceTransferBean&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TraceContext context : contextList) &#123;        <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">if</span> (context.getTraceBeans().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Topic value corresponding to original message entity content</span></span><br><span class="line">        String topic = context.getTraceBeans().get(<span class="number">0</span>).getTopic();     <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">// Use  original message entity&#x27;s topic as key</span></span><br><span class="line">        String key = topic;</span><br><span class="line">        List&lt;TraceTransferBean&gt; transBeanList = transBeanMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (transBeanList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transBeanList = <span class="keyword">new</span> ArrayList&lt;TraceTransferBean&gt;();</span><br><span class="line">            transBeanMap.put(key, transBeanList);</span><br><span class="line">        &#125;</span><br><span class="line">        TraceTransferBean traceData = TraceDataEncoder.encoderFromContextBean(context);    <span class="comment">// @3</span></span><br><span class="line">        transBeanList.add(traceData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;TraceTransferBean&gt;&gt; entry : transBeanMap.entrySet()) &#123;       <span class="comment">// @4</span></span><br><span class="line">        flushData(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：遍历收集的消息轨迹数据。</p><p>代码@2：获取存储消息轨迹的Topic。</p><p>代码@3：对TraceContext进行编码，这里是消息轨迹的传输数据，稍后对其详细看一下，了解其上传的格式。</p><p>代码@4：将编码后的数据发送到Broker服务器。</p><h4 id="1-3-6-TraceDataEncoder-encoderFromContextBean"><a href="#1-3-6-TraceDataEncoder-encoderFromContextBean" class="headerlink" title="1.3.6 TraceDataEncoder#encoderFromContextBean"></a>1.3.6 TraceDataEncoder#encoderFromContextBean</h4><p>根据消息轨迹跟踪类型，其格式会有一些不一样，下面分别来介绍其合适。</p><h5 id="1-3-6-1-PUB-消息发送"><a href="#1-3-6-1-PUB-消息发送" class="headerlink" title="1.3.6.1 PUB(消息发送)"></a>1.3.6.1 PUB(消息发送)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Pub: &#123;</span><br><span class="line">    TraceBean bean = ctx.getTraceBeans().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//append the content of context and traceBean to transferBean&#x27;s TransData</span></span><br><span class="line">    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">     .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>消息轨迹数据的协议使用字符串拼接，字段的分隔符号为1，整个数据以2结尾，感觉这个设计还是有点“不可思议”，为什么不直接使用json协议呢？</p><h5 id="1-3-6-2-SubBefore-消息消费之前"><a href="#1-3-6-2-SubBefore-消息消费之前" class="headerlink" title="1.3.6.2 SubBefore(消息消费之前)"></a>1.3.6.2 SubBefore(消息消费之前)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (TraceBean bean : ctx.getTraceBeans()) &#123;</span><br><span class="line">    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>轨迹就是按照上述顺序拼接而成，各个字段使用1分隔，每一条记录使用2结尾。</p><h5 id="1-3-2-3-SubAfter（消息消费后）"><a href="#1-3-2-3-SubAfter（消息消费后）" class="headerlink" title="1.3.2.3 SubAfter（消息消费后）"></a>1.3.2.3 SubAfter（消息消费后）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SubAfter: &#123;</span><br><span class="line">    <span class="keyword">for</span> (TraceBean bean : ctx.getTraceBeans()) &#123;</span><br><span class="line">        sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getContextCode()).append(TraceConstants.FIELD_SPLITOR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>格式编码一样，就不重复多说。</p><p>经过上面的源码跟踪，消息发送端的消息轨迹跟踪流程、消息轨迹数据编码协议就清晰了，接下来我们使用一张序列图来结束本部分的讲解。<br><img src="https://img-blog.csdnimg.cn/20190803204514547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其实行文至此，只关注了消息发送的消息轨迹跟踪，消息消费的轨迹跟踪又是如何呢？其实现原理其实是一样的，就是在消息消费前后执行特定的钩子函数，其实现类为ConsumeMessageTraceHookImpl，由于其实现与消息发送的思路类似，故就不详细介绍了。</p><h2 id="2、-消息轨迹数据如何存储"><a href="#2、-消息轨迹数据如何存储" class="headerlink" title="2、 消息轨迹数据如何存储"></a>2、 消息轨迹数据如何存储</h2><p>其实从上面的分析，我们已经得知，RocketMQ的消息轨迹数据存储在到Broker上，那消息轨迹的主题名如何指定？其路由信息又怎么分配才好呢？是每台Broker上都创建还是只在其中某台上创建呢？RocketMQ支持系统默认与自定义消息轨迹的主题。</p><h3 id="2-1-使用系统默认的主题名称"><a href="#2-1-使用系统默认的主题名称" class="headerlink" title="2.1 使用系统默认的主题名称"></a>2.1 使用系统默认的主题名称</h3><p>RocketMQ默认的消息轨迹主题为：RMQ_SYS_TRACE_TOPIC，那该Topic需要手工创建吗？其路由信息呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceTopicEnable()) &#123;    <span class="comment">// @1</span></span><br><span class="line">        String topic = <span class="keyword">this</span>.brokerController.getBrokerConfig().getMsgTraceTopicName();</span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line">        <span class="keyword">this</span>.systemTopicList.add(topic);</span><br><span class="line">        topicConfig.setReadQueueNums(<span class="number">1</span>);                                              <span class="comment">// @2</span></span><br><span class="line">        topicConfig.setWriteQueueNums(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码出自TopicConfigManager的构造函数，在Broker启动的时候会创建topicConfigManager对象，用来管理topic的路由信息。</p><p>代码@1：如果Broker开启了消息轨迹跟踪(traceTopicEnable=true)时，会自动创建默认消息轨迹的topic路由信息，注意其读写队列数为1。</p><h3 id="2-2-用户自定义消息轨迹主题"><a href="#2-2-用户自定义消息轨迹主题" class="headerlink" title="2.2 用户自定义消息轨迹主题"></a>2.2 用户自定义消息轨迹主题</h3><p>在创建消息发送者、消息消费者时，可以显示的指定消息轨迹的Topic，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook, <span class="keyword">boolean</span> enableMsgTrace,<span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">        AllocateMessageQueueStrategy allocateMessageQueueStrategy, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br></pre></td></tr></table></figure><p>通过customizedTraceTopic来指定消息轨迹Topic。</p><blockquote><p>温馨提示：通常在生产环境上，将不会开启自动创建主题，故需要RocketMQ运维管理人员提前创建好Topic。</p></blockquote><p>好了，本文就介绍到这里了，本文详细介绍了RocktMQ消息轨迹的实现原理，下一篇，我们将进入到多副本的学习中。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文沿着&lt;a href=&quot;https://blog.csdn.net/prestigeding/article/details/95922489&quot;&gt;《RocketMQ消息轨迹-设计篇》&lt;/a&gt;的思路，从如下3个方面对其源码进行解读：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送消息轨迹&lt;/li&gt;
&lt;li&gt;消息轨迹格式&lt;/li&gt;
&lt;li&gt;存储消息轨迹数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1、发送消息轨迹流程&quot;&gt;&lt;a href=&quot;#1、发送消息轨迹流程&quot; class=&quot;headerlink&quot; title=&quot;1、发送消息轨迹流程&quot;&gt;&lt;/a&gt;1、发送消息轨迹流程&lt;/h2&gt;&lt;p&gt;首先我们来看一下在消息发送端如何启用消息轨迹，示例代码如下：&lt;/p&gt;</summary>
    
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/categories/rocketmq/"/>
    
    
    <category term="rocketmq" scheme="https://www.codingw.net/tags/rocketmq/"/>
    
    <category term="消息轨迹" scheme="https://www.codingw.net/tags/%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>AtomicIntegerArray源码分析与感悟.</title>
    <link href="https://www.codingw.net/posts/e3c7511d.html"/>
    <id>https://www.codingw.net/posts/e3c7511d.html</id>
    <published>2020-12-14T11:53:01.000Z</published>
    <updated>2020-12-24T10:13:23.731Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><a id="more"></a>![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)<p>AtomicIntegerArray，提供了一个原子访问数据中元素方法的一种途径。</p><p>对于这类原子操作，在理解上应该没什么问题，通过AtomitoIntegerArray，我学到如下几个关键点：</p><ul><li>int  sacle = unsafe.arrayIndexScale（int[].class）与  int base = unsafe.arrayBaseOffset(Int[].class);<br>其中 unsafe.arrayBaseOffset 获取该类型的数组，在对象存储时，存放第一个元素的内存地址，相对于数组对象起始地址的内存偏移量。unsafe.arrayIndexSacle(int[].class) 获取该类型的数组中元素的大小，占用多少个字节。</li><li>根据scale ，base 如何准备定位到任意一个下标的地址呢？请查看如下关键代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>用于定位元素偏移量的控制值。</p><p>举例说明，int scale = 4;1个int类型，在java中占用4个字节。</p><p>Integer.numberOfLeadingZeros(scale); 返回 scale 高位连续0的个数，得出shift = 2, 而shift在如下方法使用</p><p>得出结论了吧，shift就是 用来定位数组中的内存位置，用来移位用的，每向左移动移位，在不越界的情况下，想当于乘以2。也就是int类型的长度为4，也就是第0个位置是0，第1(i)个位置是4,，第二个(i)位置是8，也就是偏移位置等于  i * 4,也就是  i &lt;&lt; 2;总结出一个乘法转换成移位操作的案例： a * (一个2的幂(n)的数)  =  a &lt;&lt; n; 给出一个指定2的幂的数，怎么算成n,,参照shift的计算方法。 </p><p>附上AtomicIntegerArray 源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@code</span> int&#125; array in which elements may be updated atomically.</span></span><br><span class="line"><span class="comment"> * See the &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package</span></span><br><span class="line"><span class="comment"> * specification for description of the properties of atomic</span></span><br><span class="line"><span class="comment"> * variables.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArray</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2862133569453604235L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray of the given length, with all</span></span><br><span class="line"><span class="comment">     * elements initially zero.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray with the same length as, and</span></span><br><span class="line"><span class="comment">     * all elements copied from, the given array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array the array to copy elements from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if array is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">        <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the length of the array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value at position &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, newValue))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * and does not provide ordering guarantees, so is only rarely an</span></span><br><span class="line"><span class="comment">     * appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSet(i, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, current + delta))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">int</span> next = current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current values of array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current values of array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iMax = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            b.append(getRaw(byteOffset(i)));</span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            b.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
      
      
    <summary type="html">&lt;div id=&quot;vip-container&quot;&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

&lt;p</summary>
      
    
    
    
    <category term="java" scheme="https://www.codingw.net/categories/java/"/>
    
    
    <category term="java" scheme="https://www.codingw.net/tags/java/"/>
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo Filter机制概述</title>
    <link href="https://www.codingw.net/posts/a061d56c.html"/>
    <id>https://www.codingw.net/posts/a061d56c.html</id>
    <published>2020-12-12T11:10:01.000Z</published>
    <updated>2020-12-24T10:13:31.780Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo&#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter</span><br><span class="line">generic&#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter</span><br><span class="line">genericimpl&#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter</span><br><span class="line">token&#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter</span><br><span class="line">accesslog&#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter</span><br><span class="line">activelimit&#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span><br><span class="line">classloader&#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</span><br><span class="line">context&#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter</span><br><span class="line">consumercontext&#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter</span><br><span class="line">exception&#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br><span class="line">executelimit&#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span><br><span class="line">deprecated&#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter</span><br><span class="line">compatible&#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter</span><br><span class="line">timeout&#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter</span><br></pre></td></tr></table></figure><p>以其中一个来说明一下Filter的定义要素：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * EchoInvokerFilter</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Activate(group &#x3D; Constants.PROVIDER, order &#x3D; -110000)    &#x2F;&#x2F; @2</span><br><span class="line">public class EchoFilter implements Filter &#123;                                 &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        if (inv.getMethodName().equals(Constants.$ECHO) &amp;&amp; inv.getArguments() !&#x3D; null &amp;&amp; inv.getArguments().length &#x3D;&#x3D; 1)</span><br><span class="line">            return new RpcResult(inv.getArguments()[0]);</span><br><span class="line">        return invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：实现com.alibaba.dubbo.rpc.Filter接口。</p><p>代码@2：添加Activate，其注解含义如下：</p><ul><li><p>group： 所属组，String[],例如消费端、服务端。<br>value String[]，如果指定该值，只有当消费者或服务提供者URL中包含属性名为value的键值对，该过滤器才处于激活状态。</p></li><li><p>before：String[]，用于指定执行顺序，before指定的过滤器在该过滤器之前执行。</p></li><li><p>after：string[]，用于指定执行顺序，after指定的过滤器在该过滤器之后执行。</p></li><li><p>order：用户指定顺序，值越小，越先执行。<br>除了支持默认的过滤器外，Dubbo还支持自定义Filter，可以通过service.filter指定过滤器，多个用英文逗号隔开，其配置方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:service ......&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure><p>当然，可以为所有服务提供者设置共用过滤器，其指定方法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:provider ...&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:provider&gt;</span><br></pre></td></tr></table></figure><p>消费端自定义过滤器的key为reference.filter，其使用方法在&lt; dubbo:reference/&gt;标签或&lt; dubbo:consumer/&gt;标签下定义属性。关于自定义Filter的解析代码如下：<br>ExtensionLoader#getActivateExtension</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String key, String group) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        String value &#x3D; url.getParameter(key);                                                 &#x2F;&#x2F; @2</span><br><span class="line">        return getActivateExtension(url, value &#x3D;&#x3D; null || value.length() &#x3D;&#x3D; 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), group);    &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1：参数说明。</p><ul><li>URL url：服务提供者或服务消费者url。</li><li>String key：过滤器属性key，服务提供者固定为:service.filter，服务消费者固定为reference.filter。</li><li>String group：服务提供者或服务消费者。</li></ul><p>代码@2：从url中获取配置的自定义filter。</p><p>代码@3：如果value不为空，则将字符串调用split转换为数组，然后调用getActivateExtension方法，获取符合条件的过滤器。</p><p>ExtensionLoader#getActivateExtension</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) &#123;</span><br><span class="line">        List&lt;T&gt; exts &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; names &#x3D; values &#x3D;&#x3D; null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);</span><br><span class="line">        if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">            getExtensionClasses();                                                                                                            &#x2F;&#x2F; @2</span><br><span class="line">            for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">                String name &#x3D; entry.getKey();</span><br><span class="line">                Activate activate &#x3D; entry.getValue();</span><br><span class="line">                if (isMatchGroup(group, activate.group())) &#123;                                                                        &#x2F;&#x2F; @3</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    if (!names.contains(name)</span><br><span class="line">                            &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)                    &#x2F;&#x2F; @4      </span><br><span class="line">                            &amp;&amp; isActive(activate, url)) &#123;                                                                                      &#x2F;&#x2F; @5</span><br><span class="line">                        exts.add(ext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; usrs &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.size(); i++) &#123;                                                                                           &#x2F;&#x2F; @6</span><br><span class="line">            String name &#x3D; names.get(i);</span><br><span class="line">            if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                    &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">                if (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    if (!usrs.isEmpty()) &#123;</span><br><span class="line">                        exts.addAll(0, usrs);</span><br><span class="line">                        usrs.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    usrs.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!usrs.isEmpty()) &#123;</span><br><span class="line">            exts.addAll(usrs);</span><br><span class="line">        &#125;</span><br><span class="line">        return exts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：如果配置的service.filter或referecnce.filter包含了-default，表示禁用系统默认提供的一系列过滤器。</p><p>代码@2：如果不禁用系统默认过滤器链，则首先加载所有默认过滤器。</p><p>代码@3：根据group刷选出适配的过滤器。</p><p>代码@4：也可以对单个filter进行禁用，其方法是-过滤器名称的方式。例如如想禁用AccessLogFilter，则可以通过-accesslog方式禁用。-key,key为/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中定义的key。</p><p>代码@5：判断过滤器是否激活，其逻辑是如果Filter上的@Activate注解value值不为空，则需要判断url中是否包含键为value的属性对，存在则启用，不存在则不启用。</p><p>代码@6：加载用户自定义的Filter，也即是service.filter或reference.filter指定的过滤器。<br>综上所述，Dubbo提供了过滤器机制，在真实服务被调用前提供扩展点。Filter机制就简单介绍到这里了，从下文开始会重点分析Dubbo服务提供的核心Filter。</p><p>如果需要自定过滤器，需要在自定的工程中META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中注册。</p><p>本文就介绍到这里了，从下篇开始将会根据Dubbo的功能特性来详细分析其实现过程，其本质都是各种Dubbo 过滤器器。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;echo&amp;#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;generic&amp;#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;genericimpl&amp;#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;token&amp;#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;accesslog&amp;#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;activelimit&amp;#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;classloader&amp;#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;context&amp;#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;consumercontext&amp;#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;exception&amp;#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;executelimit&amp;#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;deprecated&amp;#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;compatible&amp;#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;timeout&amp;#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以其中一个来说明一下Filter的定义要素：&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="https://www.codingw.net/categories/dubbo/"/>
    
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="https://www.codingw.net/tags/dubbo/"/>
    
    <category term="Filter" scheme="https://www.codingw.net/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo服务治理之灰度发布方案（版本发布控制影响范围）</title>
    <link href="https://www.codingw.net/posts/6bc72b05.html"/>
    <id>https://www.codingw.net/posts/6bc72b05.html</id>
    <published>2020-12-11T11:30:01.000Z</published>
    <updated>2020-12-24T10:13:42.430Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h2 id="1、方案背景"><a href="#1、方案背景" class="headerlink" title="1、方案背景"></a>1、方案背景</h2><p>背景：基于Dubbo服务的治理，是否可以支持业务级别的灰度发布、是否基于业务参数的路由转发。例如以GIS为例，当发布一个新版本时，是否可以以按照解析地址或合作伙伴来区分，版本发布之初，只希望地址为：广东省的解析请求发送到新版本，而其他的地址请求还是使用旧版；或者根据合作伙伴例如UCP(优享寄)的请求转发到新版本服务器，其他合作伙伴还是转发到旧版，达成业务级别的灰度发布，控制新版本的影响范围。例如OMS系统，可以根据合作伙伴，将重量级客户的请求转发到单独的服务器集群，确保其高可用。<br>本文将对上述议题结合Dubbo提供的功能，提出设计方案。</p><h2 id="2、方案理论基础"><a href="#2、方案理论基础" class="headerlink" title="2、方案理论基础"></a>2、方案理论基础</h2><p>Dubbo的服务调用原理图：<br><img src="https://img-blog.csdn.net/20181015123333422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>客户端在发起RPC服务调用之前，在客户端首先从服务器列表中选择一个服务调用者，包含如下关键角色：</p><a id="more"></a><p>1、Directory<br>服务的动态发现，通常基于注册中心进行服务的动态注册与发现，其具体实现类为RegistryDirectory。<br>2、Router<br>路由实现，其含义是根据Directory发现的所有服务提供者列表中，进行路由选择，也就是根据一定的路由规则选择合适的服务提供者，为Directory发现的服务提供者列表子集，可以基于Condition或脚本（默认为JS脚本，其实现类为ScriptRouter）。<br>3、LoadBalance<br>负载均衡机制，其作用主要是根据负载均衡算法（随机、轮询）<br>等算法，从（Directory–&gt;Router）中返回的服务提供者列表中选择一个服务提供者，进行本次的RPC服务调用。<br>4、Cluster<br>集群（容错机制），就是当从服务提供者列表中按照负载均衡算法选择一个服务提供者，进行RPC服务调用后，发送了异常后的策略，例如failover(重试)、failfast(快速失败)等。<br>服务的灰度发布，其目标是希望根据请求，某些请求走新版本服务器，某些请求走旧版本服务器，其本质就是路由机制，即通过一定的条件来缩小服务的服务提供者列表，正好与Dubbo的Router相吻合。<br>有关于Dubbo的Router机制，请参考官方文档第【46、47、48】页，如果想从源码的角度了解其实现机制，请参考博文：<a href="https://blog.csdn.net/prestigeding/article/details/80848594">https://blog.csdn.net/prestigeding/article/details/80848594</a><br>有了理论支持，下文将根据上述理论进行实战。</p><h2 id="3、方案具体实现示例"><a href="#3、方案具体实现示例" class="headerlink" title="3、方案具体实现示例"></a>3、方案具体实现示例</h2><p>本示例代码需要完成的任务是，对DemoService#createUser服务，其用户机构ID(orgId)为1的走新版本（当前服务提取者列表的最后一台服务器），其他的请求走所有的服务器（除最后一台服务器）。<br> <img src="https://img-blog.csdn.net/20181015123609793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20181015123700316?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>由于是需要基于请求参数，本文给出基于JS脚本的路由机制，首先，当前版本的dubbo-admin可以后台页面维护基于条件表达式的路由规则，其界面如下：<br> <img src="https://img-blog.csdn.net/20181015123744903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdn.net/20181015123836904?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>备注：并且当前dubbo-admin版本，并不支持基于JS表达式的路由规则，如果手动建立基于表达式的路由规则，其页面将无法列出路由表达式，其界面如下：<br><img src="https://img-blog.csdn.net/20181015123902592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p><h3 id="3-1-JS脚本"><a href="#3-1-JS脚本" class="headerlink" title="3.1 JS脚本"></a>3.1 JS脚本</h3><p>各个项目，各个服务需要根据自身的需求，定义如下脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * DemoService router，针对不同的方法，可能需要各自提供，主要是参数的获取，不同的过滤规则</span><br><span class="line"> * 针对参数进行路由过滤</span><br><span class="line"> * </span><br><span class="line"> * 本示例针对 DemoSerivce# ResponseResult createUser(User user) 方法，根据user的orgId进行路由选择</span><br><span class="line"> * @param invokers</span><br><span class="line"> * @param invocation</span><br><span class="line"> * @param context</span><br><span class="line"> * @returns</span><br><span class="line"> *&#x2F;</span><br><span class="line">function demoService_createUser_router(invokers, invocation, context) &#123;</span><br><span class="line">if(invokers &#x3D;&#x3D; null || invokers.size() &lt; 1) &#123;</span><br><span class="line">return invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(!&quot;createUser&quot;.equals(invocation.getMethodName())) &#123; &#x2F;&#x2F; 如果方法不匹配，默认无条件通过该路由规则</span><br><span class="line">return invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var availableInvokers &#x3D; new java.util.ArrayList(invokers.size());</span><br><span class="line">for (var i&#x3D;0;i&lt;invokers.size(); i++) &#123;    &#x2F;&#x2F; 先选择可用的服务提供者列表</span><br><span class="line">if(invokers.get(i).isAvailable()) &#123;</span><br><span class="line">availableInvokers.add(invokers.get(i));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var invArguments &#x3D; invocation.getArguments();</span><br><span class="line">if(invArguments &#x3D;&#x3D; null || invArguments.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 如果参数为空，无法根据参数进行路由选择</span><br><span class="line">return availableInvokers; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取需要进行路由的参数，这里使用第一个参数 ，这里各自根据各自的业务 进行获取，本实例默认使用第一个参数</span><br><span class="line">var firstArgument &#x3D; invArguments[0];</span><br><span class="line">var orgId &#x3D; firstArgument &#x3D;&#x3D; null ? &quot;&quot; : firstArgument.getOrgId();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if(orgId &#x3D;&#x3D; 1 || orgId &#x3D;&#x3D; &quot;1&quot;) &#123; &#x2F;&#x2F; 如果orgId &#x3D;&#x3D; 1 ，只走最后一个节点，其余的走其他节点</span><br><span class="line">var selectInvokers &#x3D; new java.util.ArrayList(1);</span><br><span class="line">selectInvokers.add(availableInvokers.get(availableInvokers.size()-1));</span><br><span class="line">return selectInvokers;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">var selectInvokers &#x3D; new java.util.ArrayList(availableInvokers.size()-1);</span><br><span class="line">for(var i&#x3D;0;i&lt;availableInvokers.size()-1; i++) &#123;</span><br><span class="line">selectInvokers.add(availableInvokers.get(i));</span><br><span class="line">&#125;</span><br><span class="line">return selectInvokers;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-向注册中心注册JS脚本路由规则"><a href="#3-2-向注册中心注册JS脚本路由规则" class="headerlink" title="3.2 向注册中心注册JS脚本路由规则"></a>3.2 向注册中心注册JS脚本路由规则</h3><p>上文已经说明，目前的dubbo-admin不支持在界面上注册路由规则，现给出基于JAVA代码来编写注册程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">URL registryUrl &#x3D; URL.valueOf(&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;);</span><br><span class="line">    ZookeeperRegistryFactory zookeeperRegistryFactory &#x3D; new </span><br><span class="line">                       ZookeeperRegistryFactory();</span><br><span class="line">   zookeeperRegistryFactory.setZookeeperTransporter(new </span><br><span class="line">        CuratorZookeeperTransporter());</span><br><span class="line">   Registry zookeeperRegistry &#x3D; (ZookeeperRegistry) </span><br><span class="line">             zookeeperRegistryFactory.createRegistry(registryUrl);</span><br><span class="line">   URL routerURL &#x3D; </span><br><span class="line">          URL.valueOf(&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.alibaba.dubbo.demo.Demo</span><br><span class="line">                Service?category&#x3D;routers&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;fo</span><br><span class="line">                rce&#x3D;false&amp;name&#x3D;demoService_createUser_router&amp;priority&#x3D;</span><br><span class="line">          0&amp;runtime&#x3D;true&quot;);</span><br><span class="line">   routerURL &#x3D; routerURL.addParameter(&quot;rule&quot;, </span><br><span class="line">   URL.encode(get_demoService_createUser_router()));</span><br><span class="line">   zookeeperRegistry.register(routerURL);     &#x2F;&#x2F; 注册</span><br><span class="line">   &#x2F;&#x2F; zookeeperRegistry.unregister(routerURL); &#x2F;&#x2F; 取消注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦运行上述代码，将会动态注册URL，服务提供者无需重启，下次服务调用后会自动生效（其背后原理是基于注册中心的动态发现）。<br>上述示例代码，我已经在本地环境，已能成功运行，并达到预期效果，公司项目需要根据自身的特点，特别服务方法的参数（例如合作伙伴ID的获取方式），以及路由需求来定制编写其路由脚本（js脚本）。</p><h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><p>上述展示了Dubbo服务基于业务灰度发布的方案，以及基于合作伙伴的服务隔离机制（根据服务调用业务参数来决定服务调用者的筛选）。主要是展示了基于脚步的路由规则，其条件表达式的路由规则请参考其Demo，其核心理论支持是Dubbo提供的Router，在进行负载均衡前，根据路由规则对服务提供者列表进行筛选。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1、方案背景&quot;&gt;&lt;a href=&quot;#1、方案背景&quot; class=&quot;headerlink&quot; title=&quot;1、方案背景&quot;&gt;&lt;/a&gt;1、方案背景&lt;/h2&gt;&lt;p&gt;背景：基于Dubbo服务的治理，是否可以支持业务级别的灰度发布、是否基于业务参数的路由转发。例如以GIS为例，当发布一个新版本时，是否可以以按照解析地址或合作伙伴来区分，版本发布之初，只希望地址为：广东省的解析请求发送到新版本，而其他的地址请求还是使用旧版；或者根据合作伙伴例如UCP(优享寄)的请求转发到新版本服务器，其他合作伙伴还是转发到旧版，达成业务级别的灰度发布，控制新版本的影响范围。例如OMS系统，可以根据合作伙伴，将重量级客户的请求转发到单独的服务器集群，确保其高可用。&lt;br&gt;本文将对上述议题结合Dubbo提供的功能，提出设计方案。&lt;/p&gt;
&lt;h2 id=&quot;2、方案理论基础&quot;&gt;&lt;a href=&quot;#2、方案理论基础&quot; class=&quot;headerlink&quot; title=&quot;2、方案理论基础&quot;&gt;&lt;/a&gt;2、方案理论基础&lt;/h2&gt;&lt;p&gt;Dubbo的服务调用原理图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20181015123333422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;br&gt;客户端在发起RPC服务调用之前，在客户端首先从服务器列表中选择一个服务调用者，包含如下关键角色：&lt;/p&gt;</summary>
    
    
    
    <category term="dubbo" scheme="https://www.codingw.net/categories/dubbo/"/>
    
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="dubbo" scheme="https://www.codingw.net/tags/dubbo/"/>
    
    <category term="灰度发布" scheme="https://www.codingw.net/tags/%E7%81%B0%E5%BA%A6%E5%8F%91%E5%B8%83/"/>
    
    <category term="router" scheme="https://www.codingw.net/tags/router/"/>
    
    <category term="路由" scheme="https://www.codingw.net/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>java并发容器ConcurrentHashMap源码分析</title>
    <link href="https://www.codingw.net/posts/7310f98.html"/>
    <id>https://www.codingw.net/posts/7310f98.html</id>
    <published>2020-12-10T13:40:01.000Z</published>
    <updated>2020-12-24T10:13:51.112Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、ConcurrentHashMap-与-HashTable"><a href="#1、ConcurrentHashMap-与-HashTable" class="headerlink" title="1、ConcurrentHashMap 与 HashTable"></a>1、ConcurrentHashMap 与 HashTable</h1><p>HashTable 是 HashMap 的线程安全版本，使用的是 HashTable 的对象锁，同一时刻只能有一个线程 新增元素，获取元素。锁等待多，并发度低。而 ConcurrentHashMap 采用的是锁分段机制，就是用多把锁，让每把锁管理一部分数据。怎么实现的呢？引入了段(Segment)数据结构。</p><p>我们不妨来回忆一下HashMap、HashTable 的数据结构</p><p><img src="https://img-blog.csdn.net/20161129121630568?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>结合下文对ConcurrentHashMap的分析，可以得知ConcurrentHashMap的数据结构如下，其实就是可以简单的认为，ConcurrentHashMap就是 HashMap[] 数组，就是一个数组，数组元素是一个一个的 HashMap。</p><p><img src="https://img-blog.csdn.net/20161129121705356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><a id="more"></a><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>为了更好的理解ConcurrentHashMap，最好首先阅读如下几篇文章：</p><ul><li>HashMap源码分析 <a href="http://blog.csdn.net/prestigeding/article/details/52861420">http://blog.csdn.net/prestigeding/article/details/52861420</a></li><li>使用Unsafe根据内存地址与偏移量访问数组元素方法：<a href="http://blog.csdn.net/prestigeding/article/details/52980801">http://blog.csdn.net/prestigeding/article/details/52980801</a></li><li>ReentrantLock锁分析：<a href="http://blog.csdn.net/prestigeding/article/details/53084883">http://blog.csdn.net/prestigeding/article/details/53084883</a></li></ul><h1 id="2、ConcurrentHashMap-详解"><a href="#2、ConcurrentHashMap-详解" class="headerlink" title="2、ConcurrentHashMap 详解"></a>2、ConcurrentHashMap 详解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> java.util.Map&#125; providing additional atomic</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;putIfAbsent&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt;, and &lt;tt&gt;replace&lt;/tt&gt; methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Memory consistency effects: As with other concurrent</span></span><br><span class="line"><span class="comment"> * collections, actions in a thread prior to placing an object into a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ConcurrentMap&#125; as a key or value</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * actions subsequent to the access or removal of that object from</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> ConcurrentMap&#125; in another thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If the specified key is not already associated</span></span><br><span class="line"><span class="comment">     * with a value, associate it with the given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (!map.containsKey(key))</span></span><br><span class="line"><span class="comment">     *       return map.put(key, value);</span></span><br><span class="line"><span class="comment">     *   else</span></span><br><span class="line"><span class="comment">     *       return map.get(key);&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with the specified key, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with the key,</span></span><br><span class="line"><span class="comment">     *         if the implementation supports null values.)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the entry for a key only if currently mapped to a given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key) &amp;&amp; map.get(key).equals(value)) &#123;</span></span><br><span class="line"><span class="comment">     *       map.remove(key);</span></span><br><span class="line"><span class="comment">     *       return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else return false;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value expected to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the value was removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the key or value is of an inappropriate</span></span><br><span class="line"><span class="comment">     *         type for this map</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the entry for a key only if currently mapped to a given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key) &amp;&amp; map.get(key).equals(oldValue)) &#123;</span></span><br><span class="line"><span class="comment">     *       map.put(key, newValue);</span></span><br><span class="line"><span class="comment">     *       return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else return false;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue value expected to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the value was replaced</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of a specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if a specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of a specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the entry for a key only if currently mapped to some value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key)) &#123;</span></span><br><span class="line"><span class="comment">     *       return map.put(key, value);</span></span><br><span class="line"><span class="comment">     *   &#125; else return null;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with the specified key, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with the key,</span></span><br><span class="line"><span class="comment">     *         if the implementation supports null values.)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-ConcurrentHashMap构造方法与数据结构分析"><a href="#2-1-ConcurrentHashMap构造方法与数据结构分析" class="headerlink" title="2.1 ConcurrentHashMap构造方法与数据结构分析"></a>2.1 ConcurrentHashMap构造方法与数据结构分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new, empty map with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity, load factor and concurrency level.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">     * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">     * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">     * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment">     * updating threads. The implementation performs internal sizing</span></span><br><span class="line"><span class="comment">     * to try to accommodate this many threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment">     * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment">     * nonpositive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;                               <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;                                                                                          <span class="comment">//@2 start</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;                                                              <span class="comment">//@2 end</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">// 每个 segment 内部容里</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1 concurrencyLevel，含义，并发级别，并发度，在键不冲突的情况下，最多允许多少个线程同时访问数据不需要阻塞（理想情况下），我们应该知道，ConcurrentHashMap 的基本实现原理就是引入Segment 数据结构，将锁的粒度细化到Segment, 也就是说，如果多个线程，同时操作多个 key,如果这些 key，分布在不同的 Segment, 那这些线程的操作互不影响，当然不需要加锁，提高性能。所以 concurrencyLevel，就是要求告诉 ConcurrentHashMap, 我需要这么过个线程同时访问你而不产生锁冲突。</p><p>代码@2，ssize，该变量的值等于ConcurrentHashMap 中 segment 的长度，也就是 Segment[] 的长度。该值取决于concurrencyLevel, 其实就是小于concurrencyLevel 的最大的2的幂，比如concurrencyLevel= 16,那 ssize=16,如果 concurrencyLevel = 12, ssize=8，因为ssize的长度为2的幂。</p><p>变量shift的值，看出来了没，其实就是 ssize 2 ^ shift,其实就是表示ssize需要的二进制位。</p><p>segmentMask、segmentShift ，这两个属性在该表达式中使用：(h &gt;&gt;&gt; segmentShift) &amp; segmentMask)，很明显，就是用来算Segment[]数组中的下标来的。意图segmentShift = 32 - sshift，也就是利用hash的高位与代表（ssize-1）来定位下标。// 如果默认，初始容量16,那么ssize=16, sshift=4 定位端 hash 无符号向右移多少28位，（总共32位），那就是使原本32-29位参与运算（高位）</p><p>变量cap,就是每个Segment中HashEntity[]的长度，大于【初始容量/segment长度】的最小2的幂。</p><p>分析到这里，ConcurrentHashMap就构建成功了，我们先重点关注一下 Segment 的数据结构。</p><p>Segment 段的内部数据结构如下：</p><ul><li>类的声明：static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</li><li>数据结构：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">// 内部键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;  <span class="comment">// 元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;     <span class="comment">// 结构发生变化的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">// 扩容时的阔值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;     <span class="comment">// 扩容因子，主要影响threshold，影响什么时候扩容</span></span><br></pre></td></tr></table></figure><p>对上述结构，是否似曾相识，对了，就是它，HashMap；每个 Segment 其实就是一个 HashMap; 还有一个很关键点：Segment继承自 ReentrantLock, 也就是 Segment 本身就是一把锁。</p><h2 id="2-2-public-V-put-K-key-V-value-源码分析"><a href="#2-2-public-V-put-K-key-V-value-源码分析" class="headerlink" title="2.2  public V put(K key, V value) 源码分析"></a>2.2  public V put(K key, V value) 源码分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)                                      </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;   <span class="comment">//@2</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck in ensureSegment</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment  @3</span></span><br><span class="line">            s = ensureSegment(j);                                      <span class="comment">//@4</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);                   <span class="comment">//@5</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1，表明 ConcurrentHashMap不支持value为空的键值对。</p><p>代码@2，计算该key对应的Segment的位置（数组下标），并发包中获取数组元素的方式，采用的是UNSAFE直接操作内存的方式，而不是典型的  Segment[] a = new Segment[16],  第j个元素的值为  a[j]。如果需要详细了解UNSAFE操作数组元素的原理，请查看  另一篇博客(AtomicIntegerArray 源码分析)</p><p>比如一个Integer[]中，每个int是32位，占4个字节，那数组中第3个位置的开始字节是多少呢？=(3-1) &lt;&lt; 2,也就是说SHIFT的值为元素中长度的幂。怎么获取每个元素在数组中长度（字节为单位）= UNSAFE.arrayIndexScale,</p><p>而 UNSAFE.arrayBaseOffset,返回的是，第一个数据元素相对于对象起始地址的便宜量，该部分的详解，请参考我的技术博客【<a href="http://blog.csdn.net/prestigeding/article/details/52980801%E3%80%91">http://blog.csdn.net/prestigeding/article/details/52980801】</a></p><p>代码@3，就是获取j下标的segment对象。相当于  if(  (s == segments[j])== null  )</p><p>代码@4，我们将目光移到 ensureSegment方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment">     * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">        Segment&lt;K,V&gt; seg;</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">            <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">            <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">            <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">            <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">                Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">                <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                       == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法，主要是确保segment槽的k位置的Segment不为空，如果为空，初始化。</p><p>代码@5，代码@4初始化k位置的segment后，将键值对加入到segment,接下重点看一下Segment的put方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);   <span class="comment">// @1</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);      <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;                         <span class="comment">// @3</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;                                                     <span class="comment">// @4           </span></span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||                                          </span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;      <span class="comment">//@5</span></span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;                                                                   <span class="comment">//@6                                                        </span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法，实现思路其实和HashMap一样，就是要在Segment的HashEntity[] table的指定位置加入新的Node,如果在位置k的位置不为空，此时，说明该位置发生了hash冲突，这是需要先遍历整个链，看是否有相等的key,如果key相等，则替换该值，如果没有，则将新加入的节点的next指针指向 table[k],然后将node加入到k位置。但是，由于ConcurrentHashMap是支持多个线程同时访问的，对于单个Segment的操作，需要加锁。</p><p>代码@1，首先尝试获取锁，如果成功获取锁，则继续添加元素，如果获取锁失败，后面重点分析。</p><p>代码@2，获取该key所对应的table[]中的下标。根据该元素是否为空，有两种操作，如果为空，说明没有发生冲突，也就是走代码@6分支，就是将新创建的节点的节点放入table[k]处，当然，此时需要判断是否需要进行rehash操作（ConcurrentHashMap的是否需要rehash,就是判断阔值）。</p><p>代码@4，就是循环判断table[k]的链条中，是否有key与待操作key相等，如果相等，直接替换就好。由于@3开始，其实就是整个put方法，会在锁保护中。</p><p>上述过程，应该很好理解，所以，现在重点关注两个方法，一是scanAndLockForPut，二是rehash(比较好奇，是否与HashMap相同，应该是一样的吧，呵呵)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment">         * acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment">         * return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment">         * methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment">         * traversal speed doesn&#x27;t matter, we might as well help warm</span></span><br><span class="line"><span class="comment">         * up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                    e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                    retries = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在没有成功获取锁的情况下，先不急于阻塞，而是乐观的估计获取锁的线程操作的key与当前操作的key没关系，那我该干嘛就干嘛，自旋尝试获取锁（尝试MAX_SCAN_RETRIES，如果未成功获取锁）尝试超过最大尝试次数，为了性能考虑，该线程阻塞，参加代码@2。</p><p>@3，每隔一次，检查一下 Segment HashEntity[] table 处k的位置的元素是否发生变化，如果发生变化，则重试次数设置为-1，继续尝试获取锁。该方法如果在阻塞在lock()方法，时，一旦获取锁，则进入到final V put(K key, int hash, V value, boolean onlyIfAbsent) 方法中，进行常规的put方法（与HashMap操作类似。）</p><p>接下来重点看一下代码@7，如果当前segment中容量大于阔值，并小于允许的最大长度时，需要进行rehash,下面分析一下rehash源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment">         * given node to new table</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Reclassify nodes in each list to new table.  Because we</span></span><br><span class="line"><span class="comment">             * are using power-of-two expansion, the elements from</span></span><br><span class="line"><span class="comment">             * each bin must either stay at same index, or move with a</span></span><br><span class="line"><span class="comment">             * power of two offset. We eliminate unnecessary node</span></span><br><span class="line"><span class="comment">             * creation by catching cases where old nodes can be</span></span><br><span class="line"><span class="comment">             * reused because their next fields won&#x27;t change.</span></span><br><span class="line"><span class="comment">             * Statistically, at the default threshold, only about</span></span><br><span class="line"><span class="comment">             * one-sixth of them need cloning when a table</span></span><br><span class="line"><span class="comment">             * doubles. The nodes they replace will be garbage</span></span><br><span class="line"><span class="comment">             * collectable as soon as they are no longer referenced by</span></span><br><span class="line"><span class="comment">             * any reader thread that may be in the midst of</span></span><br><span class="line"><span class="comment">             * concurrently traversing table. Entry accesses use plain</span></span><br><span class="line"><span class="comment">             * array indexing because they are followed by volatile</span></span><br><span class="line"><span class="comment">             * table write.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">                (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="keyword">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTable[lastIdx] = lastRun;</span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                            <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在理解了HashMap的rehash方法后，再来看该方法，应该能很好的理解，故不做重复讲解了。</p><h3 id="2-2-2-public-V-putIfAbsent-K-key-V-value"><a href="#2-2-2-public-V-putIfAbsent-K-key-V-value" class="headerlink" title="2.2.2 public V putIfAbsent(K key, V value)"></a>2.2.2 public V putIfAbsent(K key, V value)</h3><p>该方法的语义是，如果存在key，则直接返回key关联的value,如果key不存在，则加入该键值对，并返回null；该步骤是原子操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法与put方法的实现基本相同，唯一不同的是，对已经存在key时，put方法是直接覆盖旧值，而putIfAbsent是，返回旧值。</p><h3 id="2-2-3-public-void-putAll-Map-m"><a href="#2-2-3-public-void-putAll-Map-m" class="headerlink" title="2.2.3 public void putAll(Map m)"></a>2.2.3 public void putAll(Map m)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接将传人的Map类型的参数，遍历，调用put方法。</p><p>看过了put函数，我们将目标转向到get方法中，瞧一瞧get相关方法的实现：</p><h3 id="2-2-4-public-V-get-Object-key-源码分析"><a href="#2-2-4-public-V-get-Object-key-源码分析" class="headerlink" title="2.2.4 public V get(Object key)源码分析"></a>2.2.4 public V get(Object key)源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> key.equals(k)&#125;,</span></span><br><span class="line"><span class="comment">     * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上文中可以看到，get方法并没有加锁，只是根据key的hash，然后算出Segment槽的位置，不是直接根据下标去获取Segment，也不是直接根据下标去Segment 的 HashEntity[] tab中去获取元素，而是使用了 UNSAFE.getObjectVolatile方法，直接操作内存，并使用volatile方式获取，最大程度保证可见性。有人或许有疑问，为什么get方法不加读锁，阻止其他写入请求呢？其实这样做意义并不大，ConcurrentHashMap的是一个容器，数据存储，提供基本的 put,get操作，对单一一个get请求加锁，没什么意义，因为get方法并不会改变ConcurrentHashMap的内部结构，在当前线程获取到key中的值，然后其他线程删除了该key,这在业务场景上本身就是正常不过的操作。所以get方法并不需要加锁。</p><p>2.3 浏览源码，发现无论是replace方法，还是remove方法等操作内部等都和HashMap相似，因为Segment就是一个带锁的HashMap。所以，接下来，我们可以这样思考，put,replace,remove这些方法比HashMap效率高，因为提供了并发度，那这些获取全局的属性的方法呢，比如keys,size等这些方法，性能又是如何呢？我们将目光转向size，keys等遍历方法。</p><h3 id="2-3-1-public-int-size方法"><a href="#2-3-1-public-int-size方法" class="headerlink" title="2.3.1 public int size方法"></a>2.3.1 public int size方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.  If the</span></span><br><span class="line"><span class="comment">     * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法的核心实现原理：从上文的解读，我想大家应该已经了解每一个Segment就是一个HashMap,HashMap中有两个变量，modCount，表示数据结构发生变化次数，比如put一个未在HashMap中包含的key,比如remove,比如clear方法，每调用一次上述方法，modCount就加1，也就是影响size属性的操作，都会将modeCount加一；另一个变量size，记录HashMap中键值对的个数。那ConcurrentHashMap的size方法，如果结构没有发生改变，只需将各个Segment的size相加，就可以得到ConcurrentHashMap的size,然并卯，在相加的过程其他线程如果有改变Segment内部的结构的话，导致size不准确，该方法的实现办法，是先乐观的尝试计算相加的过程最多三次，最少两次，如果前后两次的modCount一样，就说明在计算size的过程中，其他线程并没有改变ConcurrentHashMap的结构没有变化，则可以直接将size返回，结束该方法的调用，如果有变化，则需要依次对所有Segment申请加锁操作，只有获取全部锁后，然后对每个segment的size相加，然后是否锁，并返回size值。</p><p>代码@1,如果重试次数达到 (RETRIES_BEFORE_LOCK +１　,默认为2)次数后，说明需要加锁才能计算。</p><p>代码@2，对Segment相加计算size</p><p>代码@3，就是实现，判断连续两次计算出的modCount相等，说明该size值正确，否则，继续尝试，获取去请求锁。</p><h3 id="2-3-2-public-boolean-isEmpty-方法源码解读"><a href="#2-3-2-public-boolean-isEmpty-方法源码解读" class="headerlink" title="2.3.2 public boolean isEmpty() 方法源码解读"></a>2.3.2 public boolean isEmpty() 方法源码解读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Sum per-segment modCounts to avoid mis-reporting when</span></span><br><span class="line"><span class="comment">         * elements are concurrently added and removed in one segment</span></span><br><span class="line"><span class="comment">         * while checking another, in which case the table was never</span></span><br><span class="line"><span class="comment">         * actually empty at any point. (The sum ensures accuracy up</span></span><br><span class="line"><span class="comment">         * through at least 1&lt;&lt;31 per-segment modifications before</span></span><br><span class="line"><span class="comment">         * recheck.)  Methods size() and containsValue() use similar</span></span><br><span class="line"><span class="comment">         * constructions for stability checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sum += seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    sum -= seg.modCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法的核心实现原理：就是遍历有所有的segment，一旦发现有存在size不等于0的segment，则返回false；如果发现所有的segment的size为0，则再次遍历，如果两次遍历时 modCount一样，则返回true,否则返回false。</p><p>大家再看看如下方法：</p><h3 id="2-3-3-public-boolean-containsKey-Object-key"><a href="#2-3-3-public-boolean-containsKey-Object-key" class="headerlink" title="2.3.3 public boolean containsKey(Object key)"></a>2.3.3 public boolean containsKey(Object key)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if the specified object is a key in this table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key   possible key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object</span></span><br><span class="line"><span class="comment">     *         is a key in this table, as determined by the</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;equals&lt;/tt&gt; method; &lt;tt&gt;false&lt;/tt&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// same as get() except no need for volatile value read</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-4-public-boolean-containsValue-Object-value"><a href="#2-3-4-public-boolean-containsValue-Object-value" class="headerlink" title="2.3.4 public boolean containsValue(Object value)"></a>2.3.4 public boolean containsValue(Object value)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">   * specified value. Note: This method requires a full internal</span></span><br><span class="line"><span class="comment">   * traversal of the hash table, and so is much slower than</span></span><br><span class="line"><span class="comment">   * method &lt;tt&gt;containsKey&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">   *         specified value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified value is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Same idea as size()</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">      <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                      ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">long</span> hashSum = <span class="number">0L</span>;</span><br><span class="line">              <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                  HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">                  Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                  <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (tab = seg.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tab.length; i++) &#123;</span><br><span class="line">                          HashEntry&lt;K,V&gt; e;</span><br><span class="line">                          <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                              V v = e.value;</span><br><span class="line">                              <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)) &#123;</span><br><span class="line">                                  found = <span class="keyword">true</span>;</span><br><span class="line">                                  <span class="keyword">break</span> outer;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      sum += seg.modCount;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (retries &gt; <span class="number">0</span> &amp;&amp; sum == last)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              last = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                  segmentAt(segments, j).unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> found;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet-遍历元素方法。"><a href="#2-3-5-public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet-遍历元素方法。" class="headerlink" title="2.3.5 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 遍历元素方法。"></a>2.3.5 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 遍历元素方法。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            V v = ConcurrentHashMap.<span class="keyword">this</span>.get(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; v.equals(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.remove(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; e = <span class="keyword">super</span>.nextEntry();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WriteThroughEntry(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextSegmentIndex;</span><br><span class="line">        <span class="keyword">int</span> nextTableIndex;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] currentTable;</span><br><span class="line">        HashEntry&lt;K, V&gt; nextEntry;</span><br><span class="line">        HashEntry&lt;K, V&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            nextSegmentIndex = segments.length - <span class="number">1</span>;</span><br><span class="line">            nextTableIndex = -<span class="number">1</span>;</span><br><span class="line">            advance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set nextEntry to first node of next non-empty table</span></span><br><span class="line"><span class="comment">         * (in backwards order, to simplify checks).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;       <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextTableIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((nextEntry = entryAt(currentTable,</span><br><span class="line">                                             nextTableIndex--)) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nextSegmentIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, nextSegmentIndex--);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (currentTable = seg.table) != <span class="keyword">null</span>)</span><br><span class="line">                        nextTableIndex = currentTable.length - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;     <span class="comment">// @2</span></span><br><span class="line">            HashEntry&lt;K,V&gt; e = nextEntry;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            lastReturned = e; <span class="comment">// cannot assign until after null check</span></span><br><span class="line">            <span class="keyword">if</span> ((nextEntry = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                advance();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">            lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteThroughEntry</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractMap</span>.<span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        WriteThroughEntry(K k, V v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set our entry&#x27;s value and write through to the map. The</span></span><br><span class="line"><span class="comment">         * value to return is somewhat arbitrary here. Since a</span></span><br><span class="line"><span class="comment">         * WriteThroughEntry does not necessarily track asynchronous</span></span><br><span class="line"><span class="comment">         * changes, the most recent &quot;previous&quot; value could be</span></span><br><span class="line"><span class="comment">         * different from what we return (or could even have been</span></span><br><span class="line"><span class="comment">         * removed in which case the put will re-establish). We do not</span></span><br><span class="line"><span class="comment">         * and cannot guarantee more.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            V v = <span class="keyword">super</span>.setValue(value);</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.put(getKey(), value);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码主要关注两点：第一是遍历元素的方法；第二是调用该迭代器的size,isEmpty等方法。</p><p>代码@1，advance，该方法主要是从segments[]数组中的最后一个元素开始，找出segment中HashEntity[] table数组中最后一个元素开始遍历，找到一个不为空nextEntity,这里返回的nextEntity,就是 table[]数组中的元素，不包括链表中的HashEntity，链表中的HashEntity遍历在代码@2 nextEntry 方法中，实现真的挺优雅的。</p><p>第二个特点是，调用迭代器的size、contains，isEmpty等方法，都是对ConcurrentHashMap对应方法的调用。</p><p>最后，通过上述的分析，我想对ConcurrentHashMap做一个简单的总结：</p><ol><li><p>结合上述源码分析，我们可以清楚的认为，一个Segment就是一个与HashMap相同的结构，当然每个Segment就是一把锁，该类的核心思想，就是通过对key的第一次hash,定位的不是以前的HashEntity,而是一个Segemnt,然后对该key限定在该Segment中执行，，这样可以同时允许多个线程向ConcurrentHashMap同时添加元素（当然，要分散到不同的Segment类，故提供了并发度。）</p></li><li><p>ConcurrentHashMap是一个并发容器，所谓的并发容器并不是说在使用过程中一定不需要加锁，并发容器能提    供的保证是多个线程同时访问该容器，同时调用会改变内部结构的方法时，比如put方法时，不会破坏内部结构    以至于不能提供服务或提供错误服务（数据视图）。怎么理解并不是一定不要加锁这句话，我举一个例子，比如我们用ConcurrentHashMap来存储数据，完成如下操作1、第一步，设置一个key 为”status”:1,然后经过复杂的逻辑处理，由存入一个金额 key为amount,值为10； 伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentHashMap a &#x3D; new ConcurrentHashMap();</span><br><span class="line">   </span><br><span class="line">     逻辑代码</span><br><span class="line">   </span><br><span class="line">     void eval(参数 ...) &#123;</span><br><span class="line">   </span><br><span class="line">           a.put(&quot;status&quot;,1);</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;经过计算</span><br><span class="line">   </span><br><span class="line">           a.put(&quot;amount&quot;: 10);</span><br><span class="line">   </span><br><span class="line">          &#x2F;&#x2F;付款</span><br><span class="line">   </span><br><span class="line">         if(  a.get(&quot;status&quot;)&#x3D;&#x3D;1  ) &#123;</span><br><span class="line">   </span><br><span class="line">          &#x2F;&#x2F;执行付款操作</span><br><span class="line">   </span><br><span class="line">         &#125; </span><br><span class="line">   </span><br><span class="line">     &#125;  </span><br></pre></td></tr></table></figure><p>从上面的代码，如果多个线程执行eval方法，肯定会有问题。所以，还是需要加锁，说白了，ConcurrentHashMap只对单个方法负责，比如对 put 方法负责，只是对调用一次put方法，保证该操作，不会受到其他线程的影响。</p></li><li><p>ConcurrentHash采取如下方法从Segment[] segments,HashEntity[]  table,数组中获取元素，其准确实施性依次增强。</p></li></ol><ul><li>segment[下标],table[下标]</li><li>使用UNSAFE根据便宜量直接操作内存方式，使用(voliate方式)</li><li>重试一定次数后，加锁。</li></ul></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、ConcurrentHashMap-与-HashTable&quot;&gt;&lt;a href=&quot;#1、ConcurrentHashMap-与-HashTable&quot; class=&quot;headerlink&quot; title=&quot;1、ConcurrentHashMap 与 HashTable&quot;&gt;&lt;/a&gt;1、ConcurrentHashMap 与 HashTable&lt;/h1&gt;&lt;p&gt;HashTable 是 HashMap 的线程安全版本，使用的是 HashTable 的对象锁，同一时刻只能有一个线程 新增元素，获取元素。锁等待多，并发度低。而 ConcurrentHashMap 采用的是锁分段机制，就是用多把锁，让每把锁管理一部分数据。怎么实现的呢？引入了段(Segment)数据结构。&lt;/p&gt;
&lt;p&gt;我们不妨来回忆一下HashMap、HashTable 的数据结构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161129121630568?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;img&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;点击并拖拽以移动&quot;&gt;&lt;/p&gt;
&lt;p&gt;结合下文对ConcurrentHashMap的分析，可以得知ConcurrentHashMap的数据结构如下，其实就是可以简单的认为，ConcurrentHashMap就是 HashMap[] 数组，就是一个数组，数组元素是一个一个的 HashMap。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdn.net/20161129121705356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center&quot; alt=&quot;img&quot;&gt;</summary>
    
    
    
    <category term="juc" scheme="https://www.codingw.net/categories/juc/"/>
    
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="并发容器" scheme="https://www.codingw.net/tags/%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    
    <category term="ConcurrentHashMap" scheme="https://www.codingw.net/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁ReentrantLock源码分析二之Condition实现原理</title>
    <link href="https://www.codingw.net/posts/c82e1c77.html"/>
    <id>https://www.codingw.net/posts/c82e1c77.html</id>
    <published>2020-12-10T13:33:01.000Z</published>
    <updated>2020-12-24T10:14:03.853Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、Condition接口一览"><a href="#1、Condition接口一览" class="headerlink" title="1、Condition接口一览"></a>1、Condition接口一览</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>Condition 实现的语义为 Object.wait 与 Object.notify。</p><p>关于Condition 的实现类为 AbstractQueuedSynchronizer.ConditionObject 内部类。</p><p>首先在讲解源码之前，我重点罗列出ConditionObject的关键数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node fristWaiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure><p>从这里看出，每个CondtionObject,都维护着自己的条件等待等待队列，并且是一个双端链表。</p><a id="more"></a><h2 id="1-1-void-await-throws-InterruptedException"><a href="#1-1-void-await-throws-InterruptedException" class="headerlink" title="1.1 void await() throws InterruptedException"></a>1.1 void await() throws InterruptedException</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with</span></span><br><span class="line"><span class="comment">         *      saved state as argument, throwing</span></span><br><span class="line"><span class="comment">         *      IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())    <span class="comment">// @1 </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">            Node node = addConditionWaiter();    <span class="comment">//@2</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);   <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;     <span class="comment">//@4</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)  <span class="comment">// @5</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//@6</span></span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled                                 //@7</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)                                                                            <span class="comment">//@8</span></span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码@1：检测当前线程的中断标记，如果中断位为1，则抛出异常。</p><p>代码@2：添加等待节点。就是一个简单的链表维护节点的操作，具体参照addConditionWaiter讲解。</p><p>代码@3：释放占有的锁，并获取当前锁的state,因为await实现的语意为Object.wait,释放锁并并等待条件的发生。当条件满足后，线程被唤醒后，第一步是需要获取锁，然后在上次await的下一条指令处继续执行。代码3就是实现上述语义的释放锁。</p><p>代码@4：isOnSyncQueue 当前节点是否在同步队列中，如果在同步阻塞队列中，则申请锁，去执行；如果不在同步队列中（在条件队列中），阻塞，等待满足条件，新增的节点，默认在条件队列中(Conditon)。isOnSyncQueue 源码解读在下文中；</p><p>代码@5：线程从条件等待被唤醒,唤醒后，线程要从条件队列移除，进入到同步等待队列，被唤醒有有如下两种情况，一是条件满足，收到singal信号，二是线程被取消（中断），该步骤是从条件队列移除，加入到同步等待队列，返回被唤醒的原因，如果是被中断，需要根据不同模式，处理中断。处理中断，也有两种方式：1.继续设置中断位；2：直接抛出InterruptedException。请看下文关于checkInterruptWhileWaiting的源码解读。</p><p>代码@6：运行到代码6时，说明线程已经结束了释放锁，从条件队列移除，线程运行，在继续执行业务逻辑之前，必须先获取锁。只有成功获取锁后，才会去判断线程的中断标志，才能在中断标志为真时，抛出InterruptException。</p><p>代码@7，执行一些收尾工作，清理整个条件队列：</p><p>代码@8，处理中断，是设置中断位，还是抛出InterruptException。</p><p>那我们先关注一下addConditionWaiter方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;     <span class="comment">//@1</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);  <span class="comment">//@2</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>添加条件等待节点，根据链表的特征，直接在尾部节点的nextWaiter指向新建的节点，并将新建的节点设置为整个链表的尾部，首先要知道如下数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">object &#123;</span><br><span class="line"></span><br><span class="line">      Node firstWaiter;</span><br><span class="line"></span><br><span class="line">      Node lastWaiter;</span><br><span class="line"></span><br><span class="line">      node &#123;</span><br><span class="line"></span><br><span class="line">           node nextWaiter;</span><br><span class="line"></span><br><span class="line">          该节点承载的业务数据，比如这里的Thread t;等</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道上述结构，其实整个链的数据维护，基本一目了然，自己都可以实现下面的逻辑。</p><p>代码@1,如果最后一个等待节点的状态不是Node.CONDITION,则，则先删除等待链中节点状态不为Node.CONDITION的节点。具体代码分析请参照下文unlinkCancelledWaiters的解读。</p><p>代码@2开始，就是普通链表的节点添加的基本方法。</p><p>清除等待节点方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">         * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">         * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">         * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">         * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">         * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">         * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">         * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">         * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">         * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">         * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">         * storms.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter;  <span class="comment">// </span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;       <span class="comment">//@1</span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = t.nextWaiter;    </span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;  <span class="comment">// @3</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)                      <span class="comment">// @4</span></span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;       <span class="comment">//@5</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)    <span class="comment">// @6</span></span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">// @4</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法的思路为，从第一节点开始，将不等于Node.CONDITION的节点。</p><p>代码@1,设置尾部节点临时变量，用来记录最终的尾部节点。代码@1 第一次循环，是循环第一个节点，如果它的状态为Node.CONDITION, 则该链的头节点保持不变，设置临时尾节点为t,然后进行一个节点的判断，如果节点不为Node.CONDITION, 重置头节点的下一个节点，或尾部节点的下一个节点(@4,@5)。代码@6代表整个循环结束，设置 ConditionObject对象的lastWaiter为trail的值；</p><p>await步骤中，释放锁过程源码解析。释放锁的过程，逻辑为unlock,但该方法，返回当前锁的state,因为释放锁后，该方法在条件没有满足前提下，自身需要阻塞。被唤醒后，需要先尝试获取锁，然后才能执行接下来的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">     * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>await，@4步骤中，isOnSyncQueue 源码解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment">     * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)   <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue   // @2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">         * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">         * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">         * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">         * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">         * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1,如果节点的状态为Node.CONDITION 或 node.prev == null,表明该节点在条件队列中，并没有加入同步阻塞队列（同步阻塞队列为申请锁等待的队列），await方法中，新增的节点，默认满足上述条件，所以返回false,表示在条件队列中，等待条件的发生，条件满足之前，当前线程应该阻塞。这里，先预留一个疑问，那node.prev在什么时候会改变呢？</p><p>代码@2,如果node.next不为空，说明在同步阻塞队列中。这个我想毫无疑问。当然也说明next域肯定是在进入同步队列过程中会设置值。</p><p>代码@3, 上面的注释也说的比较清楚，node.prev不为空，但也不在同步队列中，这个是由于CAS可能会失败，为了不丢失信号，从同步队列中再次选择该节点，如果找到则返回true,否则返回false,在这里，我就更加对node.prev在什么时候会设置值感兴趣了，请继续await方法向下看，总有水落石出的时候。</p><p>await @5 checkInterruptWhileWaiting 代码解读：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">         * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">         * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">         * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;   <span class="comment">// 重新设置中断位，中断由上层处理</span></span><br><span class="line">        <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span>  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;    <span class="comment">// 直接抛出 InterruptedException  0:正常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">         * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">         * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers node, if necessary, to sync queue after a cancelled</span></span><br><span class="line"><span class="comment">     * wait. Returns true if thread was cancelled before being</span></span><br><span class="line"><span class="comment">     * signalled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current the waiting thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node its node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;   <span class="comment">//@1</span></span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we lost out to a signal(), then we can&#x27;t proceed</span></span><br><span class="line"><span class="comment">         * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">         * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">         * spin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>重点关注@1,首先需要知道一点，如果收到正常的singal()信号而被唤醒的节点【这个再singal方法时重点分析】，状态为Node.SINGAL,不会是Node.CONDITION状态，所以如果代码1compareAndSetWaitStatus设置成功，说明线程是调用了t.interrupt方法而使得LockSupport.park解除阻塞的，然后将该节点加入到同步队列中，使得 while( ! isOnSyncQueue(node)) 的条件为真，结束 await的等待条件触发语义，，进入到 抢占锁阶段。【再次重申Object wait语义，释放当前锁，然后等待条件的触发【条件队列】，，条件发生后，要先重新去抢占锁，获取锁则继续执行，否则阻塞在获取锁【同步队列】】，所以当 线程阻塞在  await 方法时，调用 t.interrupt方法时只是中断条件队列的等待，并不能马上取消执行，马上抛出InterrupterException。</p><p><strong>await方法流程图：</strong></p><h2 id="1-2-signal-方法详解"><a href="#1-2-signal-方法详解" class="headerlink" title=" 1.2 signal()方法详解"></a><img src="https://img-blog.csdn.net/20161114141204119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> 1.2 signal()方法详解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">         * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">         * owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())  <span class="comment">//如果当前线程不是锁的持有者，直接抛出异常。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first); <span class="comment">//通知第一个等待者          //@2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">         * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">         * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)   <span class="comment">// @3</span></span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);                          <span class="comment">// @4</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">     * Returns true if successful.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">     * cancelled before signal).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;  <span class="comment">// @5</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))   <span class="comment">//@6</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node p = enq(node);     <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))     <span class="comment">//@8</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>signal的具体实现，是从doSignal方法开始。</p><p>@代码3，首先将要被通知的节点的下一个节点设置为等待队列的head节点，如果当前节点的下一个节点为空，则设在等待队列的尾节点（lastWaiter）设置为空，然后将当前被通知的节点的下一个节点设为空；该步骤核心思想就是将被通知节点移除条件等待队列，然后重新维护条件等待对的firstWaiter和lastWaiter。</p><p>@代码4，!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null，根据后文的解析可以知道，如果被通知节点没有进入到同步阻塞队列(transferForSignal返回false)并且条件等待队列还有不为空的节点，则继续循环通知。</p><p>@代码5，transferForSignal该方法，将被通知的节点放入同步等待队列。</p><p>@代码6，首先判断，尝试将节点状态设置为0,如果设置失败，则说明该节点的状态已经不是Node.CONDITION,进一步说明该节点在没有等到通知信号时，被取消，直接返回false,通知下一个等待者。（回到代码@3,@4）</p><p>@代码7，将节点放入到同步队列中。个人认为信号通知，主要是将节点从条件等待队列移入到同步等待队列，主要是防止sinal信号的丢失。</p><p>@代码8，如果前置节点取消，或者在设置前置节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程，@8设置失败发送的情况也就是前置节点状态发送改变（被取消等），所以直接唤醒被通知节点的线程，也就是说，sinal方法，只有在入队列后，前置节点被取消时，才会执行LockSupport.unpark方法唤醒线程，通常该方法，只是将节点从条件等待队列放入同步队列，然后该方法执行完毕，释放持有的锁。</p><p>整个通知sinal方法的流程如下：</p><p><img src="https://img-blog.csdn.net/20161114141402135?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、Condition接口一览&quot;&gt;&lt;a href=&quot;#1、Condition接口一览&quot; class=&quot;headerlink&quot; title=&quot;1、Condition接口一览&quot;&gt;&lt;/a&gt;1、Condition接口一览&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitUninterruptibly&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitNanos&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; nanosTimeout)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;await&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; time, TimeUnit unit)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;awaitUntil&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Date deadline)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;signalAll&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Condition 实现的语义为 Object.wait 与 Object.notify。&lt;/p&gt;
&lt;p&gt;关于Condition 的实现类为 AbstractQueuedSynchronizer.ConditionObject 内部类。&lt;/p&gt;
&lt;p&gt;首先在讲解源码之前，我重点罗列出ConditionObject的关键数据结构：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node fristWaiter;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;transient&lt;/span&gt; Node lastWaiter;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;从这里看出，每个CondtionObject,都维护着自己的条件等待等待队列，并且是一个双端链表。&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="https://www.codingw.net/categories/juc/"/>
    
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="Condition" scheme="https://www.codingw.net/tags/Condition/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁ReentrantLock源码分析一 可重入支持中断锁的实现原理</title>
    <link href="https://www.codingw.net/posts/22168d83.html"/>
    <id>https://www.codingw.net/posts/22168d83.html</id>
    <published>2020-12-09T13:08:01.000Z</published>
    <updated>2020-12-24T10:14:21.350Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文将详细介绍 ReentrantLock 的实现原理。</p><p>在进入源码分析之前，我先提出如下观点：希望大家纠正与讨论：</p><ul><li>如果一个节点的状态设置为Node.SIGNAL,则说明它有后继节点，并处于阻塞状态。</li><li>ReentantLock的head节点，如果不为空，在该节点代表的线程为锁的占有者。这是对CLH算法的改进之处。众所周知，CLH算法的head节点为假节点，不代表任何线程。</li><li>ReentantLock几个编码技巧值得借鉴：<ul><li>利用内部类实现功能扩展，使得java.util.concurrent.locks包类数量少，十分清晰。</li><li>利用了模板模式，AbstractQueuedSynchronizer就是锁机制的模板（CLH算法的一个变种）。</li></ul></li></ul><p>本文重点关注如下几个方法的实现：</p><ul><li>lock()  </li><li>unlock()</li><li>lockInterruptibly()</li></ul><p>进入源码分析之前，希望读者带着如下问题边看边想：</p><p>问题1：一个线程用lock方法申请锁而被阻塞后，调用线程的interput方法，会发生什么情况，能中断锁的获取吗？</p><p>问题2：什么是CLH算法，RenntrantLock针对CLH算法做了哪些变化。</p><p>问题3：Node.CANCEL状态的节点在什么时候会删除。</p><a id="more"></a><h1 id="1、ReentrantLock-lock-方法详解"><a href="#1、ReentrantLock-lock-方法详解" class="headerlink" title="1、ReentrantLock#lock 方法详解"></a>1、ReentrantLock#lock 方法详解</h1><p>如下摘录自  ReentrantLock.NonFairSync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))     <span class="comment">// @1</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码@1 首先线程请求锁时，第一步，直接通过锁的状态 state, 如果 state 为0，通过 CAS 尝试去获取锁，如果获取，直接返回，这里就是所谓的不公平，先抢占，然后再尝试排队。如果当前锁被占用，则尝试申请锁, 进入代码 @2；</p><p>继续查看 acquire(1)方法，该方法存在于 AbstractQueuedSynchronizer 类，该类是 java.util.concurent.locks 锁的队列机制实现类，基于CLH 算法的变体的基本思想。，附上 AbstractQueuedSynchronizer 的 acquire 方法源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>先进入到 tryAcquire(arg)方法，查看获取锁的逻辑，该方法不阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;   <span class="comment">// 说明，该方法在具体的子类中实现。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们一路跟踪进来，发现尝试获取锁的代码在 ReentrantLock内部类 Sync 汇总，Sync 是 NonFairSync 和 FairSync 的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is</span></span><br><span class="line"><span class="comment">         * implemented in subclasses, but both need nonfair</span></span><br><span class="line"><span class="comment">         * try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;    <span class="comment">// @1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>该方法，尝试获取锁，如果成功获取锁，则返回true,否则，返回false;</p><p>重点关注 代码@1, 再次查看 锁的 state,该字段，表示该锁被占用的次数，如果为0，表示没有线程持有该锁，如果     大于1，表示同一个线程，多次请求锁；也就是可重入锁的实现原理。</p><p>代码@2：进一步说明可重入锁的实现机制。再次回到上文提到的 AbstractQueuedSynchronizer的 acquire(arg)方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如果 tryAcquire(arg) 返回 true,则不会执行 acquireQueued，表示成功获取锁，如果 tryAcquire(arg) 返回 false, 说明没有成功获取锁，则加入请求队列中。接着请看 addWaiter (Node.EXCLUSIVE) 方法。</p><p>addWaiter 中涉及的逻辑，就是 CLH 思想的实现，故在 AbstractQueuedSynchronizer 中,源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     * 创建并入队一节点，为当前线程和给定的模式, Node.EXCLUSIVE 独占模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//@1 start</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//@1 end</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于上面的代码@1,处说，如果当前该锁的尾部节点不为空时，只需要原子性的将新增节点放入原先的尾部，然后更新锁的 tail 属性即可。如果尾部节点不为空，说明有线程已经在该锁上等待，那如果尾部为空，是什么情况呢？尾部为空，表示没有线程持有锁，为什么该获取锁没有成功呢？我们不妨设想一下，该线程在没有执行到 addWaiter 时，尾部不为空，无法获取锁，当执行到 addWaiter 时，别的线程释放了锁，导致尾部为空，可以重新获取锁了；（其实这个就是并发编程的魅力，与 synchronized 关键字不同的机制）；为了解答上述疑问，我们进入到 enq(node) 方法中一探究竟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize                     @1</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>使用自旋来加入,众所周知，CLH算法，需要初始化一个假的 head 节点，也就是 head 节点并不代表一个等待获取锁的对象，AbstractQueuedSynchronzier 选择初始化 head,tail 的时机为第一次产生锁争用的时候。@1处为初始化head,tail,设置成功后，初始化后，再将新添加的节点放入到队列的尾部，然后该方法会返回原先的尾节点。addWaiter方法执行后，继续回到acquire(args)方法处：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来，查看 acquireQueued 方法,addWaiter 方法返回的是代表当前线程的 Node 节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">//  @1</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  parkAndCheckInterrupt()  )   <span class="comment">//@3</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先@1,获取该节点的 node 的上一个节点。</p><p>@2如果node的前节点是head,因为head初始化时，都是假节点，不代表有线程拥有锁，所以，再次尝试获取锁，如果获取锁，则将锁的 head 设置为当前获取锁的线程的 Node，然后返回 false。返回 false, 则代表 if (!tryAcquire(arg) &amp;&amp;  acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 的结果为 false,直接返回，并不需要设置中断标记。如果当前节点不是head的话，则说明该锁被别的线程占用了，那就需要等待其他线程释放该锁，具体，我们看一下shouldParkAfterFailedAcquire，为了更好的理解 shouldParkAfterFailedAcquire, 我们先看一下parkAndCheckInterrupt 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     * 阻塞该线程，然等待唤醒后，会返回 当前线程的中断位；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       该方法，如果返回true,则代表该线程将被阻塞。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">//  @1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)    <span class="comment">// @2</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// @4 start</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);   <span class="comment">//@4 end</span></span><br><span class="line"></span><br><span class="line">            pred.next = node; <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               只有前置节点的状态为 0 或 PROPAGATE,,才能进入到该代码块，表明我们需要一个信号，但暂不挂起线程，调用者需要重                  试一次，确保它不能获取到锁，从而阻塞该线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>@1 首先获取前置节点的 waitStatus。</p><p>@2 如果前置节点的waitStatus = Node.SIGNAL,那么当前节点，直接阻塞，说明状态是一个信号，如果前置节点状态为       Node.SIGNAL,那么后续节点应该阻塞的信号量，为什么这么说，情况代码@6,一个节点，新增的时候，为 0 正常。</p><p> @3,ws &gt; 0 ，则代表前置节点已取消。</p><p>@4 处的代码，就是当前 Node 的第一个不为取消状态的前置节点，重构 CLH 队列后，返回 false, 再次进入到 acquireQueued  的无限循环中，又继续 acquireQueued 的流程，继续尝试获取锁，获取锁，或者阻塞。</p><p>@6，如果前置节点为0或 PROPAGATE(可传播)，如果前置节点为0，还没有其他节点通过(prev)来判断该 prev 的后继节点是否需要阻塞过，所以，通过 CAS 设置前置节点为 Node.SIGNAL, 重试获取锁过程，避免不必要的线程阻塞。</p><p>至此，获取锁的过程就结束了，为了直观体现上述获取锁的过程，现给出如下流程图：</p><p><img src="https://img-blog.csdn.net/20161108175842999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="2、ReentrantLock-unlock"><a href="#2、ReentrantLock-unlock" class="headerlink" title="2、ReentrantLock unlock"></a>2、ReentrantLock unlock</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码直接进入到AbstractQueuedSynchronzier 的 relase方法。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;  @<span class="number">1</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>直接看代码 tryRelease(arg)方法：tryRelease 方法，是由具体的子类实现的，故将目光转移到 NonFairSync 类的 tryRelease() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;   <span class="comment">//  @1</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">//@2</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// @3</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);   <span class="comment">//@4</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码@1，首先，计算持有锁的次数=当前被持有锁的次数-减去释放的锁的数量；</p><p>代码@2，判断当前锁的持有线程释放与释放锁的线程是否相同，否则，直接抛出运行时异常</p><p>代码@3，如果释放锁后，占有次数为0，则代表该锁被释放，设置锁的占有线程为null,</p><p>代码@4，设置锁的state,如果返回true,表示锁被释放，如果返回false,表示，锁继续被该线程占有（重入了多次，就需要释放多次）。再次回到release方法，如果tryRelease方法返回true,表示可以释放锁，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;  @<span class="number">1</span></span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)   <span class="comment">// @2</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>代码@2为什么需要判断 h!=null &amp;&amp; h.waitStatus != 0的判断呢？，在讲解获取锁的时候，方法 shouldParkAfterFailedAcquire 中对于代码@6处的讲解，其实不难发现，一个节点在请求锁时，只有当它的前驱节点的waitStatus=Node.SIGNAL时，才会阻塞。如果 head为空，则说明 CLH 队列为空，压根就不会有线程阻塞，故无需执行 unparkSuccessor(h), 同样的道理，如果根节点的waitStatus=0，则说明压根就没有 head 后继节点判断是否要绑定的逻辑，故也没有线程被阻塞这一说。原来一个更重要的原因：改进后的CLH，head如果不为空，该节点代表获取锁的那个线程对于的Node,请看获取锁代码acquireQueued中的代码@2处，如果获得锁，setHead(node);知道这一点，就不难理解为什么在释放锁时调用unparkSuccessor(h)时，参数为head了。</p><p>现在将目光转移到 AbstractQueuedSynchronizer. unparkSuccessor(h)方法中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;  </span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)     <span class="comment">// @1</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  <span class="comment">//@2 start</span></span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125; <span class="comment">// @2 end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// @3</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>代码@1，目前waitStatus &gt; 0表示取消，等于0表示正常（新建），该步骤主要是   为了保护，避免重复释放。</p><p>代码@2 start-end,此处，主要是从占有锁的节点，往后找，找到第一个没有被取   消的节点，然后唤醒它所代表的线程。这里为什么要从尾部寻址呢？</p><p>代码@3，唤醒线程，释放锁的逻辑代码已经结束，那调用LockSupport.unpark(s.thread)后，会进入到哪呢？此时，请再次进入获取锁代码的 acquireQueue方法和shouldParkAfterFailedAcquire方法，先解读如下：</p><p>当LockSupport.unpark(s.thread)事，那acquireQueued的代码@3处parkAndCheckInterrupt方法会解除阻塞，继续放下执行，进入到 acquireQueued的for循环处：此时会有两种情况</p><ul><li>HEAD –&gt; Node  … &gt; 其中Node 为  LockSupport.unpark 中的 s;</li><li>HEAD –&gt; A Cancel Node –&gt;  Node(s)</li></ul><p>如果为第一种情况，直接进入 @2去尝试获取锁。</p><p>如果为第二种情况，shouldParkAfterFailedAcquire(prev,node) 中的 prev 为一个取消的节点，然后会重构整个 CLH 链表，删除Node 到 head 节点直接的取消节点，使得被唤醒线程的节点的上一个节点为 head,从而满足@2处的条件，进入获取锁方法。至此， lock 方法与 unlock 方法流通畅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">//  @1</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  parkAndCheckInterrupt()  )   <span class="comment">//@3</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">与shouldParkAfterFailedAcquire方法：</span><br><span class="line">  */</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">//  @1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)    <span class="comment">// @2</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// @4 start</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);   <span class="comment">//@4 end</span></span><br><span class="line"></span><br><span class="line">            pred.next = node; <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               只有前置节点的状态为 0 或 PROPAGATE,,才能进入到该代码块，表明我们需要一个信号，但暂不挂起线程，调用者需要重                  试一次，确保它不能获取到锁，从而阻塞该线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>为了方便大家理解，给出一个简要的释放锁的流程图：</p><p><img src="https://img-blog.csdn.net/20161108180244374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="3、ReentrantLock-lockInterruptibly-源码分析"><a href="#3、ReentrantLock-lockInterruptibly-源码分析" class="headerlink" title="3、ReentrantLock lockInterruptibly 源码分析"></a>3、ReentrantLock lockInterruptibly 源码分析</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure><p>首先先提一个问题： void lock()，通过该方法去获取锁，如果锁被占用，线程阻塞，如果调用被阻塞线程的          interupt()方法，会取消获取锁吗？答案是否定的。</p><p>首先需要知道 LockSupport.park 会响应中断，但不会抛出 InterruptedException。</p><p>接下来，我们就从lockInterruptibly()方法入手，一步一步解析，并分析与lock方法的差异。</p><p>首先进入的是AbstractQueuedSynchronizer的acquireInterruptibly方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, aborting if interrupted.</span></span><br><span class="line"><span class="comment">     * Implemented by first checking interrupt status, then invoking</span></span><br><span class="line"><span class="comment">     * at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;, returning on</span></span><br><span class="line"><span class="comment">     * success.  Otherwise the thread is queued, possibly repeatedly</span></span><br><span class="line"><span class="comment">     * blocking and unblocking, invoking &#123;<span class="doctag">@link</span> #tryAcquire&#125;</span></span><br><span class="line"><span class="comment">     * until success or the thread is interrupted.  This method can be</span></span><br><span class="line"><span class="comment">     * used to implement method &#123;<span class="doctag">@link</span> Lock#lockInterruptibly&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);   <span class="comment">// @1</span></span><br><span class="line">    &#125;</span><br><span class="line">    如果尝试获取锁失败后，进入获取锁并等待锁逻辑，doAcquireInterruptibly</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;              <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">//@3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node); <span class="comment">//@4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>整个获取锁的逻辑与 lock 方法一样，唯一的区别在于  @3 处，如果 parkAndCheckInterrupt 如果是通过 t.interupt 方法，使LockSupport.park 取消阻塞的话，会抛出 InterruptedException，停止尝试获取锁，然后将添加的节点取消，那重点关注一下cancelAcquire(node); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">        Node pred = node.prev;   </span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  <span class="comment">// @1</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">        <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">        <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">        Node predNext = pred.next; <span class="comment">//@2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">        <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">        <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;   <span class="comment">// @3 </span></span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @4</span></span><br><span class="line">            <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">            <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;   <span class="comment">// @5</span></span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @6</span></span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>代码@1：此处的目的就是, 设置prev的值为从当前取消节点往head节点方向，第一个未取消节点。并将中间的取消节点脱离这条链。</p><p>代码@2 Node predNext = pred.next;</p><p>代码@3 如果被取消的节点是尾节点的话，那么将pred设置为尾节点，compareAndSetTail(node, pred)，如果设置失败，说明，有别的线程在申请锁，使得尾部节点发生了变化，那这样的话，我当前节点取消的工作，就到此可以结束了；如果设置成功了，既然pred是尾节点，那么再次将pred的next域设置为null;当然也能设置失败，表明又有新的线程在申请说，创建了节点。所以取消操作，也到此结束。</p><p>代码@4，如果取消的节点，不是尾部节点的话，这时，需要维护CLH链，请看代码@5</p><p>代码@5,首先pred不是head节点，接下来判断是否需要设置pred.next = 当前待取消节点的next。如果pred.waitStatus == Node.SIGNAL, 或者试图将 pred.waitStatus = Node.SIGNAL 状态成功，并且pred.thread 的线程不为空；此时进一步判断待取消的节点的 next 不为空，并且状态为非取消的时，将 pred.next 设置为 node.next；该取消节点被删除。</p><p>代码@6，如果pred为head,执行一次唤醒操作。</p><p>处于Node.CANCEL状态节点的删除发生在shouldParkAfterFailedAcquire，一处就发生在cancelAcquire方法。</p><p>本文就介绍到这里了，文章开头部分的问题能解答了没，可以加笔者微信号 ：dingwpmz，共同探讨交流。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文将详细介绍 ReentrantLock 的实现原理。&lt;/p&gt;
&lt;p&gt;在进入源码分析之前，我先提出如下观点：希望大家纠正与讨论：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一个节点的状态设置为Node.SIGNAL,则说明它有后继节点，并处于阻塞状态。&lt;/li&gt;
&lt;li&gt;ReentantLock的head节点，如果不为空，在该节点代表的线程为锁的占有者。这是对CLH算法的改进之处。众所周知，CLH算法的head节点为假节点，不代表任何线程。&lt;/li&gt;
&lt;li&gt;ReentantLock几个编码技巧值得借鉴：&lt;ul&gt;
&lt;li&gt;利用内部类实现功能扩展，使得java.util.concurrent.locks包类数量少，十分清晰。&lt;/li&gt;
&lt;li&gt;利用了模板模式，AbstractQueuedSynchronizer就是锁机制的模板（CLH算法的一个变种）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文重点关注如下几个方法的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock()  &lt;/li&gt;
&lt;li&gt;unlock()&lt;/li&gt;
&lt;li&gt;lockInterruptibly()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进入源码分析之前，希望读者带着如下问题边看边想：&lt;/p&gt;
&lt;p&gt;问题1：一个线程用lock方法申请锁而被阻塞后，调用线程的interput方法，会发生什么情况，能中断锁的获取吗？&lt;/p&gt;
&lt;p&gt;问题2：什么是CLH算法，RenntrantLock针对CLH算法做了哪些变化。&lt;/p&gt;
&lt;p&gt;问题3：Node.CANCEL状态的节点在什么时候会删除。&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="https://www.codingw.net/categories/juc/"/>
    
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
    <category term="ReentrantLock" scheme="https://www.codingw.net/tags/ReentrantLock/"/>
    
    <category term="可重入" scheme="https://www.codingw.net/tags/%E5%8F%AF%E9%87%8D%E5%85%A5/"/>
    
    <category term="锁" scheme="https://www.codingw.net/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁ReentrantReadWriteLock读写锁源码分析</title>
    <link href="https://www.codingw.net/posts/9ba20a53.html"/>
    <id>https://www.codingw.net/posts/9ba20a53.html</id>
    <published>2020-12-08T13:38:01.000Z</published>
    <updated>2020-12-24T10:14:30.948Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、ReentrantReadWriterLock-基础"><a href="#1、ReentrantReadWriterLock-基础" class="headerlink" title="1、ReentrantReadWriterLock 基础"></a>1、ReentrantReadWriterLock 基础</h1><p>所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。</p><p>java.util.concurrent.locks中关于多写锁的接口：ReadWriteLock。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提一个问题，是否觉得 ReentrantReadWriteLock 会实现 Lock 接口吗？与 ReentrantLock 有什么关系？</p><a id="more"></a><p>答案是否定的，ReentrantReadWriterLock 通过两个内部类实现 Lock 接口，分别是 ReadLock,WriterLock 类。与 ReentrantLock一样，ReentrantReadWriterLock 同样使用自己的内部类Sync（继承AbstractQueuedSynchronizer）实现CLH算法。为了方便对读写锁获取机制的了解，先介绍一下Sync内部类中几个属性，采用了位运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">         * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">         * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">         * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>首先ReentrantReadWriterLock使用一个32位的int类型来表示锁被占用的线程数（ReentrantLock中的state）,用所以，采取的办法是，高16位用来表示读锁占有的线程数量，用低16位表示写锁被同一个线程申请的次数。</p><ul><li>SHARED_SHIFT，表示读锁占用的位数，常量16</li><li>SHARED_UNIT，  增加一个读锁，按照上述设计，就相当于增加 SHARED_UNIT；</li><li>MAX_COUNT   ，表示申请读锁最大的线程数量，为65535</li><li>EXCLUSIVE_MASK  :表示计算写锁的具体值时，该值为 15个1,用 getState &amp; EXCLUSIVE_MASK算出写锁的线程数，大于1表示重入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>举例说明，比如，现在当前，申请读锁的线程数为13个，写锁一个，那state怎么表示？</p><p>上文说过，用一个32位的int类型的高16位表示读锁线程数，13的二进制为 1101,那state的二进制表示为</p><p>00000000 00001101 00000000 00000001，十进制数为 851969， 接下在具体获取锁时，需要根据这个 851968 这个值得出上文中的 13 与 1。要算成13，只需要将state 无符号向左移位16位置，得出00000000 00001101，就出13，根据851969要算成低16位置，只需要用该00000000 00001101 00000000 00000001 &amp; 111111111111111（15位），就可以得出00000001,就是利用了1&amp;1得1,1&amp;0得0这个技巧。</p><p>移位元素，如果一个数值向左移(&lt;)一位，在没越界（超过该类型表示的最大值）的情况下，想当于操作数 * 2</p><p>如果一个数值向右(&gt;) 移动移位，在没有越界的情况下，想到于操作数 除以2。</p><p>然后再关注如下几个与线程本地变量相关的属性：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">         * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">         * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The hold count of the last thread to successfully acquire</span></span><br><span class="line"><span class="comment">         * readLock. This saves ThreadLocal lookup in the common case</span></span><br><span class="line"><span class="comment">         * where the next thread to release is the last one to</span></span><br><span class="line"><span class="comment">         * acquire. This is non-volatile since it is just used</span></span><br><span class="line"><span class="comment">         * as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Can outlive the Thread for which it is caching the read</span></span><br><span class="line"><span class="comment">         * hold count, but avoids garbage retention by not retaining a</span></span><br><span class="line"><span class="comment">         * reference to the Thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">         * model&#x27;s final field and out-of-thin-air guarantees.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * firstReader is the first thread to have acquired the read lock.</span></span><br><span class="line"><span class="comment">         * firstReaderHoldCount is firstReader&#x27;s hold count.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;More precisely, firstReader is the unique thread that last</span></span><br><span class="line"><span class="comment">         * changed the shared count from 0 to 1, and has not released the</span></span><br><span class="line"><span class="comment">         * read lock since then; null if there is no such thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Cannot cause garbage retention unless the thread terminated</span></span><br><span class="line"><span class="comment">         * without relinquishing its read locks, since tryReleaseShared</span></span><br><span class="line"><span class="comment">         * sets it to null.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">         * model&#x27;s out-of-thin-air guarantees for references.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This allows tracking of read holds for uncontended read</span></span><br><span class="line"><span class="comment">         * locks to be very cheap.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure><p>上述这4个变量，其实就是完成一件事情，将获取读锁的线程放入线程本地变量(ThreadLocal)，方便从整个上 下文，根据当前线程获取持有锁的次数信息。其实 firstReader,firstReaderHoldCount ,cachedHoldCounter 这三个变量就是为readHolds变量服务的，是一个优化手段，尽量减少直接使用readHolds.get方法的次数，firstReader与firstReadHoldCount保存第一个获取读锁的线程，也就是readHolds中并不会保存第一个获取读锁的线程；cachedHoldCounter 缓存的是最后一个获取线程的HolderCount信息，该变量主要是在如果当前线程多次获取读锁时，减少从readHolds中获取HoldCounter的次数。请结合如下代码理解上述观点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    firstReader = current;</span><br><span class="line">    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">    firstReaderHoldCount++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">        readHolds.set(rh);</span><br><span class="line">    rh.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、ReentrantReadWriterLock源码分析"><a href="#2、ReentrantReadWriterLock源码分析" class="headerlink" title="2、ReentrantReadWriterLock源码分析"></a>2、ReentrantReadWriterLock源码分析</h2><h2 id="2-1-ReadLock-源码分析"><a href="#2-1-ReadLock-源码分析" class="headerlink" title="2.1 ReadLock 源码分析"></a>2.1 ReadLock 源码分析</h2><h3 id="2-1-1-lock方法"><a href="#2-1-1-lock方法" class="headerlink" title="2.1.1 lock方法"></a>2.1.1 lock方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Acquires the read lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">         * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">         * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">         * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>sync.acquireShared方法存在于AbstractQueuedSynchronizer类中，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    <span class="comment">//@1</span></span><br><span class="line">            doAcquireShared(arg);           <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据常识，具体获取锁的过程在子类中实现，果不其然，tryAcquireShared方法在ReentrantReadWriterLock的Sync类中实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();    <span class="comment">//@1 start</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;                                                     <span class="comment">// @1 end</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;                          </span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;                                      <span class="comment">//@21                               </span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;  <span class="comment">//@22</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// @23</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);      <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>尝试获取共享锁代码解读：</p><p>@1 start–end ，如果有线程已经抢占了写锁，并且不是当前线程，则直接返回-1，通过排队获取锁。</p><p>@2,如果线程不需要阻塞，并且获取读锁的线程数没有超过最大值，并且使用 CAS更新共享锁线程数量成功的话；表示成获取读锁，然后进行内部变量的相关更新操作；先关注一下，成功获取读锁后，内部变量的更新操作：</p><p>@21,如果r=0, 表示，当前线程为第一个获取读锁的线程</p><p>@22,如果第一个获取读锁的对象为当前对象，将firstReaderHoldCount 加一</p><p>@23，成功获取锁后，如果不是第一个获取多锁的线程，将该线程持有锁的次数信息，放入线程本地变量中，方便在整个请求上下文（请求锁、释放锁等过程中）使用持有锁次数信息。</p><p>@3 在讲解代码@3之前，我们先重点分析@2处的第一个条件，是否需要阻塞方法：readerShouldBlock，在具体的子类中，现在查看的是NonfairSync中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">             * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">             * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">             * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">             * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">             * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();   <span class="comment">//该方法，具体又是在 AbstractQueuedSynchronizer中</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment">     * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment">     * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment">     * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment">     * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该方法如果头节点不为空，并头节点的下一个节点不为空，并且不是共享模式【独占模式，写锁】、并且线程不为空。则返回true,说明有当前申请读锁的线程占有写锁，并有其他写锁在申请。为什么要判断head节点的下一个节点不为空，或是thread不为空呢？因为第一个节点head节点是当前持有写锁的线程，也就是当前申请读锁的线程，这里，也就是锁降级的关键所在，如果占有的写锁不是当前线程，那线程申请读锁会直接失败。</p><p>现在继续回到@3，讲解如果第一次尝试获取读锁失败后，该如何处理。首先，进入该方法的条件如下：</p><ul><li>没有写锁被占用时，尝试通过一次CAS去获取锁时，更新失败（说明有其他读锁在申请）。</li><li>当前线程占有写锁，并且没有有其他写锁在当前线程的下一个节点等待获取写锁。；其实如果是这种情况，除非当前线程占有锁的下个线程取消，否则进入fullTryAcquireShared方法也无法获取锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;                                     <span class="comment">//@31</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;                             <span class="comment">//@32</span></span><br><span class="line">                    <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;                              <span class="comment">//@33</span></span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;                                                              <span class="comment">//@34</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId()) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)                           </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;     <span class="comment">// @35</span></span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码@31,首先再次判断，如果当前线程不是写锁的持有者，直接返回-1，结束尝试获取读锁，需要排队去申请读锁。</p><p>代码@32，如果需要阻塞，说明除了当前线程持有写锁外，还有其他线程已经排队在申请写锁，故，即使申请读锁的线程已经持有写锁（写锁内部再次申请读锁，俗称锁降级）还是会失败，因为有其他线程也在申请写锁，此时，只能结束本次申请读锁的请求，转而去排队，否则，将造成死锁。代码@34，就是从readHolds中移除当前线程的持有数，然后返回-1，结束尝试获取锁步骤（结束tryAcquireShared 方法）然后去排队获取。</p><p>代码@33，因为，如果当前线程是第一个获取了写锁，那其他线程无法申请写锁（该部分在分析完，读写锁的队列机制后，才回来做更详细的解答。）</p><p>代码@35,表示成功获取读锁，后续就是更新readHolds等内部变量，该部分在上文中已有讲解。如果是通过@35尝试获取锁成功，这就是写锁内部–》再次申请读锁（锁降级）的原理。</p><p>至此，完成尝试获取锁步骤 tryAcquireShared 方法，我们再次回到 acquireShared，如果返回-1,那么需要排队申请,具体请看 doAcquireShared(arg);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    <span class="comment">//@1</span></span><br><span class="line">            doAcquireShared(arg);           <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);   <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// @2,开始自旋重试</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// @3</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;                                   <span class="comment">// @4</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);         </span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);    <span class="comment">//@5</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())                                              <span class="comment">// @6</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取共享锁解读：</p><p>代码@1，在队列尾部增加一个节点。锁模式为共享模式。</p><p>代码@3，获取该节点的前置节点。</p><p>代码@4，如果该节点的前置节点为head(头部)，为什么前置节点是head时，可以再次尝试呢？在讲解ReentrantLock时，也讲过，head节点的初始化在第一次产生锁争用时初始化，刚开始初始化的head节点是不代表线程的，故可以尝试获取锁。如果获取失败，则将进入到shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法中，线程阻塞，等待被唤醒。</p><p>重点分析一下获取锁后的操作：setHeadAndPropagate</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;   <span class="comment">// @1</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())    <span class="comment">// @2</span></span><br><span class="line">                doReleaseShared();          <span class="comment">//@3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signal successor and ensure</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;   <span class="comment">//@4</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;   <span class="comment">//@5</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))   <span class="comment">//@6</span></span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed      //@7</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>释放共享锁的步骤：</p><p>代码@1,如果读锁（共享锁）获取成功，或头部节点为空，或头节点取消，或刚获取读锁的线程的下一个节点为空，或在节点的下个节点也在申请读锁，则在CLH队列中传播下去唤醒线程，怎么理解这个传播呢，就是只要获取成功到读锁，那就要传播到下一个节点（如果一下个节点继续是读锁的申请，只要成功获取，就再下一个节点，直到队列尾部或为写锁的申请，停止传播）。具体请看doReleaseShared方法。</p><p>代码@4，从队列的头部开始遍历每一个节点。</p><p>代码@5，如果节点状态为 Node.SIGNAL,将状态设置为0，设置成功，唤醒线程。为什么会设置不成功，可能改节点被取消；还有一种情况就是有多个线程在运行该代码段，这就是PROPAGATE的含义吧，传播，请看代码@7的理解。</p><p>代码@6，如果状态为0，则设置为Node.PROPAGATE，设置为传播，该值然后会在什么时候变化呢？在判断该节点的下一个节点是否需要阻塞时，会判断，如果状态不是Node.SIGNAL或取消状态，为了保险起见，会将前置节点状态设置为Node.SIGNAL，然后再次判断，是否需要阻塞。</p><p>代码@7，如果处理过一次 unparkSuccessor 方法后，头节点没有发生变化，就退出该方法，那head在什么时候会改变呢？当然在是抢占锁成功的时候，head节点代表获取锁的节点。一旦获取锁成功，则又会进入setHeadAndPropagate方法，当然又会触发doReleaseShared方法，传播特性应该就是表现在这里吧。再想一下，同一时间，可以有多个多线程占有锁，那在锁释放时，写锁的释放比较简单，就是从头部节点下的第一个非取消节点，唤醒线程即可，为了在释放读锁的上下文环境中获取代表读锁的线程，将信息存入在 readHolds ThreadLocal变量中。</p><p>到这里为止，读锁的申请就讲解完毕了，先给出如下流程图：</p><p><img src="https://img-blog.csdn.net/20161122154102536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p>​                                    尝试获取读锁过程</p><p>从队列中获取读锁的流程如下：</p><h3 id="2-1-2-ReadLock-的-unlock方法详解"><a href="#2-1-2-ReadLock-的-unlock方法详解" class="headerlink" title="  2.1.2 ReadLock 的 unlock方法详解"></a><img src="https://img-blog.csdn.net/20161122154203111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">  2.1.2 ReadLock 的 unlock方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer的  realseShared方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantReadWriterLock.Sync tryReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; </span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;                               <span class="comment">// @1 start               </span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;                                                            <span class="comment">// @1 end</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;                                                               <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">AbstractQueuedSynchronizer的doReleaseShared</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signal successor and ensure</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>锁的释放，比较简单，代码@1，主要是将当前线程所持有的锁的数量信息得到（从firstReader或cachedHoldCounter，或readHolds中获取 ），然后将数量减少1,如果持有数为1，则直接将该线程变量从readHolds ThreadLocal变量中移除，避免垃圾堆积。</p><p>代码@2，就是在无限循环中将共享锁的数量减少一，在释放锁阶段，只有当所有的读锁，写锁被占有，才会去执行doReleaseShared 方法。</p><h2 id="2-2-WriterLock-源码分析"><a href="#2-2-WriterLock-源码分析" class="headerlink" title="2.2 WriterLock 源码分析"></a>2.2 WriterLock 源码分析</h2><h3 id="2-2-1-lock方法详解"><a href="#2-2-1-lock方法详解" class="headerlink" title="2.2.1 lock方法详解"></a>2.2.1 lock方法详解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">对上述代码是不是似曾相识，对了，在学习ReentrantLock时候，看到的一样，acquire是在AbstractQueuedSynchronizer中，关键是在 tryAcquire方法，是在不同的子类中实现的。那我们将目光移到ReentrantReadWriterLock.Sync中</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;                                   <span class="comment">// @1</span></span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())                <span class="comment">//@2</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)              </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);                                                             <span class="comment">//@3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||                                                               </span><br><span class="line">                !compareAndSetState(c, c + acquires))                                   <span class="comment">//@4</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);                                             <span class="comment">//@5</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>代码@1,如果锁的state不为0，说明有写锁，或读锁，或两种锁持有。</p><p>代码@2，如果写锁为0，再加上c!=0，说明此时有读锁，自然返回false，表示只能排队去获取写锁；如果写锁不为0，如果持有写锁的线程不为当前线程，自然返回false,排队去获取写锁。</p><p>代码@3，表示，当前线程持有写锁，现在是重入，所以只需要修改锁的额数量即可。</p><p>代码@4，表示，表示通过一次CAS去获取锁的时候失败，说明被别的线程抢去了，也返回false,排队去重试获取锁。</p><p>代码@5，成获取写锁后，将当前线程设置为占有写锁的线程。尝试获取锁方法结束。如果该方法返回false,则进入到acquireQueue方法去排队获取写锁，写锁的获取过程，与ReentrantLock获取方法一样，就不过多的解读了。</p><p>读写锁的实现原理就分析到这了，走过路过的朋友，欢迎拍砖讨论。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、ReentrantReadWriterLock-基础&quot;&gt;&lt;a href=&quot;#1、ReentrantReadWriterLock-基础&quot; class=&quot;headerlink&quot; title=&quot;1、ReentrantReadWriterLock 基础&quot;&gt;&lt;/a&gt;1、ReentrantReadWriterLock 基础&lt;/h1&gt;&lt;p&gt;所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。&lt;/p&gt;
&lt;p&gt;java.util.concurrent.locks中关于多写锁的接口：ReadWriteLock。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReadWriteLock&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Returns the lock used for reading.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the lock used for reading.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Lock &lt;span class=&quot;title&quot;&gt;readLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * Returns the lock used for writing.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the lock used for writing.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;     */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;Lock &lt;span class=&quot;title&quot;&gt;writeLock&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;提一个问题，是否觉得 ReentrantReadWriteLock 会实现 Lock 接口吗？与 ReentrantLock 有什么关系？&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="https://www.codingw.net/categories/juc/"/>
    
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="读写琐" scheme="https://www.codingw.net/tags/%E8%AF%BB%E5%86%99%E7%90%90/"/>
    
    <category term="ReentrantReadWriteLock" scheme="https://www.codingw.net/tags/ReentrantReadWriteLock/"/>
    
  </entry>
  
  <entry>
    <title>java并发锁机制-ReentrantLock Condtion准备篇</title>
    <link href="https://www.codingw.net/posts/aa807b75.html"/>
    <id>https://www.codingw.net/posts/aa807b75.html</id>
    <published>2020-12-07T11:53:01.000Z</published>
    <updated>2020-12-24T10:14:39.789Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>根据网上的说法，jdk并发包中的 Condition await 与 signal 实现了 Object.wait notify 语义。以下总结，是基于Condition await,singal方法的实现原理总结出来的：</p><ul><li>monitorObject.wait，该方法调用必须在临界区中（锁保护的代码段）被调用，线程如果在临界区中调用监视器的wait方法，然后线程会释放占有监视器monitorObject的锁，然后阻塞（等待条件的发生，该线程会保存在monitorObject的条件等待队列，当该线程收到信号或中断被唤醒后，首先需要尝试获取监视器的锁，然后继续执行操作，如果是被中断，需要在获取锁后，才会被中断。）</li><li>monitorObject.notify,该方法调用同样只能在临界区中被调用，锁的释放，在执行完临界区后，才会释放。根据Condition.singal实现机制，首先唤醒，是先将线程从条件等待队列放入到同步阻塞队列，然后执行完临界区代码后，释放锁，其他线程竞争锁。</li></ul><p>为了对Condition await 与 signal 方法有一个直接的了解，现给出一个简单的生产者、消费者测试示例：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.study.concurent.bread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">BreadContainerByObject container = <span class="keyword">new</span> BreadContainerByObject();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Producers(container)).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(container)).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BreadContainer</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Reentrant Condition实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadContainerByCondition</span> <span class="keyword">implements</span> <span class="title">BreadContainer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> Condition NotFull = lock.newCondition();</span><br><span class="line"><span class="keyword">private</span> Condition NotEmpty = lock.newCondition();</span><br><span class="line"><span class="comment">// 面包容器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Bread&gt; breads = <span class="keyword">new</span> ArrayList&lt;Bread&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span>(breads.size() &gt;= MAX ) &#123; <span class="comment">//已经满了</span></span><br><span class="line">NotFull.await();</span><br><span class="line">&#125;</span><br><span class="line">b.setId(num ++);</span><br><span class="line">breads.add(b);</span><br><span class="line"><span class="comment">//放入一个元素后，NotEmpty</span></span><br><span class="line">NotEmpty.signalAll();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">while</span>(breads.isEmpty()) &#123;<span class="comment">//如果为空</span></span><br><span class="line">NotEmpty.await();</span><br><span class="line">&#125;</span><br><span class="line">Bread b = breads.remove(breads.size() -<span class="number">1</span>);</span><br><span class="line">NotFull.signalAll();</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Object.notify Object.wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadContainerByObject</span> <span class="keyword">implements</span> <span class="title">BreadContainer</span></span>&#123;</span><br><span class="line"><span class="comment">// 面包容器</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Bread&gt; breads = <span class="keyword">new</span> ArrayList&lt;Bread&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (breads) &#123;</span><br><span class="line"><span class="keyword">while</span>(breads.size() &gt;= MAX) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">breads.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();<span class="comment">//这里不应该 将 InterruptedExcepiton 吞掉</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b.setId(num ++);</span><br><span class="line">breads.add(b);</span><br><span class="line">breads.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Bread b = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">synchronized</span> (breads) &#123;</span><br><span class="line"><span class="keyword">while</span>(breads.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">breads.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();<span class="comment">//这里不应该 将 InterruptedExcepiton 吞掉</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">b = breads.remove(breads.size() -<span class="number">1</span>);</span><br><span class="line">breads.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producers</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BreadContainerByObject container;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Producers</span><span class="params">(BreadContainerByObject container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.container = container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">b.setFactoryName(Thread.currentThread().getName());</span><br><span class="line">container.put(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> BreadContainerByObject container;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BreadContainerByObject container)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.container = container;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;</span><br><span class="line">Bread b = container.poll();</span><br><span class="line">System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了&quot;</span> + b.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String factoryName;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;面包:&quot;</span> + (id == <span class="keyword">null</span> ? <span class="number">0</span> : id.intValue()) + <span class="string">&quot;;生产工厂：&quot;</span> + getFactoryName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getFactoryName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> factoryName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryName</span><span class="params">(String factoryName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.factoryName = factoryName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Reentrant Condition ,细化了消息通知的粒度，比如使用了当队列中产品时，通过 NotEmpty 条件来唤醒消费者，当队列还有可用的空间存放产品时，使用 NotFull 条件来唤醒生产者，使用两个条件队列，确保被唤醒的线程的准确性，加入到同步队列的节点，在该节点获取到锁后，确实是满足条件的（特别在临界情况的时候)。而Object.wait, Object.notify ,  生产者，消费者在同一个条件队列中排队。</p></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据网上的说法，jdk并发包中的 Condition await 与 signal 实现了 Object.wait notify 语义。以下总结，是基于Condition await,singal方法的实现原理总结出来的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;monitorObject.wait，该方法调用必须在临界区中（锁保护的代码段）被调用，线程如果在临界区中调用监视器的wait方法，然后线程会释放占有监视器monitorObject的锁，然后阻塞（等待条件的发生，该线程会保存在monitorObject的条件等待队列，当该线程收到信号或中断被唤醒后，首先需要尝试获取监视器的锁，然后继续执行操作，如果是被中断，需要在获取锁后，才会被中断。）&lt;/li&gt;
&lt;li&gt;monitorObject.notify,该方法调用同样只能在临界区中被调用，锁的释放，在执行完临界区后，才会释放。根据Condition.singal实现机制，首先唤醒，是先将线程从条件等待队列放入到同步阻塞队列，然后执行完临界区代码后，释放锁，其他线程竞争锁。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了对Condition await 与 signal 方法有一个直接的了解，现给出一个简单的生产者、消费者测试示例：&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://www.codingw.net/categories/java/"/>
    
    
    <category term="juc" scheme="https://www.codingw.net/tags/juc/"/>
    
    <category term="并发琐" scheme="https://www.codingw.net/tags/%E5%B9%B6%E5%8F%91%E7%90%90/"/>
    
    <category term="wait" scheme="https://www.codingw.net/tags/wait/"/>
    
    <category term="notify" scheme="https://www.codingw.net/tags/notify/"/>
    
  </entry>
  
  <entry>
    <title>java多线程Thread join与CountDownLatch源码分析</title>
    <link href="https://www.codingw.net/posts/7da5265a.html"/>
    <id>https://www.codingw.net/posts/7da5265a.html</id>
    <published>2020-12-06T13:43:01.000Z</published>
    <updated>2020-12-24T10:14:50.141Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><h1 id="1、Thread-join方法详解"><a href="#1、Thread-join方法详解" class="headerlink" title="1、Thread join方法详解"></a>1、Thread join方法详解</h1><p>首先，对于JAVA的一些基础知识，工作年限到了一定时间后，尽量不要一来就百度查询，比如thread join的作用，我们不妨先看一看join方法的源码，先试着自己理解，然后再去查询别人的理解，举一反三，美哉美哉。</p><a id="more"></a><p>join方法的声明与源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">     * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">     * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">     * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先，join方法是线程对象的实例方法，并不同于sleep方法。并且被 synchronized关键字被修饰，说明要进入join方法，必须获得线程的对象锁。所以join(long millis)方法，指的是获取对象锁后需要等待的时间，并不是join方法等待的时间。</p><p>join的方法是在a线程中，调用 b.join()方法，实现的语义是，线程a等待线程b执行完毕后，再执行；join方法支持中断。实现的原理是在线程处于激活状态(isActive())方法时，调用 wait 方法或 wait(long milliseconds)方法。下面提供三个测试方法，进一步说明join方法语义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.study.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * t.join学习</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test1();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test2();</span></span><br><span class="line"></span><br><span class="line">        test3();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 join的基本语义，在其他线程执行完毕后，主线程才会结束</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 该测试用例说明：</span></span><br><span class="line"><span class="comment">     * 如果将t1.join 注释掉，则输出基本是</span></span><br><span class="line"><span class="comment">     *     main 线程启动.....</span></span><br><span class="line"><span class="comment">     *     main 线程结束......</span></span><br><span class="line"><span class="comment">     *         1</span></span><br><span class="line"><span class="comment">     *         2</span></span><br><span class="line"><span class="comment">     *         3</span></span><br><span class="line"><span class="comment">     * 如果增加t1.join则，主线程需要等待 t1线程运行结束后，才会退出，输出如下：</span></span><br><span class="line"><span class="comment">     *     main 线程启动.....</span></span><br><span class="line"><span class="comment">     *            1</span></span><br><span class="line"><span class="comment">     *         2</span></span><br><span class="line"><span class="comment">     *         3</span></span><br><span class="line"><span class="comment">     *     main 线程结束......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread1());</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(); <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 t1.join(long miliseconds) 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread2());</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(<span class="number">3000</span>); <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread3(t1));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="comment">//确认t1,t2都在运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            t1.join(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;join方法执行后，经过&quot;</span> + ((end - start) / <span class="number">1000</span>) + <span class="string">&quot;秒结束&quot;</span>); <span class="comment">//这里不是1秒，需要等线程t2执行完毕才能被唤醒，</span></span><br><span class="line">                                                                               <span class="comment">//为什么呢，因为在线程t2中，占用了t1线程的对象锁，t1.join首先需要获取t1的对象锁。所以需要等t2执行完毕，                              </span></span><br><span class="line">                                                                              <span class="comment">//释放锁后才能开始执行join方法。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunThread3</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">synchronized</span>(t) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="2、CountDownLatch源码分析"><a href="#2、CountDownLatch源码分析" class="headerlink" title="2、CountDownLatch源码分析"></a>2、CountDownLatch源码分析</h1><p>CountDownLatch，闭锁，能够实现Thread join 类似的语义，用在如下业务场景，比如协调者（主线程）创建多个线程去并发的完成一件事情，主线程创建并启动线程后，需要等待任务全部运行完毕后，主线程处理相关事情后再退出。</p><p>如下代码是我们经常会看到的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试开始。。&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(  <span class="keyword">new</span> ThreadA()).start();<span class="comment">//处理任务</span></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了防止主线程提早退出，我们一般会让主线程sleep,</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>* <span class="number">1000</span>);  <span class="comment">//这种不准确，实现方法不友好。</span></span><br><span class="line">   </span><br><span class="line">    System.out.println(<span class="string">&quot;测试结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">为了解决上述问题，CountDownLatch 能精确的解决上述问题。</span><br><span class="line">CountDownLatch使用实例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnalA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch cdl;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnalA</span> <span class="params">(CountDownLatch cdl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cdl=cdl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">// 线程运行完毕后，</span></span><br><span class="line">         cdl.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainCls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptException </span>&#123;</span><br><span class="line">        CountDownLatch  cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnalA(cdl) ).start();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//需要等10个线程全部运行完毕后，主线程才结束</span></span><br><span class="line">       cdl.await();<span class="comment">//等10个线程运行完毕后，主线程才会退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-1-CountDownLatch-方法实现原理"><a href="#2-1-CountDownLatch-方法实现原理" class="headerlink" title="2.1 CountDownLatch 方法实现原理"></a>2.1 CountDownLatch 方法实现原理</h2><p>首先，通过CountDownLatch的构造方法，设置锁的state变量，从分析ReentrantLock,ReentrantReadWriteLock 中我们应该知道state的意义。</p><p>然后await方法,使用获取共享锁的模式，由于state不为，则await方法调用，必然会在CLH队列中增加一个节点，然后线程阻塞。</p><p>countDown方法，每次将state减1，直到state=0时，唤醒线程，awiat方法成功获取锁，方法解除阻塞，继续执行。源码的分析就不做过多的解读，因为如下代码在学习ReentrantLock,ReentrantReadWriterLock锁时已经详细分析了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatch对tryAcquireSharedd的实现，是 </span><br><span class="line"><span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;  如果getState()的值为<span class="number">0</span>,则不阻塞，直接返回。如果state大于<span class="number">0</span>，则在CLH队列中等待，由于我们在使用的时候，一定是先调用await方法，这样await方法在调用的时候，肯定是获取不到锁的，故在CLH队列中，会是这样的结构  head--&gt;Node[队列尾部，就是代表调用await方法的线程。]</span><br><span class="line"></span><br><span class="line">CountDownLatch的 countDown方法,内部就是调用releaseShared方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123; <span class="comment">//如果 state或减去1之后的值为0，则返回ture,表明可以唤醒由于调用                                                                                  //await方法调用的线程</span></span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1、Thread-join方法详解&quot;&gt;&lt;a href=&quot;#1、Thread-join方法详解&quot; class=&quot;headerlink&quot; title=&quot;1、Thread join方法详解&quot;&gt;&lt;/a&gt;1、Thread join方法详解&lt;/h1&gt;&lt;p&gt;首先，对于JAVA的一些基础知识，工作年限到了一定时间后，尽量不要一来就百度查询，比如thread join的作用，我们不妨先看一看join方法的源码，先试着自己理解，然后再去查询别人的理解，举一反三，美哉美哉。&lt;/p&gt;</summary>
    
    
    
    <category term="juc" scheme="https://www.codingw.net/categories/juc/"/>
    
    
    <category term="源码" scheme="https://www.codingw.net/tags/%E6%BA%90%E7%A0%81/"/>
    
    <category term="join" scheme="https://www.codingw.net/tags/join/"/>
    
    <category term="CountDownLatch" scheme="https://www.codingw.net/tags/CountDownLatch/"/>
    
  </entry>
  
  <entry>
    <title>Spring系列之基础篇-Spring BeanDefinition初探</title>
    <link href="https://www.codingw.net/posts/4054ca58.html"/>
    <id>https://www.codingw.net/posts/4054ca58.html</id>
    <published>2020-12-05T11:40:01.000Z</published>
    <updated>2020-12-24T10:14:59.452Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>BeanDefinition，顾名思义，是一个对象(Bean)在Spring中描述，其核心类图：<br><img src="https://img-blog.csdn.net/20180528231257873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180528231316723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从类图我们详细了解BeanDefinition。<br>BeanDefinition接口继承自BeanMetadataElement和AttributeAccessor两个接口。<br>BeanMetadataElement：bean元数据，返回该bean的来源。<br>AttributeAccessor：Spring定义的属性访问器，对Bean的属性进行操作的API,例如设置属性、获取属性、判断是否存在该属性，返回bean所有的属性名称等。<br>下面重点分析一下BeanDefinition接口。</p><a id="more"></a><p>属性列表：<br>1）String SCOPE_SINGLETON，bean的作用范围，单例模式<br>2）String SCOPE_PROTOTYPE，bean的作用范围为prototype，在Spring生命周期中，会存在多个，由垃圾回收期管理其生命周期。<br>3）int ROLE_APPLICATION：bean的角色定义，默认，为应用程序定义。<br>4）int ROLE_SUPPORT：bean的角色定义，为应用程序定义的比较大的对象。<br>5）int ROLE_INFRASTRUCTURE：Spring内部定义的Bean对象。<br>核心方法详解：<br>1）void setBeanClassName(String beanClassName) ：该Bean的class name。<br>2）void setScope(String scope)：bean的生命周期，单例还是prototype。<br>3）void setLazyInit(boolean lazyInit)：lazyInit，是否延迟加载，如果设置为true,在需要用到时再初始化。<br>4）void setDependsOn(String… dependsOn)：dependsOn一般用于两个bean之间没有显示依赖，但后一个Bean需要用到前一个Bean执行初始方法后的结果。例如在&lt; bean id=”a” dependsOn=”b”/&gt; 时，在初始化a时首先先初始化b，在销毁b之前会先销毁a。<br>5）void setAutowireCandidate(boolean autowireCandidate)设置该对象是否可以被其他对象自动装配。<br>spring通过配置bean的autowire属性设置自动装配方式：<br>     no：不使用自动装配，必须通过ref元素指定依赖，为autowire默认值。<br>     byName：使用属性名自动装配，如果存在一个与指定属性名相同类型的bean则自动装配，如果有多个，则抛出异常。<br>     byType：根据类型自动状态，如果存在与指定属性类型相同的bean,则自动装配，如果有多个，则抛出异常。<br>     constructor：与byType类似，不同之处在于它使用的是构造器的参数类型。<br>     autodetect：通过bean的自省机制来决定是使用constructor还是byType来进行自动装配。如果有默认构造<br>                       器，则使用byType，否则使用constructor。<br>6）void setPrimary(boolean primary)，如果其他对象按照类型自动装配时发现有多个符合类型的多个实现bean，如果bean的primary属性为true，则以primary为true的优先，当然如果有多个primary为true，则抛出异常。<br>7）void setFactoryBeanName(String factoryBeanName)：设置bean的factoryBeanName。<br>8）void setFactoryMethodName(String factoryMethodName):设置bean工厂的方法名，Spring在实例化Bean对象时支持工厂方法设计模式，在初始化bean时不是通过bean的class发射创建 bean实例，而是根据factoryBeanName反射出工厂的实例，然后调用它的实例方法factoryMethodName来创建bean实例。<br>9）ConstructorArgumentValues getConstructorArgumentValues()：获取bean的构造方法参数。<br>10）MutablePropertyValues getPropertyValues()：获取实例bean的所有属性。<br>11）boolean isSingleton()：是否是单例。<br>12）boolean isPrototype()：是否是非单例。<br>13）boolean isAbstract()：是否是抽象的。</p><p>本文主要是根据BeanDefinition接口了解bean的一些特性,值得引起注意的是：lazy-init、depends-on、autowire-candidate、autowire、primary、factory-bean、factory-method。</p><blockquote><p>注：本文并没有尝试去罗列spring bean标签的全部属性。</p></blockquote></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;BeanDefinition，顾名思义，是一个对象(Bean)在Spring中描述，其核心类图：&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180528231257873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180528231316723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;从类图我们详细了解BeanDefinition。&lt;br&gt;BeanDefinition接口继承自BeanMetadataElement和AttributeAccessor两个接口。&lt;br&gt;BeanMetadataElement：bean元数据，返回该bean的来源。&lt;br&gt;AttributeAccessor：Spring定义的属性访问器，对Bean的属性进行操作的API,例如设置属性、获取属性、判断是否存在该属性，返回bean所有的属性名称等。&lt;br&gt;下面重点分析一下BeanDefinition接口。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://www.codingw.net/categories/java/"/>
    
    
    <category term="spring" scheme="https://www.codingw.net/tags/spring/"/>
    
    <category term="BeanDefinition" scheme="https://www.codingw.net/tags/BeanDefinition/"/>
    
    <category term="内存溢出" scheme="https://www.codingw.net/tags/%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA/"/>
    
  </entry>
  
  <entry>
    <title>TreeMap之NavigableMap API 学习</title>
    <link href="https://www.codingw.net/posts/4757c2d8.html"/>
    <id>https://www.codingw.net/posts/4757c2d8.html</id>
    <published>2020-12-04T11:37:01.000Z</published>
    <updated>2020-12-24T10:15:10.388Z</updated>
    
    <content type="html"><![CDATA[<div id="vip-container"><p>本文主要学习TreeMap的核心API，下面是测试数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeMap&lt; Long, Long&gt; treeMap &#x3D; new TreeMap&lt;&gt;();</span><br><span class="line">for(int i &#x3D; 2; i &lt;&#x3D; 20; i &#x3D; i + 2) &#123;</span><br><span class="line">   treeMap.put(new Long(i), new Long(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1、K lowerKey(K key) | Map.Entry&lt; K,V&gt; lowerEntry(K key)   </p><p>1）英文注释<br>Returns a key-value mapping associated with the greatest keystrictly less than the given key, or {@code null} if there is no such key.<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626214930370?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>   输出结果：<br>   4<br>   4<br>   null<br>3）中文解释<br>  返回第一个小于该key的键或Entry，不包含指定key。指定key不存在不影响结果，例如测试用例中的不存在键为5的键值对，但还是能返回Key:4，如果没有扎到小于key的键，则返回null。</p><a id="more"></a><p>2、K floorKey(K key) | Map.Entry&lt; K,V&gt; floorEntry(K key)</p><p>1）英文注释<br>Returns a key-value mapping associated with the greatest key less than or equal to the given key, or {@code null} if there is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215016389?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   6<br>   4<br>   null<br>3）中文解释<br>   返回小于等于指定key的键值，与lowerKey的区别是floorKey方法，如果TreeMap中包含指定的key，则返回指定key，否则返回第一个小于指定key的键。</p><p>3、K ceilingKey(K key) | Map.Entry&lt; K,V&gt; ceilingEntry(K key)</p><p>1）英文注释<br>Returns a key-value mapping associated with the least key greater than or equal to the given key, or {@code null} if there is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215110522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   6<br>   6<br>   null<br>3）中文解释<br>   ceiling : 天花板，查找指定key的天花板，也就是说，查找第一个大于等于指定key的可以。</p><p>4、K higherKey(K key) | Map.Entry&lt; K,V&gt; higherEntry(K key)</p><p>1）英文注释<br>Returns a key-value mapping associated with the least key strictly greater than the given key, or {@code null} if there  is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215144375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   8<br>   6<br>   null<br>3）中文解释<br>   返回第一个大于指定key的键，不包含指定key。而ceilingKey包含指定key。</p><p>5、Map.Entry&lt; K,V&gt; firstEntry()、Map.Entry&lt; K,V&gt; lastEntry()、Map.Entry&lt; K,V&gt; pollFirstEntry()、Map.Entry&lt; K,V&gt; pollLastEntry()<br>这四个方法很好理解，这里不做详细讲解。</p><p>6、NavigableMap&lt; K,V&gt; descendingMap()、 NavigableSet&lt; K&gt; descendingKeySet()<br>这两个方法，返回逆序。</p><p>7、NavigableMap&lt; K,V&gt; subMap(K fromKey, boolean fromInclusive,  K toKey,   boolean toInclusive)<br>1）英文注释<br><img src="https://img-blog.csdn.net/20180626215248417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215316903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  输出结果：<br>{4=4, 6=6, 8=8}<br>返回子集合(TreeMap),从fromKey,到toKey，boolean fromInclusive表示是否包含fromKey,boolean toInclusive是否包含toKey。<br>TreeMap#subMap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123;</span><br><span class="line">        return subMap(fromKey, true, toKey, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、NavigableMap&lt; K,V&gt; headMap(K toKey, boolean inclusive)<br>1）英文注释<br><img src="https://img-blog.csdn.net/20180626215421299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）中文说明<br>   测试结果省略（推理后，也验证过），根据上面的学习过程，可以推导出，该方法相当于 subMap(firstKey, true, toKey, inclusive)。<br>TreeMap#headMap(Key toKey)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; headMap(K toKey) &#123;</span><br><span class="line">        return headMap(toKey, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>9、NavigableMap&lt; K,V&gt; tailMap(K fromKey, boolean inclusive)<br>1）英文描述<br><img src="https://img-blog.csdn.net/20180626215518663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）中文解释<br>返回从fromKey到lastKey的子集合，相当于subMap(fromKey,inclusive,lastKey,true)。<br>TreeMap#tailMap(K fromKey) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123;</span><br><span class="line">        return tailMap(fromKey, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script><script>var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);if (!isMobile) {    var btw = new BTWPlugin();    btw.init({        "id": "vip-container",        "blogId": "18019-1573088808868-542",        "name": "中间件兴趣圈",        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",        "keyword": "more"    });}</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要学习TreeMap的核心API，下面是测试数据：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;TreeMap&amp;lt; Long, Long&amp;gt; treeMap &amp;#x3D; new TreeMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;for(int i &amp;#x3D; 2; i &amp;lt;&amp;#x3D; 20; i &amp;#x3D; i + 2) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   treeMap.put(new Long(i), new Long(i));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;1、K lowerKey(K key) | Map.Entry&amp;lt; K,V&amp;gt; lowerEntry(K key)   &lt;/p&gt;
&lt;p&gt;1）英文注释&lt;br&gt;Returns a key-value mapping associated with the greatest keystrictly less than the given key, or {@code null} if there is no such key.&lt;br&gt;2）测试结果&lt;br&gt;&lt;img src=&quot;https://img-blog.csdn.net/20180626214930370?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70&quot; alt=&quot;这里写图片描述&quot;&gt;&lt;br&gt;   输出结果：&lt;br&gt;   4&lt;br&gt;   4&lt;br&gt;   null&lt;br&gt;3）中文解释&lt;br&gt;  返回第一个小于该key的键或Entry，不包含指定key。指定key不存在不影响结果，例如测试用例中的不存在键为5的键值对，但还是能返回Key:4，如果没有扎到小于key的键，则返回null。&lt;/p&gt;</summary>
    
    
    
    <category term="java" scheme="https://www.codingw.net/categories/java/"/>
    
    
    <category term="java" scheme="https://www.codingw.net/tags/java/"/>
    
    <category term="TreepMap" scheme="https://www.codingw.net/tags/TreepMap/"/>
    
  </entry>
  
</feed>
