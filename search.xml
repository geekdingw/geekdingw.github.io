<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10年IT老兵给职场新人的一些建议</title>
    <url>/posts/7b3f0619.html</url>
    <content><![CDATA[<div id="vip-container"><p>2020年04年01，对我来说一个非常值得纪念的日子，因为10年前的今天我从一个<strong>普通二类本科</strong>的大学毕业生正式步入职场，开启了我人生的新篇章。</p>
<p>经过10年的成长，我从一个青涩少年依然蜕变为一个“中年大叔”了，也取得了一定的成绩，为了突破“中年危机”，将持续努力。</p>
<p>首先先来一个自我介绍：丁威，《RocketMQ技术内幕》作者、『中间件兴趣圈』公众号维护者、2019年RocketMQ社区优秀布道师评选斩获第一名、2019年度CSDN博客之星TOP10获得者，目前就任中通科技技术平台部担任资深架构师，负责消息中间件与全链路压测在科技中心的落地与实施工作。</p>
<a id="more"></a>

<p>回想这10年的工作经历，我个人觉得有很多点可以和大家一起来分享分享。</p>
<p>首先我职业生涯的前面四年，是呆在一家国企控股公司，主要从事的业务是电子政务方面的业务，是一个传统行业，虽然我很努力，解决工作中的问题显得得心应手，在公司所在的部门也能得到领导的赏识、同事们的认可，但受限于所在平台的局限性以及公司的规模，薪资无法得到较大幅度的提升，萌生了离开的想法。但让我所料不及的是我满怀信心去找工作的时候让我备受打击，阿里系企业直接将我秒杀，诸如HashMap的内存结构是什么？HashMap为什么不是线程安全的，什么大数据、高并发这些场景更是连想都没有相关，后面就选择一家外部公司，开始了探究互联网相关的技能。</p>
<p><strong>回想这段经验，我有如下感悟与建议</strong><br><strong>1、第一份工作真的很重要，如果有好的学历背景，找工作时不能将就。</strong><br><strong>2、如果没有好的学历背景，也无需气馁，要一开始就为自己树立一个远大的目标：一定要凭着自己的努力，励志要进入一线互联网企业。</strong><br><strong>3、有了目标，在工作的第一年主要还是要扩大知识面，点到为止，以便功能好的完成工作，进入工作第二年后，就要开始打牢基础，探究原理，快速成长。</strong></p>
<p>那如何打牢基础，探究原理，快速成长呢？</p>
<p>在经过阿里系面试打击后，我决定先离开工作了4年的环境，寻找了一家有机会接触互联网相关技术的公司，开始打拼，这个时候，在完成工作的情况下，我会利用业余时间进行学习，越努力越幸运，我的运气还不错，认识了MyCat社区的负责人，为我指明了方向，融入开源社区，但那个时候的我发现我无看懂MyCat的源码，也就无法深层次参与其开源建设，那如何破解。</p>
<p>后面痛定思痛，既然没有能力看懂MyCat源码，那就从JAVA的基础开始，故与2016年9月正式开通CSDN博客，从源码分析Java集合、JUC(Java并发包)、Java NIO、Netty，经过了半年源码研究分析，基础终于打牢，一鼓作气在CSDNS上发表了源码分析MyCat专栏，并且还对MyCat开源社区贡献过代码，在MyCat形成了一定的社区影响力。</p>
<p>正式由于在MyCat社区活跃的表现，终于迎来职业生涯一个非常重要的转折点：一家公司在生产环境大规模使用MyCat，但缺乏专业人士对其进行维护，故通过MyCat社区的介绍，我正式入职该公司，从此正式进入亿级数据规模，我所学的知识终于有了用武之地，而且能应付自如，在一家拥有300号人的科技公司崭露头角。</p>
<p><strong>回顾这段经验，有如下感悟我觉得可以分享一下。<br>如果当我们没有一个好的平台，无法接触高并发，大数据这样的场景时，我们该如何破解，无需气馁，努力学习高并发、大数据相关的基础知识，例如Java并发、Netty网络，各主流中间件的原理、以及JVM诊断的理论基础，相信总会有伯乐找到你，让你的能力得到施展。</strong></p>
<p>在成功进入好的平台后，不能松懈，继续在工作之余学习了互联网架构中中主流的中间件，陆续发表了源码研究RocketMQ、Dubbo、ElasticJob等专栏。越努力越幸运，由于源码分析RocketMQ专栏总共发表了40余篇，成体系的剖析了RocketMQ的实现原理，被出版社相中，邀请我出书，最终成功出版了《RocketMQ技术内幕》一书，并且获得了广大读者朋友一致好评，并受我其中一个读者的邀请，最终入职了中通科技，进入更加广阔的平台，继续努力打拼。</p>
<p><strong>这段建议给我的感悟就是：越努力越幸运，唯有坚持不懈。</strong></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
        <tag>职场感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba Sentinel 限流与熔断初探(技巧篇)</title>
    <url>/posts/84defd78.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>温馨提示：源码分析 Alibaba Sentinel 专栏开始连载，本文展示如何学习一个全新的技术的方法。该专栏基于 1.7.0 版本。</p>
</blockquote>
<p>在学习一个新技术或新框架时，建议先查看其官方文档， Sentinel 官方文档链接如下：<a href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">官方文档</a>，以获得对其形成一个整体的认识。</p>
<h2 id="1、Sentinel-是什么-？主要能解决什么问题？"><a href="#1、Sentinel-是什么-？主要能解决什么问题？" class="headerlink" title="1、Sentinel 是什么 ？主要能解决什么问题？"></a>1、Sentinel 是什么 ？主要能解决什么问题？</h2><p>按照官方的定义，Sentinel 意为分布式系统的流量防卫兵，主要提供限流、熔断等服务治理相关的功能。</p>
<p>服务的动态注册、服务发现是 SOA、微服务架构体系中首先需要解决的基本问题，服务治理是 SOA 领域又一重要课题，而 dubbo 框架只提供了一些基本的服务治理能力，例如限制服务并发调用数、配置合适的业务线程数量等，但熔断相关的功能就涉及的较少。</p>
<p>Sentinel 将作为 Dubbo 生态的重要一员，将集中解决服务治理相关的课题，服务限流与熔断又是服务治理首先要解决的课题。</p>
<p>那什么是限流与熔断呢？</p>
<p>限流：我们通常使用TPS对流量来进行描述，限流就是现在服务被调用的并发TPS，从而对系统进行自我保护。</p>
<p>熔断：就是当系统中某一个服务出现性能瓶颈是，对这个服务的调用进行快速失败，避免造成连锁反应，从而影响整个链路的调用。</p>
<h2 id="2、限流与熔断的使用场景"><a href="#2、限流与熔断的使用场景" class="headerlink" title="2、限流与熔断的使用场景"></a>2、限流与熔断的使用场景</h2><p>限流还是比较好理解，例如一个项目在上线之前经过性能测试评估，例如服务在 TPS 达到 1w/s 时系统资源利用率飙升，与此同时响应时间急剧增大，那我们就要控制该服务的调用TPS，超过该 TPS 的流量就需要进行干预，可以采取拒绝、排队等策略，实现流量的削峰填谷。</p>
<p>还有一个场景，例如一下开放平台，对接口进行收费，免费用户要控制调用TPS，账户的等级不同，允许调用的TPS也不同，这种情况就非常适合限流。</p>
<p>那熔断的使用场景呢？我们首先来看一下如下的分布式架构。<br><img src="https://img-blog.csdnimg.cn/20191214230343989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例如应用A 部署了3台机器，如果由于某种原因，例如线程池 hold 住，导致发送到它上面的请求会出现超时而报错，由于该进程并未宕机，请求还是会通过负载算法请求出现故障的机器，出现整个1/3的请求出现超时报错，影响整个系统的可用性？也就是其中一台故障会对整个服务质量产生严重的影响，虽然是集群部署，但无法达到高可用性。那如何解决该问题？如果在调用方(API-Center) 对异常进行统计，发现发往某一台机器的错误数或错误率达到设定的值，就在一定的世界间隔内不继续发往该机器，转而发送给集群内正常的节点，这样就实现了高可用，这就是所谓的熔断机制。</p>
<p>有了上面的基本认识，接下来会进行一些阅读源码的准备，为后面的源码分析 Sentinel 打下坚实的基础。</p>
<a id="more"></a>

<h2 id="3、Sentinel-源码结构"><a href="#3、Sentinel-源码结构" class="headerlink" title="3、Sentinel 源码结构"></a>3、Sentinel 源码结构</h2><p><img src="https://img-blog.csdnimg.cn/20191214230725995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Sentinel 的核心模块说明如下：</p>
<ul>
<li><p>sentinel-core<br>Sentinel 核心模块，实现限流、熔断等基本能力。</p>
</li>
<li><p>sentinel-dashboard<br>Sentinel 可视化控制台，提供基本的管理界面，配置限流、熔断规则等，展示监控数据等。</p>
</li>
<li><p>sentinel-adapter<br>Sentinel 适配，Sentinel-core 模块提供的是限流等基本API，主要是提供给应用自己去显示调用，对代码有侵入性，故该模块对主流框架进行了适配，目前已适配的模块如下：</p>
<ul>
<li>sentinel-apache-dubbo-adapter<br>对 Apache Dubbo 版本进行适配，这样应用只需引入 sentinel-apache-dubbo-adapter 包即可对 dubbo 服务进行流控与熔断，大家可以思考会利用 Dubbo 的哪个功能特性。</li>
<li>sentinel-dubbo-adapter<br>对 Alibaba Dubbo 版本进行适配。</li>
<li>sentinel-grpc-adapter<br>对 GRPC 进行适配。</li>
<li>sentinel-spring-webflux-adapter<br>对响应式编程框架 webflux 进行适配。</li>
<li>sentinel-web-servlet<br>对 servlet 进行适配，例如 Spring MVC。</li>
<li>sentinel-zuul-adapter<br>对 zuul 网关进行适配。</li>
</ul>
</li>
<li><p>sentinel-cluster<br>提供集群模式的限流与熔断支持，因为通常一个应用会部署在多台机器上组成应用集群。</p>
</li>
<li><p>sentinel-transport<br>网络通讯模块，提供 Sentinel 节点与 sentinel-dashboard 的通讯支持，主要有如下两种实现。</p>
<ul>
<li>sentinel-transport-netty-http<br>基于 Netty 实现的 http 通讯模式。</li>
<li>sentinel-transport-simple-http<br>简单的 http 实现方式。</li>
</ul>
</li>
<li><p>sentinel-extension<br>Sentinel 扩展模式。主要提供了如下扩展(高级)功能：</p>
<ul>
<li>sentinel-annotation-aspectj<br>提供基于注解的方式来定义资源等。</li>
<li>sentinel-parameter-flow-control<br>提供基于参数的限流（热点限流）。</li>
<li>sentinel-datasource-extension<br>限流规则、熔断规则的存储实现，默认是存储在内存中。</li>
<li>sentinel-datasource-apollo<br>基于 apollo 配置中心实现限流规则、熔断规则的存储，动态推送生效机制。</li>
<li>sentinel-datasource-consul<br>基于 consul 实现限流规则、熔断规则的存储，动态推送生效机制。</li>
<li>sentinel-datasource-etcd<br>基于 etcd 实现限流规则、熔断规则的存储，动态推送生效机制。</li>
<li>sentinel-datasource-nacos<br>基于 nacos 实现限流规则、熔断规则的存储，动态推送生效机制。</li>
<li>sentinel-datasource-redis<br>基于 redis 实现限流规则、熔断规则的存储，动态推送生效机制。</li>
<li>sentinel-datasource-spring-cloud-config<br>基于 spring-cloud-config 实现限流规则、熔断规则的存储，动态推送生效机制。</li>
<li>sentinel-datasource-zookeeper<br>基于 zookeeper 实现限流规则、熔断规则的存储，动态推送生效机制。</li>
</ul>
</li>
</ul>
<h2 id="4、在-IntelliJ-IDEA-中运行-Sentine-Demo"><a href="#4、在-IntelliJ-IDEA-中运行-Sentine-Demo" class="headerlink" title="4、在 IntelliJ IDEA 中运行 Sentine Demo"></a>4、在 IntelliJ IDEA 中运行 Sentine Demo</h2><p>在 sentinel-demo 模块下提供了很多示例，Seninel 一开始是为 Dubbo 而生的，故我们选取一下 sentinel-demo-apache-dubbo 为本次演示的示例。</p>
<p>注意：该版本需要引入的 apache dubbo 版本需要修改为 2.7.2。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.dubbo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Step1：先启动 sentinel-dashboard，启动参数配置如下：<br><img src="https://img-blog.csdnimg.cn/20191214230758222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>sentinel-demo-apache-dubbo 模块如下所示：<br><img src="https://img-blog.csdnimg.cn/20191214230836334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先启动服务提供者，其配置参数如下：<br><img src="https://img-blog.csdnimg.cn/20191214230902547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后启动服务消费者，其配置参数如下：<br><img src="https://img-blog.csdnimg.cn/20191214230924603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>启动后，我们能看到消费者会出现报错，因为触发了限流，我们可以通过控制台查看接入应用的信息，例如输入：<a href="http://localhost:8080/">http://localhost:8080</a></p>
<p>部分截图如下：<br><img src="https://img-blog.csdnimg.cn/20191214231003110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191214231019623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以在控制台动态添加限流、熔断等规则配置，然后接入的客户端将能在不启动应用的情况下生效。</p>
<p>默认情况下，sentinel-dashboard 中的规则是存储在内存中，重启后就会丢失，因此 Sentinel 提供了很多种数据源的实现，例如 sentinel-datasource-zookeeper，这部分内容随着该专栏的陆续更新，将会对该机制进行介绍。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>限流</tag>
        <tag>熔断</tag>
      </tags>
  </entry>
  <entry>
    <title>AtomicIntegerArray源码分析与感悟.</title>
    <url>/posts/e3c7511d.html</url>
    <content><![CDATA[<div id="vip-container"><a id="more"></a>![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)

<p>AtomicIntegerArray，提供了一个原子访问数据中元素方法的一种途径。</p>
<p>对于这类原子操作，在理解上应该没什么问题，通过AtomitoIntegerArray，我学到如下几个关键点：</p>
<ul>
<li>int  sacle = unsafe.arrayIndexScale（int[].class）与  int base = unsafe.arrayBaseOffset(Int[].class);<br>其中 unsafe.arrayBaseOffset 获取该类型的数组，在对象存储时，存放第一个元素的内存地址，相对于数组对象起始地址的内存偏移量。unsafe.arrayIndexSacle(int[].class) 获取该类型的数组中元素的大小，占用多少个字节。</li>
<li>根据scale ，base 如何准备定位到任意一个下标的地址呢？请查看如下关键代码块</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>用于定位元素偏移量的控制值。</p>
<p>举例说明，int scale = 4;1个int类型，在java中占用4个字节。</p>
<p>Integer.numberOfLeadingZeros(scale); 返回 scale 高位连续0的个数，得出shift = 2, 而shift在如下方法使用</p>
<p>得出结论了吧，shift就是 用来定位数组中的内存位置，用来移位用的，每向左移动移位，在不越界的情况下，想当于乘以2。也就是int类型的长度为4，也就是第0个位置是0，第1(i)个位置是4,，第二个(i)位置是8，也就是偏移位置等于  i * 4,也就是  i &lt;&lt; 2;总结出一个乘法转换成移位操作的案例： a * (一个2的幂(n)的数)  =  a &lt;&lt; n; 给出一个指定2的幂的数，怎么算成n,,参照shift的计算方法。 </p>
<p>附上AtomicIntegerArray 源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Written by Doug Lea with assistance from members of JCP JSR-166</span></span><br><span class="line"><span class="comment"> * Expert Group and released to the public domain, as explained at</span></span><br><span class="line"><span class="comment"> * http://creativecommons.org/publicdomain/zero/1.0/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> java.util.concurrent.atomic;</span><br><span class="line"><span class="keyword">import</span> sun.misc.Unsafe;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An &#123;<span class="doctag">@code</span> int&#125; array in which elements may be updated atomically.</span></span><br><span class="line"><span class="comment"> * See the &#123;<span class="doctag">@link</span> java.util.concurrent.atomic&#125; package</span></span><br><span class="line"><span class="comment"> * specification for description of the properties of atomic</span></span><br><span class="line"><span class="comment"> * variables.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArray</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2862133569453604235L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> base = unsafe.arrayBaseOffset(<span class="keyword">int</span>[].class);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> shift;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> scale = unsafe.arrayIndexScale(<span class="keyword">int</span>[].class);</span><br><span class="line">        <span class="keyword">if</span> ((scale &amp; (scale - <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;data type scale not a power of two&quot;</span>);</span><br><span class="line">        shift = <span class="number">31</span> - Integer.numberOfLeadingZeros(scale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkedByteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= array.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">&quot;index &quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> byteOffset(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">byteOffset</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>) i &lt;&lt; shift) + base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray of the given length, with all</span></span><br><span class="line"><span class="comment">     * elements initially zero.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> length the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        array = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new AtomicIntegerArray with the same length as, and</span></span><br><span class="line"><span class="comment">     * all elements copied from, the given array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array the array to copy elements from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if array is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicIntegerArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Visibility guaranteed by final field guarantees</span></span><br><span class="line">        <span class="keyword">this</span>.array = array.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the length of the array.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the length of the array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets the current value at position &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getRaw(checkedByteOffset(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getRaw</span><span class="params">(<span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getIntVolatile(array, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putIntVolatile(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Eventually sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        unsafe.putOrderedInt(array, checkedByteOffset(i), newValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * value and returns the old value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, newValue))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful. False return indicates that</span></span><br><span class="line"><span class="comment">     * the actual value was not equal to the expected value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compareAndSetRaw</span><span class="params">(<span class="keyword">long</span> offset, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(array, offset, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically sets the element at position &#123;<span class="doctag">@code</span> i&#125; to the given</span></span><br><span class="line"><span class="comment">     * updated value if the current value &#123;<span class="doctag">@code</span> ==&#125; the expected value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;May &lt;a href=&quot;package-summary.html#Spurious&quot;&gt;fail spuriously&lt;/a&gt;</span></span><br><span class="line"><span class="comment">     * and does not provide ordering guarantees, so is only rarely an</span></span><br><span class="line"><span class="comment">     * appropriate alternative to &#123;<span class="doctag">@code</span> compareAndSet&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expect the expected value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> update the new value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successful.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">weakCompareAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compareAndSet(i, expect, update);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getAndAdd(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, current + delta))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically decrements by one the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAndGet(i, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically adds the given value to the element at index &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delta the value to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> offset = checkedByteOffset(i);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getRaw(offset);</span><br><span class="line">            <span class="keyword">int</span> next = current + delta;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetRaw(offset, current, next))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the String representation of the current values of array.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the String representation of the current values of array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> iMax = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (iMax == -<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder b = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        b.append(<span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123;</span><br><span class="line">            b.append(getRaw(byteOffset(i)));</span><br><span class="line">            <span class="keyword">if</span> (i == iMax)</span><br><span class="line">                <span class="keyword">return</span> b.append(<span class="string">&#x27;]&#x27;</span>).toString();</span><br><span class="line">            b.append(<span class="string">&#x27;,&#x27;</span>).append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>juc</tag>
      </tags>
  </entry>
  <entry>
    <title>Canal binlog 日志 Dump 流程分析</title>
    <url>/posts/aeb9a46c.html</url>
    <content><![CDATA[<div id="vip-container"><p>Canal 的 dump 支持串行和并行模式两种模式，本篇重点梳理 dump 的核心流程，以便对 dump 过程有一个充分的了解，更好的理解 Canal 的实现原理与细节，下一篇中将重点关注Canal是如何引入并行模式来提高dump的性能，即并行编程相关的技巧。</p>
<p>从前面的文章我们得知 Canal binlog 日志解析的基本流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200809175601739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>解析来重点梳理一下 dump 命令的发送逻辑，特别是日志的处理流程，一些基本的日志格式。</p>
<h2 id="1、-dump-流程分析"><a href="#1、-dump-流程分析" class="headerlink" title="1、 dump 流程分析"></a>1、 dump 流程分析</h2><p>在 Canal 中 dump 方法声明如下：<br><img src="https://img-blog.csdnimg.cn/20200809175612589.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>带有参数 MultiStageCoprocessor 为并行处理模式，底层使用了disruptor 高性能并发框架，下文将重点关注学习。我们今天重点来看一下串行dump的实现，其方法声明如下：<img src="https://img-blog.csdnimg.cn/20200809175625678.png#pic_center" alt="在这里插入图片描述">其方法参数说明如下：</p>
<ul>
<li>String binlogfilename<pre><code> binlog 文件名称，例如  mysql-bin.000038。</code></pre>
</li>
<li>Long binlogPosition<br>在文件中的偏移量。</li>
<li>SinkFunction func<br>每解析出一条binlog日志的处理函数。</li>
</ul>
<p>接下来我们直奔主题，一起来看一下 MysqlConnection 关于 dump 的实现流程。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20200809175645466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step1：在发送dump之前先设置相关的参数。</p>
<ul>
<li>set wait_timeout=9999999<br>连接空闲超时时间，默认为8消息，用于 Canal Slave 的等待超时时间远大于默认值。</li>
<li>set net_write_timeout=1800<br>网络写请求超时时间，针对正在进行数据读写的连接，该值默认为 60s。</li>
<li>set net_read_timeout=1800<br>网络读请求超时时间，针对正在进行数据读写的连接，该值默认为 30s。</li>
<li>set names ‘binary’<br>设置服务端返回结果时不做编码转化，直接按照数据库的二进制编码进行发送，由客户端自己根据需求进行编码转化。</li>
<li>set @master_binlog_checksum= @@global.binlog_checksum<br>设置master_binlog_checksum，因为在mysql5.6之后为binlog引入了checksum机制，例如crc32，canal作为mysql slave，需要与服务端相关参数保持一致。</li>
<li>set @slave_uuid=uuid()<br>canal相对与mysql数据库服务而言就是一个从服务器，这个指令用于设置server_id，使用uuid，避免server_id重复。</li>
<li>SET @master_heartbeat_period=15<br>设置客户端与服务端心跳发送间隔，默认为15s。<br><img src="https://img-blog.csdnimg.cn/20200809175657119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step2：从主库查询binlog checksum，具体向主库发送 select @@global.binlog_checksum 语句。<br><img src="https://img-blog.csdnimg.cn/20200809175707476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step3：向MySQL Master 注册从节点，告知客户端的host、port、用户名与密码、serverId，具体实现是发送命令CODE为 0x15。<br><img src="https://img-blog.csdnimg.cn/20200809175717357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step4：向 MySQL Master 发送 dump 请求，MySQL是基于请求与应答模式，发送请求命令后，就会向网络通道中写入响应请求。（在这里大家不妨先大概思考一下如何读取 dump 命令的返回值，这部分虽然涉及到网络相关的知识，我在这边会稍微简单提一下）。<br><img src="https://img-blog.csdnimg.cn/20200809175726519.png#pic_center" alt="MysqlConnection#dump"><br>Step5：构建 DirectLogFetcher对象，实现基于 socket 的日志拉取服务，并构建 LogDecoder 对象，用于解析 binlog 日志。<br><img src="https://img-blog.csdnimg.cn/20200809175748490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlConnection#dump"><br>Step6：使用 while 循环反复拉取消息，通过通过 LogDecoder 对二进制流进行解析，提取一条完整的binlog事件，交给 SinkFunction 去处理，并且如果开启了半同步机制，则需要向master发送ACK。既然是while循环，该方法的退出条件还是值的我们关注的：</li>
<li>fetch.fetch()方法返回 false</li>
<li>SinkFunction 的 sink 方法 false，SinkFunction的详细处理流程将在下文介绍，这里先告知返回false的情况是 binlog 日志解析线程已停止运行。</li>
</ul>
<p>上面粗略的介绍了 dump 命令的几个核心关键步骤，要想详细掌握其实现细节，我们必须继续深入探讨如下几个问题：</p>
<ul>
<li>DirectLogFetcher 内部工作机制</li>
<li>LogDecoder binlog 日志解析</li>
<li>发送Dump底层网实现思路</li>
</ul>
<h2 id="2、DirectLogFetcher-内部工作机制"><a href="#2、DirectLogFetcher-内部工作机制" class="headerlink" title="2、DirectLogFetcher 内部工作机制"></a>2、DirectLogFetcher 内部工作机制</h2><h4 id="2-1-DirectLogFetcher-类图"><a href="#2-1-DirectLogFetcher-类图" class="headerlink" title="2.1 DirectLogFetcher 类图"></a>2.1 DirectLogFetcher 类图</h4><p><img src="https://img-blog.csdnimg.cn/20200809175803860.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>DirectLogFetcher的类继承体系如上图所示，我们来看一下其关键点：</p>
<ul>
<li>LogBuffer<br>日志buffer，主要定义如下属性：</li>
<li>byte[] buffer<br>缓存区中数据容器。</li>
<li>int origin<br>当前buffer中的读指针</li>
<li>int limit<br>当前buffer的最大可读可写指针</li>
<li>int position<br>当前buffer的写指针。</li>
<li>int semival<br>是否需要发送ACK(用于半同步)。<br>LogBuffer封装了字节相关的操作，不仅定义了上面的属性，也定义了字节读取相关众多API，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20200809175816470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li>
<li>LogFetcher<br>binlog日志抓取抽象类，定义了如下关键属性与抽象方法。<ul>
<li>int DEFAULT_INITIAL_CAPACITY<br>LogBuffer中的初始容量，默认为8K。</li>
<li>float DEFAULT_GROWTH_FACTOR<br>容量增长因子，默认为 2.0。</li>
<li>int   BIN_LOG_HEADER_SIZE<br>binlog日志条目 header 的长度，固定为4字节。</li>
<li>float  factor<br>  增长因子。</li>
<li>public abstract boolean fetch()<br>抓取binlog日志。</li>
<li>public abstract void close() <pre><code>    关闭 Fetch。</code></pre>
</li>
</ul>
</li>
<li>DirectLogFetcher<br>Canal LogFetcher模式实现类，其核心属性如下：<ul>
<li>SocketChannel channel<br>网络通道，用于发送dump请求的网络通道。</li>
<li>boolean issemi = false<br>是否开启半同步。</li>
</ul>
</li>
</ul>
<h4 id="2-2-fetch流程详解"><a href="#2-2-fetch流程详解" class="headerlink" title="2.2 fetch流程详解"></a>2.2 fetch流程详解</h4><p>接下来我们重点剖析 DirectLogFetcher 的 fetch 方法，来探究其实现原理。<br>在研究DirectLogFetcher的fetch方法之前，我们先重点跟踪一下其内部网络读写方法fetch0方法，该方法是具体与网络读写相关的实现。<br><img src="https://img-blog.csdnimg.cn/20200809175830366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch0"><br>在详细介绍该方法之前先来介绍一下其参数的含义：</p>
<ul>
<li>int off<br>从通道中读取到的内容放入到buffer中的起始位置</li>
<li>int len<br>期望从通道中读取的字节长度。</li>
</ul>
<p>该方法的实现关键点如下：</p>
<ul>
<li>首先先确保接收缓存区有足够的剩余空间，如果空间不足，则进行扩容。</li>
<li>然后从通道中读取指定长度的字节。</li>
</ul>
<p>接下来我们来重点看一下DirectLogFetcher的fetch的实现流程。<br><img src="https://img-blog.csdnimg.cn/20200809175842606.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch"><br>Step1：尝试从网络通道中读取４个字节（即读取协议的头部），如果通道中还没有可读取内容，返回false，造成的效果是一次 dump 请求结束。<br><img src="https://img-blog.csdnimg.cn/202008091758523.png#pic_center" alt="DirectLogFetcher#fetch"><br>Step2：从上文读到的４个字节分别读出该网络包的总长度以及当前包的序号，从这里可以看成MySQL协议头为４字节，前３个字节为网络包的总长度，第４个字节为包的序列号。再取出数据包的长度后，继续向通道中读取netlen个字节，即读取一个完整的数据包到buffer中。<br><img src="https://img-blog.csdnimg.cn/2020080917590177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch"><br>Step3：继续从数据包中读取一个字节，判断该包的状态码，是否是一个成功的响应，如果是错误的响应，会向外抛出一次，Canal 会记录dump命令执行错误的次数。<br><img src="https://img-blog.csdnimg.cn/20200809175910291.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="DirectLogFetcher#fetch"><br>Step４：如果一个包的长度为允许的最大包长度，则继续读取，这个主要是根据MySQL协议做的处理，即读取到一个数据包，然后返回true，表示拉取到一条日志，然后通过LogDecoder解码，然后传入到sink方法中，进行日志的后续处理。<br><img src="https://img-blog.csdnimg.cn/2020080917592088.png#pic_center" alt="DirectLogFetcher#fetch"><br>Step5：这一步的目的，就是将buffer中的当前指针指向数据的开始位置。这样一次 fetch就结束了。</p>
<p>从上面的流程来看，DirectLogFetcher#fetch 方法结束后，就将进入到LogDecoder中。经过一次DirectLogFetcher#fetch方法后，即取回一条binlog日志，即二进制流，接下来就根据binlog协议对其解析。本文暂不深入该方法，如果大家想深入数据库中间件方面，可以作为一个很好的示例，面向MySQL通信协议进行编程。</p>
<h2 id="３、SinkFunction"><a href="#３、SinkFunction" class="headerlink" title="３、SinkFunction"></a>３、SinkFunction</h2><p>通过 LogDecoder从中解析一个事件后，会调用SinkFunction的sink方法，如果该方法返回 false，一次dump请求将介绍，接下来我们看一下其sink方法。<br><img src="https://img-blog.csdnimg.cn/20200809175932873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="AbstractEventParser＃start"><br>该方法的实现比较简单，这里不打算继续深入，我们重点来看一下 Canal.Entry 的结构：<br><img src="https://img-blog.csdnimg.cn/20200809175945791.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这个结构是基于Canal做架构设计，解决顺序消费、数据不丢失一个重要参考依据，没解析一条事务，最终放如到环形缓存区，环形缓存区尽量以一个事务提交到Sink组件，其代码如下：<br><img src="https://img-blog.csdnimg.cn/20200809175956839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里主要有如下几个关键点：</p>
<ul>
<li>首先需要调用EventSink组件将解析出来的数据传入EventSink。</li>
<li>EventSink组件处理成功后，会提交解析位点。</li>
</ul>
<p>本文就介绍到这里了，Dump的流程就分析到这里了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
        <tag>dump</tag>
        <tag>binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>Canal binlog 日志管理器与GTID简介</title>
    <url>/posts/f051946a.html</url>
    <content><![CDATA[<div id="vip-container"><p>正如上文提到的那样，在 Canal Instance 启动的时候，首先会查询日志管理器中查找上一次的同步位点，如果没有查询到，则默认会从最新的位点开始同步，但如果每一次启动Instance都从最后开始同步，其数据完整性无法保证，正确的做法是在数据同步的过程中应该记录位点并持久化，重新启动后按照继续从上一次的位置继续同步，实现真正的增量同步。</p>
<p>本文就是来详细探讨 Canal的几个日志管理器，并来探究一下MySQL的GTID机制。</p>
<a id="more"></a>

<h2 id="1、Canal-位点管理（日志管理器）"><a href="#1、Canal-位点管理（日志管理器）" class="headerlink" title="1、Canal 位点管理（日志管理器）"></a>1、Canal 位点管理（日志管理器）</h2><h3 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20200726150555918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>整个日志管理器由接口 CanalLogPositionManager定义，主要定义两个方法：</p>
<ul>
<li>LogPosition getLatestIndexBy(String destination)<br>根据destination获取同步位点，即在Canal Instance 中同步进度是以源实例为最小维度的。</li>
<li>void persistLogPosition(String destination, LogPosition logPosition)<br>持久化同步位点。</li>
</ul>
<p>Canal 中提供了7种位点管理机制，分别如下：</p>
<ul>
<li>MemoryLogPositionManager<br>同步位点存储在内存中，即存放在 Map&lt;String, LogPosition&gt; positions 中，通常用于测试或结合其他位点管理，用来提高性能。</li>
<li>ZooKeeperLogPositionManager<br>同步位点存储在zookeeper中，是主流的分布式存储方案。</li>
<li>MetaLogPositionManager<br>Canal中的元数据存储方式，即位点信息与元数据存放在一起。</li>
<li>MixedLogPositionManager<br>混合日志位点管理器，主要是内存与Zookeeper的混合方式，在存储位点时先存入内存，然后用线程池异步存储到zookeeper中。</li>
<li>FileMixedLogPositionManager<br>基于内存与本地文件的混合日志管理器，存储位点时首先存入内存，然后定时同步到文件中。</li>
<li>PeriodMixedLogPositionManager<br>带定时功能的基于内存与zookeeper的混合日志管理器，存储位点时先写入内存，然后定时同步到zookeeper。</li>
<li>FailbackLogPositionManager<br>待failback机制的日志位点管理器，即可以创建准备两种日志管理器，例如在构建时可以将 ZooKeeperLogPositionManager 当为主管理器，基于 FileMixedLogPositionManager 当备用日志位点管理器，在写入日志位点时，尝试写入主日志管理器，如果抛出异常，则使用备用日志管理器；查询位点时先查主日志<br>管理器，如果未查到，则查备用日志管理器。</li>
</ul>
<h3 id="1-2-日志管理器使用方法"><a href="#1-2-日志管理器使用方法" class="headerlink" title="1.2 日志管理器使用方法"></a>1.2 日志管理器使用方法</h3><p>由于Canal日志管理器的实现比较简单，这里就不一一去看源码了，那这里就重点介绍一下其使用方法。</p>
<p>CanalInstanceWithManager#initLogPositionManager<br><img src="https://img-blog.csdnimg.cn/2020072615072310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">从这里可以看到，Canal 提供了 indexMode 属性来指定使用哪种日志管理器，其可选项：</p>
<ul>
<li>MEMORY<br>内存</li>
<li>ZOOKEEPER<br>基于zookeeper，使用该模式还需要通过 zkClusters 设置 zk 集群的地址。</li>
<li>MIXED<br>混合模式，基于内存+Zookeeper + Period，即定时存储到 zookeeper 中，使用的实现类为MixedLogPositionManager，默认为每隔1s持久化一次。</li>
<li>META<br>基于元数据的管理模式。</li>
<li>MEMORY_META_FAILBACK<br>基于内存与元数据的fallback，其中主日志管理器为 MEMORY。</li>
</ul>
<blockquote>
<p>在生产环境，通常建议使用 MIXED，基于内存与Zookeeper的混合模式。</p>
</blockquote>
<h2 id="2、MySQL-GTID-扫盲"><a href="#2、MySQL-GTID-扫盲" class="headerlink" title="2、MySQL GTID 扫盲"></a>2、MySQL GTID 扫盲</h2><p>在MySQL5.6.x中引入了GTID机制，用于优化主从同步机制，本文不打算详细介绍GTID的方方面面，只是初步认识GTID，方面在后续实现数据同步方面思考数据一致性如何保证等方案时具备必要的基础。</p>
<p>首先我们可以通过如下命令查看与gtid相关的属性。<br><img src="https://img-blog.csdnimg.cn/20200726150842239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>主要的变量的含义如下：</p>
<ul>
<li>gtid_executed<br>当前MySQL实现已经执行过的事务。在开启GTID模块时每执行一个事务会产生一个全局唯一的事务ID。再每一台MySQL实例上执行的事务何止上亿，这个字段要存储所有已执行的的事务ID，怎么存储能节省空间就是一个需要解决的问题，稍后再进行展开说明。</li>
<li>gtid_executed_compression_period<pre><code> 在MySQL5.7版本专门引入了一个系统表：mysql.gtid_executed，gtid_executed_compression_period 参数就是设置每执行多个事务，对这个表进行压缩，默认值为1000。</code></pre>
</li>
<li>gtid_mode<br>是否开启gtid模式。</li>
<li>gtid_purged<br>已不在binlog日志中的事务ID，Mysql并不会永久存储binlog日志，而是通过 expire_logs_days 设置过期时间，单位为天，默认为10天。</li>
</ul>
<p>一个GTID由两部分组成：server id uuid 与递增序号，两者之间用英文冒号隔开，例如上图中的：1f0eee4c-a66e-11ea-8999-00dbdfe417b8:1。</p>
<p>再来回到 gtid_executed 的存储问题上，为了减少存储空间，连续的gtid可以用进行合并，例如  1f0eee4c-a66e-11ea-8999-00dbdfe417b8:1-10，表示连续代表1-10个事务。</p>
<p>GTID的生成有自动递增与手动执行模式，自动递增模式可以在单个Server集群中保证有序，即GTID值越大，说明事务越后执行，但如果进行了人工干预，GTID就不是越大越先执行了，举例如下：<br><img src="https://img-blog.csdnimg.cn/20200726150942999.png#pic_center" alt="在这里插入图片描述"><br>通过如下命令手动指定gtid：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set gtid_next&#x3D;&#39;1f0eee4c-a66e-11ea-8999-00dbdfe417b8:10&#39;;</span><br><span class="line">begin;</span><br><span class="line">commit;</span><br><span class="line">set gtid_next&#x3D;&#39;AUTOMATIC&#39;;</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20200726151133619.png#pic_center" alt="在这里插入图片描述"><br>故这里产生了另外一个事件，其gtid 为 10,下一条语句产生的GTID会是 11 还是 4 呢？<br><img src="https://img-blog.csdnimg.cn/20200726151150175.png#pic_center" alt="在这里插入图片描述"><br>从这里看成，会先使用空洞，其binlog记录如下。<br><img src="https://img-blog.csdnimg.cn/20200726151203444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从这里看出，在后续避免数据顺序性方面，使用GTID并不是一个十全的方法，基于binlog的写入时间更为靠谱。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
        <tag>binlog</tag>
        <tag>gtid</tag>
      </tags>
  </entry>
  <entry>
    <title>Canal 初次启动时如何定位同步位点(文末附流程图)</title>
    <url>/posts/dcbc2c14.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将详细剖析Canal在初次启动时如何定位同步位点，行为思路先源码，再辅以流程图进行说明，并在总结部分使用思维导图进行总结，试图引发各位的讨论。</p>
<h2 id="1、Canal定位启动位点"><a href="#1、Canal定位启动位点" class="headerlink" title="1、Canal定位启动位点"></a>1、Canal定位启动位点</h2><p>在一个 Canal Instance 实例启动时，在向 MySQL 发送 dump 命令之前，首先先得计算该从 binlog 的什么位置开始同步，初次启动时如何寻找位点等。其代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200719150553488.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="AbstractEventParser#start"><br>从这里可以看成，将调用 findStartPosition 方法查找启动时需要从那个位置开始同步 binglog ,该方法是一个抽象方法，具体实现在其子类中，我们将重点关注一下其子类 MysqlEventParser。<br><img src="https://img-blog.csdnimg.cn/20200719150633861.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPostion"><br>在MySQL中定位binlog日志可以分为gtid、binlog文件名+position两种方式，故Canal查找position的方式也分两种情况进行展开，由于篇幅问题，本节将暂不考虑gtid。</p>
<p>这里主要是调用 findStartPositionInternal 方法进行查找位点，这里还有一个标记 needTransactionPosition，表示查出来的位点是不是一个事务的开始或结束。</p>
<p>接下来重点探讨 Canal在启动时如何定位解析位点的。</p>
<a id="more"></a>

<h4 id="1-1-查找位点"><a href="#1-1-查找位点" class="headerlink" title="1.1 查找位点"></a>1.1 查找位点</h4><p><img src="https://img-blog.csdnimg.cn/20200719150704437.png#pic_center" alt="MysqlEventParser#findStartPositionInternal"><br>Step1：使用位点存储管理器中查看已解析过的位点数据，Canal 提供了多种日志管理实现，这部分稍后会详细展开。<br><img src="https://img-blog.csdnimg.cn/20200719150726743.png#pic_center" alt="MysqlEventParser#findStartPositionInternal">Step2：这里分如下两种情况</p>
<ul>
<li>如果日志位点管理器(LogPositionManager)中并未存储相关的位点信息，例如初次启动时的处理逻辑。</li>
<li>如果日志位点管理器中已存储相关的位点信息的处理逻辑。</li>
</ul>
<p>由于初次启动时日志位点管理器并没有存储其位点信息，故我们先看位点管理器并未存储位点的情况。<br><img src="https://img-blog.csdnimg.cn/20200719150813198.png#pic_center" alt="MysqlEventParser#findStartPositionInternal"><br>Step3：如果当前连接的是主节点，则尝试使用 masterPosition，如果当前连接的是从节点（发生了切换），即使用 standbyPosition，那这两个位点信息是从哪来的的呢？原来在 Canal Instance 实例启动之前，可以手动通过 positions 属性手动设置开始解析位点。<br><img src="https://img-blog.csdnimg.cn/20200719150831508.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPositionInternal">Step4：如果在启动时未手动设置初始解析位点，则从当前 binlog 日志最后的位点开始同步，其实现原理是向 MySQL 服务器发送 show master status\G 命令，其命令输出结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200719150856825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center"><br>接下来再关注一下如果从日志位点管理器中查找到位点的处理逻辑，在进入该流程的探究之前，先看一下表示位点的实体类，一睹其结构。<br><img src="https://img-blog.csdnimg.cn/20200719150911285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>会在 LogIdentity 中记录该日志位点是由哪个 slaveId 以及所连接的 MySQL 服务器信息。<br><img src="https://img-blog.csdnimg.cn/20200719150952220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPositionInternal"><br>Step5：如果从日志位点管理器中查询到位点，则需要判断当前连接的服务器地址与日志位点中记录的是否一致，如果不一致则说明发生了故障切换，为了确保数据不丢失，提供了回退时间的机制，其具体实现关键点如下：</p>
<ul>
<li>如果解析 dump 出现的次数超过其阔值，可能是基于VIP模式发生了漂移，此时可以根据 serverId 来判断是否发生了切换，如何切换了，则按时间回退来重新寻找位点。</li>
<li>如果查找到的位点连接的信息与当前连接的信息不符合，说明发生了切换，则需要回退指定的时间，即根据时间区重新定位位点，至于回退多久的时间，可以通过参数 fallbackIntervalInSeconds 进行设置，默认为 60s。</li>
</ul>
<p>Canal Instance 启动时如何定位同步位点的流程就介绍到这里了，接下来我们再来看一下 Canal 如何基于时间戳来定位 binlog 位点。</p>
<p>为了流程的完整性，在学习如何根据时间戳查找binlog位点之前，我们先来看一下从位点管理器中查询到对应的位点信息后的处理流程。<br><img src="https://img-blog.csdnimg.cn/2020071915102882.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findStartPositionInternal">如果从位点管理器中查询到位点信息，首先判断当前连接的MySQL服务器(主或从)与位点信息是否一致，如果不一致，说明发生了主从切换，为了保证数据的完整性，需要对位点进行前移，默认为回退到60s之前的位点，</p>
<h4 id="1-2-基于时间戳从查找-binlog-位点"><a href="#1-2-基于时间戳从查找-binlog-位点" class="headerlink" title="1.2 基于时间戳从查找 binlog 位点"></a>1.2 基于时间戳从查找 binlog 位点</h4><p>基于时间戳查找 binlog 位点的实现方法为 MysqlEventParser 的　findByStartTimeStamp，接下来我们来看一下其实现原理。<br><img src="https://img-blog.csdnimg.cn/2020071915111442.png#pic_center" alt="MysqlEventParser#findByStartTimeStamp"><br>Step1：首先先查询最大的位点与最小位点，最小位点可发送SQL：show binlog events limit 1。<br><img src="https://img-blog.csdnimg.cn/2020071915113412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findByStartTimeStamp"><br>Step2：然后从最后一个文件开始，尝试根据开始时间戳进行日志查找，等下会详细介绍如果从一个binlog日志定位 endposition。<br><img src="https://img-blog.csdnimg.cn/2020071915115830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findByStartTimeStamp"><br>Step3：如果找到一个合适的endposition，则结束寻找。如果没有找到一个合适的endposition，则尝试向前一个文件进行解析，首先解析出要查找的最小文件的名称，例如(mysql-bin.000036)，从文件名称序号，然后减1，再判断该文件名是否小于这次可查找的最小文件名，如果不大于，则向前继续选择，否则结束查找，返回null。</p>
<p>接下来我们看一下如果在一个binlog文件中根据时间戳查找合适的位点。<br><img src="https://img-blog.csdnimg.cn/20200719152049556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="MysqlEventParser#findAsPerTimestampInSpecificLogFile"><br>通过向 MySQL Master 发送 dump 命令，建立连接，一条一条从 binlog 日志中解析事件，一条日志日志进行匹配，每从master获取一个logevent，调用 SinkFunction 的 seek 方法。<br><img src="https://img-blog.csdnimg.cn/20200719152108279.png#pic_center" alt="在这里插入图片描述"><br>Step1：如果 justForPositionTimestamp 参数为 true，表示在查询位点时只考虑时间戳，并不考虑事务，在按开始时间戳寻找的方法中该参数为 false，即不会进入该方法。<br><img src="https://img-blog.csdnimg.cn/20200719151412889.png#pic_center" alt="SinkFunction#sink"><br>Step2：获取当前日志的基本信息，例如所在的binlog日志文件、日志偏移量、日志写入时间戳、master serverId。<br><img src="https://img-blog.csdnimg.cn/2020071915143632.png#pic_center" alt="SinkFunction#sink"><br>Step3：如果记录日志的时间戳大于等于待查找的时间戳，返回 false，停止在文件中的停止，是否继续查找其他文件取决在在当前文件中是否已查到符合条件的日志(LogEvent)，即是否查找到小于或等于要查找的时间戳。</p>
<blockquote>
<p>温馨提示：按照时间戳去查找，其设计理念就是查找小于待查找时间戳中的最大时间戳的LogEvent。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200719151456693.png#pic_center" alt="SinkFunction#sink"><br>Step4：如果当前的解析的日志偏移量小于此次待查找的最大偏移量，同样结束本文件的查找（针对查找的第一个文件）。因为在查询的时候，首先会查询当前最大偏移量，即查找时的快照，新的内容不在本次查找范围内。<br><img src="https://img-blog.csdnimg.cn/20200719152416688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step5：重点查找事件类型为TRANSACTIONEND与TRANSACTIONBEGIN ，即事务结束与事务开始的事件，并将其存储在 logPostion 中，表示该文件中满足查找条件的事件，但并不是只要找到一条就退出，而是继续向后找，直到找到最合适的事件。</p>
<p>由于源码剖析不够直观，为了更好的理解按照时间戳查找日志位点，再给出其流程图，如下：<br><img src="https://img-blog.csdnimg.cn/20200719152451570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h2><p>阅读源码不那么直观，故先来一张流程图对其进行一个总结，辅助大家了解定位位点的核心步骤。<br><img src="https://img-blog.csdnimg.cn/20200719152508266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
      </tags>
  </entry>
  <entry>
    <title>Canal 如何实现数据库库事务的一致性</title>
    <url>/posts/d0c99696.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将主要介绍在 EventParser binlog 日志同步流程中关于环形缓存区的使用技巧。</p>
<h2 id="1、环形缓存区"><a href="#1、环形缓存区" class="headerlink" title="1、环形缓存区"></a>1、环形缓存区</h2><p>关系型数据库讲究的是ACID 4个特性，故引入了数据库事务的概念，一个数据库事务中的多条SQL引发的多条数据变更要么全部成功，要么全部失败，即数据的一致性，那同样在数据同步的场景，在解析一个事务的 binlog 日志时，一次数据同步应该至少以事务为单位，一个事务内的所有 Event 应该作为一个批次提交到数据消费端，让消费端有能力一次同步一个事务中的数据，而不是一条一条变更日志的处理，这样容易造成数据不一致。</p>
<p>环形缓存区的引用就是为了解决将一个事务的完整数据一次提交到消费端，既然是多条消息，故一定需要用到缓存，环形缓存区就在这样的背景下被引入。</p>
<p>在 Canal 中关于事务 Event 的环形缓存区实现类为 EventTransactionBuffer。</p>
<a id="more"></a>

<h4 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h4><p>EventTransactionBuffer 的类图如下：<br><img src="https://img-blog.csdnimg.cn/2020071215153646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>根据类图我们可以到其存储结构还是比较简单的。</p>
<ul>
<li>int bufferSize环形缓存区的长度，默认为 1024，该长度必须为 2 的幂次方，因为对位运算非常友好。</li>
<li>int indexMask环形缓存区下标掩码，其值为 bufferSize - 1 ，sequence * indexMask 能快速定位序号 sequence 所在环形缓存区中的具体下标。</li>
<li>CannalEntry.Entry[] entries环形缓存区数据数组，即缓存区实际存储数据的内存区域，为数组结构，长度为 bufferSize。</li>
<li>AtomicLong putSequence当前写入的序号，每调用 add 方法添加一条数据，该值增加一，可超过缓存区的实际长度。</li>
<li>AtomicLong flushSequence当前已处理的数据序号，flushSequence &lt;= putSequence，（putSequence - flushSequence）表示未处理的数据，即缓存区累积的有效数据。</li>
<li>TransactionFlushCallback flushCallbackflush 回调函数，这个和环形缓存区本身关系不大，这个与 Canal 特定业务的，环形缓存区中收集到一个完整的事务变更日志列表后，将这部分内容传入业务回调方法，并重新利用这些缓存空间。</li>
</ul>
<p><strong>环形缓存区的重大要义就是循环利用。</strong></p>
<h4 id="1-2-环形缓存区存储实现"><a href="#1-2-环形缓存区存储实现" class="headerlink" title="1.2 环形缓存区存储实现"></a>1.2 环形缓存区存储实现</h4><p>接下来我们通过其 add 方法来看一下环形缓存区的，在研究环形缓存区之前，将结合8个元素的环形缓存区进行讲解。<br><img src="https://img-blog.csdnimg.cn/20200712151715438.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>EventTransactionBuffer 的 add 方法代码如下：<br><img src="https://img-blog.csdnimg.cn/20200712151726412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先根据 binlog 事件类型来决定是否调用 flush 方法，这个就是实现将一个事务的事务一起提交到消费端，回到环形缓存区的具体实现，我们重点关注 put 方法 与 flush 方法的实现。<br>EventTransactionBuffer#put<br><img src="https://img-blog.csdnimg.cn/20200712152102435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其实现的核心步骤：</p>
<ol>
<li><p>检测当前环形缓存区是否已满，如果未满，则向缓存区中添加一条数据。添加数据的具体逻辑：</p>
<ul>
<li><p>获取下一个写入的序号 next，等于当前已写入的序号 + 1，即 putSequence + 1。</p>
</li>
<li><p>通过 next &amp; indexMask 取得放入 CannalEntry.Entry[] entries 中的下标，与 next % bufferSize 效果等同。</p>
</li>
</ul>
</li>
<li><p>如果已满，则首先将缓存区中的数据刷新，即将未处理的数据全部抽取，提交到数据消费方，然后释放缓存区，继续添加数据。</p>
</li>
</ol>
<p>关键在于如何判断环形缓存区已满，具体算法如下：<br>EventTransactionBuffer#checkFreeSlotAt<br><img src="https://img-blog.csdnimg.cn/20200712152142683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为了加强对这段代码的理解，我举一个示例，在一个8个元素的环形缓存区中，假设一个事务包含5条日志，首先依次写入5条日志，其环形缓存区如下：<br><img src="https://img-blog.csdnimg.cn/20200712152158449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时 putSequence 为 4，flushSequence 为 -1 ，我们应该能发现，在第一轮时，由于 sequeue 小于 bufferSize ，如果不执行 flush 操作，连续写入 8条数据，sequence = 7 时，sequence - bufferSize &gt; flushSequence 这个表达式都不会满足，即代表缓存区未满，但在写入第9条消息时，sequence = 8 ，此时 sequence - bufferSize &gt; flushSequence 已满足，即缓存区已满，需要先刷新数据，然后才能再填充。</p>
<p>再回到本示例中，一个事务只包含5条日志，在写满 5条日志后会即调用 flush 方法，将环形缓存区中下标为 0~4 的消息传入数据消费方，在 Canal 中会将这批消息一次传入 EventSink 组件。执行完 flush 方法后，flushSequence 等于4，其环形缓存区如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200712152209765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>此时 putSequence = flushSequence = 4，那这个时候环形缓存区的容量是多少呢？其实就是又恢复到 bufferSize 了，那我们怎么计算环形缓存区当前已写入的消息呢？其实很简单，putSequence - flushSequence 表示已写入的元素数量。那当前剩余容量就等于 bufferSize - (putSequence - flushSequence )，即只需要 bufferSize - (putSequence - flushSequence ) &gt; 0 就表示有剩余空闲。有了这一层思路，就能明白 checkFreeSlotAt 的算法，这也是环形缓存区的核心所在。</p>
<blockquote>
<p>思考，Canal 基于环形缓存区的实现，一定能保证一个事务的所有变更日志都一次提交到 EventSink 组件吗，大家可以简单思考一下，在文末的总结部分有笔者的思考。</p>
</blockquote>
<p>答案是否定的，如果一个事务包含的日志条目超过了环形缓存区的长度，为了保证数据不丢失，会首先将环形缓存区的数据全部提交，然后接收新的数据，这样一个事务中的消息会被分成多次提交到 EventSink。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
        <tag>事务的一致性</tag>
        <tag>环形缓存区</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo Filter机制概述</title>
    <url>/posts/a061d56c.html</url>
    <content><![CDATA[<div id="vip-container"><p>从上文可知，在服务的调用或消费端发送请求命令中，Dubbo引入过滤器链机制来实现功能的包装（或扩展）。Dubbo很多功能，例如泛化调用、并发控制等都是基于Filter机制实现的，系统默认的Filter在/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中定义，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo&#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter</span><br><span class="line">generic&#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter</span><br><span class="line">genericimpl&#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter</span><br><span class="line">token&#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter</span><br><span class="line">accesslog&#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter</span><br><span class="line">activelimit&#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span><br><span class="line">classloader&#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</span><br><span class="line">context&#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter</span><br><span class="line">consumercontext&#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter</span><br><span class="line">exception&#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br><span class="line">executelimit&#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span><br><span class="line">deprecated&#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter</span><br><span class="line">compatible&#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter</span><br><span class="line">timeout&#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter</span><br></pre></td></tr></table></figure>
<p>以其中一个来说明一下Filter的定义要素：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * EchoInvokerFilter</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Activate(group &#x3D; Constants.PROVIDER, order &#x3D; -110000)    &#x2F;&#x2F; @2</span><br><span class="line">public class EchoFilter implements Filter &#123;                                 &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        if (inv.getMethodName().equals(Constants.$ECHO) &amp;&amp; inv.getArguments() !&#x3D; null &amp;&amp; inv.getArguments().length &#x3D;&#x3D; 1)</span><br><span class="line">            return new RpcResult(inv.getArguments()[0]);</span><br><span class="line">        return invoker.invoke(inv);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：实现com.alibaba.dubbo.rpc.Filter接口。</p>
<p>代码@2：添加Activate，其注解含义如下：</p>
<ul>
<li><p>group： 所属组，String[],例如消费端、服务端。<br>value String[]，如果指定该值，只有当消费者或服务提供者URL中包含属性名为value的键值对，该过滤器才处于激活状态。</p>
</li>
<li><p>before：String[]，用于指定执行顺序，before指定的过滤器在该过滤器之前执行。</p>
</li>
<li><p>after：string[]，用于指定执行顺序，after指定的过滤器在该过滤器之后执行。</p>
</li>
<li><p>order：用户指定顺序，值越小，越先执行。<br>除了支持默认的过滤器外，Dubbo还支持自定义Filter，可以通过service.filter指定过滤器，多个用英文逗号隔开，其配置方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:service ......&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:service&gt;</span><br></pre></td></tr></table></figure>

<p>当然，可以为所有服务提供者设置共用过滤器，其指定方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dubbo:provider ...&gt;</span><br><span class="line">  &lt;dubbo:parameter key &#x3D; &quot;service.filter&quot; value &#x3D; &quot;filter1,filer2,...&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;dubbo:provider&gt;</span><br></pre></td></tr></table></figure>

<p>消费端自定义过滤器的key为reference.filter，其使用方法在&lt; dubbo:reference/&gt;标签或&lt; dubbo:consumer/&gt;标签下定义属性。关于自定义Filter的解析代码如下：<br>ExtensionLoader#getActivateExtension</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String key, String group) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        String value &#x3D; url.getParameter(key);                                                 &#x2F;&#x2F; @2</span><br><span class="line">        return getActivateExtension(url, value &#x3D;&#x3D; null || value.length() &#x3D;&#x3D; 0 ? null : Constants.COMMA_SPLIT_PATTERN.split(value), group);    &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数说明。</p>
<ul>
<li>URL url：服务提供者或服务消费者url。</li>
<li>String key：过滤器属性key，服务提供者固定为:service.filter，服务消费者固定为reference.filter。</li>
<li>String group：服务提供者或服务消费者。</li>
</ul>
<p>代码@2：从url中获取配置的自定义filter。</p>
<p>代码@3：如果value不为空，则将字符串调用split转换为数组，然后调用getActivateExtension方法，获取符合条件的过滤器。</p>
<p>ExtensionLoader#getActivateExtension</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;T&gt; getActivateExtension(URL url, String[] values, String group) &#123;</span><br><span class="line">        List&lt;T&gt; exts &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        List&lt;String&gt; names &#x3D; values &#x3D;&#x3D; null ? new ArrayList&lt;String&gt;(0) : Arrays.asList(values);</span><br><span class="line">        if (!names.contains(Constants.REMOVE_VALUE_PREFIX + Constants.DEFAULT_KEY)) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">            getExtensionClasses();                                                                                                            &#x2F;&#x2F; @2</span><br><span class="line">            for (Map.Entry&lt;String, Activate&gt; entry : cachedActivates.entrySet()) &#123;</span><br><span class="line">                String name &#x3D; entry.getKey();</span><br><span class="line">                Activate activate &#x3D; entry.getValue();</span><br><span class="line">                if (isMatchGroup(group, activate.group())) &#123;                                                                        &#x2F;&#x2F; @3</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    if (!names.contains(name)</span><br><span class="line">                            &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)                    &#x2F;&#x2F; @4      </span><br><span class="line">                            &amp;&amp; isActive(activate, url)) &#123;                                                                                      &#x2F;&#x2F; @5</span><br><span class="line">                        exts.add(ext);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Collections.sort(exts, ActivateComparator.COMPARATOR);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;T&gt; usrs &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; names.size(); i++) &#123;                                                                                           &#x2F;&#x2F; @6</span><br><span class="line">            String name &#x3D; names.get(i);</span><br><span class="line">            if (!name.startsWith(Constants.REMOVE_VALUE_PREFIX)</span><br><span class="line">                    &amp;&amp; !names.contains(Constants.REMOVE_VALUE_PREFIX + name)) &#123;</span><br><span class="line">                if (Constants.DEFAULT_KEY.equals(name)) &#123;</span><br><span class="line">                    if (!usrs.isEmpty()) &#123;</span><br><span class="line">                        exts.addAll(0, usrs);</span><br><span class="line">                        usrs.clear();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    T ext &#x3D; getExtension(name);</span><br><span class="line">                    usrs.add(ext);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!usrs.isEmpty()) &#123;</span><br><span class="line">            exts.addAll(usrs);</span><br><span class="line">        &#125;</span><br><span class="line">        return exts;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果配置的service.filter或referecnce.filter包含了-default，表示禁用系统默认提供的一系列过滤器。</p>
<p>代码@2：如果不禁用系统默认过滤器链，则首先加载所有默认过滤器。</p>
<p>代码@3：根据group刷选出适配的过滤器。</p>
<p>代码@4：也可以对单个filter进行禁用，其方法是-过滤器名称的方式。例如如想禁用AccessLogFilter，则可以通过-accesslog方式禁用。-key,key为/dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中定义的key。</p>
<p>代码@5：判断过滤器是否激活，其逻辑是如果Filter上的@Activate注解value值不为空，则需要判断url中是否包含键为value的属性对，存在则启用，不存在则不启用。</p>
<p>代码@6：加载用户自定义的Filter，也即是service.filter或reference.filter指定的过滤器。<br>综上所述，Dubbo提供了过滤器机制，在真实服务被调用前提供扩展点。Filter机制就简单介绍到这里了，从下文开始会重点分析Dubbo服务提供的核心Filter。</p>
<p>如果需要自定过滤器，需要在自定的工程中META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter文件中注册。</p>
<p>本文就介绍到这里了，从下篇开始将会根据Dubbo的功能特性来详细分析其实现过程，其本质都是各种Dubbo 过滤器器。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>Filter</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo路由机制概述</title>
    <url>/posts/9d847bb5.html</url>
    <content><![CDATA[<div id="vip-container"><p>上一节我们主要讲解了利用dubbo-admin如何进行参数的动态修改，本节将重点介绍集群实现中另外一个实现细节：路由机制，Dubbo的路由机制主要解决的目的就是服务调用时，从已知的所有服务提供者中根据路由规则刷选服务提供者。</p>
<h2 id="1、Dubbo路由机制概述"><a href="#1、Dubbo路由机制概述" class="headerlink" title="1、Dubbo路由机制概述"></a>1、Dubbo路由机制概述</h2><p>以下内容来源于官方文档：<br><img src="https://img-blog.csdn.net/20180628201426372?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180628201447412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180628201509453?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/2018062820152941?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180628201547105?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>以上是Dubbo 路由机制的基本知识，接下来从源码的角度分析一下其实现原理。</p>
<a id="more"></a>

<h2 id="2、Router相关类图："><a href="#2、Router相关类图：" class="headerlink" title="2、Router相关类图："></a>2、Router相关类图：</h2><p><img src="https://img-blog.csdn.net/20180628201629305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ol>
<li>Router：dubbo路由接口类<br> ● URL getUrl() ：获取路由配置URL。<br> ● &lt; T&gt; List&lt; Invoker&lt; T&gt;&gt; route(List&lt; Invoker&lt; T&gt;&gt; invokers, URL url, Invocation invocation) ：根据路由规则返回符合规则的服务调用者。</li>
<li>ConditionRouter：条件路由规则。</li>
<li>ScriptRouter：脚本路由规则（JavaScript）。</li>
</ol>
<h3 id="2-1-如何添加路由规则"><a href="#2-1-如何添加路由规则" class="headerlink" title="2.1 如何添加路由规则"></a>2.1 如何添加路由规则</h3><p>可以通过dubbo-admin管理后台，动态添加路由规则，其界面如图所示：<br><img src="https://img-blog.csdn.net/20180628201726802?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>点击保存后，使用URL描述一条路由规则，并将存储在注册中心${service}/routers目录下，然后通知相关订阅者（服务消费者【调用方】）。<br>具体调用的方法为RegistryDirecotry#notify方法，其片段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; routers</span><br><span class="line">if (routerUrls !&#x3D; null &amp;&amp; !routerUrls.isEmpty()) &#123;  &#x2F;&#x2F; @1</span><br><span class="line">     List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);     &#x2F;&#x2F; @2</span><br><span class="line">     if (routers !&#x3D; null) &#123; &#x2F;&#x2F; null - do nothing           </span><br><span class="line">          setRouters(routers);                                        &#x2F;&#x2F; @3</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1:如果routerUrls 不为空，说明注册中心的catalog=routers目录下新增或删除了某些路由规则，最后存在路由规则。<br>代码@2：将路由规则URL转换为路由实现类Router接口的实现类，例如条件路由规则、脚本路由规则具体实现类。<br>代码@3：将现存的路由规则实现类覆盖RegistroyDirectory#routers属性，在下一次服务调用时，这些路由规则将生效。</p>
<p>我们见到看一下toRouter方法的实现：</p>
<p>RegistryDirectory#toRouters</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private List&lt;Router&gt; toRouters(List&lt;URL&gt; urls) &#123;</span><br><span class="line">        List&lt;Router&gt; routers &#x3D; new ArrayList&lt;Router&gt;();</span><br><span class="line">        if (urls &#x3D;&#x3D; null || urls.isEmpty()) &#123;</span><br><span class="line">            return routers;</span><br><span class="line">        &#125;</span><br><span class="line">        if (urls !&#x3D; null &amp;&amp; !urls.isEmpty()) &#123;</span><br><span class="line">            for (URL url : urls) &#123;</span><br><span class="line">                if (Constants.EMPTY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                String routerType &#x3D; url.getParameter(Constants.ROUTER_KEY);</span><br><span class="line">                if (routerType !&#x3D; null &amp;&amp; routerType.length() &gt; 0) &#123;</span><br><span class="line">                    url &#x3D; url.setProtocol(routerType);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    Router router &#x3D; routerFactory.getRouter(url);</span><br><span class="line">                    if (!routers.contains(router))</span><br><span class="line">                        routers.add(router);</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;convert router url to router error, url: &quot; + url, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return routers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>方法实现比较简单，就是基于协议头condition://或script://构建具体的路由规则实现类。<br>从上面两个方法可以看出，当主从中心的路由配置发生变化后，会重新构建RegistryDirectory的List&lt; Router&gt; routers属性，那这个属性在什么时候用呢？</p>
<p>AbstractDirectory#list</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (destroyed) &#123;</span><br><span class="line">            throw new RpcException(&quot;Directory already destroyed .url: &quot; + getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers &#x3D; doList(invocation);</span><br><span class="line">        List&lt;Router&gt; localRouters &#x3D; this.routers; &#x2F;&#x2F; local reference</span><br><span class="line">        if (localRouters !&#x3D; null &amp;&amp; !localRouters.isEmpty()) &#123;</span><br><span class="line">            for (Router router : localRouters) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (router.getUrl() &#x3D;&#x3D; null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) &#123;</span><br><span class="line">                        invokers &#x3D; router.route(invokers, getConsumerUrl(), invocation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Failed to execute router: &quot; + getUrl() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invokers;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在通过RegistryDirector时，获取List&lt; Invoker&gt;时，会对所有的Invoker列表进行路由过滤，然后返回符合路由规则的Invoker，本文就不相信分析Dubbo是如何根据配置的条件路由规则、脚本路由规则去过滤，其实现细节，如有兴趣，可关注：ConditionRouter、ScriptRouter。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>路由机制</tag>
        <tag>Router</tag>
        <tag>ConditionRouter</tag>
        <tag>ScriptRouter</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo服务治理之灰度发布方案（版本发布控制影响范围）</title>
    <url>/posts/6bc72b05.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、方案背景"><a href="#1、方案背景" class="headerlink" title="1、方案背景"></a>1、方案背景</h2><p>背景：基于Dubbo服务的治理，是否可以支持业务级别的灰度发布、是否基于业务参数的路由转发。例如以GIS为例，当发布一个新版本时，是否可以以按照解析地址或合作伙伴来区分，版本发布之初，只希望地址为：广东省的解析请求发送到新版本，而其他的地址请求还是使用旧版；或者根据合作伙伴例如UCP(优享寄)的请求转发到新版本服务器，其他合作伙伴还是转发到旧版，达成业务级别的灰度发布，控制新版本的影响范围。例如OMS系统，可以根据合作伙伴，将重量级客户的请求转发到单独的服务器集群，确保其高可用。<br>本文将对上述议题结合Dubbo提供的功能，提出设计方案。</p>
<h2 id="2、方案理论基础"><a href="#2、方案理论基础" class="headerlink" title="2、方案理论基础"></a>2、方案理论基础</h2><p>Dubbo的服务调用原理图：<br><img src="https://img-blog.csdn.net/20181015123333422?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>客户端在发起RPC服务调用之前，在客户端首先从服务器列表中选择一个服务调用者，包含如下关键角色：</p>
<a id="more"></a>

<p>1、Directory<br>服务的动态发现，通常基于注册中心进行服务的动态注册与发现，其具体实现类为RegistryDirectory。<br>2、Router<br>路由实现，其含义是根据Directory发现的所有服务提供者列表中，进行路由选择，也就是根据一定的路由规则选择合适的服务提供者，为Directory发现的服务提供者列表子集，可以基于Condition或脚本（默认为JS脚本，其实现类为ScriptRouter）。<br>3、LoadBalance<br>负载均衡机制，其作用主要是根据负载均衡算法（随机、轮询）<br>等算法，从（Directory–&gt;Router）中返回的服务提供者列表中选择一个服务提供者，进行本次的RPC服务调用。<br>4、Cluster<br>集群（容错机制），就是当从服务提供者列表中按照负载均衡算法选择一个服务提供者，进行RPC服务调用后，发送了异常后的策略，例如failover(重试)、failfast(快速失败)等。<br>服务的灰度发布，其目标是希望根据请求，某些请求走新版本服务器，某些请求走旧版本服务器，其本质就是路由机制，即通过一定的条件来缩小服务的服务提供者列表，正好与Dubbo的Router相吻合。<br>有关于Dubbo的Router机制，请参考官方文档第【46、47、48】页，如果想从源码的角度了解其实现机制，请参考博文：<a href="https://blog.csdn.net/prestigeding/article/details/80848594">https://blog.csdn.net/prestigeding/article/details/80848594</a><br>有了理论支持，下文将根据上述理论进行实战。</p>
<h2 id="3、方案具体实现示例"><a href="#3、方案具体实现示例" class="headerlink" title="3、方案具体实现示例"></a>3、方案具体实现示例</h2><p>本示例代码需要完成的任务是，对DemoService#createUser服务，其用户机构ID(orgId)为1的走新版本（当前服务提取者列表的最后一台服务器），其他的请求走所有的服务器（除最后一台服务器）。<br> <img src="https://img-blog.csdn.net/20181015123609793?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdn.net/20181015123700316?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>由于是需要基于请求参数，本文给出基于JS脚本的路由机制，首先，当前版本的dubbo-admin可以后台页面维护基于条件表达式的路由规则，其界面如下：<br> <img src="https://img-blog.csdn.net/20181015123744903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdn.net/20181015123836904?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br>备注：并且当前dubbo-admin版本，并不支持基于JS表达式的路由规则，如果手动建立基于表达式的路由规则，其页面将无法列出路由表达式，其界面如下：<br><img src="https://img-blog.csdn.net/20181015123902592?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<h3 id="3-1-JS脚本"><a href="#3-1-JS脚本" class="headerlink" title="3.1 JS脚本"></a>3.1 JS脚本</h3><p>各个项目，各个服务需要根据自身的需求，定义如下脚本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * DemoService router，针对不同的方法，可能需要各自提供，主要是参数的获取，不同的过滤规则</span><br><span class="line"> * 针对参数进行路由过滤</span><br><span class="line"> * </span><br><span class="line"> * 本示例针对 DemoSerivce# ResponseResult createUser(User user) 方法，根据user的orgId进行路由选择</span><br><span class="line"> * @param invokers</span><br><span class="line"> * @param invocation</span><br><span class="line"> * @param context</span><br><span class="line"> * @returns</span><br><span class="line"> *&#x2F;</span><br><span class="line">function demoService_createUser_router(invokers, invocation, context) &#123;</span><br><span class="line">	if(invokers &#x3D;&#x3D; null || invokers.size() &lt; 1) &#123;</span><br><span class="line">		return invokers;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	if(!&quot;createUser&quot;.equals(invocation.getMethodName())) &#123; &#x2F;&#x2F; 如果方法不匹配，默认无条件通过该路由规则</span><br><span class="line">		return invokers;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	var availableInvokers &#x3D; new java.util.ArrayList(invokers.size());</span><br><span class="line">	for (var i&#x3D;0;i&lt;invokers.size(); i++) &#123;    &#x2F;&#x2F; 先选择可用的服务提供者列表</span><br><span class="line">		if(invokers.get(i).isAvailable()) &#123;</span><br><span class="line">			availableInvokers.add(invokers.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	var invArguments &#x3D; invocation.getArguments();</span><br><span class="line">	if(invArguments &#x3D;&#x3D; null || invArguments.length &#x3D;&#x3D; 0) &#123; &#x2F;&#x2F; 如果参数为空，无法根据参数进行路由选择</span><br><span class="line">		return availableInvokers; </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 获取需要进行路由的参数，这里使用第一个参数 ，这里各自根据各自的业务 进行获取，本实例默认使用第一个参数</span><br><span class="line">	var firstArgument &#x3D; invArguments[0];</span><br><span class="line">	var orgId &#x3D; firstArgument &#x3D;&#x3D; null ? &quot;&quot; : firstArgument.getOrgId();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	if(orgId &#x3D;&#x3D; 1 || orgId &#x3D;&#x3D; &quot;1&quot;) &#123; &#x2F;&#x2F; 如果orgId &#x3D;&#x3D; 1 ，只走最后一个节点，其余的走其他节点</span><br><span class="line">		var selectInvokers &#x3D; new java.util.ArrayList(1);</span><br><span class="line">		selectInvokers.add(availableInvokers.get(availableInvokers.size()-1));</span><br><span class="line">		return selectInvokers;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		var selectInvokers &#x3D; new java.util.ArrayList(availableInvokers.size()-1);</span><br><span class="line">		for(var i&#x3D;0;i&lt;availableInvokers.size()-1; i++) &#123;</span><br><span class="line">			selectInvokers.add(availableInvokers.get(i));</span><br><span class="line">		&#125;</span><br><span class="line">		return selectInvokers;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-向注册中心注册JS脚本路由规则"><a href="#3-2-向注册中心注册JS脚本路由规则" class="headerlink" title="3.2 向注册中心注册JS脚本路由规则"></a>3.2 向注册中心注册JS脚本路由规则</h3><p>上文已经说明，目前的dubbo-admin不支持在界面上注册路由规则，现给出基于JAVA代码来编写注册程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">	URL registryUrl &#x3D; URL.valueOf(&quot;zookeeper:&#x2F;&#x2F;127.0.0.1:2181&quot;);</span><br><span class="line">    ZookeeperRegistryFactory zookeeperRegistryFactory &#x3D; new </span><br><span class="line">                       ZookeeperRegistryFactory();</span><br><span class="line">   zookeeperRegistryFactory.setZookeeperTransporter(new </span><br><span class="line">        CuratorZookeeperTransporter());</span><br><span class="line">   Registry zookeeperRegistry &#x3D; (ZookeeperRegistry) </span><br><span class="line">             zookeeperRegistryFactory.createRegistry(registryUrl);</span><br><span class="line">   URL routerURL &#x3D; </span><br><span class="line">          URL.valueOf(&quot;script:&#x2F;&#x2F;0.0.0.0&#x2F;com.alibaba.dubbo.demo.Demo</span><br><span class="line">                Service?category&#x3D;routers&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;fo</span><br><span class="line">                rce&#x3D;false&amp;name&#x3D;demoService_createUser_router&amp;priority&#x3D;</span><br><span class="line">          0&amp;runtime&#x3D;true&quot;);</span><br><span class="line">   routerURL &#x3D; routerURL.addParameter(&quot;rule&quot;, </span><br><span class="line">   URL.encode(get_demoService_createUser_router()));</span><br><span class="line">   zookeeperRegistry.register(routerURL);     &#x2F;&#x2F; 注册</span><br><span class="line">   &#x2F;&#x2F; zookeeperRegistry.unregister(routerURL); &#x2F;&#x2F; 取消注册</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦运行上述代码，将会动态注册URL，服务提供者无需重启，下次服务调用后会自动生效（其背后原理是基于注册中心的动态发现）。<br>上述示例代码，我已经在本地环境，已能成功运行，并达到预期效果，公司项目需要根据自身的特点，特别服务方法的参数（例如合作伙伴ID的获取方式），以及路由需求来定制编写其路由脚本（js脚本）。</p>
<h3 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h3><p>上述展示了Dubbo服务基于业务灰度发布的方案，以及基于合作伙伴的服务隔离机制（根据服务调用业务参数来决定服务调用者的筛选）。主要是展示了基于脚步的路由规则，其条件表达式的路由规则请参考其Demo，其核心理论支持是Dubbo提供的Router，在进行负载均衡前，根据路由规则对服务提供者列表进行筛选。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>灰度发布</tag>
        <tag>router</tag>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka与RocketMQ性能对比大揭秘</title>
    <url>/posts/b9e3e3ee.html</url>
    <content><![CDATA[<div id="vip-container"><p>在双十一过程中投入同样的硬件资源，Kafka 搭建的日志集群单个Topic可以达到几百万的TPS，而使用RocketMQ组件的核心业务集群，集群TPS只能达到几十万TPS，这样的现象激发了我对两者性能方面的思考。</p>
<blockquote>
<p>温馨提示：TPS只是众多性能指标中的一个，我们在做技术选型方面要从多方面考虑，本文并不打算就消息中间件选型方面投入太多笔墨，重点想尝试剖析两者在性能方面的设计思想。</p>
</blockquote>
<a id="more"></a>

<h2 id="1、文件布局"><a href="#1、文件布局" class="headerlink" title="1、文件布局"></a>1、文件布局</h2><h3 id="1-1-Kafka-文件布局"><a href="#1-1-Kafka-文件布局" class="headerlink" title="1.1 Kafka 文件布局"></a>1.1 Kafka 文件布局</h3><p>Kafka 文件在宏观上的布局如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201130220311325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>正如上图所示，Kafka 文件布局的主要特征如下：</p>
<p>文件的组织以 topic + 分区进行组织，每一个 topic 可以创建多个分区，每一个分区包含单独的文件夹，并且是多副本机制，即 topic 的每一个分区会有 Leader 与 Follow，<strong>并且 Kafka 内部有机制保证 topic 的某一个分区的 Leader 与 follow 不会存在在同一台机器，并且每一台 broker 会尽量均衡的承担各个分区的 Leader</strong>，当然在运行过程中如果不均衡，可以执行命令进行手动重平衡。Leader 节点承担一个分区的读写，follow 节点只负责数据备份。</p>
<p>Kafka 的负载均衡主要依靠分区 Leader 节点的分布情况。</p>
<p>分区的 Leader 节点负责读写，而从节点负责数据同步，如果Leader分区所在的Broker节点发生宕机，会触发主从节点的切换，会在剩下的 follow 节点中选举一个新的 Leader 节点，其数据的流入流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201130220357452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>分区 Leader 收到客户端的消息发送请求时，是写入到 Leader 节点后就返回还是要等到它的从节点全部写入后再返回，这里非常关键，会直接影响消息发送端的时延，故 Kafka 提供了 ack 这个参数来进行策略选择：</p>
<ul>
<li><p>ack = 0</p>
<p>不等broker端确认就直接返回，即客户端将消息发送到网络中就返回发送成功。</p>
</li>
<li><p>ack = 1</p>
<p>Leader 节点接受并存储后向客户端返回成功。</p>
</li>
<li><p>ack = -1<br>Leader节点和所有的Follow节点接受并成功存储再向客户端返回成功。</p>
</li>
</ul>
<h3 id="1-2-RocketMQ-文件布局"><a href="#1-2-RocketMQ-文件布局" class="headerlink" title="1.2 RocketMQ 文件布局"></a>1.2 RocketMQ 文件布局</h3><p>RocketMQ 的文件布局如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020113022041578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>RocketMQ 所有主题的消息都会写入到 commitlog 文件中，然后基于 commitlog 文件构建消息消费队列文件(Consumequeue)，消息消费队列的组织结构按照 /topic/{queue} 进行组织。从集群的视角来看如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201130220429439.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>RocketMQ 默认采取的是主从同步，当然从RocketMQ4.5引入了多副本机制，但其<strong>副本的粒度为 Commitlog 文件</strong>，上图中不同 master 节点之间的数据完成不一样（数据分片），而主从节点节点数据一致。</p>
<h3 id="1-3-文件布局对比"><a href="#1-3-文件布局对比" class="headerlink" title="1.3 文件布局对比"></a>1.3 文件布局对比</h3><p>Kafka 中文件的布局是以 Topic/partition ，每一个分区一个物理文件夹，在<strong>分区文件级别实现文件顺序写</strong>，如果一个Kafka集群中拥有成百上千个主题，每一个主题拥有上百个分区，消息在高并发写入时，其IO操作就会显得零散，其操作相当于随机IO，<strong>即 Kafka 在消息写入时的IO性能会随着 topic 、分区数量的增长，其写入性能会先上升，然后下降</strong>。</p>
<p>而 RocketMQ在消息写入时追求极致的顺序写，所有的消息不分主题一律顺序写入 commitlog 文件，并不会随着 topic 和 分区数量的增加而影响其顺序性。但通过笔者的实践来看一台物理机并使用SSD盘，但一个文件无法充分利用磁盘IO的性能。</p>
<p>两者文件组织方式，除了在磁盘的顺序写方面有所区别后，由于其粒度的问题，Kafka 的 topic 扩容分区会涉及分区在各个 Broker 的移动，其扩容操作比较重，而 RocketMQ 数据存储是基于 commitlog 文件的，扩容时不会产生数据移动，只会对新的数据产生影响，RocketMQ 的运维成本对 Kafka 更低。</p>
<p>最后 Kafka 的 ack 参数可以类比 RocketMQ 的同步复制、异步复制。</p>
<p>Kafka 的 ack 参数为 1 时，对比 RocketMQ 的异步复制； -1 对标 RocketMQ 的 同步复制，而 -1 则对标 RocketMQ 消息发送方式的 oneway 模式。</p>
<h2 id="2、数据写入方式"><a href="#2、数据写入方式" class="headerlink" title="2、数据写入方式"></a>2、数据写入方式</h2><h3 id="2-1-Kafka-消息写入方式"><a href="#2-1-Kafka-消息写入方式" class="headerlink" title="2.1 Kafka 消息写入方式"></a>2.1 Kafka 消息写入方式</h3><p>Kafka 的消息写入使用的是 FileChannel，其代码截图如下：<br><img src="https://img-blog.csdnimg.cn/20201130220453340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>并且在消息写入时使用了 transferTo 方法</strong>，根据网上的资料说 NIO 中网络读写真正是零拷贝的就是需要调用 FileChannel 的 transferTo或者 transferFrom 方法，其内部机制是利用了 sendfile 系统调用。</p>
<h3 id="2-2-RocketMQ-消息写入方式"><a href="#2-2-RocketMQ-消息写入方式" class="headerlink" title="2.2 RocketMQ 消息写入方式"></a>2.2 RocketMQ 消息写入方式</h3><p>RocketMQ 的消息写入支持 内存映射 与 FileChannel 写入两种方式， 示例如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020113022052734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="2-3-消息写入方式对比"><a href="#2-3-消息写入方式对比" class="headerlink" title="2.3 消息写入方式对比"></a>2.3 消息写入方式对比</h3><p>尽管 RocketMQ 与 Kafka 都支持 FileChannel 方式写入，但 RocketMQ 基于 FileChannel 写入时调用的 API 却并不是 transferTo，而是先调用 writer，然后定时 flush 刷写到磁盘，其代码截图如下：<br><img src="https://img-blog.csdnimg.cn/20201130220540388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为什么 RocketMQ 不调用 transerTo 方法呢，个人觉得和 RocketMQ 需要在 Broker 组装 MQ 消息格式有关，需要从网络中解码请求，传输到堆内存，然后对消息进行加工，最终持久化到磁盘相关。</p>
<p>从网上查询资料中大概倾向于这样一个 观点：sendfile 系统调用相比内存映射多了一次从用户缓存区拷贝到内核缓存区，但对于超过64K的内存写入时往往 sendfile 的性能更高，可能是由于 sendfile 是基于块内存的。</p>
<h2 id="3、消息发送方式"><a href="#3、消息发送方式" class="headerlink" title="3、消息发送方式"></a>3、消息发送方式</h2><h3 id="3-1-Kafka-消息发送机制"><a href="#3-1-Kafka-消息发送机制" class="headerlink" title="3.1 Kafka 消息发送机制"></a>3.1 Kafka 消息发送机制</h3><p>Kafka 在消息发送客户端采用了一个双端队列，引入了批处理思想，其消息发送机制如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201130220558530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>客户端通过调用 kafka 的消息发送者发送消息时，消息会首先存入到一个双端队列中，双端队列中单个元素为 ProducerBatch，表示一个发送批次，其最大大小受参数 batch.size 控制，默认为 16K。然后会单独开一个 Send 线程，从双端队列中获取一个发送批次，将消息按批发送到 Kafka集群中，这里引入了 linger.ms 参数来控制 Send 线程的发送行为。</p>
<p>为了提高 kafka 消息发送的高吞吐量，即控制在缓存区中未积满 batch.size 时来控制消息发送线程的行为，是立即发送还是等待一定时间，如果linger.ms 设置为 0表示立即发送，如果设置为大于0，则消息发送线程会等待这个值后才会向broker发送。 <strong>linger.ms 参数者会增加响应时间，但有利于增加吞吐量。有点类似于 TCP 领域的 Nagle 算法</strong>。</p>
<p>Kafka 的消息发送，在写入 ProducerBatch 时会按照消息存储协议组织好数据，在服务端可以直接写入到文件中。</p>
<h3 id="3-2-RocketMQ-消息发送机制"><a href="#3-2-RocketMQ-消息发送机制" class="headerlink" title="3.2 RocketMQ 消息发送机制"></a>3.2 RocketMQ 消息发送机制</h3><p>RocketMQ 消息发送在客户端主要是根据路由选择算法选择一个队列，然后将消息发送到服务端，消息会在服务端按照消息的存储格式进行组织，然后进行持久化等操作。</p>
<h3 id="3-3-消息发送对比"><a href="#3-3-消息发送对比" class="headerlink" title="3.3 消息发送对比"></a>3.3 消息发送对比</h3><p>Kafka 在消息发送方面比 RokcetMQ 有一个显著的优势就是消息格式的组织是发生在客户端，这样会有一个大的优势节约了 Broker 端的CPU压力，客户端“分布式”的承接了其优势，其架构方式有点类似 shardingjdbc 与 MyCat 的区别。</p>
<p>Kafka 在消息发送端另外一个特点是引入了双端缓存队列，Kafka 无处不在追求批处理，这样显著的特点是能提高消息发送的吞吐量，但与之带来的是增大消息的响应时间，并且带来了消息丢失的可能性，因为 Kafka 追加到消息缓存后会返回成功，如果消息发送方异常退出，会带来消息丢失。</p>
<p>Kafka 中的 linger.ms = 0 可类比 RocketMQ 消息发送的效果。</p>
<p>但 Kafka 通过提供 batch.size 与 linger.ms 两个参数按照场景进行定制化，比 RocketMQ 灵活。</p>
<p>例如日志集群，通常会调大 batch.size 与 linger.ms 参数，重复发挥消息批量发送机制，提高其吞吐量；但如果对一些响应时间比较敏感的话，可以适当减少 linger.ms 的值。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>从上面的对比来看，Kafka 在性能上综合表现确实要比 RocketMQ 更加的优秀，但在消息选型过程中，我们不仅仅要参考其性能，还有从功能性上来考虑，例如 RocketMQ 提供了丰富的消息检索功能、事务消息、消息消费重试、定时消息等。</p>
<p>笔者个人认为通常在大数据、流式处理场景基本选用 Kafka，业务处理相关选择 RocketMQ。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
        <tag>rocketmq</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎读书笔记(MySQL日志文件)</title>
    <url>/posts/3f9b27cb.html</url>
    <content><![CDATA[<div id="vip-container"><p>MySQL日志文件主要包含错误日志，慢查询日志，查询日志，binlog、与事务日志(redo,undo)。</p>
<p>本文为了突出重点，将日志文件分成如下两类：普通日志、重点日志（binlog,redo,undo)</p>
<h2 id="1、普通日志"><a href="#1、普通日志" class="headerlink" title="1、普通日志"></a>1、普通日志</h2><h3 id="1-1、错误日志"><a href="#1-1、错误日志" class="headerlink" title="1.1、错误日志"></a>1.1、错误日志</h3><p>错误文件，默认为 ${mysql_home}/data/主机名.err</p>
<p>配置日志文件的参数为 log_error</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%log_error%&#39;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2、慢查询日志"><a href="#1-2、慢查询日志" class="headerlink" title="1.2、慢查询日志"></a>1.2、慢查询日志</h3><p>MySQL判断语句执行慢的参考如下：</p>
<ol>
<li><p>执行时间不能超过 long_query_time(单位为秒，支持到微妙，通过小数点表示)</p>
</li>
<li><p>是否使用了索引开关( log_queries_not_using_indexes 如果设置为1或on,表示如果没有使用索引的语句认为是慢查询 )</p>
</li>
<li><p>本次查询扫描的行数如果小于min_examined_row_limit ,如果本次查收扫描的行数小于该配置值，则不写</p>
</li>
</ol>
<p>​       入慢查询日志。</p>
<ol start="4">
<li>如果没有使用索引，可以控制每分钟出现多少次后才写入一条到慢查询日志中。</li>
</ol>
<blockquote>
<p>参数为： log_throttle_queries_not_using_indexes，默认为0表示不做限制</p>
</blockquote>
<a id="more"></a>

<p>官方文档关于慢查询日志链接：<a href="https://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html">https://dev.mysql.com/doc/refman/5.6/en/slow-query-log.html</a></p>
<p>根据使用经验，可以使用如下命令查看与慢查询相关的配置属性：</p>
<p><img src="https://img-blog.csdn.net/20170709102229138?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdn.net/20170709102305468?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdn.net/20170709102338525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p><img src="https://img-blog.csdn.net/20170709102404515?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="1-3、查询日志"><a href="#1-3、查询日志" class="headerlink" title="1.3、查询日志"></a>1.3、查询日志</h3><p>查询日志官方说明：<a href="https://dev.mysql.com/doc/refman/5.6/en/query-log.html">https://dev.mysql.com/doc/refman/5.6/en/query-log.html</a></p>
<p>查询日志，详细的记录了所有查询语句对应mysql通信协议语句类型(COM_QUERY)相关的语句执行情况，非常适合定位问题，但生产环境下必须禁用该属性，不然会严重影响性能。查询日志相关的两个属性如下：</p>
<p><img src="https://img-blog.csdn.net/20170709102446664?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>既然是COM_QUERY类型的，也包含update,insert语句。</p>
<h2 id="2、binlog、redo、undo"><a href="#2、binlog、redo、undo" class="headerlink" title="2、binlog、redo、undo"></a>2、binlog、redo、undo</h2><p>接下来重点讨论binlog、redo、undo日志</p>
<p>基于InnoDB存储引擎来讨论binlog,redo,undo。</p>
<h3 id="2-1-binlog"><a href="#2-1-binlog" class="headerlink" title="2.1 binlog"></a>2.1 binlog</h3><p>mysql二进制日志，在mysql服务层面记录mysql数据的变化轨迹，其存储格式为基于SQL语句（statement）、基于数据行变化(row)、混合方式(mixed)，其作用主要用来做主从同步。横向类比（Redis主从复制）。</p>
<p>写入时机：下文与redo时一起讨论。</p>
<h4 id="2-1-1-binglog相关参数与解读"><a href="#2-1-1-binglog相关参数与解读" class="headerlink" title="2.1.1 binglog相关参数与解读"></a>2.1.1 binglog相关参数与解读</h4><p>binlog相关的配置参数如下：</p>
<ul>
<li><p>log-bin=mysql-bin  (指定binlog的日志名，默认路径为${mysql_home}/data)</p>
</li>
<li><p>binlog_format 指定binglog的存放格式，statement,row,mixed</p>
</li>
<li><p>max_binlog_size</p>
</li>
<li><p>binlog_cache_size</p>
</li>
<li><p>sync_binlog<br>涉及文件操作，一般的做法是先缓存（内存中），然后隔一段时间将缓存写入到文件中。</p>
<p>binlog的写入同样如此，mysql会为binlog提供一个写缓存区，每个会话将binglog,首先会写入到写缓存区，然后按某种机制刷写到磁盘。</p>
<p>通过max_binlog_size设置单个binlog文件的大小，默认为1G，一个文件达到上限后，再新建一个文件,.index记录了所有的binlog文件。binlog_cache_size,是会话级别的参数，设置binlog的内存缓存区大小，默认为32K。</p>
<p>如果一个会话内的产生的binlog日志超过32K后，mysql会将binglog写入临时的日志文件。mysql提供两个运行时变量binlog_cache_use、binlog_cache_disk_use来记录利用内存缓存和文件缓存的次数。</p>
<p>sync_binlog用来设置输入缓存的频率，表示多少次写缓存区后刷新到磁盘。我们知道，在事务允许过程中，首先会将产生的binlog写入到会话内的缓存区（内存缓存区），然后在事务提交后，将内存缓存区的数据写入到mysql binlog的写缓存区，然后刷写到磁盘，sync_binlog=1表示事务提交时（发出commit之前会先写binlog,但不一定会落盘,InnoDB1.2之后，提交阶段写redo,binlog日志为两阶段提交，见下文详解），将缓存区中的数据立即刷写到磁盘（落盘）。</p>
<p>生产环境下sync_binlog设置为1，保证其数据一致性。但还存在这样一种情况，如果发出事务comit操作，binlog已经被写入，但事务提交过程中，mysql服务器down了，此时会引起主从数据不一致性，该怎么办呢？innodb存储引擎提供了innodb_support_xa=1来解决binlog与innodb存储引擎日志文件不一致的问题（二阶段提交），下午redo,undo部分再详细解读。</p>
</li>
<li><p>binlog-do-db      指定需要同步的数据库(schema)</p>
</li>
<li><p>binlog-ignore-db   指定需要同步（记录binlog）日志的数据库(schema)</p>
</li>
<li><p>log-slave-update   设置从服务器是否也写binglog日志，默认是关闭的,log-slave-update=1表示开启。</p>
</li>
</ul>
<h4 id="2-1-2-binglog工具"><a href="#2-1-2-binglog工具" class="headerlink" title="2.1.2 binglog工具"></a>2.1.2 binglog工具</h4><p>mysql提供了官方的binlog查看工具，mysqlbinlog</p>
<h3 id="2-2-redo与undo日志"><a href="#2-2-redo与undo日志" class="headerlink" title="2.2 redo与undo日志"></a>2.2 redo与undo日志</h3><p>redo与undo是mysql存储引擎级别的日志，俗称事务日志，与事务的实现息息相关。那我们从事务的ACID属性开始说起：</p>
<ul>
<li><p>原子性（Atomicity）<br>事务内的操作要么全部执行，要么全部不执行。</p>
</li>
<li><p>一致性（Consistency）<br>在事务开始之前和事务开始之后，数据库的完整性约束没有被破坏。</p>
</li>
<li><p>隔离性<br>两个事务的执行互不干扰，sql定义了4种隔离级别（读未提交、读已提交、可重复读、串行话读）</p>
</li>
<li><p>持久性（Durability）<br>事务成功执行后，该事务所对数据库所做的变更持久的保存在数据库之中。</p>
</li>
</ul>
<p>redo 重做日志，主要用来保证事务的持久性。</p>
<p>undo 回滚日志，在InnoDB中，将undo看成是数据，并不是日志，存放在数据文件中(innodb表空间文件中ibdata1)。</p>
<h4 id="2-2-1-redo-undo日志基础"><a href="#2-2-1-redo-undo日志基础" class="headerlink" title="2.2.1 redo,undo日志基础"></a>2.2.1 redo,undo日志基础</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size">https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_log_buffer_size</a> 官方文档关于InnoDB参数</p>
<p>undo 取消操作，用于事务回滚，将数据恢复到修改之前的状态，InnoDB的多版本并发控制（MVCC）就是基于undo来实现的。undo严格意义上来说，InnoDB将undo信息当成数据，存放在数据文件。数据文件相关的参数如下：</p>
<ul>
<li>innodb_data_home_dir :数据文件的路径，在my.cnf中对应 data_dir</li>
<li>innodb_data_file_path:数据文件名（默认表空间文件）,默认为ibdata1:12M:autoextend</li>
<li>innodb_file_per_table : 支持每个表单独一个表空间文件（数据文件）</li>
<li>innodb_tmpdir      :临时表空间路径</li>
<li>innodb_temp_data_file_path:临时表空间文件，默认为ibtmp1:12M:autoextend</li>
<li>innodb_undo_directory : undo独立目录（undo独立表空间）</li>
<li>innodb_undo_log_truncate:默认为off,undo日志是否支持压缩，删除已经落盘的信</li>
<li>innodb_undo_logs:128,默认为128个undo段，其中0号回滚段存在于默认表空间中，1-32号表空间位于临时表空间。</li>
<li>innodb_undo_tablespaces:默认为0，表示不开启独立的undo表空间。</li>
</ul>
<h5 id="2-2-1-1-redo日志"><a href="#2-2-1-1-redo日志" class="headerlink" title="2.2.1.1 redo日志"></a>2.2.1.1 redo日志</h5><p>重做日志，用来实现服务器异常时的数据恢复，实现事务的持久性。</p>
<p>redo日志的核心思想是使用顺序IO(事务提交时主要写redo日志，操作一个顺序的联系的IO文件)来代替每个事务提交时大量的随机IO去更新数据文件。也就是对数据的修改不会立马刷写到数据文件，而是写入redo文件，然后使用一定的机制，将内存中的脏页异步写入到数据文件，提高事务的执行效率与并发能力。</p>
<p>redo相关的配置参数：</p>
<ul>
<li><p>innodb_log_buffer_size : 一般根据页的大小（8K,16K）设置为8M,16M,写redo日志的缓冲区大小</p>
</li>
<li><p>innodb_log_file_size:单个redo日志文件的大小，默认为48M</p>
</li>
<li><p>innodb_log_files_in_group:默认为2，表示一个redo日志组中包含多少个文件，默认为2个。进行循环覆盖写- </p>
</li>
<li><p>innodb_log_write_ahead_size,每次追加写到redo日志文件的大小，默认为页的大小。8K或16K</p>
</li>
<li><p>innodb_log_group_home_dir:redo日志文件目录，默认为数据文件路径${mysql_home}\data</p>
</li>
</ul>
<h5 id="2-2-1-2-binlog、undo、redo日志写入时机"><a href="#2-2-1-2-binlog、undo、redo日志写入时机" class="headerlink" title="2.2.1.2 binlog、undo、redo日志写入时机"></a>2.2.1.2 binlog、undo、redo日志写入时机</h5><p>redo,重做日志，其引入的目的就是能够回复InnoDB的事务，达到恢复数据的目的。（持久性）</p>
<p>undo回滚日志，其引入的目的就是事务内的回滚(rollback)。（原子性）</p>
<p>redo日志引入的技术性原理分析：</p>
<ul>
<li><p>数据库存储其底层是文件系统，也就是数据库的数据最终存放在文件中,称之为数据文件。其持久性最通俗的要求就是事务执行后变更要能反馈到数据文件中即可。</p>
<p>操作数据库数据的逻辑一般是这样的：</p>
</li>
<li><p>从数据库文件中找到记录，文件一般是按照一种特定的格式存放，比如页，然后加载整页数据到内存，在内存中进行数据的操作（脏页）然后将脏页同步回文件，一般不会立即将脏页刷回到磁盘，这样会产生大量的随机IO操作，性能低下，如果不立即刷回磁盘，那么当服务器挂掉后，存放在内存中的数据会丢失，造成数据的不一致性，也就无从持久化。为了解决这一矛盾，引入了redo日志。</p>
</li>
<li><p>redo日志的引入核心一个思想是采用对redo日志文件的顺序IO来替换频繁的随机IO(更新数据文件)，redo文件使用循环覆写方式。redo一般会有两个文件ib_log0与ib_log1。引入redo日志后，数据库修改数据的通常逻辑为，从数据文件中找到数据页并加载到内存，在内存中修改数据，在事务提交之前先写redo日志，确保redo日志落盘，然后提交事务。数据库中的脏页使用一定的机制，统一刷写到数据文件。这样就将每次事务提交的时候，将随机访问数据文件变成顺序写redo日志。这样就提高了效率。</p>
</li>
</ul>
<p>接下来我们以示例来分析，redo,undo是如何写入的。</p>
<ul>
<li>update语句<br>我们知道，InnoDB使用多版本控制并发控制协议(MVCC)来实现无锁的并发读控制，MVCC,就是借助于undo日志。根据MVCC的实现方式，update语句执行逻辑为，先复制一份老的数据，请删除版本号设置为当前的事务ID，然后插入一条新的数据，更新版本号为当前事务。这里复制老的数据这一个步骤完全与undo的引入非常吻合，可以利用undo来恢复数据。那么MVCC结合undo关于update的实现：<ul>
<li>首先将数据（数据行）拷贝一份，将其删除版本号设置为当前事务ID，申请回滚段(undo),记录undo日志,undo日志的存储方式是一条链表（双链表）并且按照事务ID后排序。因为InnoDB把undo日志当成是数据，存放于表空间中，故在写undo之前，需要先写redo日志，redo日志将包含undo信息（可以根据redo日志重建undo日志链）,也就是undo是受redo日志保护的。</li>
<li>然后用插入一条数据，将数据行的更新版本号设置为当前事务。此时继续写redo日志。然后提交事务，此时redo日志落盘，undo日志与数据文件可能还保存在内存中，innodb会按照一定的策略将undo日志和数据脏页写入到磁盘。</li>
</ul>
</li>
</ul>
<p><strong>事务内的查询可见性机制：</strong></p>
<p>我想在事务内根据主键ID查询一条数据应该是先从数据文件中加载该数据，然后判断根据版本号与当前事务ID判断其可见性，如果不可见，则需要从undo链去找，数据文件行中存储了该记录所在的回滚段与偏移量。沿着回滚链找到向前找到第一个符合可见性的记录。</p>
<p>binlog、redo日志的写入关系。</p>
<p>在innodb_support_xa=1与sync_binlog=1时，,innodb会使用二阶段协议来写binlog与redo日志。[innodb_flush_log_at_trx_commit=1]</p>
<p>在mysql服务层发出commit命令后：</p>
<ul>
<li><p>prepare阶段：先写redo日志并落盘(redo日志信息包含undo信息)，状态为prepare。</p>
</li>
<li><p>commit阶段：写binlog文件并落盘</p>
</li>
<li><p>写redo日志并落盘（commit信息）</p>
</li>
</ul>
<p><img src="https://img-blog.csdn.net/20170709102605771?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>状态1: Redo Log里存在，Binary Log里也存在 –正常情况，crash恢复时需要commit</p>
<p>状态2: Redo Log里存在，Binary Log里不存在 –prepare完毕后发生crash，恢复时需要rollback</p>
<p>状态3: Redo Log里不存在，Binary Log里也不存在 –提交失败，无需处理</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>binlog</tag>
        <tag>mysql</tag>
        <tag>慢查询日志</tag>
        <tag>redo</tag>
        <tag>undo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL技术内幕-InnoDB存储引擎读写笔记(性能调优)</title>
    <url>/posts/5b656c60.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、CPU"><a href="#1、CPU" class="headerlink" title="1、CPU"></a>1、CPU</h2><p>数据库一般是IO密集型的，其性能瓶颈在于IO。数据库服务器的选购偏内存，CPU可以适当降低其要求。</p>
<p>InnoDB存储引擎相关后台线程：</p>
<p>show engine innodb status\G;</p>
<p>  <img src="https://img-blog.csdn.net/20170717201302449?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li><p>插入缓冲区线程 <a href="http://www.cnblogs.com/yuyue2014/p/3802779.html">http://www.cnblogs.com/yuyue2014/p/3802779.html</a><br>InnoDB insert buffer thread 线程主要是更新非唯一索引的索引数据，避免频繁随机的读写索引文件。（索引数据存放在表默认表空间中）</p>
</li>
<li><p>log thread : InnoDB的默认指的就是redo日志,log thread 就是写 redo 日志的线程。</p>
</li>
<li><p>read thread | write thread 读、写日志线程（文件 《—-》内存）</p>
<p>根据CPU适当调节innodb_read_io_threads与innodb_write_io_threads</p>
</li>
</ul>
<h2 id="2、内存"><a href="#2、内存" class="headerlink" title="2、内存"></a>2、内存</h2><p>内存的大小最能直接反应数据库的性能。InnoDB存储引擎既缓存数据，又缓存索引（存放在数据文件中，表空间），并放入一个很大的缓冲池中(InnoDB Buffer Pool)。</p>
<p>innodb_buffer_pool的大小如果能等于数据文件的大小，则能缓存所有的数据文件，性能会得到极高的提升（innodb_buffer_pool_size）,如何判断当前数据库的内存是否达到了瓶颈了呢。</p>
<p>mysql提供  show global status 命令查看系统运行状况监控，（INFORMATION_SCHEMA GLOBAL_STATUS临时表）。</p>
<p><img src="https://img-blog.csdn.net/20170717201359777?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>关注如下参数：</p>
<ul>
<li><p>innodb_buffer_pool_reads: 从物理磁盘读取页的次数</p>
</li>
<li><p>innodb_buffer_pool_read_ahead:预读的次数</p>
</li>
<li><p>innodb_buffer_pool_read_ahead_evicted:预读的页，但没有被读取就从缓冲区被替换的也的数量，一般用来判断预读的效率。</p>
</li>
<li><p>innodb_buffer_pool_read_requests:从缓冲池中读取页的次数（可以理解为缓冲命中次数）</p>
</li>
<li><p>innodb_data_read:总共读入的字节数</p>
</li>
<li><p>innodb_data_reads:发起读请求的次数</p>
<a id="more"></a>

</li>
</ul>
<p>预读的效率：(1 -  (innodb_buffer_pool_read_ahead / innodb_buffer_pool_read)) * 100 %</p>
<p>InnoDB缓存命中率： innodb_buffer_pool_read_requests /  ( innodb_buffer_pool_read_requests + innodb_buffer_pool_reads  + innodb_buffer_pool_read_ahead )  * 100 %</p>
<p>InnoDB缓存命中率通常要保持在99%以上，才表明内存无压力，这样性能杠杠的。</p>
<p>平均每次读取的字节数= innodb_data_read/innodb_data_reads</p>
<p>内存大于数据文件，并不意味着没有IO操作，Innodb会定时刷脏（将被修改的页刷写到数据文件），并且每次事务提交，会写redo日志。</p>
<h2 id="3、磁盘对数据库性能的影响"><a href="#3、磁盘对数据库性能的影响" class="headerlink" title="3、磁盘对数据库性能的影响"></a>3、磁盘对数据库性能的影响</h2><p>数据库是IO密集型应用，推荐使用raid10(磁盘冗余阵列)</p>
<h2 id="4、SQL语句优化"><a href="#4、SQL语句优化" class="headerlink" title="4、SQL语句优化"></a>4、SQL语句优化</h2><p>SQL语句的优化点基本上会落到是否能利用索引这个问题上来。</p>
<ul>
<li>养成好的SQL使用习惯</li>
</ul>
<p>​      a、禁止使用 select *，应写需要的数据字段。</p>
<p>​      b、尽量使用exists代替in</p>
<ul>
<li>尽量利用索引来加速SQL数据的查询效率</li>
</ul>
<p>以下情况将无法利用索引： </p>
<ul>
<li><p>不支持 != 表达式，如果使用不等于，无法利用到索引。索引的存储结构是B+树，支持等值查询与范围查询。</p>
</li>
<li><p>like ‘%a%’无法利用索引，但’a%’可以使用索引。<br>原因分析，索引的存储结构是B+树，叶子节点存放数据，数据本身是排序的，输入值必须是一个明确的值，方便对比，a%开头的查询，是可以用a当查询关键字首先定位记录的，但%a%无法定位。</p>
</li>
<li><p>复合索引，查询条件必须包含第一列（最左列）<br>道理是一样的，索引的优势就是天生是排序的，查询类似于二分查询（每比较一次，就会缩短查询范围）。<br>例如有两列的复合索引类似(  1, 1  ) (  1, 3  ) (  2, 1  )  (  2, 5  )  (  3, 1  ) 只有包含第一列，整个二元序列就是有序的，但如果剔除第一列，那序列为  1,3,1,5,1，无序序列的查找，复杂度为o(n)。</p>
</li>
<li><p>对字段使用表达式或函数允许，将无法使用索引<br>索引建立原则</p>
<ul>
<li>列高选择性（重复率低）</li>
<li>频繁查询的列</li>
<li>order by 或 group by字段（利用索引的有序性）</li>
</ul>
</li>
</ul>
<h2 id="5、MySQL执行计划解读"><a href="#5、MySQL执行计划解读" class="headerlink" title="5、MySQL执行计划解读"></a>5、MySQL执行计划解读</h2><p>MySQL提供explain查看查询语句的执行计划，使用案例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">  t.id,</span><br><span class="line">  t.order_no,</span><br><span class="line">  t.total_price,</span><br><span class="line">  t.seller_id,</span><br><span class="line">  t.creator,</span><br><span class="line">  t.create_time</span><br><span class="line">FROM</span><br><span class="line">  (</span><br><span class="line">   SELECT a.id,</span><br><span class="line">      a.order_no,</span><br><span class="line">      a.total_price,</span><br><span class="line">      a.seller_id,</span><br><span class="line">      a.creator,</span><br><span class="line">      a.create_time</span><br><span class="line">    FROM</span><br><span class="line">      es_order a</span><br><span class="line">    WHERE</span><br><span class="line">     a.seller_id &#x3D; 24</span><br><span class="line">    LIMIT 20,</span><br><span class="line">    10</span><br><span class="line">  ) t</span><br><span class="line"></span><br><span class="line">INNER JOIN es_order_item b ON b.order_id &#x3D; t.id</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdn.net/20170717201612086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcHJlc3RpZ2VkaW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">相关字段：id、select_type、table、type、prossible_keys、key、ken_len、ref、rows、Extr</p>
<ul>
<li><p>id : 执行顺序，数字越大，先执行。</p>
</li>
<li><p>select_type: (只是标记为查询类型)</p>
<ul>
<li>simple : 查询中不包含子查询或union</li>
<li>primary:若查询中包含任何复杂的子查询，最外层查询标记为：PRIMARY</li>
<li>subquery:子查询</li>
<li>derived:驱动表，不是真实的物理表，但不同于临时表</li>
<li>union:</li>
<li>union result</li>
</ul>
</li>
<li><p>type:访问类型，重点关注<br>取值如下：all、index、range、ref、  eq_ref、  const system、null</p>
<ul>
<li>all : 全表扫描</li>
<li>index: Full Index Scan,index与all的区别为index只遍历索引树。<br>例如：(select a.id from es_order a)</li>
<li>range:索引范围扫描，常见于索引字段上的  between &gt; &lt;  like( like ‘a%’)</li>
<li>ref : 非唯一索引的等值匹配，例如a.seller_id=24 (seller_id上建有索引)</li>
<li>eq_ref:唯一索引的等值匹配</li>
<li>const、system:当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问explain select a.id,a.name from es_order a where a.id=8078</li>
<li>null : 不需要访问表，索引等。</li>
</ul>
</li>
<li><p>possible_keys</p>
<p> 指出mysql能使用哪个索引能在表中找到行，查询涉及到的字段若存在索引，则会列出，但不一定使用</p>
</li>
<li><p>key （重点关注）<br>使用到的索引</p>
</li>
<li><p>key_len (索引用到的长度)</p>
</li>
<li><p>ref 索引匹配的情况（列）【无需太关注】</p>
</li>
<li><p>rows<br>本次查询，预计需要扫描的行数</p>
</li>
<li><p>Extra  额外的说明信息</p>
</li>
<li><p>using index (covering Index)</p>
</li>
<li><p>using where<br>表示mysql服务器从存储引擎收到记录后，进行“后过滤”，如果未使用索引，提醒</p>
</li>
<li><p>Using temporary</p>
</li>
</ul>
<p>​      表示使用了临时表空间（排序、分组）</p>
<ul>
<li>Using filesort</li>
</ul>
<p>​      Mysql中无法利用索引完成的排序操作成为文件排序。</p>
<h2 id="6、数据库设计心得"><a href="#6、数据库设计心得" class="headerlink" title="6、数据库设计心得"></a>6、数据库设计心得</h2><p>1、数据库的表的设计方法论为理解ER关系</p>
<p>   一对一、一对多、多对对（分拆成两个1对多关系，也就是引入一个关系实体）</p>
<p>2）适当打破数据库第三范式<br>适当增加冗余字段，减少表的连接操作。<br>举例：订单表中有商品ID，由于订单反映的当时下单时商品的信息，我们完成可以增加一个冗余字段，商品名称goods_name,这样在展示订单信息时，无需join商品信息表。（冗余字段的增加可能会带来数据的不一致性，所以要结合实际情况，不能为了冗余而冗余）</p>
<p>3）数据库字段类型选择</p>
<p>尽量选择满足需求的最小长度。比如订单状态，可以使用tinyint,而无需使用int。这样的直接好处就是减少数据行的长度，每页能存储更多的数据行，IO效率得到提高。（性能是一个积累的过程）</p>
<p>4）表的垂直分割<br>将一个表的信息分割成多个表，这样主要是保证频繁使用的主表每行的数据尽量少，每页存放更多数据行，提高IO读效率。表分割后，如果每次查询主表，都需要连接查询从表，那就没有必要进行垂直分割。</p>
<p>举例：比如一条资讯信息，咨询的内容使用的类型为(text)，在实际使用时，一般是先出资讯列表，然后点击到每一条资讯时，才去查询资讯内容，此时可以将咨询内容单独分割出一张表，在咨询主表中冗余一个字段（摘要），存放咨询内容的部分信息，用于列表展示。</p>
<p>反例：<br>比如一条评论，有评论内容，类型为text,此时就没必要单独将评论内容抽取出来，因为每次显示评论时，基本上都要查看全部的评论内容，如果分开，会进行多边连接，性能反而受影响。</p>
<p>5）表设计阶段应该考虑索引的建立</p>
<p>应根据系统相关需求，在创建表时建立必要的索引。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>innodb</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis执行SQL的4大基础组件详解</title>
    <url>/posts/7c04b5f0.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、Executor"><a href="#1、Executor" class="headerlink" title="1、Executor"></a>1、Executor</h2><p>sql执行器，其对应的类全路径：org.apache.ibatis.executor.Executor。</p>
<h3 id="1-1-Executor类图"><a href="#1-1-Executor类图" class="headerlink" title="1.1 Executor类图"></a>1.1 Executor类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526170433414.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>Executor<br>执行器根据接口，定义update(更新或插入)、query(查询)、commit(提交事务)、rollback(回滚事务)。接下来简单介绍几个重要方法：</p>
<ul>
<li>int update(MappedStatement ms, Object parameter) throws SQLException<br>更新或插入方法，其参数含义如下：、<br>1）MappedStatement ms：SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）<br>2）Object parameter：参数，通常是List集合。</li>
<li>&lt; E&gt; List&lt; E&gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)<br>查询方法，其参数含义如下：<br>1）RowBounds：行边界，主要值分页参数limit、offset。<br>2）ResultHandler resultHandler：结果处理器。</li>
<li>CacheKey createCacheKey(MappedStatement ms, Object parameterObj, RowBounds bounds, BoundSql bSql)<br>创建缓存Key，Mybatis一二级缓存的缓存Key，可以看出Key由上述4个参数来决定。<br>1）BoundSql boundSql：可以通过该对象获取SQL语句。</li>
</ul>
</li>
<li><p>CachingExecutor<br>支持结果缓存的SQL执行器，注意其设计模式的应用，该类中，会持有Executor的一个委托对象，CachingExecutor关注与缓存特定的逻辑，其最终的SQL执行由其委托对象来实现，即其内部的委托对象为BaseExecutor的实现类。</p>
</li>
<li><p>BaseExecutor<br>Executor的基础实现类，该类为抽象类，关于查询、更新具体的实现由其子类来实现，下面4个都是其子类。</p>
</li>
<li><p>SimpleExecutor<br>简单的Executor执行器。</p>
</li>
<li><p>BatchExecutor<br>支持批量执行的Executor执行器。</p>
</li>
<li><p>ClosedExecutor<br>表示一个已关闭的Executor。</p>
</li>
<li><p>ReuseExecutor<br>支持重复使用Statement,以SQL为键，缓存Statement对象。</p>
</li>
</ul>
<h3 id="1-2-创建Executor"><a href="#1-2-创建Executor" class="headerlink" title="1.2 创建Executor"></a>1.2 创建Executor</h3><p>在Mybatis中，Executor的创建由Configuration对象来创建，具体的代码如下：</p>
<h4 id="Configuration-newExecitor"><a href="#Configuration-newExecitor" class="headerlink" title="Configuration#newExecitor"></a>Configuration#newExecitor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> newExecutor(transaction, defaultExecutorType);   <span class="comment">// @1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;   <span class="comment">// @2</span></span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123; <span class="comment">// @3</span></span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);  <span class="comment">// @4</span></span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看出，Executor的创建由如下三个关键点：<br>代码@1：默认的ExecutorType为ExecutorType.SIMPLE，即默认创建的Executory为SimpleExecutor。<br>代码@2：根据executorType的值创建对应的Executory。<br>代码@3：如果cacheEnabled为true，则创建CachingExecutory，然后在其内部持有上面创建的Executor,cacheEnabled默认为true，则默认创建的Executor为CachingExecutor，并且其内部包裹着SimpleExecutor。<br>代码@4：使用InterceptorChain.pluginAll为executor创建代理对象，即Mybatis的拆件机制，将在该系列文章中详细介绍。</p>
<a id="more"></a>

<h2 id="2、StatementHandler"><a href="#2、StatementHandler" class="headerlink" title="2、StatementHandler"></a>2、StatementHandler</h2><p>在学习StatementHandler之前，我们先来回顾一下JDBC相关的知识。JDBC与语句执行的两大主流对象：java.sql.Statement、java.sql.PrepareStatement对象大家应该不会陌生，该对象的execute方法就是执行SQL语句的入口，通过java.sql.Connection对象创建Statement对象。Mybatis的StatementHandler，是Mybatis创建Statement对象的处理器，即StatementHandler会接管Statement对象的创建。</p>
<h3 id="2-1-StatementHandler类图"><a href="#2-1-StatementHandler类图" class="headerlink" title="2.1 StatementHandler类图"></a>2.1 StatementHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171050653.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>StatementHandler<br>根接口，我们重点关注一下其定义的方法：</p>
<ul>
<li>Statement prepare(Connection connection)<br>创建Statement对象，即该方法会通过Connection对象创建Statement对象。</li>
<li>void parameterize(Statement statement)<br>对Statement对象参数化，特别是PreapreStatement对象。</li>
<li>void batch(Statement statement)<br>批量执行SQL。</li>
<li>int update(Statement statement)<br>更新操作。</li>
<li>&lt; E&gt; List&lt; E&gt; query(Statement statement, ResultHandler resultHandler)<br>查询操作。</li>
<li>BoundSql getBoundSql()<br>获取SQL语句。</li>
<li>ParameterHandler getParameterHandler()<br>获取对应的参数处理器。</li>
</ul>
</li>
<li><p>BaseStatementHandler<br>StatementHandler的抽象实现类，SimpleStatementHandler、PrepareStatementHandler、CallableStatementHandler是其子类。<br>我们来一一看一下其示例变量：</p>
<ul>
<li>Configuration configuration<br>Mybatis全局配置对象。</li>
<li>ObjectFactory objectFactory<br>对象工厂。</li>
<li>TypeHandlerRegistry typeHandlerRegistry<br>类型注册器。</li>
<li>ResultSetHandler resultSetHandler<br>结果集Handler。</li>
<li>ParameterHandler parameterHandler<br>参数处理器Handler。</li>
<li>Executor executor<br>SQL执行器。</li>
<li>MappedStatement mappedStatement<br>SQL映射语句（Mapper.xml文件每一个方法对应一个MappedStatement对象）</li>
<li>RowBounds rowBounds<br>行边界，主要值分页参数limit、offset。</li>
<li>BoundSql boundSql<br>可以通过该对象获取SQL语句。</li>
</ul>
</li>
<li><p>SimpleStatementHandler<br>具体的StatementHandler实现器，java.sql.Statement对象创建处理器。</p>
</li>
<li><p>PrepareStatementHandler<br>java.sql.PrepareStatement对象的创建处理器。</p>
</li>
<li><p>CallableStatementHandler<br>java.sql.CallableStatement对象的创建处理器，可用来执行存储过程调用的Statement。</p>
</li>
<li><p>RoutingStatementHandler<br>StatementHandler路由器，我们看一下其构造方法后，就会对该类了然于胸。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoutingStatementHandler</span><span class="params">(Executor executor, MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (ms.getStatementType()) &#123; <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">case</span> STATEMENT:</span><br><span class="line">      delegate = <span class="keyword">new</span> SimpleStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PREPARED:</span><br><span class="line">      delegate = <span class="keyword">new</span> PreparedStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> CALLABLE:</span><br><span class="line">      delegate = <span class="keyword">new</span> CallableStatementHandler(executor, ms, parameter, rowBounds, resultHandler, boundSql);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Unknown statement type: &quot;</span> + ms.getStatementType());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来是会根据MappedStatement对象的statementType创建对应的StatementHandler。</p>
</li>
</ul>
<h3 id="2-2-创建StatementHandler"><a href="#2-2-创建StatementHandler" class="headerlink" title="2.2 创建StatementHandler"></a>2.2 创建StatementHandler</h3><h4 id="Configuration-newStatementHandler"><a href="#Configuration-newStatementHandler" class="headerlink" title="Configuration#newStatementHandler"></a>Configuration#newStatementHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatementHandler <span class="title">newStatementHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  StatementHandler statementHandler = <span class="keyword">new</span> RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql); <span class="comment">// @1</span></span><br><span class="line">  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler); <span class="comment">// @2</span></span><br><span class="line">  <span class="keyword">return</span> statementHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的两个关键点如下：<br>代码@1：创建RoutingStatementHandler对象，在其内部再根据SQL语句的类型，创建对应的StatementHandler对象。<br>代码@2：对StatementHandler引入拆件机制，该部分将在该专题的后续文章中会详细介绍，这里暂时跳过。</p>
<h2 id="3、ParameterHandler"><a href="#3、ParameterHandler" class="headerlink" title="3、ParameterHandler"></a>3、ParameterHandler</h2><p>参数处理器。同样我们先来看一下其类图。</p>
<h3 id="3-1-ParameterHandler类图"><a href="#3-1-ParameterHandler类图" class="headerlink" title="3.1 ParameterHandler类图"></a>3.1 ParameterHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171502281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这个比较简单，就是处理PreparedStatemet接口的参数化处理，也可以顺便看一下其调用链(该部分会在下一篇中详细介绍)。<br><img src="https://img-blog.csdnimg.cn/20190526171635381.png" alt="在这里插入图片描述"></p>
<h3 id="3-2-创建ParameterHandler"><a href="#3-2-创建ParameterHandler" class="headerlink" title="3.2 创建ParameterHandler"></a>3.2 创建ParameterHandler</h3><h4 id="Configuration-newParameterHandler"><a href="#Configuration-newParameterHandler" class="headerlink" title="Configuration#newParameterHandler"></a>Configuration#newParameterHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ParameterHandler <span class="title">newParameterHandler</span><span class="params">(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);</span><br><span class="line">  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);  <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">return</span> parameterHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样该接口也支持插件化机制。</p>
<h2 id="4、ResultSetHandler"><a href="#4、ResultSetHandler" class="headerlink" title="4、ResultSetHandler"></a>4、ResultSetHandler</h2><p>处理结果的Handler。我们同样看一下其类图。</p>
<h3 id="4-1-ResultSetHandler类图"><a href="#4-1-ResultSetHandler类图" class="headerlink" title="4.1 ResultSetHandler类图"></a>4.1 ResultSetHandler类图</h3><p><img src="https://img-blog.csdnimg.cn/20190526171756530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>处理Jdbc ResultSet的处理器。</p>
<h3 id="4-2-ResultSetHandler创建"><a href="#4-2-ResultSetHandler创建" class="headerlink" title="4.2 ResultSetHandler创建"></a>4.2 ResultSetHandler创建</h3><h4 id="Configuration-newResultSetHandler"><a href="#Configuration-newResultSetHandler" class="headerlink" title="Configuration#newResultSetHandler"></a>Configuration#newResultSetHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ResultSetHandler <span class="title">newResultSetHandler</span><span class="params">(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResultHandler resultHandler, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  ResultSetHandler resultSetHandler = <span class="keyword">new</span> DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);</span><br><span class="line">  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);</span><br><span class="line">  <span class="keyword">return</span> resultSetHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样支持插件化机制，我们也稍微再看一下其调用链：<br><img src="https://img-blog.csdnimg.cn/20190526171844420.png" alt="在这里插入图片描述"><br>可以看出其调用的入口为SQL执行时。</p>
<p>本文作为下一篇《源码分析Mybatis整合ShardingJdbc SQL执行流程》的前置篇，重点介绍Executor、StatementHandler、ParameterHandler、ResultSetHandler的具体职责，以类图为基础并详细介绍其核心方法的作用，然后详细介绍了这些对象是如何创建，并引出Mybatis拆件机制。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>Executor</tag>
        <tag>StatementHandler</tag>
        <tag>ParameterHandler</tag>
        <tag>ResultSetHandler</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty4 Channel 概述</title>
    <url>/posts/a79560fc.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>专栏介绍：《让天下没有难学的Netty》系列，基于 Netty，以源码分析为主要手段，关键流程给出流程图，从 通道篇、内存篇、性能篇三个维度深度剖析 Netty 的实现原理。 </p>
</blockquote>
<h2 id="1、通道概述"><a href="#1、通道概述" class="headerlink" title="1、通道概述"></a>1、通道概述</h2><p>我们从如下几个方面来简单了解一下 Channel。</p>
<ul>
<li>通道的当前状态，open(端口打开)、connect(连接)。</li>
<li>通道的配置，包含通道的配置属性与网络通信选项(ChannelOption)。</li>
<li>IO 通道方法诸如 read、write、connect、bind 与管道(ChannelPipeline)。</li>
<li>所有 IO 操作在 Netty 中都是异步的，调用 IO 方法例如 write 方法后，并不是等 IO 操作实际完成后再返回，而是会立即返回一个凭证，IO 操作完成后会将结果写入凭证中，典型的 Future设计模式。</li>
<li>Channel 具有父子关系，由于所有的 SocketChannel（客户端发起TCP连接）都是由 ServerSocketChannel（服务端接收连接）接收客户端连接而创建的，故 SocketChannel 的 parent() 方法会返回对应的 ServerSocketChannel。</li>
<li>所有通道对象在使用完后，请务必调用通道的colse方法来释放资源。</li>
</ul>
<p>本节将从如下3个方面来重点介绍Channel。</p>
<ul>
<li>Channel 常用API</li>
<li>Channel 配置与选项</li>
<li>NIO相关的Channel继承图</li>
</ul>
<a id="more"></a>

<h2 id="2、Channel常用API"><a href="#2、Channel常用API" class="headerlink" title="2、Channel常用API"></a>2、Channel常用API</h2><p>Channel 类图结构如下：<br><img src="https://img-blog.csdnimg.cn/20201129210717360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心API一览：</p>
<ul>
<li>EventLoop eventLoop()<br>返回该通道注册的事件轮询器。</li>
<li>Channel parent()<br>返回该通道的父通道，如果是ServerSocketChannel实例则返回null，SocketChannel实例则返回对应的ServerSocketChannel。</li>
<li>ChannelConfig config()<br>返回该通道的配置参数。</li>
<li>boolean isOpen()<br>端口是否处于open，通道默认一创建isOpen方法就会返回true，close方法被调用后该方法返回false。</li>
<li>boolean isRegistered()<br>是否已注册到EventLoop。</li>
<li>public boolean isActive()<br>通道是否处于激活。NioSocketChannel的实现是java.nio.channels.SocketChannel实例的isOpen()与isConnected()都返回true。NioServerSocketChannel的实现是ServerSocketChannel.socket().isBound()，如果绑定到端口中，意味着处于激活状态。</li>
<li>ChannelFuture closeFuture()<br>Future模式的应用，调用该方法的目的并不是关闭通道，而是预先创建一个凭证(Future)，等通道关闭时，会通知该Future，用户可以通过该Future注册事件。</li>
<li>ChannelFuture bind(SocketAddress localAddress)<br>Netty服务端绑定到本地端口，开始监听客户端的连接请求。该过程会触发事件链(ChannelPipeline)。该部分将在后续讲解服务端启动流程时再详细分析。</li>
<li>ChannelFuture connect(SocketAddress remoteAddress)<br>Netty客户端连接到服务端，该过程同样会触发一系列事件(ChannelPipeline)。该部分将在后续讲解客户端启动流程时再详细分析。</li>
<li>ChannelFuture disconnect()<br>断开连接，但不会释放资源，该通道还可以再通过connect重新与服务器建立连接。</li>
<li>ChannelFuture close()<br>关闭通道，回收资源，该通道的生命周期完全结束。</li>
<li>ChannelFuture deregister()<br>取消注册。</li>
<li>Channel read()<br>通道读，该方法并不是直接从读写缓存区读取文件，而是向NIO Selecor注册读事件（目前主要基于NIO）。当通道收到对端的数后，事件选择器会处理读事件，从而触发ChannelInboundHandler#channelRead 事件，然后继续触发ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)事件。</li>
<li>ChannelFuture write(Object msg)<br>向通道写字节流，会触发响应的写事件链，该方法只是会将字节流写入到通道缓存区，并不会调用flush方法写入通道中。</li>
<li>Channel flush()<br>刷写所有挂起的消息（刷写到流中）。</li>
<li>ChannelFuture writeAndFlush(Object msg)<br>相当于调用write与flush方法。</li>
</ul>
<h2 id="3、Channel配置与选项"><a href="#3、Channel配置与选项" class="headerlink" title="3、Channel配置与选项"></a>3、Channel配置与选项</h2><h4 id="3-1-Channel配置"><a href="#3-1-Channel配置" class="headerlink" title="3.1 Channel配置"></a>3.1 Channel配置</h4><p>ChannelConfig 的类图如下：<br><img src="https://img-blog.csdnimg.cn/20201129210953154.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心配置如下：</p>
<ul>
<li>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options：选项，在下文会重点介绍。</li>
<li>int connectTimeoutMillis：连接超时时间。</li>
<li>int maxMessagesPerRead：每次读事件中调用读方法的最大次数(AbstractNioByteChannel)或读事件循环中最多处理的消息条数(AbstractNioMessageChannel)。</li>
<li>int writeSpinCount：一次写事件处理期间最多调用write方法的次数，引入该机制主要是为了避免一个网络通道写入大量数据，对其他网络通道的读写处理带来延迟，默认值为16。</li>
<li>ByteBufAllocator getAllocator()：返回该通道的内存分配器(ByteBuf)。<br>RecvByteBufAllocator getRecvByteBufAllocator()：读事件读缓冲区的分配策略。</li>
<li>boolean autoRead：是否自动触发read方法调用，默认为true，读事件触发后自动调用read方法 ，而无需应用程序显示调用。</li>
<li>int writeBufferHighWaterMark：设置写缓存区的高水位线。如果写缓存区中的数据超过该值，Channel#isWritable()方法将返回false。</li>
<li>int writeBufferLowWaterMark：设置写缓存区的低水位线。如果写缓存区的数据超过高水位线后，通道将变得不可写，等写缓存数据降低到低水位线后通道恢复可写状态(Channel#isWritable()将再次返回true)。<h4 id="3-2-ChannelOption"><a href="#3-2-ChannelOption" class="headerlink" title="3.2 ChannelOption"></a>3.2 ChannelOption</h4><img src="https://img-blog.csdnimg.cn/20201129211116360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>网络通道(Channel)选项值，下面介绍一下与TCP协议相关的核心参数：</li>
<li>SO_BROADCAST<br>选择值类型:boolean。表值该数据包是否是广播包，true表示广播包，false表示非广播，如果包的IP地址为广播地址，但该选型为false，则在内核层会抛出错误。</li>
<li>SO_KEEPALIVE<br>对于面向连接的TCP socket,在实际应用中通常都要检测对端是否处于连接中,连接端口分两种情况:<ul>
<li><pre><code>连接正常关闭,调用close() shutdown()连接优雅关闭,send与recv立马返回错误,select返回SOCK_ERR</code></pre>
</li>
<li><pre><code>连接的对端异常关闭,比如网络断掉,突然断电.</code></pre>
</li>
</ul>
</li>
<li>SO_SNDBUF的大小<br>为了达到最大网络吞吐，socket send buffer size(SO_SNDBUF)不应该小于带宽和延迟的乘积。</li>
<li>SO_REUSEADDR<br>该参数如果设置为true的一个常用应用场景是端口复用(直接复用TIME_WAIT状态的socket)。</li>
<li>SO_LINGER<br>该参数是控制TCP关闭行为的。</li>
<li>SO_BACKLOG<br>服务端接受客户端连接的处理队列，在TCP三次握手协议中，服务端接收到客户端的SYN包后，会向客户端发送SYN+ACK包，同时会将连接放入到 backlog 队列中，等待客户端ACK包。在服务端没有接收到客户端的ACK包之前，连接会暂存 backlog 队列。</li>
<li>SO_TIMEOUT<br>以毫秒为单位定义套接字超时(SO_TIMEOUT)，它是等待数据的超时，或者换句话说，是两个连续数据包之间的最大活动周期。超时值为0将被解释为无限超时。如果没有设置该参数，读取操作将不会超时(无穷小超时)。个人思考：在NIO编程开发中应该不要设置该值，但为了保证每个连接的读平等，Netty会控制一次事件选择周期，最多可调用read方法的次数。</li>
<li>TCP_NODELAY<br>在TCP数据包发送的时候，有一种算法（Nagle算法）。该算法的核心是如果发生数据包比较小，为了提高带宽的利用率，会等待更多的数据到达后再发送或等待超时后将小包发送，也就是TCP发送延迟，TCP_NODELAY=true表示不使用tcp delay延迟，故禁用Nagle算法。通常接受端的ACK包也会使用延迟（默认40ms)，旨在合并多个ACK确认包。<br>Nagle 算法的改进在于：如果发送端欲多次发送包含少量字符的数据包(一般情况下,后面统一称长度小于MSS的数据包为小包,与此相对,称长度等于MSS的数据包为大包,为了某些对比说明,还有中包,即长度比小包长,但又不足一个MSS的包;MSS,TCP最大分段大小,以太网下一般就是1460字节。),则发送端会先将第一个小包发送出去,而将后面到达的少量字符数据都缓存起来而不立即发送,直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据,或者积攒到了一定数量的数据(比如缓存的字符数据已经达到数据包报文段的最大长度)等多种情况才将其组成一个较大的数据包发送出去。</li>
</ul>
<h2 id="4、Channel-NIO-继承图"><a href="#4、Channel-NIO-继承图" class="headerlink" title="4、Channel NIO 继承图"></a>4、Channel NIO 继承图</h2><p>Channel 类继承图主要是想展示一下与 NIO 相关的 NioSocketChannel (客户端通道)与NioServerSocketChannel (服务端通道)在 Channel 中的位置。<br><img src="https://img-blog.csdnimg.cn/20201129212730624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Channel 通道统一抽象接口。</p>
<ul>
<li>AbstractChannel 通道默认抽象实现类</li>
<li>AbstractEpollChannel unix Epoll通道实现</li>
<li>AbstractOioChannel 阻塞IO通道抽象类</li>
<li>AbstractNioChannel NIO通道抽象类</li>
<li>AbstractNioByteChannel NIO客户端通道抽象类</li>
<li>AbstractNIoMessageChannel NIO服务端通道抽象类</li>
<li>NioSocketChannel  NIO客户端通道实现类</li>
<li>NioServerSocketChannel NIO服务端通道实现类</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>netty4</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>netty4</tag>
        <tag>Channel</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty4 ChannelHandler 概述</title>
    <url>/posts/eab70bff.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>专栏介绍：《让天下没有难学的Netty》系列，基于 Netty，以源码分析为主要手段，关键流程给出流程图，从 通道篇、内存篇、性能篇三个维度深度剖析 Netty 的实现原理。 </p>
</blockquote>
<h2 id="1、通道概述"><a href="#1、通道概述" class="headerlink" title="1、通道概述"></a>1、通道概述</h2><p>我们从如下几个方面来简单了解一下 Channel。</p>
<ul>
<li>通道的当前状态，open(端口打开)、connect(连接)。</li>
<li>通道的配置，包含通道的配置属性与网络通信选项(ChannelOption)。</li>
<li>IO 通道方法诸如 read、write、connect、bind 与管道(ChannelPipeline)。</li>
<li>所有 IO 操作在 Netty 中都是异步的，调用 IO 方法例如 write 方法后，并不是等 IO 操作实际完成后再返回，而是会立即返回一个凭证，IO 操作完成后会将结果写入凭证中，典型的 Future设计模式。</li>
<li>Channel 具有父子关系，由于所有的 SocketChannel（客户端发起TCP连接）都是由 ServerSocketChannel（服务端接收连接）接收客户端连接而创建的，故 SocketChannel 的 parent() 方法会返回对应的 ServerSocketChannel。</li>
<li>所有通道对象在使用完后，请务必调用通道的colse方法来释放资源。</li>
</ul>
<p>本节将从如下3个方面来重点介绍Channel。</p>
<ul>
<li>Channel 常用API</li>
<li>Channel 配置与选项</li>
<li>NIO相关的Channel继承图</li>
</ul>
<a id="more"></a>

<h2 id="2、Channel常用API"><a href="#2、Channel常用API" class="headerlink" title="2、Channel常用API"></a>2、Channel常用API</h2><p>Channel 类图结构如下：<br><img src="https://img-blog.csdnimg.cn/20201129210717360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心API一览：</p>
<ul>
<li>EventLoop eventLoop()<br>返回该通道注册的事件轮询器。</li>
<li>Channel parent()<br>返回该通道的父通道，如果是ServerSocketChannel实例则返回null，SocketChannel实例则返回对应的ServerSocketChannel。</li>
<li>ChannelConfig config()<br>返回该通道的配置参数。</li>
<li>boolean isOpen()<br>端口是否处于open，通道默认一创建isOpen方法就会返回true，close方法被调用后该方法返回false。</li>
<li>boolean isRegistered()<br>是否已注册到EventLoop。</li>
<li>public boolean isActive()<br>通道是否处于激活。NioSocketChannel的实现是java.nio.channels.SocketChannel实例的isOpen()与isConnected()都返回true。NioServerSocketChannel的实现是ServerSocketChannel.socket().isBound()，如果绑定到端口中，意味着处于激活状态。</li>
<li>ChannelFuture closeFuture()<br>Future模式的应用，调用该方法的目的并不是关闭通道，而是预先创建一个凭证(Future)，等通道关闭时，会通知该Future，用户可以通过该Future注册事件。</li>
<li>ChannelFuture bind(SocketAddress localAddress)<br>Netty服务端绑定到本地端口，开始监听客户端的连接请求。该过程会触发事件链(ChannelPipeline)。该部分将在后续讲解服务端启动流程时再详细分析。</li>
<li>ChannelFuture connect(SocketAddress remoteAddress)<br>Netty客户端连接到服务端，该过程同样会触发一系列事件(ChannelPipeline)。该部分将在后续讲解客户端启动流程时再详细分析。</li>
<li>ChannelFuture disconnect()<br>断开连接，但不会释放资源，该通道还可以再通过connect重新与服务器建立连接。</li>
<li>ChannelFuture close()<br>关闭通道，回收资源，该通道的生命周期完全结束。</li>
<li>ChannelFuture deregister()<br>取消注册。</li>
<li>Channel read()<br>通道读，该方法并不是直接从读写缓存区读取文件，而是向NIO Selecor注册读事件（目前主要基于NIO）。当通道收到对端的数后，事件选择器会处理读事件，从而触发ChannelInboundHandler#channelRead 事件，然后继续触发ChannelInboundHandler#channelReadComplete(ChannelHandlerContext)事件。</li>
<li>ChannelFuture write(Object msg)<br>向通道写字节流，会触发响应的写事件链，该方法只是会将字节流写入到通道缓存区，并不会调用flush方法写入通道中。</li>
<li>Channel flush()<br>刷写所有挂起的消息（刷写到流中）。</li>
<li>ChannelFuture writeAndFlush(Object msg)<br>相当于调用write与flush方法。</li>
</ul>
<h2 id="3、Channel配置与选项"><a href="#3、Channel配置与选项" class="headerlink" title="3、Channel配置与选项"></a>3、Channel配置与选项</h2><h4 id="3-1-Channel配置"><a href="#3-1-Channel配置" class="headerlink" title="3.1 Channel配置"></a>3.1 Channel配置</h4><p>ChannelConfig 的类图如下：<br><img src="https://img-blog.csdnimg.cn/20201129210953154.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>核心配置如下：</p>
<ul>
<li>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options：选项，在下文会重点介绍。</li>
<li>int connectTimeoutMillis：连接超时时间。</li>
<li>int maxMessagesPerRead：每次读事件中调用读方法的最大次数(AbstractNioByteChannel)或读事件循环中最多处理的消息条数(AbstractNioMessageChannel)。</li>
<li>int writeSpinCount：一次写事件处理期间最多调用write方法的次数，引入该机制主要是为了避免一个网络通道写入大量数据，对其他网络通道的读写处理带来延迟，默认值为16。</li>
<li>ByteBufAllocator getAllocator()：返回该通道的内存分配器(ByteBuf)。<br>RecvByteBufAllocator getRecvByteBufAllocator()：读事件读缓冲区的分配策略。</li>
<li>boolean autoRead：是否自动触发read方法调用，默认为true，读事件触发后自动调用read方法 ，而无需应用程序显示调用。</li>
<li>int writeBufferHighWaterMark：设置写缓存区的高水位线。如果写缓存区中的数据超过该值，Channel#isWritable()方法将返回false。</li>
<li>int writeBufferLowWaterMark：设置写缓存区的低水位线。如果写缓存区的数据超过高水位线后，通道将变得不可写，等写缓存数据降低到低水位线后通道恢复可写状态(Channel#isWritable()将再次返回true)。<h4 id="3-2-ChannelOption"><a href="#3-2-ChannelOption" class="headerlink" title="3.2 ChannelOption"></a>3.2 ChannelOption</h4><img src="https://img-blog.csdnimg.cn/20201129211116360.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>网络通道(Channel)选项值，下面介绍一下与TCP协议相关的核心参数：</li>
<li>SO_BROADCAST<br>选择值类型:boolean。表值该数据包是否是广播包，true表示广播包，false表示非广播，如果包的IP地址为广播地址，但该选型为false，则在内核层会抛出错误。</li>
<li>SO_KEEPALIVE<br>对于面向连接的TCP socket,在实际应用中通常都要检测对端是否处于连接中,连接端口分两种情况:<ul>
<li><pre><code>连接正常关闭,调用close() shutdown()连接优雅关闭,send与recv立马返回错误,select返回SOCK_ERR</code></pre>
</li>
<li><pre><code>连接的对端异常关闭,比如网络断掉,突然断电.</code></pre>
</li>
</ul>
</li>
<li>SO_SNDBUF的大小<br>为了达到最大网络吞吐，socket send buffer size(SO_SNDBUF)不应该小于带宽和延迟的乘积。</li>
<li>SO_REUSEADDR<br>该参数如果设置为true的一个常用应用场景是端口复用(直接复用TIME_WAIT状态的socket)。</li>
<li>SO_LINGER<br>该参数是控制TCP关闭行为的。</li>
<li>SO_BACKLOG<br>服务端接受客户端连接的处理队列，在TCP三次握手协议中，服务端接收到客户端的SYN包后，会向客户端发送SYN+ACK包，同时会将连接放入到 backlog 队列中，等待客户端ACK包。在服务端没有接收到客户端的ACK包之前，连接会暂存 backlog 队列。</li>
<li>SO_TIMEOUT<br>以毫秒为单位定义套接字超时(SO_TIMEOUT)，它是等待数据的超时，或者换句话说，是两个连续数据包之间的最大活动周期。超时值为0将被解释为无限超时。如果没有设置该参数，读取操作将不会超时(无穷小超时)。个人思考：在NIO编程开发中应该不要设置该值，但为了保证每个连接的读平等，Netty会控制一次事件选择周期，最多可调用read方法的次数。</li>
<li>TCP_NODELAY<br>在TCP数据包发送的时候，有一种算法（Nagle算法）。该算法的核心是如果发生数据包比较小，为了提高带宽的利用率，会等待更多的数据到达后再发送或等待超时后将小包发送，也就是TCP发送延迟，TCP_NODELAY=true表示不使用tcp delay延迟，故禁用Nagle算法。通常接受端的ACK包也会使用延迟（默认40ms)，旨在合并多个ACK确认包。<br>Nagle 算法的改进在于：如果发送端欲多次发送包含少量字符的数据包(一般情况下,后面统一称长度小于MSS的数据包为小包,与此相对,称长度等于MSS的数据包为大包,为了某些对比说明,还有中包,即长度比小包长,但又不足一个MSS的包;MSS,TCP最大分段大小,以太网下一般就是1460字节。),则发送端会先将第一个小包发送出去,而将后面到达的少量字符数据都缓存起来而不立即发送,直到收到接收端对前一个数据包报文段的ACK确认、或当前字符属于紧急数据,或者积攒到了一定数量的数据(比如缓存的字符数据已经达到数据包报文段的最大长度)等多种情况才将其组成一个较大的数据包发送出去。</li>
</ul>
<h2 id="4、Channel-NIO-继承图"><a href="#4、Channel-NIO-继承图" class="headerlink" title="4、Channel NIO 继承图"></a>4、Channel NIO 继承图</h2><p>Channel 类继承图主要是想展示一下与 NIO 相关的 NioSocketChannel (客户端通道)与NioServerSocketChannel (服务端通道)在 Channel 中的位置。<br><img src="https://img-blog.csdnimg.cn/20201129212730624.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Channel 通道统一抽象接口。</p>
<ul>
<li>AbstractChannel 通道默认抽象实现类</li>
<li>AbstractEpollChannel unix Epoll通道实现</li>
<li>AbstractOioChannel 阻塞IO通道抽象类</li>
<li>AbstractNioChannel NIO通道抽象类</li>
<li>AbstractNioByteChannel NIO客户端通道抽象类</li>
<li>AbstractNIoMessageChannel NIO服务端通道抽象类</li>
<li>NioSocketChannel  NIO客户端通道实现类</li>
<li>NioServerSocketChannel NIO服务端通道实现类</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>netty4</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>netty4</tag>
        <tag>ChannelHandler</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ ACL 使用指南</title>
    <url>/posts/7b95946e.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、什么是ACL"><a href="#1、什么是ACL" class="headerlink" title="1、什么是ACL?"></a>1、什么是ACL?</h2><p>ACL是access control list的简称，俗称访问控制列表。访问控制，基本上会涉及到用户、资源、权限、角色等概念，那在RocketMQ中上述会对应哪些对象呢？</p>
<ul>
<li>用户<br>用户是访问控制的基础要素，也不难理解，RocketMQ ACL必然也会引入用户的概念，即支持用户名、密码。</li>
<li>资源<br>资源，需要保护的对象，在RocketMQ中，消息发送涉及的Topic、消息消费涉及的消费组，应该进行保护，故可以抽象成资源。</li>
<li>权限<br>针对资源，能进行的操作，</li>
<li>角色<br>RocketMQ中，只定义两种角色：是否是管理员。</li>
</ul>
<p>另外，RocketMQ还支持按照客户端IP进行白名单设置。</p>
<h2 id="2、ACL基本流程图"><a href="#2、ACL基本流程图" class="headerlink" title="2、ACL基本流程图"></a>2、ACL基本流程图</h2><p>在讲解如何使用ACL之前，我们先简单看一下RocketMQ ACL的请求流程：<br><img src="https://img-blog.csdnimg.cn/2019063014185470.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>对于上述具体的实现，将在后续文章中重点讲解，本文的目的只是希望给读者一个大概的了解。</p>
<h2 id="3、如何配置ACL"><a href="#3、如何配置ACL" class="headerlink" title="3、如何配置ACL"></a>3、如何配置ACL</h2><h3 id="3-1-acl配置文件"><a href="#3-1-acl配置文件" class="headerlink" title="3.1 acl配置文件"></a>3.1 acl配置文件</h3><p>acl默认的配置文件名：plain_acl.yml,需要放在${ROCKETMQ_HOME}/store/config目录下。下面对其配置项一一介绍。</p>
<a id="more"></a>

<h4 id="3-1-1-globalWhiteRemoteAddresses"><a href="#3-1-1-globalWhiteRemoteAddresses" class="headerlink" title="3.1.1 globalWhiteRemoteAddresses"></a>3.1.1 globalWhiteRemoteAddresses</h4><p>全局白名单，其类型为数组，即支持多个配置。其支持的配置格式如下：</p>
<ul>
<li>空<br>表示不设置白名单，该条规则默认返回false。</li>
<li>“*”<br>表示全部匹配，该条规则直接返回true，将会阻断其他规则的判断，请慎重使用。</li>
<li>192.168.0.{100,101}<br>多地址配置模式，ip地址的最后一组，使用{}，大括号中多个ip地址，用英文逗号(,)隔开。</li>
<li>192.168.1.100,192.168.2.100<br>直接使用,分隔，配置多个ip地址。</li>
<li>192.168.*.<em>或192.168.100-200.10-20<br>每个IP段使用 “</em>“ 或”-“表示范围。</li>
</ul>
<h4 id="3-1-2-accounts"><a href="#3-1-2-accounts" class="headerlink" title="3.1.2 accounts"></a>3.1.2 accounts</h4><p>配置用户信息，该类型为数组类型。拥有accessKey、secretKey、whiteRemoteAddress、admin、defaultTopicPerm、defaultGroupPerm、topicPerms、groupPerms子元素。</p>
<h5 id="3-1-2-1-accessKey"><a href="#3-1-2-1-accessKey" class="headerlink" title="3.1.2.1 accessKey"></a>3.1.2.1 accessKey</h5><p>登录用户名，长度必须大于6个字符。</p>
<h5 id="3-1-2-2-secretKey"><a href="#3-1-2-2-secretKey" class="headerlink" title="3.1.2.2 secretKey"></a>3.1.2.2 secretKey</h5><p>登录密码。长度必须大于6个字符。</p>
<h5 id="3-1-2-3-whiteRemoteAddress"><a href="#3-1-2-3-whiteRemoteAddress" class="headerlink" title="3.1.2.3 whiteRemoteAddress"></a>3.1.2.3 whiteRemoteAddress</h5><p>用户级别的IP地址白名单。其类型为一个字符串，其配置规则与globalWhiteRemoteAddresses，但只能配置一条规则。</p>
<h5 id="3-1-2-4-admin"><a href="#3-1-2-4-admin" class="headerlink" title="3.1.2.4 admin"></a>3.1.2.4 admin</h5><p>boolean类型，设置是否是admin。如下权限只有admin=true时才有权限执行。</p>
<ul>
<li>UPDATE_AND_CREATE_TOPIC<br>更新或创建主题。</li>
<li>UPDATE_BROKER_CONFIG<br>更新Broker配置。</li>
<li>DELETE_TOPIC_IN_BROKER<br>删除主题。</li>
<li>UPDATE_AND_CREATE_SUBSCRIPTIONGROUP<br>更新或创建订阅组信息。</li>
<li>DELETE_SUBSCRIPTIONGROUP<br>删除订阅组信息。</li>
</ul>
<h5 id="3-1-2-5-defaultTopicPerm"><a href="#3-1-2-5-defaultTopicPerm" class="headerlink" title="3.1.2.5 defaultTopicPerm"></a>3.1.2.5 defaultTopicPerm</h5><p>默认topic权限。该值默认为DENY(拒绝)。</p>
<h5 id="3-1-2-6-defaultGroupPerm"><a href="#3-1-2-6-defaultGroupPerm" class="headerlink" title="3.1.2.6 defaultGroupPerm"></a>3.1.2.6 defaultGroupPerm</h5><p>默认消费组权限，该值默认为DENY(拒绝)，建议值为SUB。</p>
<h5 id="3-1-2-7-topicPerms"><a href="#3-1-2-7-topicPerms" class="headerlink" title="3.1.2.7 topicPerms"></a>3.1.2.7 topicPerms</h5><p>设置topic的权限。其类型为数组，其可选择值在下节介绍。</p>
<h5 id="3-1-2-8-groupPerms"><a href="#3-1-2-8-groupPerms" class="headerlink" title="3.1.2.8 groupPerms"></a>3.1.2.8 groupPerms</h5><p>设置消费组的权限。其类型为数组，其可选择值在下节介绍。可以为每一消费组配置不一样的权限。</p>
<h3 id="3-2-RocketMQ-ACL权限可选值"><a href="#3-2-RocketMQ-ACL权限可选值" class="headerlink" title="3.2 RocketMQ ACL权限可选值"></a>3.2 RocketMQ ACL权限可选值</h3><ul>
<li>DENY<br>拒绝。</li>
<li>PUB<br>拥有发送权限。</li>
<li>SUB<br>拥有订阅权限。</li>
</ul>
<h3 id="3-3、权限验证流程"><a href="#3-3、权限验证流程" class="headerlink" title="3.3、权限验证流程"></a>3.3、权限验证流程</h3><p>上面定义了全局白名单、用户级别的白名单，用户级别的权限，为了更好的配置ACL权限规则，下面给出权限匹配逻辑。<br><img src="https://img-blog.csdnimg.cn/20190630142301617.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4、使用示例"><a href="#4、使用示例" class="headerlink" title="4、使用示例"></a>4、使用示例</h2><h3 id="4-1-Broker端安装"><a href="#4-1-Broker端安装" class="headerlink" title="4.1 Broker端安装"></a>4.1 Broker端安装</h3><p>首先，需要在broker.conf文件中，增加参数aclEnable=true。并拷贝distribution/conf/plain_acl.yml文件到${ROCKETMQ_HOME}/conf目录。</p>
<p>broker.conf的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerClusterName &#x3D; DefaultCluster</span><br><span class="line">brokerName &#x3D; broker-b</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class="line">listenPort&#x3D;10915</span><br><span class="line">storePathRootDir&#x3D;E:&#x2F;SH2019&#x2F;tmp&#x2F;rocketmq_home&#x2F;rocketmq4.5MB&#x2F;store</span><br><span class="line">storePathCommitLog&#x3D;E:&#x2F;SH2019&#x2F;tmp&#x2F;rocketmq_home&#x2F;rocketmq4.5MB&#x2F;store&#x2F;commitlog</span><br><span class="line">namesrvAddr&#x3D;127.0.0.1:9876</span><br><span class="line">autoCreateTopicEnable&#x3D;false</span><br><span class="line">aclEnable&#x3D;true</span><br></pre></td></tr></table></figure>
<p>plain_acl.yml文件内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">globalWhiteRemoteAddresses:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">accounts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">RocketMQ</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">defaultTopicPerm:</span> <span class="string">DENY</span></span><br><span class="line">  <span class="attr">defaultGroupPerm:</span> <span class="string">SUB</span></span><br><span class="line">  <span class="attr">topicPerms:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">TopicTest=PUB</span></span><br><span class="line">  <span class="attr">groupPerms:</span></span><br><span class="line">  <span class="comment"># the group should convert to retry topic</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">oms_consumer_group=DENY</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">accessKey:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">secretKey:</span> <span class="number">12345678</span></span><br><span class="line">  <span class="attr">whiteRemoteAddress:</span></span><br><span class="line">  <span class="comment"># if it is admin, it could access all resources</span></span><br><span class="line">  <span class="attr">admin:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>从上面的配置可知，用户RocketMQ只能发送TopicTest的消息，其他topic无权限发送；拒绝oms_consumer_group消费组的消息消费，其他消费组默认可消费。</p>
<h3 id="4-2-消息发送端示例"><a href="#4-2-消息发送端示例" class="headerlink" title="4.2 消息发送端示例"></a>4.2 消息发送端示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AclProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>, getAclRPCHook());</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest3&quot;</span> ,<span class="string">&quot;TagA&quot;</span> , (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RPCHook <span class="title">getAclRPCHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AclClientRPCHook(<span class="keyword">new</span> SessionCredentials(<span class="string">&quot;rocketmq&quot;</span>,<span class="string">&quot;12345678&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20190630142551897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-3-消息消费端示例"><a href="#4-3-消息消费端示例" class="headerlink" title="4.3 消息消费端示例"></a>4.3 消息消费端示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AclConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_4&quot;</span>, getAclRPCHook(),<span class="keyword">new</span> AllocateMessageQueueAveragely());</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> RPCHook <span class="title">getAclRPCHook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AclClientRPCHook(<span class="keyword">new</span> SessionCredentials(<span class="string">&quot;rocketmq&quot;</span>,<span class="string">&quot;12345678&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现并不没有消费消息，符合预期。</p>
<p>关于RocketMQ ACL的使用就介绍到这里了，下一篇将介绍RocketMQ ACL实现原理。，下一篇，我们将进入到多副本的学习中。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>acl</tag>
        <tag>访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ HA机制(主从同步)</title>
    <url>/posts/12eccc4e.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>温馨提示：建议参考代码RocketMQ4.4版本，4.5版本引入了多副本机制，实现了主从自动切换，本文并不关心主从切换功能。</p>
</blockquote>
<h2 id="1、初识主从同步"><a href="#1、初识主从同步" class="headerlink" title="1、初识主从同步"></a>1、初识主从同步</h2><p>主从同步基本实现过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190625233757881.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>RocketMQ 的主从同步机制如下：<br>A. 首先启动Master并在指定端口监听；<br>B. 客户端启动，主动连接Master，建立TCP连接；<br>C. 客户端以每隔5s的间隔时间向服务端拉取消息，如果是第一次拉取的话，先获取本地commitlog文件中最大的偏移量，以该偏移量向服务端拉取消息；<br>D. 服务端解析请求，并返回一批数据给客户端；<br>E. 客户端收到一批消息后，将消息写入本地commitlog文件中，然后向Master汇报拉取进度，并更新下一次待拉取偏移量；<br>F. 然后重复第3步；</p>
<p>RocketMQ主从同步一个重要的特征：主从同步不具备主从切换功能，即当主节点宕机后，从不会接管消息发送，但可以提供消息读取。</p>
<blockquote>
<p>温馨提示：本文并不会详细分析RocketMQ主从同步的实现细节，如大家对其感兴趣，可以查阅笔者所著的《RocketMQ技术内幕》或查看笔者博文：<a href="https://blog.csdn.net/prestigeding/article/details/79600792">https://blog.csdn.net/prestigeding/article/details/79600792</a></p>
</blockquote>
<h2 id="2、提出问题"><a href="#2、提出问题" class="headerlink" title="2、提出问题"></a>2、提出问题</h2><ul>
<li>主，从服务器都在运行过程中，消息消费者是从主拉取消息还是从从拉取？</li>
<li>RocketMQ主从同步架构中，如果主服务器宕机，从服务器会接管消息消费，此时消息消费进度如何保持，当主服务器恢复后，消息消费者是从主拉取消息还是从从服务器拉取，主从服务器之间的消息消费进度如何同步？</li>
</ul>
<p>接下来带着上述问题，一起来探究其实现原理。</p>
<h2 id="3、原理探究"><a href="#3、原理探究" class="headerlink" title="3、原理探究"></a>3、原理探究</h2><h3 id="3-1-RocketMQ主从读写分离机制"><a href="#3-1-RocketMQ主从读写分离机制" class="headerlink" title="3.1 RocketMQ主从读写分离机制"></a>3.1 RocketMQ主从读写分离机制</h3><p>RocketMQ的主从同步，在默认情况下RocketMQ会优先选择从主服务器进行拉取消息，并不是通常意义的上的读写分离，那什么时候会从拉取呢？</p>
<blockquote>
<p>温馨提示：本节同样不会详细整个流程，只会点出其关键点，如果想详细了解消息拉取、消息消费等核心流程，建议大家查阅笔者所著的《RocketMQ技术内幕》。</p>
</blockquote>
<p>在RocketMQ中判断是从主拉取，还是从从拉取的核心代码如下：<br>DefaultMessageStore#getMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;  <span class="comment">// @1</span></span><br><span class="line"><span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">                            * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));  <span class="comment">// @2</span></span><br><span class="line">getResult.setSuggestPullingFromSlave(diff &gt; memory);   <span class="comment">// @3</span></span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍一下几个局部变量的含义：</p>
<ul>
<li>maxOffsetPy<br>当前最大的物理偏移量。返回的偏移量为已存入到操作系统的PageCache中的内容。</li>
<li>maxPhyOffsetPulling<br>本次消息拉取最大物理偏移量，按照消息顺序拉取的基本原则，可以基本预测下次开始拉取的物理偏移量将大于该值，并且就在其附近。</li>
<li>diff<br>maxOffsetPy与maxPhyOffsetPulling之间的间隔，getMessage通常用于消息消费时，即这个间隔可以理解为目前未处理的消息总大小。</li>
</ul>
<p>代码@2：获取RocketMQ消息存储在PageCache中的总大小，如果当RocketMQ容量超过该阔值，将会将被置换出内存，如果要访问不在PageCache中的消息，则需要从磁盘读取。</p>
<ul>
<li>StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE<br>返回当前系统的总物理内存。参数</li>
<li>accessMessageInMemoryMaxRatio<br>设置消息存储在内存中的阀值，默认为40。<br>结合代码@2这两个参数的含义，算出RocketMQ消息能映射到内存中最大值为40% * (机器物理内存)。</li>
</ul>
<p>代码@3：设置下次拉起是否从从拉取标记，触发下次从从服务器拉取的条件为：当前所有可用消息数据(所有commitlog)文件的大小已经超过了其阔值，默认为物理内存的40%。</p>
<a id="more"></a>

<p>那GetResult的suggestPullingFromSlave属性在哪里使用呢？</p>
<p>PullMessageProcessor#processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;      <span class="comment">// @1</span></span><br><span class="line">responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole()) &#123;      <span class="comment">// @2</span></span><br><span class="line">       <span class="keyword">case</span> ASYNC_MASTER:</span><br><span class="line">       <span class="keyword">case</span> SYNC_MASTER:</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       <span class="keyword">case</span> SLAVE:</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123;</span><br><span class="line">                        response.setCode(ResponseCode.PULL_RETRY_IMMEDIATELY);</span><br><span class="line">                        responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">               &#125;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isSlaveReadEnable()) &#123; <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">// consume too slow ,redirect to another machine</span></span><br><span class="line">            <span class="keyword">if</span> (getMessageResult.isSuggestPullingFromSlave()) &#123;</span><br><span class="line">                 responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getWhichBrokerWhenConsumeSlowly());</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">// consume ok</span></span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">                responseHeader.setSuggestWhichBrokerId(subscriptionGroupConfig.getBrokerId());</span><br><span class="line">           &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           responseHeader.setSuggestWhichBrokerId(MixAll.MASTER_ID);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果从commitlog文件查找消息时，发现消息堆积太多，默认超过物理内存的40%后，会建议从从服务器读取。</p>
<p>代码@2：如果当前服务器的角色为从服务器:并且slaveReadEnable=true，则忽略代码@1设置的值，下次拉取切换为从主拉取。</p>
<p>代码@3：如果slaveReadEnable=true(从允许读)，并且建议从从服务器读取，则从消息消费组建议当消息消费缓慢时建议的拉取brokerId，由订阅组配置属性whichBrokerWhenConsumeSlowly决定；如果消息消费速度正常，则使用订阅组建议的brokerId拉取消息进行消费，默认为主服务器。如果不允许从可读，则固定使用从主拉取。</p>
<blockquote>
<p>温馨提示：请注意broker服务参数slaveReadEnable，与订阅组配置信息：whichBrokerWhenConsumeSlowly、brokerId的值，在生产环境中，可以通过updateSubGroup命令动态改变订阅组的配置信息。</p>
</blockquote>
<p>如果订阅组的配置保持默认值的话，拉取消息请求发送到从服务器后，下一次消息拉取，无论是否开启slaveReadEnable，下一次拉取，还是会发往主服务器。</p>
<p>上面的步骤，在消息拉取命令的返回字段中，会将下次建议拉取Broker返回给客户端，根据其值从指定的broker拉取。</p>
<p>消息拉取实现PullAPIWrapper在处理拉取结果时会将服务端建议的brokerId更新到broker拉取缓存表中。<br><img src="https://img-blog.csdnimg.cn/20190625234245349.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在发起拉取请求之前，首先根据如下代码，选择待拉取消息的Broker。<br><img src="https://img-blog.csdnimg.cn/20190625234309172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-2-消息消费进度同步机制"><a href="#3-2-消息消费进度同步机制" class="headerlink" title="3.2 消息消费进度同步机制"></a>3.2 消息消费进度同步机制</h3><p>从上面内容可知，主从同步引入的主要目的就是消息堆积的内容默认超过物理内存的40%，则消息读取则由从服务器来接管，实现消息的读写分离，避免主服务IO抖动严重。那问题来了，主服务器宕机后，从服务器接管消息消费后，那消息消费进度存储在哪里？当主服务器恢复正常后，消息是从主服务器拉取还是从从服务器拉取？主服务器如何得知最新的消息消费进度呢？</p>
<p>RocketMQ消息消费进度管理（集群模式）：<br>集群模式下消息消费进度存储文件位于服务端${ROCKETMQ_HOME}/store/config/consumerOffset.json。消息消费者从服务器拉取一批消息后提交到消费组特定的线程池中处理消息，当消息消费成功后会向Broker发送ACK消息，告知消费端已成功消费到哪条消息，Broker收到消息消费进度反馈后，首先存储在内存中，然后定时持久化到consumeOffset.json文件中。备注：关于消息消费进度管理更多的实现细节，建议查阅笔者所著的《RocketMQ技术内幕》。</p>
<p>我们先看一下客户端向服务端反馈消息消费进度时如何选择Broker。<br>因为主服务的brokerId为0，默认情况下当主服务器存活的时候，优先会选择主服务器，只有当主服务器宕机的情况下，才会选择从服务器。</p>
<p>既然集群模式下消息消费进度存储在Broker端，当主服务器正常时，消息消费进度文件存储在主服务器，那提出如下两个问题：<br>1）消息消费端在主服务器存活的情况下，会优先向主服务器反馈消息消费进度，那从服务器是如何同步消息消费进度的。<br>2）当主服务器宕机后则消息消费端会向从服务器反馈消息消费进度，此时消息消费进度如何存储，当主服务器恢复正常后，主服务器如何得知最新的消息消费进度。</p>
<p>为了解开上述两个疑问，我们优先来看一下Broker服务器在收到提交消息消费进度反馈命令后的处理逻辑：</p>
<p>客户端定时向Broker端发送更新消息消费进度的请求，其入口为：RemoteBrokerOffsetStore#updateConsumeOffsetToBroker，该方法中一个非常关键的点是：选择broker的逻辑，如下所示：<br><img src="https://img-blog.csdnimg.cn/20190625234502316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果主服务器存活，则选择主服务器，如果主服务器宕机，则选择从服务器。也就是说，不管消息是从主服务器拉取的还是从从服务器拉取的，提交消息消费进度请求，优先选择主服务器。服务端就是接收其偏移量，更新到服务端的内存中，然后定时持久化到${ROCKETMQ_HOME}/store/config/consumerOffset.json。</p>
<p>经过上面的分析，我们来讨论一下这个场景：<br>消息消费者首先从主服务器拉取消息，并向其提交消息消费进度，如果当主服务器宕机后，从服务器会接管消息拉取服务，此时消息消费进度存储在从服务器，主从服务器的消息消费进度会出现不一致？那当主服务器恢复正常后，两者之间的消息消费进度如何同步？</p>
<h5 id="3-2-1-从服务定时同步主服务器进度"><a href="#3-2-1-从服务定时同步主服务器进度" class="headerlink" title="3.2.1 从服务定时同步主服务器进度"></a>3.2.1 从服务定时同步主服务器进度</h5><p><img src="https://img-blog.csdnimg.cn/20190625234556971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果Broker角色为从服务器，会通过定时任务调用syncAll，从主服务器定时同步topic路由信息、消息消费进度、延迟队列处理进度、消费组订阅信息。</p>
<p>那问题来了，如果主服务器启动后，从服务器马上从主服务器同步消息消息进度，那岂不是又要重新消费？</p>
<p>其实在绝大部分情况下，就算从服务从主服务器同步了很久之前的消费进度，只要消息者没有重新启动，就不需要重新消费，在这种情况下，RocketMQ提供了两种机制来确保不丢失消息消费进度。</p>
<p>第一种，消息消费者在内存中存在最新的消息消费进度，继续以该进度去服务器拉取消息后，消息处理完后，会定时向Broker服务器反馈消息消费进度，在上面也提到过，在反馈消息消费进度时，会优先选择主服务器，此时主服务器的消息消费进度就立马更新了，从服务器此时只需定时同步主服务器的消息消费进度即可。</p>
<p>第二种是，消息消费者在向主服务器拉取消息时，如果是是主服务器，在处理消息拉取时，也会更新消息消费进度。</p>
<h5 id="3-2-2-主服务器消息拉取时更新消息消费进度"><a href="#3-2-2-主服务器消息拉取时更新消息消费进度" class="headerlink" title="3.2.2 主服务器消息拉取时更新消息消费进度"></a>3.2.2 主服务器消息拉取时更新消息消费进度</h5><p>主服务器在处理消息拉取命令时，会触发消息消费进度的更新，其代码入口为：PullMessageProcessor#processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> storeOffsetEnable = brokerAllowSuspend;  <span class="comment">// @1</span></span><br><span class="line">storeOffsetEnable = storeOffsetEnable &amp;&amp; hasCommitOffsetFlag; </span><br><span class="line">storeOffsetEnable = storeOffsetEnable</span><br><span class="line">            &amp;&amp; <span class="keyword">this</span>.brokerController.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE;  <span class="comment">// @2</span></span><br><span class="line"><span class="keyword">if</span> (storeOffsetEnable) &#123;</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().commitOffset(RemotingHelper.parseChannelRemoteAddr(channel),</span><br><span class="line">                requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId(), requestHeader.getCommitOffset());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍几个局部变量的含义：</p>
<ul>
<li>brokerAllowSuspend：broker是否允许挂起，在消息拉取时，该值默认为true。</li>
<li>hasCommitOffsetFlag：消息消费者在内存中是否缓存了消息消费进度，如果缓存了，该标记设置为true。<br>如果Broker的角色为主服务器，并且上面两个变量都为true，则首先使用commitOffset更新消息消费进度。</li>
</ul>
<p>看到这里，主从同步消息消费进度的相关问题，应该就有了答案了。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>上述实现原理的讲解有点枯燥无味，我们先来回答如下几个问题：</p>
<p>1、主，从服务器都在运行过程中，消息消费者是从主拉取消息还是从从拉取？<br>答：默认情况下，RocketMQ消息消费者从主服务器拉取，当主服务器积压的消息超过了物理内存的40%，则建议从从服务器拉取。但如果slaveReadEnable为false，表示从服务器不可读，从服务器也不会接管消息拉取。</p>
<p>2、当消息消费者向从服务器拉取消息后，会一直从从服务器拉取？<br>答：不是的。分如下情况：<br>1）如果从服务器的slaveReadEnable设置为false，则下次拉取，从主服务器拉取。<br>2）如果从服务器允许读取并且从服务器积压的消息未超过其物理内存的40%，下次拉取使用的Broker为订阅组的brokerId指定的Broker服务器，该值默认为0，代表主服务器。<br>3）如果从服务器允许读取并且从服务器积压的消息超过了其物理内存的40%，下次拉取使用的Broker为订阅组的whichBrokerWhenConsumeSlowly指定的Broker服务器，该值默认为1，代表从服务器。</p>
<p>3、主从服务消息消费进是如何同步的？<br>答：消息消费进度的同步时单向的，从服务器开启一个定时任务，定时从主服务器同步消息消费进度；无论消息消费者是从主服务器拉的消息还是从从服务器拉取的消息，在向Broker反馈消息消费进度时，优先向主服务器汇报；消息消费者向主服务器拉取消息时，如果消息消费者内存中存在消息消费进度时，主会尝试跟新消息消费进度。</p>
<p>读写分离的正确使用姿势：<br>1、主从Broker服务器的slaveReadEnable设置为true。<br>2、通过updateSubGroup命令更新消息组whichBrokerWhenConsumeSlowly、brokerId，特别是其brokerId不要设置为0，不然从从服务器拉取一次后，下一次拉取就会从主去拉取。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>ha</tag>
        <tag>主从同步</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ msgId与offsetMsgId释疑(实战篇)</title>
    <url>/posts/e0111576.html</url>
    <content><![CDATA[<div id="vip-container"><p>本篇详细介绍消息发送、消息消费、RocketMQ queryMsgById 命令以及 rocketmq-console 等使用场景中究竟是用的哪一个ID。</p>
<p>@<a href="%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">TOC</a></p>
<h2 id="1、抛出问题"><a href="#1、抛出问题" class="headerlink" title="1、抛出问题"></a>1、抛出问题</h2><h4 id="1-1-从消息发送看消息ID"><a href="#1-1-从消息发送看消息ID" class="headerlink" title="1.1 从消息发送看消息ID"></a>1.1 从消息发送看消息ID</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.example.quickstart;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.DefaultMQProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.producer.SendResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.Message;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.remoting.common.RemotingHelper;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">            producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">            producer.start();</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TestTopic&quot;</span> <span class="comment">/* Topic */</span>,<span class="keyword">null</span> <span class="comment">/* Tag */</span>, (<span class="string">&quot;Hello RocketMQ test1&quot;</span> ).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="comment">/* Message body */</span>);</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">            producer.shutdown();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20200308201940382.png" alt="在这里插入图片描述">即消息发送会返回 msgId 与 offsetMsgId。</p>
<h4 id="1-2-从消息消费看消息ID"><a href="#1-2-从消息消费看消息ID" class="headerlink" title="1.2 从消息消费看消息ID"></a>1.2 从消息消费看消息ID</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.rocketmq.example.quickstart;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.client.exception.MQClientException;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.consumer.ConsumeFromWhere;</span><br><span class="line"><span class="keyword">import</span> org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">        DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;please_rename_unique_group_name_1&quot;</span>);</span><br><span class="line">        consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_FIRST_OFFSET);</span><br><span class="line">        consumer.subscribe(<span class="string">&quot;TestTopic&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">                ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;MessageExt msg.getMsgId():&quot;</span> +  msgs.get(<span class="number">0</span>).getMsgId());</span><br><span class="line">                System.out.println(<span class="string">&quot;-------------------分割线-----------------&quot;</span>);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">                <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        consumer.start();</span><br><span class="line">        System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20200308202103968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>不知道大家是否有注意到，调用 msgs.get(0).getMsgId()返回的msgId 与直接输出msgs中的 msgId 不一样，那这又是为什么呢？答案在本文的第二部分有详细分析。</strong></p>
<h2 id="2、消息ID释疑"><a href="#2、消息ID释疑" class="headerlink" title="2、消息ID释疑"></a>2、消息ID释疑</h2><p>从消息发送的结果可以得知，RocketMQ 发送的返回结果会返回msgId 与 offsetMsgId，那这两个 msgId 分别是代表什么呢？</p>
<ul>
<li>msgId：该ID 是消息发送者在消息发送时会首先在客户端生成，全局唯一，在 RocketMQ 中该 ID 还有另外的一个叫法：uniqId，无不体现其全局唯一性。</li>
<li>offsetMsgId：消息偏移ID，该 ID 记录了消息所在集群的物理地址，主要包含所存储 Broker 服务器的地址( IP 与端口号)以及所在commitlog 文件的物理偏移量。</li>
</ul>
<h4 id="2-1-msgId-即全局唯一-ID-构建规则"><a href="#2-1-msgId-即全局唯一-ID-构建规则" class="headerlink" title="2.1 msgId 即全局唯一 ID 构建规则"></a>2.1 msgId 即全局唯一 ID 构建规则</h4><p><img src="https://img-blog.csdnimg.cn/20200308202402908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从这张图可以看出，msgId确实是客户端生成的，接下来我们详细分析一下其生成算法。</p>
<p>MessageClientIDSetter#createUniqID</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createUniqID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(LEN * <span class="number">2</span>);</span><br><span class="line">    sb.append(FIX_STRING);    <span class="comment">// @1</span></span><br><span class="line">    sb.append(UtilAll.bytes2string(createUniqIDBuffer()));  <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 uniqID 的构建主要分成两个部分：FIX_STRING 与唯一 ID 生成算法，顾名思义，FIX_STRING 就是一个客户端固定一个前缀，那接下来先看一下固定字符串的生成规则。</p>
<h5 id="2-1-1-FIX-STRING"><a href="#2-1-1-FIX-STRING" class="headerlink" title="2.1.1 FIX_STRING"></a>2.1.1 FIX_STRING</h5><p>MessageClientIDSetter静态代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ip;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ip = UtilAll.getIP();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        ip = createFakeIP();</span><br><span class="line">    &#125;</span><br><span class="line">    LEN = ip.length + <span class="number">2</span> + <span class="number">4</span> + <span class="number">4</span> + <span class="number">2</span>;</span><br><span class="line">    ByteBuffer tempBuffer = ByteBuffer.allocate(ip.length + <span class="number">2</span> + <span class="number">4</span>);</span><br><span class="line">    tempBuffer.position(<span class="number">0</span>);</span><br><span class="line">    tempBuffer.put(ip);</span><br><span class="line">    tempBuffer.position(ip.length);</span><br><span class="line">    tempBuffer.putInt(UtilAll.getPid());</span><br><span class="line">    tempBuffer.position(ip.length + <span class="number">2</span>);</span><br><span class="line">    tempBuffer.putInt(MessageClientIDSetter.class.getClassLoader().hashCode());</span><br><span class="line">    FIX_STRING = UtilAll.bytes2string(tempBuffer.array());</span><br><span class="line">    setStartTime(System.currentTimeMillis());</span><br><span class="line">    COUNTER = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出 FIX_STRING 的主要由：客户端的IP、进程ID、加载 MessageClientIDSetter 的类加载器的 hashcode。</p>
<h5 id="2-1-2-唯一性算法"><a href="#2-1-2-唯一性算法" class="headerlink" title="2.1.2 唯一性算法"></a>2.1.2 唯一性算法</h5><p>msgId 的唯一性算法由 MessageClientIDSetter 的createUniqIDBuffer 方法实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] createUniqIDBuffer() &#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">4</span> + <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">long</span> current = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (current &gt;= nextStartTime) &#123;</span><br><span class="line">        setStartTime(current);</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.position(<span class="number">0</span>);</span><br><span class="line">    buffer.putInt((<span class="keyword">int</span>) (System.currentTimeMillis() - startTime));</span><br><span class="line">    buffer.putShort((<span class="keyword">short</span>) COUNTER.getAndIncrement());</span><br><span class="line">    <span class="keyword">return</span> buffer.array();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得出 msgId 的后半段主要由：当前时间与系统启动时间的差值，以及自增序号。</p>
<h4 id="2-2-offsetMsgId构建规则"><a href="#2-2-offsetMsgId构建规则" class="headerlink" title="2.2 offsetMsgId构建规则"></a>2.2 offsetMsgId构建规则</h4><p><img src="https://img-blog.csdnimg.cn/20200308202705728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在消息 Broker 服务端将消息追加到内存后会返回其物理偏移量，即在 commitlog 文件中的文件，然后会再次生成一个id，代码中虽然也叫 msgId，其实这里就是我们常说的 offsetMsgId，即记录了消息的物理偏移量，故我们重点来看一下其具体生成规则：<br>MessageDecoder#createMessageId</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createMessageId</span><span class="params">(<span class="keyword">final</span> ByteBuffer input ,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> ByteBuffer addr, <span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">	input.flip();</span><br><span class="line">    <span class="keyword">int</span> msgIDLength = addr.limit() == <span class="number">8</span> ? <span class="number">16</span> : <span class="number">28</span>;</span><br><span class="line">    input.limit(msgIDLength);</span><br><span class="line">    input.put(addr);</span><br><span class="line">    input.putLong(offset);</span><br><span class="line">    <span class="keyword">return</span> UtilAll.bytes2string(input.array());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先结合该方法的调用上下文，先解释一下该方法三个入参的含义：</p>
<ul>
<li>ByteBuffer input<br>用来存放 offsetMsgId 的字节缓存区( NIO 相关的基础知识)</li>
<li>ByteBuffer addr<br>当前 Broker 服务器的 IP 地址与端口号，即通过解析 offsetMsgId 从而得到消息服务器的地址信息。</li>
<li>long offset<br>消息的物理偏移量。<br>即构成 offsetMsgId 的组成部分：Broker 服务器的 IP 与端口号、消息的物理偏移量。</li>
</ul>
<blockquote>
<p>温馨提示：即在 RocketMQ中，只需要提供 offsetMsgId，可用不必知道该消息所属的topic信息即可查询该条消息的内容。</p>
</blockquote>
<h4 id="2-3-消息发送与消息消费返回的消息ID信息"><a href="#2-3-消息发送与消息消费返回的消息ID信息" class="headerlink" title="2.3 消息发送与消息消费返回的消息ID信息"></a>2.3 消息发送与消息消费返回的消息ID信息</h4><p>消息发送时会在 SendSesult中返回 msgId、offsetMsgId，在了解了这个两个 ID 的含义时则问题不大，接下来重点介绍一下消息消费时返回的 msgId 到底是哪一个。</p>
<p>在消息消费时，我们更加希望因为 msgId (即客户端生成的全局唯一性ID)，因为该全局性 ID 非常方便实现消费端的幂等。</p>
<p>在本文的1.2节我们也提到一个现象，为什么如下图代码中输出的 msgId 会不一样呢？<br><img src="https://img-blog.csdnimg.cn/20200308203117923.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在客户端返回的 msg 信息，其最终返回的对象是  MessageClientExt ，继承自 MessageExt。<br>那我们接下来分别看一下其 getMsgId() 方法与 toString 方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMsgId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String uniqID = MessageClientIDSetter.getUniqID(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (uniqID == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getOffsetMsgId();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> uniqID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来在调用 MessageClientExt 中的 getMsgId 方法时，如果消息的属性中存在其唯一ID，则返回消息的全局唯一ID，否则返回消息的 offsetMsgId。</p>
<p>而 MessageClientExt 方法并没有重写 MessageExt 的 toString 方法，其实现如图所示：<br><img src="https://img-blog.csdnimg.cn/20200308203311967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>故返回的是 MessageExt中 的 msgId，该 msgId 存放的是offsetMsgId，所以才造成了困扰。</p>
<blockquote>
<p>温馨提示：如果消息消费失败需要重试，RocketMQ 的做法是将消息重新发送到 Broker 服务器，此时全局 msgId 是不会发送变化的，但该消息的 offsetMsgId 会发送变化，因为其存储在服务器中的位置发生了变化。</p>
</blockquote>
<h2 id="3、实践经验"><a href="#3、实践经验" class="headerlink" title="3、实践经验"></a>3、实践经验</h2><p>在回答了消息发送与消息消费关于msgId与offsetMsgId的困扰后，再来介绍一下如果根据msgId去查询消息。</p>
<p>想必大家对 rocketmq-console ，那在消息查找界面，展示的消息列表中返回的 msgId 又是哪一个呢？<br><img src="https://img-blog.csdnimg.cn/20200308203400221.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里的 Message ID 返回的是消息的全局唯一ID。</p>
<p>其实 RokcetMQ 也提供了 queryMsgById 命令来查看消息的内容，不过这里的 msgId 是 offsetMsgId，我们首先将全局唯一ID传入命令，其执行效果如下：<br><img src="https://img-blog.csdnimg.cn/20200308203431178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现报错，那我们将 offsetMsgId 传入其执行效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20200308203452188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但在 rocketmq-console 的根据消息ID去查找消息，无论传入哪个msgId，下图该功能都能返回正确的结果：<br><img src="https://img-blog.csdnimg.cn/20200308203540222.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这是因为 rocketmq-console 做了兼容，首先将传入的 msgId 用 queryMsgById 该命令去查，如果报错，则当成 uniqID(全局ID)去查，首先全局ID会存储在消息的属性中，并会创建 Hash 索引，即可用通过 indexfile 快速定位到该条消息。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>msgId</tag>
        <tag>offsetMsgId</tag>
        <tag>queryMsgById</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 主题扩分片后遇到的坑</title>
    <url>/posts/c4065704.html</url>
    <content><![CDATA[<div id="vip-container"><p>消息组接到某项目组反馈，topic 在扩容后出现部分队列无法被消费者，导致消息积压，影响线上业务？</p>
<p>考虑到该问题是发送在真实的线上环境，为了避免泄密，本文先在笔者的虚拟机中来重现问题。</p>
<h2 id="1、案情回顾"><a href="#1、案情回顾" class="headerlink" title="1、案情回顾"></a>1、案情回顾</h2><h3 id="1-1-集群现状"><a href="#1-1-集群现状" class="headerlink" title="1.1 集群现状"></a>1.1 集群现状</h3><p>集群信息如下：<br><img src="https://img-blog.csdnimg.cn/20190906232935331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>例如业务主体名 topic_dw_test_by_order_01 的路由信息如图所示：<br><img src="https://img-blog.csdnimg.cn/20190906233008367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当前的消费者信息：<br><img src="https://img-blog.csdnimg.cn/20190906233034814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>broker 的配置信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerClusterName &#x3D; DefaultCluster</span><br><span class="line">brokerName &#x3D; broker-a</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class="line">brokerIP1&#x3D;192.168.0.220</span><br><span class="line">brokerIP2-192.168.0.220</span><br><span class="line">namesrvAddr&#x3D;192.168.0.221:9876;192.168.0.220:9876</span><br><span class="line">storePathRootDir&#x3D;&#x2F;opt&#x2F;application&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;store</span><br><span class="line">storePathCommitLog&#x3D;&#x2F;opt&#x2F;application&#x2F;rocketmq-all-4.5.2-bin-release&#x2F;store&#x2F;commitlog</span><br><span class="line">autoCreateTopicEnable&#x3D;false</span><br><span class="line">autoCreateSubscriptionGroup&#x3D;false</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：公司对 topic、消费组进行了严格的管控，项目组需要使用时需要向运维人员申请，故 broker 集群不允许自动创建主题与自动创建消费组。</p>
</blockquote>
<p>由于该业务量稳步提升，项目组觉得该主题的队列数太少，不利于增加消费者来提高其消费能力，故向运维人员提出增加队列的需求。</p>
<h3 id="1-2、RocketMQ-在线扩容队列"><a href="#1-2、RocketMQ-在线扩容队列" class="headerlink" title="1.2、RocketMQ 在线扩容队列"></a>1.2、RocketMQ 在线扩容队列</h3><p>运维通过公司自研的消息运维平台，直接以指定集群的方式为 topic 扩容，该运维平台底层其实使用了RocketMQ 提供的 updateTopic 命令，其命令说明如下：</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20190906233121258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="图片来源于《》RocketMQ技术内幕》"><br>从上图可以得知可以通过 -c 命令来指定在集群中所有的 broker 上创建队列，在本例中，将队列数从 4 设置为 8，具体命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh .&#x2F;mqadmin upateTopic -n 192.168.0.220:9876 -c DefaultCluster -t topic_dw_test_by_order_01 -r 8 -w 8</span><br></pre></td></tr></table></figure>
<p>执行效果如图所示，表示更新成功。<br><img src="https://img-blog.csdnimg.cn/20190906233249376.png" alt="在这里插入图片描述"><br>我们再来从 rocketmq-console 中来看命令执行后的效果：<br><img src="https://img-blog.csdnimg.cn/20190906233418121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以得知，主题的队列数已经扩容到了8个，并且在集群的两台broker上都创建了队列。</p>
<h3 id="1-3-消息发送"><a href="#1-3-消息发送" class="headerlink" title="1.3 消息发送"></a>1.3 消息发送</h3><p>从 RocketMQ 系列可知，RocketMQ 是支持在线 topic 在线扩容机制的，故无需重启 消息发送者、消息消费者，随着时间的推移，我们可以查看topic的所有队列都参与到了消息的负载中，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190906233500250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们可以清晰的看到，所有的16个队列(每个 broker 8个队列)都参与到了消息发送的，运维小哥愉快的完成了topic的扩容。</p>
<h2 id="2、问题暴露"><a href="#2、问题暴露" class="headerlink" title="2、问题暴露"></a>2、问题暴露</h2><p>该 topic 被 5个消费组所订阅，突然接到通知，其中有两个消费组反馈，部分队列的消息没有被消费，导致下游系统并没有及时处理。</p>
<h2 id="3、问题分析"><a href="#3、问题分析" class="headerlink" title="3、问题分析"></a>3、问题分析</h2><p>当时到项目组提交到消息组时，我第一反应是先看消费者的队列，打开该主题的消费情况，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190906233538617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现队列数并没有积压，备注（由于生产是4主4从，每一个 broker上8个队列，故总共32个队列），当时由于比较急，并没有第一时间发现这个界面，竟然只包含一个消费者，觉得并没有消息积压，又由于同一个集群，其他消费组没有问题，只有两个消费组有问题，怀疑是应用的问题，就采取了重启，打印线程栈等方法。</p>
<p>事后诸葛亮：其实这完成是错误的，为什么这样说呢？因为项目组（业务方）已经告知一部分业务未处理，说明肯定有队列的消息积压，当根据自己的知识，结合看到的监控页面做出的判断与业务方反馈的出现冲突时，一定是自己的判断出了问题。</p>
<p>正在我们“如火如荼”的认定是项目有问题时，团队的另一成员提出了自己的观点，原来在得到业务方反馈时，他得知同一个主题，被5个消费组订阅，只有其中两个有问题，那他通过rocketmq-console来找两者的区别，找到区别，找到规律，就离解决问题的路近了。</p>
<p>他通过对比发现，出问题的消费组只有两个客户端在消费（通常生产环境是4节点消费），而没有出现问题的发现有4个进程都在处理，即发现现象：出错的消费组，并没有全员参与到消费。正如上面的图所示：只有其中一个进程在处理8个队列，另外8个队列并没有在消费。</p>
<p>那现在就是要分析为啥topic共有16个队列，但这里只有1个消费者队列在消费，另外一个消费者不作为？</p>
<p>首先根据RocketMQ 消息队列负载机制，2个消费者，只有1个消费者在消费，并且一个有一个明显的特点是，只有broker-a上的队列在消费，broker-b上的队列一个也没消费。</p>
<p>正在思考为啥会出现这种现象时，他又在思考是不是集群是不是broker-b(对应我们生产环境是broker-c、broker-d上的队列都未消费)是新扩容的机器？扩容的时候是不是没有把订阅关系在新的集群上创建？提出了疑问，接下来肖工就开始验证猜想，通过查阅broker-c、broker-d在我们系统中创建的时间是2018-4月的时候，就基本得出结论，扩容时并没有在新集群上创建订阅消息，故无法消费消息。</p>
<p>于是运维小哥使用运维工具创建订阅组，创建方法如图所示：<br><img src="https://img-blog.csdnimg.cn/20190906233645848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>创建好消费组后，再去查看topic的消费情况时，另外一个消费组也开始处理消息了，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190906233708415.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4、问题复盘"><a href="#4、问题复盘" class="headerlink" title="4、问题复盘"></a>4、问题复盘</h2><p>潜在原因：DefaultCluster 集群进行过一次集群扩容，从原来的一台消息服务器( broker-a )额外增加一台broker服务器( broker-b )，但扩容的时候并没有把原先的存在于 broker-a 上的主题、消费组扩容到 broker-b 服务器。</p>
<p>触发原因：接到项目组的扩容需求，将集群队列数从4个扩容到8个，这样该topic就在集群的a、b都会存在8个队列，但Broker不允许自动创建消费组（订阅关系），消费者无法从broker-b上队列上拉取消息，导致在broker-b队列上的消息堆积，无法被消费。</p>
<p>解决办法：运维通过命令，在broker-b上创建对应的订阅消息，问题解决。 </p>
<p>经验教训：集群扩容时，需要同步在集群上的topic.json、subscriptionGroup.json文件。</p>
<p>RocketMQ 理论基础，消费者向 Broker 发起消息拉取请求时，如果broker上并没有存在该消费组的订阅消息时，如果不允许自动创建(autoCreateSubscriptionGroup 设置为 false)，默认为true，则不会返回消息给客户端，其代码如下：<br><img src="https://img-blog.csdnimg.cn/20190906234625364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>问题解决后，我们团队的成员也分享了一下他在本次排查问题的处理方法：<strong>寻找出现问题的规律、推断问题、 然后验证问题。规律可以是问题本身的规律  也可以是和正常对比的差。</strong></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>主题扩容</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 升级到主从切换(DLedger、多副本)实战</title>
    <url>/posts/e0ec5d91.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文主要介绍如何将 RocketMQ 集群从原先的主从同步升级到主从切换。</p>
<p>首先先介绍与 DLedger 多副本即 RocketMQ 主从切换相关的核心配置属性，然后尝试搭建一个主从同步集群，再从原先的 RocketMQ 集群平滑升级到 DLedger 集群的示例，并简单测试一下主从切换功能。</p>
<h2 id="1、RocketMQ-DLedger-多副本即主从切换核心配置参数详解"><a href="#1、RocketMQ-DLedger-多副本即主从切换核心配置参数详解" class="headerlink" title="1、RocketMQ DLedger 多副本即主从切换核心配置参数详解"></a>1、RocketMQ DLedger 多副本即主从切换核心配置参数详解</h2><p>其主要的配置参数如下所示：</p>
<ul>
<li>enableDLegerCommitLog<br>是否启用 DLedger，即是否启用 RocketMQ 主从切换，默认值为 false。如果需要开启主从切换，则该值需要设置为 true 。</li>
<li>dLegerGroup<br>节点所属的 raft 组，建议与 brokerName 保持一致，例如 broker-a。</li>
<li>dLegerPeers<br>集群节点信息，示例配置如下：n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913，多个节点用英文冒号隔开，单个条目遵循   legerSlefId-ip:端口，这里的端口用作 dledger 内部通信。</li>
<li>dLegerSelfId<br>当前节点id。取自 legerPeers 中条目的开头，即上述示例中的 n0，并且特别需要强调，只能第一个字符为英文，其他字符需要配置成数字。</li>
<li>storePathRootDir<br>DLedger 日志文件的存储根目录，为了能够支持平滑升级，该值与 storePathCommitLog 设置为不同的目录。</li>
</ul>
<h2 id="2、搭建主从同步环境"><a href="#2、搭建主从同步环境" class="headerlink" title="2、搭建主从同步环境"></a>2、搭建主从同步环境</h2><p>首先先搭建一个传统意义上的主从同步架构，往集群中灌一定量的数据，然后升级到 DLedger 集群。</p>
<p>在 Linux 服务器上搭建一个 rocketmq 主从同步集群我想不是一件很难的事情，故本文就不会详细介绍按照过程，只贴出相关配置。</p>
<p>实验环境的部署结构采取 一主一次，其部署图如下：<br><img src="https://img-blog.csdnimg.cn/20191013142340811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面我就重点贴一下 broker 的配置文件。<br>220 上的 broker 配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = <span class="number">0</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span></span><br><span class="line">brokerIP2=<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span></span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">9876</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store</span><br><span class="line">storePathCommitLog=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/commitlog</span><br><span class="line">autoCreateTopicEnable=<span class="literal">false</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>221 上 broker 的配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = <span class="number">1</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = SLAVE</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span></span><br><span class="line">brokerIP2=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span></span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">9876</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store</span><br><span class="line">storePathCommitLog=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/commitlog</span><br><span class="line">autoCreateTopicEnable=<span class="literal">false</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>相关的启动命令如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nohup bin/mqnamesrv  /dev/<span class="literal">null</span>  <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br><span class="line">nohup bin/mqbroker -c conf/broker.conf  /dev/<span class="literal">null</span>  <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p>安装后的集群信息如图所示：<br><img src="https://img-blog.csdnimg.cn/20191013142514649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3、主从同步集群升级到DLedger"><a href="#3、主从同步集群升级到DLedger" class="headerlink" title="3、主从同步集群升级到DLedger"></a>3、主从同步集群升级到DLedger</h2><h3 id="3-1-部署架构"><a href="#3-1-部署架构" class="headerlink" title="3.1 部署架构"></a>3.1 部署架构</h3><p>DLedger 集群至少需要3台机器，故搭建 DLedger 还需要再引入一台机器，其部署结构图如下：</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20191013142635780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从主从同步集群升级到 DLedger 集群，用户最关心的还是升级后的集群是否能够兼容原先的数据，即原先存储在消息能否能被消息消费者消费端，甚至于能否查询到。<br>为了方便后续验证，首先我使用下述程序向 mq 集群中添加了一篇方便查询的消息（设置消息的key）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;producer_dw_test&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.0.220:9876;192.168.0.221:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">600000</span>; i &lt; <span class="number">600100</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;topic_dw_test_by_order_01&quot;</span>,<span class="keyword">null</span> , <span class="string">&quot;m&quot;</span> + i,(<span class="string">&quot;Hello RocketMQ&quot;</span> + i ).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">               <span class="comment">//System.out.printf(&quot;%s%n&quot;, sendResult);</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息的查询结果示例如下：<br><img src="https://img-blog.csdnimg.cn/20191013142707763.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-2-升级步骤"><a href="#3-2-升级步骤" class="headerlink" title="3.2 升级步骤"></a>3.2 升级步骤</h3><p>Step1：将 192.168.0.220 的 rocketmq 拷贝到 192.168.0.222，可以使用如下命令进行操作。在 192.168.0.220 上敲如下命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scp -r rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/ root@<span class="number">192.168</span><span class="number">.0</span><span class="number">.222</span>:<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示：示例中由于版本是一样，实际过程中，版本需要升级，故需先下载最新的版本，然后将老集群中的 store 目录完整的拷贝到新集群的 store 目录。</p>
</blockquote>
<p>Step2：依次在三台服务器的 broker.conf 配置文件中添加与 dledger 相关的配置属性。</p>
<p>192.168.0.220 broker配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerId = <span class="number">0</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span></span><br><span class="line">brokerIP2=<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span></span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">9876</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store</span><br><span class="line">storePathCommitLog=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/commitlog</span><br><span class="line">autoCreateTopicEnable=<span class="literal">false</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">false</span></span><br><span class="line"># 与 dledger 相关的属性</span><br><span class="line">enableDLegerCommitLog=<span class="literal">true</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/dledger_store</span><br><span class="line">dLegerGroup=broker-a</span><br><span class="line">dLegerPeers=n0-<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">40911</span>;n1-<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">40911</span>;n2-<span class="number">192.168</span><span class="number">.0</span><span class="number">.222</span>:<span class="number">40911</span></span><br><span class="line">dLegerSelfId=n0</span><br></pre></td></tr></table></figure>
<p>192.168.0.221 broker配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = <span class="number">1</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = SLAVE</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span></span><br><span class="line">brokerIP2=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span></span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">9876</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store</span><br><span class="line">storePathCommitLog=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/commitlog</span><br><span class="line">autoCreateTopicEnable=<span class="literal">false</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">false</span></span><br><span class="line"># 与dledger 相关的配置属性</span><br><span class="line">enableDLegerCommitLog=<span class="literal">true</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/dledger_store</span><br><span class="line">dLegerGroup=broker-a</span><br><span class="line">dLegerPeers=n0-<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">40911</span>;n1-<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">40911</span>;n2-<span class="number">192.168</span><span class="number">.0</span><span class="number">.222</span>:<span class="number">40911</span></span><br><span class="line">dLegerSelfId=n1</span><br></pre></td></tr></table></figure>
<p>192.168.0.222 broker配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = <span class="number">0</span></span><br><span class="line">deleteWhen = <span class="number">04</span></span><br><span class="line">fileReservedTime = <span class="number">48</span></span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">brokerIP1=<span class="number">192.168</span><span class="number">.0</span><span class="number">.222</span></span><br><span class="line">brokerIP2=<span class="number">192.168</span><span class="number">.0</span><span class="number">.222</span></span><br><span class="line">namesrvAddr=<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">9876</span>;<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">9876</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store</span><br><span class="line">storePathCommitLog=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/commitlog</span><br><span class="line">autoCreateTopicEnable=<span class="literal">false</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">false</span></span><br><span class="line"># 与 dledger 相关的配置</span><br><span class="line">enableDLegerCommitLog=<span class="literal">true</span></span><br><span class="line">storePathRootDir=<span class="regexp">/opt/</span>application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/dledger_store</span><br><span class="line">dLegerGroup=broker-a</span><br><span class="line">dLegerPeers=n0-<span class="number">192.168</span><span class="number">.0</span><span class="number">.220</span>:<span class="number">40911</span>;n1-<span class="number">192.168</span><span class="number">.0</span><span class="number">.221</span>:<span class="number">40911</span>;n2-<span class="number">192.168</span><span class="number">.0</span><span class="number">.222</span>:<span class="number">40911</span></span><br><span class="line">dLegerSelfId=n2</span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提示：legerSelfId 分别为 n0、n1、n2。在真实的生产环境中，broker配置文件中的 storePathRootDir、storePathCommitLog 尽量使用单独的根目录，这样判断其磁盘使用率时才不会相互影响。</p>
</blockquote>
<p>Step3：将 store/config 下的 所有文件拷贝到 dledger store 的 congfig 目录下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd /opt/application/rocketmq-all-<span class="number">4.5</span><span class="number">.2</span>-bin-release/store/</span><br><span class="line">cp config<span class="comment">/* dledger_store/config/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示：该步骤按照各自按照时配置的目录进行复制即可。</p>
</blockquote>
<p>Step4：依次启动三台 broker。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nohup bin/mqbroker -c conf/broker.conf  /dev/<span class="literal">null</span>  <span class="number">2</span>&gt;&amp;<span class="number">1</span> &amp;</span><br></pre></td></tr></table></figure>
<p>如果启动成功，则在 rocketmq-console 中看到的集群信息如下：<br><img src="https://img-blog.csdnimg.cn/20191013143013142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-3-验证消息发送与消息查找"><a href="#3-3-验证消息发送与消息查找" class="headerlink" title="3.3 验证消息发送与消息查找"></a>3.3 验证消息发送与消息查找</h3><p>首先我们先验证升级之前的消息是否能查询到，那我们还是查找key 为 m600000 的消息，查找结果如图所示：<br><img src="https://img-blog.csdnimg.cn/20191013143037500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>然后我们来测试一下消息发送。测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;producer_dw_test&quot;</span>);</span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;192.168.0.220:9876;192.168.0.221:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">600200</span>; i &lt; <span class="number">600300</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;topic_dw_test_by_order_01&quot;</span>,<span class="keyword">null</span> , <span class="string">&quot;m&quot;</span> + i,(<span class="string">&quot;Hello RocketMQ&quot;</span> + i ).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                SendResult sendResult = producer.send(msg);</span><br><span class="line">                System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20191013143121381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>再去控制台查询一下消息，其结果也表明新的消息也能查询到。<br><img src="https://img-blog.csdnimg.cn/20191013143149105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最后我们再来验证一下主节点宕机，消息发送是否会受影响。</p>
<p>在消息发送的过程中，去关闭主节点，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20191013143249857.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/2019101314330055.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20191013143313982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">再来看一下集群的状态：<br><img src="https://img-blog.csdnimg.cn/20191013143344274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>等待该复制组重新完成主服务器选举后，即可继续处理消息发送。</p>
<blockquote>
<p>温馨提示：由于本示例是一主一从，故在选举期间，消息不可用，但在真实的生产环境上，其部署架构是多主主从，即一个复制组在 leader 选举期间，其他复制组可以接替该复制组完成消息的发送，实现消息服务的高可用。</p>
</blockquote>
<p>与 DLedger 相关的日志，默认存储在 broker_default.log 文件中。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>dledger</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 多副本前置篇：初探raft协议</title>
    <url>/posts/d198d6eb.html</url>
    <content><![CDATA[<div id="vip-container"><p>Raft协议是分布式领域解决一致性的又一著名协议，主要包含Leader选举、日志复制两个部分。</p>
<blockquote>
<p>温馨提示：<br>本文根据raft官方给出的raft动画进行学习，其动画展示地址：<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></p>
</blockquote>
<h2 id="1、Leader选举"><a href="#1、Leader选举" class="headerlink" title="1、Leader选举"></a>1、Leader选举</h2><h3 id="1-1-一轮投票中，只有一个节点发起投票的情况"><a href="#1-1-一轮投票中，只有一个节点发起投票的情况" class="headerlink" title="1.1  一轮投票中，只有一个节点发起投票的情况"></a>1.1  一轮投票中，只有一个节点发起投票的情况</h3><p><img src="https://img-blog.csdnimg.cn/20190810192221312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Raft协议中节点有3种状态（角色）：</p>
<ul>
<li>Follower<br>跟随者。</li>
<li>Candidate<br>候选者。</li>
<li>Leader<br>领导者(Leader)，通常我们所说的的主节点。</li>
</ul>
<p>首先3个节点初始状态为 Follower，每个节点会有一个超时时间(计时器)，其时间设置为150ms~300ms之间的随机值。当计时器到期后，节点状态从 Follower 变成 Candidate，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190810193027410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通常情况下，三个节点中会有一个节点的计时器率先到期，节点状态变为 Candidate ，候选者状态下的节点会发起选举投票。我们先来考虑只有一个节点变为Candidate时是如何进行选主的。</p>
<p>当节点状态为Candidate，将发起一轮投票，由于是第一轮投票，设置本轮投票轮次为1，并首先为自己投上一票，正如上图所示的NodeA节点，Team为1，Vote Count为1.<br><img src="https://img-blog.csdnimg.cn/20190810193206869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当一个节点的定时器超时后，首先为自己投上一票，然后向该组内其他的节点发起投票(用拉票更加合适)，发送投票请求。<br><img src="https://img-blog.csdnimg.cn/20190810193241874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当集群内的节点收到投票请求外，如果本轮未进行过投票，则赞同，否则反对，然后将结果返回，并重置计时器。<br><img src="https://img-blog.csdnimg.cn/2019081019345071.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当节点A收到的赞同票大于一半时，则升级为该集群的 Leader，然后定时向集群内的其他节点发送心跳，以便确定自己的领导地位，正如下图所示。<br><img src="https://img-blog.csdnimg.cn/20190810193534746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Node A，集群中的 Leader正在向其他节点发送心跳包。<br><img src="https://img-blog.csdnimg.cn/20190810193603638.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>节点在收到 Leader 的心跳包后，返回响应结果，并重置自身的计时器，如果 Flower 状态的节点在计时时间超时内没有收到Leader 的心跳包，就会从 Flower 节点变成 Candidate,该节点就会发起下一轮投票。</p>
<p>例如NodeA节点宕机，停止向它的从发送心跳，我们来看一下集群如何重新选主。</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20190810193731794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>如果主节点宕机，则停止向集群内的节点发送心跳包。随着计时器的到期，节点B的先于节点C变成 Candidate，则节点B向集群内的其他节点发起投票，如下图所示。<br><img src="https://img-blog.csdnimg.cn/20190810193840481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>节点B，首先将投票轮次设置为2，然后首先为自己投上一篇，然后向其他节点发起投票请求。<br><img src="https://img-blog.csdnimg.cn/20190810194013940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>节点C收到请求，由于其投票轮次大于自己的投票轮次，并该轮次并未投票，投出赞成票并返回结果，然后重置计时器。节点B将顺理成章的成为新的Leader并定时发送心跳包。</p>
<p>3个节点的选主就介绍到这里了，也许有网友会说，虽然各个节点的计时器是随机的，但也有可能同一时间，或一个节点在未收到另一个节点发起的投票请求之前变成 Candidate，即在一轮投票过程中，有大于1个的节点状态都是 Candidate，那该如何选主呢？</p>
<p>下面以4个节点的集群为例，来阐述上述这种情况情况下，如何进行选主。</p>
<h3 id="1-2-一轮投票中，超过一个节点发起投票的情况"><a href="#1-2-一轮投票中，超过一个节点发起投票的情况" class="headerlink" title="1.2 一轮投票中，超过一个节点发起投票的情况"></a>1.2 一轮投票中，超过一个节点发起投票的情况</h3><p>首先同时有两个节点进入Candidate状态，并开始新的一轮投票，当前投票编号为4，首先先为自己投上一票，然后向集群中的其他节点发起投票，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190810194321440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后各个节点收到投票请求，如下所示，进行投票：<br><img src="https://img-blog.csdnimg.cn/20190810194348574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先节点C、D在收到D、C节点的投票请求时，都会返回不同意，因为在本轮投票中，已经各自为自己投了一票，按照上图，节点A同意C节点、节点B同意D节点，那此时C、D都只获的两票，当然如果A,B都认为C或D成为主节点，则选择就可以结束了，上图显示，C、D都只获的2票，未超过半数，无法成为主节点，那接下来会发生什么呢？请看下图：<br><img src="https://img-blog.csdnimg.cn/20190810194709527.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>此时A,B,C,D的定时器各自在倒计时，当节点成为Candidate时，或自身状态本身是Candidate并且定时器触发后，发起一轮新的投票，图中是节点B、节点D同时发起了新的一轮投票。<br><img src="https://img-blog.csdnimg.cn/2019081019475968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>投票结果如下：节点A,节点C同意节点B成为leader，但由于BD都发起了第5轮投票，最终的投票轮次更新为6，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190810194822483.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>关于Raft协议的选主就介绍到这里了，接下来我们来思考一下，如果自己实现 Raf t协议，至少要考虑哪些问题，为下一篇源码阅读Dleger(RocketMQ多副本)模块提供一些思路。</p>
<h3 id="1-3-思考如何实现Raft选主"><a href="#1-3-思考如何实现Raft选主" class="headerlink" title="1.3 思考如何实现Raft选主"></a>1.3 思考如何实现Raft选主</h3><ol>
<li>节点状态<br> 需要引入3中节点状态：Follower(跟随者)、Candidate(候选者)，投票的触发点，Leader(主节点)。</li>
<li>进入投票状态的计时器<br> Follower、Candidate 两个状态时，需要维护一个计时器，每次定时时间从150ms-300ms之间进行随机，即每个节点的每次的计时过期不一样，Follower状态时，计时器到点后，触发一轮投票。节点在收到投票请求、Leader 的心跳请求并作出响应后需要重置定时器。</li>
<li>投票轮次Team<br> Candidate 状态的节点，每发起一轮投票，Term 加一；Term的存储。</li>
<li>投票机制<br> 每一轮一个节点只能为一个节点投赞成票，例如节点A中维护的轮次为3，并且已经为节点B投了赞成票，如果收到其他节点，投票轮次为3，则会投反对票，如果收到轮次为4的节点，是又可以投赞成票的。</li>
<li>成为Leader的条件<br> 必须得到集群中节点的大多数，即超过半数，例如如果集群中有3个节点，则必须得到两票，如果其中一台服务器宕机，剩下的两个节点，还能进行选主吗？答案是可以的，因为可以得到2票，超过初始集群中3的一半，所以通常集群中的机器各位尽量为计数，因为4台的可用性与3台的一样。</li>
</ol>
<blockquote>
<p>温馨提示：上述结论只是我的一些思考，我们可以带着上述思考，进入到Dleger的学习中，下一篇将从源码分析的角度来学习大神是如何实现Raft协议的Leader选主的，让我们一起期待吧。</p>
</blockquote>
<h2 id="2、日志复制"><a href="#2、日志复制" class="headerlink" title="2、日志复制"></a>2、日志复制</h2><p>完成集群内的选主工作后，客户端向主节点发送请求，由主节点负责数据的复制，使集群内的数据保持一致性，初始状态如下图所示：<br><img src="https://img-blog.csdnimg.cn/2019081020073042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>客户端向主节点发起请求，例如set 5，将数据更新为5，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190810201057102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主节点收到客户端请求后，将数据追加到Leader的日志中(但未提交)，然后在下一个心跳包中将日志转发到集群内从节点，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190810201124742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从节点收到Leader的日志后，追加到从节点的日志文件中，并返回确认ACK。Leader收到从节点的确认信息后，向客户端发送确认信息。<br><img src="https://img-blog.csdnimg.cn/20190810201148743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述的日志复制比较简单，是由于只考虑正常的情况，如果中间发生异常，该如何保证数据一致性呢？</p>
<ol>
<li>如果 Leader 节点向从节点广播日志时，其中某个从节点发送故障宕机，该如何处理呢？</li>
<li>日志在什么环节进行提交呢？Leader节点在收到客户端的数据变更请求后，首先追加到主节点的日志文件中，然后广播到从节点，从节点收到日志信息，是提交日志后返回ACK，还是什么时候提交呢？</li>
<li>日志如何保证唯一。</li>
<li>如何处理网络出现分区。</li>
</ol>
<p>我相信读者朋友肯定还有更多的疑问，本文不打算来回答上述疑问，而是带着这些问题进入到RocketMQ多副本的学习中，通过源码分析RocketMQ DLedger的实现后，再来重新总结raft协议。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>主从同步</tag>
        <tag>多副本</tag>
        <tag>raft</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ一行代码造成大量消息发送失败</title>
    <url>/posts/54929501.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、问题现象"><a href="#1、问题现象" class="headerlink" title="1、问题现象"></a>1、问题现象</h2><p>首先接到项目反馈使用 RocketMQ 会出现如下错误：<br><img src="https://img-blog.csdnimg.cn/2020051623272777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>错误信息关键点：MQBrokerException：CODE:2 DESC:[TIMEOUT_CLEAN_QUEUE]broker busy,start flow control for a while,period in queue：205ms，size of queue:880。</p>
<p>由于项目组并没有对消息发送失败做任何补偿，导致丢失消息发送失败，故需要对这个问题进行深层次的探讨，并加以解决。</p>
<h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><p>首先我们根据关键字：TIMEOUT_CLEAN_QUEUE 去 RocketMQ 中查询，去探究在什么时候会抛出如上错误。根据全文搜索如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200517091330168.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>该方法是在 BrokerFastFailure 中定义的，通过名称即可以看成其设计目的：Broker端快速失败机制。</p>
<p><strong>Broker 端快速失败其原理图如下：</strong><br><img src="https://img-blog.csdnimg.cn/20200517091356312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>消息发送者向 Broker 发送消息写入请求，Broker 端在接收到请求后会首先放入一个队列中(SendThreadPoolQueue)，默认容量为 10000。</li>
<li>Broker 会专门使用一个线程池(SendMessageExecutor)去从队列中获取任务并执行消息写入请求，为了保证消息的顺序处理，该线程池默认线程个数为1。</li>
</ul>
<p>如果 Broker 端受到垃圾回收等等因素造成单条写入数据发生抖动，单个 Broker 端积压的请求太多从而得不到及时处理，会极大的造成客户端消息发送的时间延长。</p>
<p>设想一下，如果由于 Broker 压力增大，写入一条消息需要500ms甚至超过1s，并且队列中积压了5000条消息，消息发送端的默认超时时间为3s，如果按照这样的速度，这些请求在轮到 Broker 执行写入请求时，客户端已经将这个请求超时了，这样不仅会造成大量的无效处理，还会导致客户端发送超时。</p>
<a id="more"></a>

<p>故 RocketMQ 为了解决该问题，引入 Broker 端快速失败机制，即开启一个定时调度线程，每隔10毫秒去检查队列中的第一个排队节点，如果该节点的排队时间已经超过了 200ms，就会取消该队列中所有已超过 200ms 的请求，立即向客户端返回失败，这样客户端能尽快进行重试，因为 Broker 都是集群部署，下次重试可以发送到其他 Broker 上，这样能最大程度保证消息发送在默认 3s 的时间内经过重试机制，能有效避免某一台 Broker 由于瞬时压力大而造成的消息发送不可用，从而实现消息发送的高可用。</p>
<p><strong>从 Broker 端快速失败机制引入的初衷来看，快速失败后会发起重试，除非同一深刻集群内所有的 Broker 都繁忙，不然消息会发送成功，用户是不会感知这个错误的，那为什么用户感知了呢？难道 TIMEOUT_ CLEAN _ QUEUE 错误，Broker 不重试？</strong></p>
<p>为了解开这个谜团，接下来会采用源码分析的手段去探究真相。接下来将以消息同步发送为例揭示其消息发送处理流程中的核心关键点。</p>
<p>MQ Client 消息发送端首先会利用网络通道将请求发送到 Broker，然后接收到请求结果后并调用 processSendResponse 方法对响应结果进行解析，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200517093407354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">在这里返回的 code 为 RemotingSysResponseCode . SYSTEM_BUSY。</p>
<p>我们从 proccessSendResponse 方法中可以得知，如果 code 为 SYSTEM_BUSY，该方法会抛出 MQBrokerException，响应 code 为 SYSTEM_BUSY，其错误描述为开头部分的错误信息。</p>
<p>那我们沿着该方法的调用链，可以找到其直接调用方为：DefaultMQProducerImpl 的 sendKernelImpl，我们重点考虑如果底层方法抛出  MQBrokerException 该方法会如何处理。</p>
<p>其关键代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200517093453648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看出在 sendKernelImpl 方法中首先会捕捉异常，先执行注册的钩子函数，即就算执行失败，对应的消息发送后置钩子函数也会执行，然后再原封不动的将该异常向上抛出。</p>
<p>sendKernelImpl 方法被 DefaultMQProducerImpl 的 sendDefaultImpl 方法调用，下面是其核心实现截图：<br><img src="https://img-blog.csdnimg.cn/20200517093512484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">从这里可以看出 RocketMQ 消息发送高可用设计一个非常关键的点，重试机制，其实现是在 for 循环中 使用 try catch 将 sendKernelImpl 方法包裹，就可以保证该方法抛出异常后能继续重试。从上文可知，如果 SYSTEM_BUSY 会抛出 MQBrokerException，但发现只有上述几个错误码才会重试，因为如果不是上述错误码，会继续向外抛出异常，此时 for 循环会被中断，即不会重试。</p>
<p>这里非常令人意外的是连 SYSTEM_ERROR 都会重试，却没有包含 SYSTEM_BUSY，显然违背了快速失败的设计初衷，故笔者断定，这是 RocketMQ 的一个BUG，将 SYSTEM_BUSY 遗漏了，后面与 RocketMQ 核心成员进行过沟通，也印证了这点，后续会提一个 PR，在上面增加一行代码，将 SYSTEM_BUSY 加上即可。</p>
<p>问题分析到这里，该问题应该就非常明了。</p>
<h2 id="3、解决方案"><a href="#3、解决方案" class="headerlink" title="3、解决方案"></a>3、解决方案</h2><p>如果大家在网上搜索 TIMEOUT_CLEAN_QUEUE 的解决方法，大家不约而同提出的解决方案是增加 waitTimeMillsInSendQueue 的值，该值默认为 200ms，例如将其设置为 1000s 等等，以前我是反对的，因为我的认知里 Broker 会重试，但现在发现 Broker 不会重试，所以我现在认为该 BUG未解决的情况下适当提高该值能有效的缓解。</p>
<p><strong>但这是并不是好的解决方案，我会在近期向官方提交一个PR，将这个问题修复，建议大家在公司尽量对自己使用的版本进行修改，重新打一个包即可，因为这已经违背了 Broker 端快速失败的设计初衷。</strong></p>
<p>但在消息发送的业务方，尽量自己实现消息的重试机制，即不依懒 RocketMQ 本身提供的重试机制，因为受制与网络等因素，消息发送不可能百分之百成功，建议大家在消息发送时捕获一下异常，如果发送失败，可以将消息存入数据库，再结合定时任务对消息进行重试，尽最大程度保证消息不丢失。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>rocketmq</tag>
        <tag>CONSUME_FROM_TIMESTAMP</tag>
        <tag>waitTimeMillsInSendQueue</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ事务消息实战</title>
    <url>/posts/56026c9f.html</url>
    <content><![CDATA[<div id="vip-container"><p>我们以一个订单流转流程来举例，例如订单子系统创建订单，需要将订单数据下发到其他子系统（与第三方系统对接）这个场景，我们通常会将两个系统进行解耦，不直接使用服务调用的方式进行交互。其业务实现步骤通常为：</p>
<ol>
<li>A系统创建订单并入库</li>
<li>发送消息到MQ</li>
<li>MQ消费者消费消息，发送远程RPC服务调用，完成订单数据的同步。</li>
</ol>
<h2 id="1、方案一"><a href="#1、方案一" class="headerlink" title="1、方案一"></a>1、方案一</h2><ol>
<li><img src="https://img-blog.csdn.net/20180731191040691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>&ensp; &ensp;方案弊端：<br>&ensp; &ensp;1、如果消息发送成功，在提交事务的时候JVM突然挂掉，事务没有成功提交，导致两个系统之间数据不一致。<br>&ensp; &ensp;2、由于消息是在事务提交之前提交，发送的消息内容是订单实体的内容，会造成在消费端进行消费时如果需要去验证订单是否存在时可能出现订单不存在。<br>&ensp; &ensp;3、消息发送可以考虑异步发送。</li>
</ol>
<a id="more"></a>

<h2 id="2、方案二："><a href="#2、方案二：" class="headerlink" title="2、方案二："></a>2、方案二：</h2><p>&ensp; &ensp;由于存在上述问题，在MQ不支持事务消息的前提条件下，可以采用下面的方式进行优化。<br><img src="https://img-blog.csdn.net/20180802105157536?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>&ensp; &ensp;然后在控制器层，使用异步发送，将消息发送，并在消息发送成功后，更新待发送状态为已发送。<br>&ensp; &ensp;然后通过定时任务，扫描待发送，结合创建时间的记录（小于当前时间5分钟的消息待发送记录），进行消息发送。<br>&ensp; &ensp;方案弊端：<br>&ensp; &ensp;1、消息有可能重复发送，但在消费端可以通过唯一业务编号来进行去重设计。<br>&ensp; &ensp;2、实现过于复杂，为了避免 极端情况下的消息丢失，需要使用定时任务。</p>
<h2 id="3、方案三：基于RocketMQ4-3版本事务消息"><a href="#3、方案三：基于RocketMQ4-3版本事务消息" class="headerlink" title="3、方案三：基于RocketMQ4.3版本事务消息"></a>3、方案三：基于RocketMQ4.3版本事务消息</h2><p><img src="https://img-blog.csdn.net/201807311912029?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>&ensp; &ensp;额外需要实现事务会查监听器：TransactionListener，其实例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.apache.rocketmq.client.producer.LocalTransactionState;</span><br><span class="line">import org.apache.rocketmq.client.producer.TransactionListener;</span><br><span class="line">import org.apache.rocketmq.common.message.Message;</span><br><span class="line">import org.apache.rocketmq.common.message.MessageExt;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">public class OrderTransactionListenerImpl implements TransactionListener &#123;</span><br><span class="line">	</span><br><span class="line">	private ConcurrentHashMap&lt;String, Integer&gt; countHashMap &#x3D; new ConcurrentHashMap&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	private final static int MAX_COUNT &#x3D; 5;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">    public LocalTransactionState executeLocalTransaction(Message msg, Object arg) &#123;</span><br><span class="line">        &#x2F;&#x2F; </span><br><span class="line">    	String bizUniNo &#x3D; msg.getUserProperty(&quot;bizUniNo&quot;); &#x2F;&#x2F; 从消息中获取业务唯一ID。</span><br><span class="line">    	&#x2F;&#x2F; 将bizUniNo入库，表名：t_message_transaction,表结构  bizUniNo(主键),业务类型。</span><br><span class="line">        return LocalTransactionState.UNKNOW;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public LocalTransactionState checkLocalTransaction(MessageExt msg) &#123;</span><br><span class="line">        Integer status &#x3D; 0;</span><br><span class="line">        &#x2F;&#x2F; 从数据库查查询t_message_transaction表，如果该表中存在记录，则提交，</span><br><span class="line">        String bizUniNo &#x3D; msg.getUserProperty(&quot;bizUniNo&quot;); &#x2F;&#x2F; 从消息中获取业务唯一ID。</span><br><span class="line">        &#x2F;&#x2F; 然后t_message_transaction 表，是否存在bizUniNo，如果存在，则返回COMMIT_MESSAGE，</span><br><span class="line">        &#x2F;&#x2F; 不存在，则记录查询次数，未超过次数，返回UNKNOW，超过次数，返回ROLLBACK_MESSAGE</span><br><span class="line">        </span><br><span class="line">        if(query(bizUniNo) &gt; 0 ) &#123;</span><br><span class="line">        	return LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return rollBackOrUnown(bizUniNo);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int query(String bizUniNo) &#123;</span><br><span class="line">    	return 1; &#x2F;&#x2F;select count(1) from t_message_transaction a where a.biz_uni_no&#x3D;#&#123;bizUniNo&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public LocalTransactionState rollBackOrUnown(String bizUniNo) &#123;</span><br><span class="line">    	Integer num &#x3D; countHashMap.get(bizUniNo);</span><br><span class="line">    	</span><br><span class="line">    	if(num !&#x3D; null &amp;&amp;  ++num &gt; MAX_COUNT) &#123;</span><br><span class="line">    		countHashMap.remove(bizUniNo);</span><br><span class="line">    		return LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	if(num &#x3D;&#x3D; null) &#123;</span><br><span class="line">    		num &#x3D; new Integer(1);</span><br><span class="line">    	&#125;</span><br><span class="line">    	</span><br><span class="line">    	countHashMap.put(bizUniNo, num);</span><br><span class="line">    	return LocalTransactionState.UNKNOW;</span><br><span class="line">    	</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp;TransactionListener 实现要点：<br>&ensp; &ensp;executeLocalTransaction：<br>&ensp; &ensp;该方法，主要是设置本地事务状态，该方法与业务方代码在一个事务中，例如OrderServer#createMap中，只要本地事务提交成功，该方法也会提交成功。<br>&ensp; &ensp;故在这里，主要是t_message_transaction添加一条记录，在事务会查时，如果存在记录，就认为是该消息需要提交。<br>&ensp; &ensp;checkLocalTransaction：<br>&ensp; &ensp;该方法主要是告知RocketMQ消息是否需要提交还是回滚，如果本地事务表（t_message_transaction）存在记录，则认为提交，如果不存在，可以设置会查次数，如果指定次数内还是未查到消息，则回滚，否则返回未知，rocketmq会按一定的频率回查事务，当然回查次数也有限制，默认为5次，可配置。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>实战</tag>
        <tag>事务消息</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ学习环境搭建(RocketMQ安装与IDEA Debug环境搭建)</title>
    <url>/posts/3f6db0.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文主要分如下几个部分展开：</p>
<ul>
<li>Linux服务器安装RocketMQ、RocketMQ-Console</li>
<li>IDEA中搭建可调试环境</li>
</ul>
<h2 id="1、Linux安装RocketMQ、RocketMQ-Console"><a href="#1、Linux安装RocketMQ、RocketMQ-Console" class="headerlink" title="1、Linux安装RocketMQ、RocketMQ-Console"></a>1、Linux安装RocketMQ、RocketMQ-Console</h2><h3 id="1-1安装RocketMQ"><a href="#1-1安装RocketMQ" class="headerlink" title="1.1安装RocketMQ"></a>1.1安装RocketMQ</h3><p>Step1：从如下地址下载RocketMQ安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /opt/application</span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/apache/rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip</span><br></pre></td></tr></table></figure>

<p>Step2：解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">unzip rocketmq-all-4.7.1-bin-release.zip</span><br><span class="line">ls -l</span><br></pre></td></tr></table></figure>

<p>解压后的文件如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011210742646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其中 conf 文件夹存放的是RocketMQ的配置文件，提供了各种部署结构的示例配置。例如2m-2s-async是2主2从异步复制的配置示例；2m-noslave是2主的示例配置。由于本文主要是搭建一个学习环境，故采取的部署架构为1主的部署架构，关于生产环境下如何搭建RocketMQ集群、如何调优参数将在该专栏的后续文章中专门介绍。</p>
<p>Step3：修改Nameserver jvm参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd bin</span><br><span class="line">vi runserver.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 定位到如下代码</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改　<span class="string">&quot;-Xms -Xmx -Xmn&quot;</span>　参数</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms512M -Xmx512M -Xmn256M -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>温馨提示：这里修改JVM参数主要目的是个人学习电脑内存不够，默认NameServer 会占用4G。</p>
</blockquote>
<p>Step4：启动nameserver</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup ./mqnamesrv &amp;</span><br></pre></td></tr></table></figure>

<p>查看${user_home}/logs/rocketmqlogs/namesrv.log日志文件，如果输出结果如下图所示即表示启动成功。<br><img src="https://img-blog.csdnimg.cn/20201011210817888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<a id="more"></a>

<p>Step5：修改broker的配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi conf/broker.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用如下配置文件</span></span><br><span class="line">brokerClusterName = DefaultCluster</span><br><span class="line">brokerName = broker-a</span><br><span class="line">brokerId = 0</span><br><span class="line">deleteWhen = 04</span><br><span class="line">fileReservedTime = 48</span><br><span class="line">brokerRole = ASYNC_MASTER</span><br><span class="line">flushDiskType = ASYNC_FLUSH</span><br><span class="line">storePathRootDir=/data/rocketmq/store</span><br><span class="line">storePathCommitLog=/data/rocketmq/store/commitlog</span><br><span class="line">namesrvAddr=127.0.0.1:9876</span><br><span class="line">brokerIP1=192.168.3.10</span><br><span class="line">brokerIP2=192.168.3.10</span><br><span class="line">autoCreateTopicEnable=false</span><br></pre></td></tr></table></figure>

<p>Step6：修改broker jvm参数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd bin</span><br><span class="line">vi runbroker.sh </span><br><span class="line"><span class="meta">#</span><span class="bash">修改如下配置(配置前)</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms8g -Xmx8g -Xmn4g&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">配置后</span></span><br><span class="line">JAVA_OPT=&quot;$&#123;JAVA_OPT&#125; -server -Xms1g -Xmx1g -Xmn512m&quot;</span><br></pre></td></tr></table></figure>

<p>Step7：启动broker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd bin</span><br><span class="line">nohup ./mqbroker -c ../conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>

<p>查看${user_home}/logs/rocketmqlogs/broker.log，如果输出结果如下图所示表示启动成功。<br><img src="https://img-blog.csdnimg.cn/20201011210843210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>经过上面的步骤，就成功在Linux环境上安装了RocketMQ Nameserver服务器与Broker服务器。</p>
<blockquote>
<p>温馨提示：如果上面在安装过程中发生了错误，大家可以查看${user_home}/logs/rocketmqlogs中的日志，通过错误日志，能够较为直观的判断错误的原因。其中${user_home}为用户主目录。</p>
<p>该目录下会有众多的日志文件，如果一开始对这些文件的含义不了解也没关系，大家可以通过 ls -l 命令，逐一查看文件大小不为０的文件，从而寻找错误日志，便于快速解决问题。</p>
</blockquote>
<p>RocketMQ提供了众多的运维命令来查看RocketMQ集群的运行状态，在这里我先简单使用clusterList命令来查看集群的状态，用于验证一下集群的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh ./mqadmin clusterList -n 127.0.0.1:9876</span><br></pre></td></tr></table></figure>
<p>其运行结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020101121091323.png#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-2-安装RocketMQ-Console"><a href="#1-2-安装RocketMQ-Console" class="headerlink" title="1.2 安装RocketMQ-Console"></a>1.2 安装RocketMQ-Console</h3><p>使用运维命令不太直观，学习成本较大，为此RocketMQ官方提供了一个运维管理界面RokcetMQ-Console，用于对RocketMQ集群提供常用的运维功能，故本节主要讲解如何在Linux环境安装rocketmq-console。</p>
<p>RocketMQ官方并未提供rocketmq-console的安装包，故需要通过源码进行编译。</p>
<p>Step1：下载源码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://github.com/apache/rocketmq-externals/archive/rocketmq-console-1.0.0.tar.gz</span><br><span class="line">tar -xf rocketmq-console-1.0.0.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名，为了方便后续操作</span></span><br><span class="line">mv rocketmq-externals-rocketmq-console-1.0.0/rocketmq-console  rocketmq-console</span><br></pre></td></tr></table></figure>

<p>Step2：修改配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd rocketmq-console</span><br><span class="line">vi src/main/resources/applications.properties</span><br></pre></td></tr></table></figure>

<p>主要是修改指向的nameserver地址，修改结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011210939919.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：使用maven命令编译源代码。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn clean  package -DskipTests</span><br></pre></td></tr></table></figure>

<p>编译后在target目录下会生成可运行的jar包，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011210958471.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step4：我们可以将该包复制到自己常用的软件安装目录，例如笔者喜欢将其放在/opt/application下。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp rocketmq-console-ng-1.0.0.jar /opt/application/</span><br></pre></td></tr></table></figure>
<p>Step5：启动rocketmq-conolse</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup java -jar rocketmq-console-ng-1.0.0.jar &amp;</span><br></pre></td></tr></table></figure>

<p>在浏览器中输入:<a href="http://localhost:8080查看是否安装成功，如果出现如下图则表示安装成功。">http://localhost:8080查看是否安装成功，如果出现如下图则表示安装成功。</a><br><img src="https://img-blog.csdnimg.cn/20201011211021557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h3 id="1-3-异常分析与解决思路"><a href="#1-3-异常分析与解决思路" class="headerlink" title="1.3 异常分析与解决思路"></a>1.3 异常分析与解决思路</h3><p>如果在安装过程中出现意想不到的错误，别慌，通过查看相关的日志文件，寻找错误日志，根据错误日志进行思考或百度，相信能够轻易将其解决。</p>
<p>例如使用的baseuser 启动的rocketmq，rocketmq-console，那相关的日志路径如下：</p>
<p>rocketmq：/home/baseuser/logs/rocketmqlogs/<br>rocketmq-console：/home/baseuser/logs/consolelogs</p>
<h2 id="2、IDEA中安装RocketMQ"><a href="#2、IDEA中安装RocketMQ" class="headerlink" title="2、IDEA中安装RocketMQ"></a>2、IDEA中安装RocketMQ</h2><p>绝大数的程序员最信赖的开发调试工具基本都是DEBUG，那能在 IDEA 中 debug RocketMQ的源码吗？答案当然是可以的。本节就来演示如何在IDEA中运行RocketMQ的Nameserver、Broker组件，并进行Debug。</p>
<p>Setp1：从github上下载RocketMQ源码，并将其导入到IEDA中，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20201011211103703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step2:namesrv/src/main/java/org/apache/rocketmq/namesrv/NamesrvStartup设置环境变量ROCKETMQ_HOME，操作步骤如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011211215333.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>设置环境变量名称：ROCKETMQ_HOME，其值用于指定RocketMQ运行的主目录，笔者设置的路径为：/home/dingwpmz/tmp/rocketmq。</p>
<p>Step3：将distribution/conf/logback_namesrv.xml文件拷贝到【Step2】中设置的主目录下,执行后的效果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011211228426.png#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>温馨提示：该文件为nameserver的日志路劲，可以手动修改logback_namesrv.xml文件中的日志目录，由于这是logback的基础知识，这里就不再详细介绍logback的配置方法。</p>
</blockquote>
<p>Step4：以debug方法运行NamesrvStartup，执行效果如下图所示,表示启动成功。<br><img src="https://img-blog.csdnimg.cn/20201011211248609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step5：将distribution/conf/logback_brokerxml、broker.conf文件拷贝到【Step2】中设置的主目录下,执行后的效果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011211302502.png#pic_center" alt="在这里插入图片描述">Step6：修改broker.conf中的配置，主要设置nameserver的地址，broker的名称等相关属性。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">vi</span> <span class="string">broker.conf</span></span><br><span class="line"><span class="comment"># 使用如下配置文件</span></span><br><span class="line"><span class="attr">brokerClusterName</span> = <span class="string">DefaultCluster</span></span><br><span class="line"><span class="attr">brokerName</span> = <span class="string">broker-a</span></span><br><span class="line"><span class="attr">brokerId</span> = <span class="string">0</span></span><br><span class="line"><span class="attr">deleteWhen</span> = <span class="string">04</span></span><br><span class="line"><span class="attr">fileReservedTime</span> = <span class="string">48</span></span><br><span class="line"><span class="attr">brokerRole</span> = <span class="string">ASYNC_MASTER</span></span><br><span class="line"><span class="attr">flushDiskType</span> = <span class="string">ASYNC_FLUSH</span></span><br><span class="line"><span class="attr">storePathRootDir</span>=<span class="string">/home/dingwpmz/tmp/rocketmq/store</span></span><br><span class="line"><span class="attr">storePathCommitLog</span>=<span class="string">/home/dingwpmz/tmp/rocketmq/store/commitlog</span></span><br><span class="line"><span class="attr">namesrvAddr</span>=<span class="string">127.0.0.1:9876</span></span><br><span class="line"><span class="attr">brokerIP1</span>=<span class="string">192.168.3.10</span></span><br><span class="line"><span class="attr">brokerIP2</span>=<span class="string">192.168.3.10</span></span><br><span class="line"><span class="attr">autoCreateTopicEnable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>Step7：broker/src/main/java/org/apache/rocketmq/broker/BrokerStartup设置环境变量ROCKETMQ_HOME，操作步骤如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011211319281.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step8：以Debug模式运行BrokerStartup，其运行结果如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201011211331486.png#pic_center" alt="在这里插入图片描述"><br>看到这样的提示就表示大功告成。</p>
<p>接下来简单来做一个验证。</p>
<p>首先先在AbstractSendMessageProcessor类的parseRequestHeader方法中打上一个断点。</p>
<p>然后运行example中org/apache/rocketmq/example/quickstart/Producer，看是否能进入到断点中，运行结果如下图所示，已进入到Debug模式。<br><img src="https://img-blog.csdnimg.cn/20201011211352570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h2><p>本篇作为RocketMQ实战系列的第一篇文章，其目的就是构建一个研究RocketMQ的学习环境，故从两个方面进行展开：</p>
<p>１、在Linux环境安装RocketMQ、RocketMQ-Console。</p>
<p>２、在IDEA中运行RocketMQ，构建一个可以调试RocketMQ的环境。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>RocketMQ安装</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ实战：生产环境中，autoCreateTopicEnable为什么不能设置为true</title>
    <url>/posts/e6afac5e.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h2><p>很多网友会问，为什么明明集群中有多台Broker服务器，autoCreateTopicEnable设置为true，表示开启Topic自动创建，但新创建的Topic的路由信息只包含在其中一台Broker服务器上，这是为什么呢？</p>
<p>期望值：为了消息发送的高可用，希望新创建的Topic在集群中的每台Broker上创建对应的队列，避免Broker的单节点故障。</p>
<p>现象截图如下：<br><img src="https://img-blog.csdnimg.cn/20190611220611635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="Broker集群信息"><br><img src="https://img-blog.csdnimg.cn/20190611220736135.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正如上图所示，自动创建的topicTest5的路由信息：</p>
<ul>
<li>topicTest5只在broker-a服务器上创建了队列，并没有在broker-b服务器创建队列，不符合期望。</li>
<li>默认读写队列的个数为4。</li>
</ul>
<p>我们再来看一下RocketMQ默认topic的路由信息截图如下：<br><img src="https://img-blog.csdnimg.cn/20190611220839184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从图中可以默认Topic的路由信息为broker-a、broker-b上各8个队列。</p>
<h2 id="2、思考"><a href="#2、思考" class="headerlink" title="2、思考"></a>2、思考</h2><p>默认Topic的路由信息是如何创建的？</p>
<ol>
<li>Topic的路由信息是存储在哪里？Nameserver？broker?</li>
<li>RocketMQ Topic默认队列个数是多少呢？</li>
</ol>
<h2 id="3、原理"><a href="#3、原理" class="headerlink" title="3、原理"></a>3、原理</h2><h3 id="3-1-RocketMQ基本路由规则"><a href="#3-1-RocketMQ基本路由规则" class="headerlink" title="3.1 RocketMQ基本路由规则"></a>3.1 RocketMQ基本路由规则</h3><p><img src="https://img-blog.csdnimg.cn/20190611221028332.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>Broker在启动时向Nameserver注册存储在该服务器上的路由信息，并每隔30s向Nameserver发送心跳包，并更新路由信息。</li>
<li>Nameserver每隔10s扫描路由表，如果检测到Broker服务宕机，则移除对应的路由信息。</li>
<li>消息生产者每隔30s会从Nameserver重新拉取Topic的路由信息并更新本地路由表；在消息发送之前，如果本地路由表中不存在对应主题的路由消息时，会主动向Nameserver拉取该主题的消息。</li>
</ol>
<p>回到本文的主题：autoCreateTopicEnable，开启自动创建主题，试想一下，如果生产者向一个不存在的主题发送消息时，上面的任何一个步骤都无法获取一个不存在的主题的路由信息，那该如何处理这种情况呢？</p>
<a id="more"></a>

<p>在RocketMQ中，如果autoCreateTopicEnable设置为true，消息发送者向NameServer查询主题的路由消息返回空时，会尝试用一个系统默认的主题名称(MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC)，此时消息发送者得到的路由信息为：<br><img src="https://img-blog.csdnimg.cn/20190611221220259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>但问题就来了，默认Topic在集群的每一台Broker上创建8个队列，那问题来了，为啥新创建的Topic只在一个Broker上创建4个队列？</p>
<h3 id="3-2-探究autoCreateTopicEnable机制"><a href="#3-2-探究autoCreateTopicEnable机制" class="headerlink" title="3.2 探究autoCreateTopicEnable机制"></a>3.2 探究autoCreateTopicEnable机制</h3><h4 id="3-2-1-默认Topic路由创建时机"><a href="#3-2-1-默认Topic路由创建时机" class="headerlink" title="3.2.1 默认Topic路由创建时机"></a>3.2.1 默认Topic路由创建时机</h4><blockquote>
<p>温馨提示：本文不会详细跟踪整个创建过程，只会点出源码的关键入口点，如想详细了解NameServer路由消息、消息发送高可用的实现原理，建议查阅笔者的书籍《RocketMQ技术内幕》第二、三章。</p>
</blockquote>
<p>Step1：在Broker启动流程中，会构建TopicConfigManager对象，其构造方法中首先会判断是否开启了允许自动创建主题，如果启用了自动创建主题，则向topicConfigTable中添加默认主题的路由信息。<br>TopicConfigManager构造方法<br><img src="https://img-blog.csdnimg.cn/20190611221400814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>备注：该topicConfigTable中所有的路由信息，会随着Broker向Nameserver发送心跳包中，Nameserver收到这些信息后，更新对应Topic的路由信息表。</p>
</blockquote>
<p>BrokerConfig的defaultTopicQueueNum默认为8。两台Broker服务器都会运行上面的过程，故最终Nameserver中关于默认主题的路由信息中，会包含两个Broker分别各8个队列信息。</p>
<p>Step2：生产者寻找路由信息<br>生产者首先向NameServer查询路由信息，由于是一个不存在的主题，故此时返回的路由信息为空，RocketMQ会使用默认的主题再次寻找，由于开启了自动创建路由信息，NameServer会向生产者返回默认主题的路由信息。然后从返回的路由信息中选择一个队列（默认轮询）。消息发送者从Nameserver获取到默认的Topic的队列信息后，队列的个数会改变吗？答案是会的，其代码如下：</p>
<p>MQClientInstance#updateTopicRouteInfoFromNameServer<br><img src="https://img-blog.csdnimg.cn/20190611221527317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>温馨提示：消息发送者在到默认路由信息时，其队列数量，会选择DefaultMQProducer#defaultTopicQueueNums与Nameserver返回的的队列数取最小值，DefaultMQProducer#defaultTopicQueueNums默认值为4，故自动创建的主题，其队列数量默认为4。</p>
</blockquote>
<p>Step3：发送消息</p>
<p>DefaultMQProducerImpl#sendKernelImpl<br><img src="https://img-blog.csdnimg.cn/20190611221914123.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在消息发送时的请求报文中，设置默认topic名称，消息发送topic名称，使用的队列数量为DefaultMQProducer#defaultTopicQueueNums，即默认为4。</p>
<p>Step4：Broker端收到消息后的处理流程<br>服务端收到消息发送的处理器为：SendMessageProcessor，在处理消息发送时，会调用super.msgCheck方法：</p>
<p>AbstractSendMessageProcessor#msgCheck<br><img src="https://img-blog.csdnimg.cn/20190611222012179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在Broker端，首先会使用TopicConfigManager根据topic查询路由信息，如果Broker端不存在该主题的路由配置(路由信息),此时如果Broker中存在默认主题的路由配置信息，则根据消息发送请求中的队列数量，在Broker创建新Topic的路由信息。这样Broker服务端就会存在主题的路由信息。</p>
<p>在Broker端的topic配置管理器中存在的路由信息，一会向Nameserver发送心跳包，汇报到Nameserver，另一方面会有一个定时任务，定时存储在broker端，具体路径为${ROCKET_HOME}/store/config/topics.json中，这样在Broker关闭后再重启，并不会丢失路由信息。</p>
<p>广大读者朋友，跟踪到这一步的时候，大家应该对启用自动创建主题机制时，新主题是的路由信息是如何创建的，为了方便理解，给出创建主题序列图：<br><img src="https://img-blog.csdnimg.cn/20190611222056216.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="3-2-2-现象分析"><a href="#3-2-2-现象分析" class="headerlink" title="3.2.2 现象分析"></a>3.2.2 现象分析</h4><p>经过上面自动创建路由机制的创建流程，我们可以比较容易的分析得出如下结论：<br>因为开启了自动创建路由信息，消息发送者根据Topic去NameServer无法得到路由信息，但接下来根据默认Topic从NameServer是能拿到路由信息(在每个Broker中，存在8个队列)，因为两个Broker在启动时都会向NameServer汇报路由信息。此时消息发送者缓存的路由信息是2个Broker，每个Broker默认4个队列（原因见3.2.1:Step2的分析）。消息发送者然后按照轮询机制，发送第一条消息选择(broker-a的messageQueue:0)，向Broker发送消息，Broker服务器在处理消息时，首先会查看自己的路由配置管理器(TopicConfigManager)中的路由信息，此时不存在对应的路由信息，然后尝试查询是否存在默认Topic的路由信息，如果存在，说明启用了autoCreateTopicEnable，则在TopicConfigManager中创建新Topic的路由信息，此时存在与Broker服务端的内存中，然后本次消息发送结束。此时，在NameServer中还不存在新创建的Topic的路由信息。</p>
<p>这里有三个关键点：</p>
<ol>
<li>启用autoCreateTopicEnable创建主题时，在Broker端创建主题的时机为，消息生产者往Broker端发送消息时才会创建。</li>
<li>然后Broker端会在一个心跳包周期内，将新创建的路由信息发送到NameServer，于此同时，Broker端还会有一个定时任务，定时将内存中的路由信息，持久化到Broker端的磁盘上。</li>
<li>消息发送者会每隔30s向NameServer更新路由信息，如果消息发送端一段时间内未发送消息，就不会有消息发送集群内的第二台Broker，那么NameServer中新创建的Topic的路由信息只会包含Broker-a，然后消息发送者会向NameServer拉取最新的路由信息，此时就会消息发送者原本缓存了2个broker的路由信息，将会变为一个Broker的路由信息，则该Topic的消息永远不会发送到另外一个Broker，就出现了上述现象。</li>
</ol>
<p>原因就分析到这里了，现在我们还可以的大胆假设，开启autoCreateTopicEnable机制，什么情况会在两个Broker上都创建队列，其实，我们只需要连续快速的发送9条消息，就有可能在2个Broker上都创建队列，验证代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest10&quot;</span> ,<span class="string">&quot;TagA&quot;</span> , (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证结果如图所示：<br><img src="https://img-blog.csdnimg.cn/2019061122240920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>本文就分析到这里了，大家如果喜欢这篇文章，麻烦大家帮忙点点赞，同时大家也可以给作者留言，告知在使用RocketMQ的过程中遇到的疑难杂症，与作者互动。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>autoCreateTopicEnable</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ核心概念扫盲篇</title>
    <url>/posts/32f79e19.html</url>
    <content><![CDATA[<div id="vip-container"><p>在正式进入RocketMQ的学习之前，我觉得有必要梳理一下RocketMQ核心概念，为大家学习RocketMQ打下牢固的基础。</p>
<h2 id="1、RocketMQ部署架构"><a href="#1、RocketMQ部署架构" class="headerlink" title="1、RocketMQ部署架构"></a>1、RocketMQ部署架构</h2><p><img src="https://img-blog.csdnimg.cn/20201018221302331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在RocketMQ主要的组件如下：</p>
<ul>
<li><p>Nameserver</p>
<p>Nameserver集群，topic的路由注册中心，为客户端根据Topic提供路由服务，从而引导客户端向Broker发送消息。Nameserver之间的节点不通信。路由信息在Nameserver集群中数据一致性采取的最终一致性。</p>
</li>
<li><p>Broker</p>
<p>消息存储服务器，分为两种角色：Master与Slave，上图中呈现的就是2主2从的部署架构，在RocketMQ中，主服务承担读写操作，从服务器作为一个备份，当主服务器存在压力时，从服务器可以承担读服务（消息消费）。所有Broker，包含Slave服务器每隔30s会向Nameserver发送心跳包，心跳包中会包含存在在Broker上所有的topic的路由信息。</p>
</li>
<li><p>Client</p>
<p>消息客户端，包括Producer(消息发送者)和Consumer(消费消费者)．客户端在同一时间只会连接一台nameserver，只有在连接出现异常时才会向尝试连接另外一台。客户端每隔30s向Nameserver发起topic的路由信息查询。</p>
</li>
</ul>
<blockquote>
<p>温馨提示：Nameserver是在内存中存储Topic的路由信息，持久化Topic路由信息的地方是在Broker中，即${    ROCKETMQ_HOME}/store/config/topics.json。</p>
</blockquote>
<p>在RocketMQ4.5.0版本后引入了多副本机制，即一个复制组（m-s）可以演变为基于raft协议的复制组，复制组内部使用raft协议保证broker节点数据的强一致性，该部署架构在金融行业用的比较多。</p>
<a id="more"></a>

<h2 id="2、消息订阅模型"><a href="#2、消息订阅模型" class="headerlink" title="2、消息订阅模型"></a>2、消息订阅模型</h2><p>在RocketMQ的消息消费模式采用的是发布与订阅模式。</p>
<p>topic：一类消息的集合，消息发送者将一类消息发送到一个主题中，例如订单模块将订单发送到 order_topic 中，而用户登录时，将登录事件发送到 user_login_topic 中。</p>
<p>consumegroup：消息消费组，一个消费单位的“群体”，消费组首先在启动时需要订阅需要消费的topic。一个topic可以被多个消费组订阅，同样一个消费组也可以订阅多个主题。一个消费组拥有多个消费者。</p>
<p><strong>术语解释起来有点枯燥晦涩，接下来我举例来阐述。</strong></p>
<p>例如我们在开发一个订单系统，其中有一个子系统：order-service-app，在该项目中会创建一个消费组order_consumer来订阅 order_topic，并且基于分布式部署，order-service-app的部署情况如下：<br><img src="https://img-blog.csdnimg.cn/20201018221353399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>即order-service-app部署了3台服务器，每一个jvm进程可以看做是消费组 order_consumer 消费组的其中一个消费者。</p>
<h4 id="2-1-消费模式"><a href="#2-1-消费模式" class="headerlink" title="2.1 消费模式"></a>2.1 消费模式</h4><p>那这三个消费者如何来分工来共同消费 order_topic 中的消息呢？</p>
<p>在RocketMQ中支持广播模式与集群模式。</p>
<p><strong>广播模式</strong>：一个消费组内的所有消费者每一个都会处理topic中的每一条消息，通常用于刷新内存缓存。</p>
<p><strong>集群模式</strong>：一个消费组内的所有消费者共同消费一个topic中的消息，即分工协作，一个消费者消费一部分数据，启动负载均衡，</p>
<p>集群模式是非常普遍的模式，符合分布式架构的基本理念，即横向扩容，当前消费者如果无法快速及时处理消息时，可以通过增加消费者的个数横向扩容，快速提高消费能力，及时处理挤压的消息。</p>
<h4 id="2-2-消费队列负载算法与重平衡机制"><a href="#2-2-消费队列负载算法与重平衡机制" class="headerlink" title="2.2 消费队列负载算法与重平衡机制"></a>2.2 消费队列负载算法与重平衡机制</h4><p>那集群模式下，消费者是如何来分配消息的呢？</p>
<p>例如上面实例中order_topic有16个队列，那一个拥有3个消费者的消费组如何来分配队列中。</p>
<p><strong>在MQ领域有一个不成文的约定：同一个消费者同一时间可以分配多个队列，但一个队列同一时间只会分配给一个消费者。</strong></p>
<p><strong>RocketMQ提供了众多的队列负载算法</strong>，其中最常用的两种平均分配算法。</p>
<ul>
<li><p>AllocateMessageQueueAveragely</p>
<p>平均分配</p>
</li>
<li><p>AllocateMessageQueueAveragelyByCircle</p>
<p>轮流平均分配</p>
</li>
</ul>
<p>为了说明这两种分配算法的分配规则，现在对16个队列，进行编号，用q0~q15表示，消费者用c0～c2表示。</p>
<p>AllocateMessageQueueAveragely分配算法的队列负载机制如下：</p>
<p>c0：q0 q1 q2 q3 q4 q5</p>
<p>c1:   q6 q7 q8 q9 q10</p>
<p>c2:    q11 q12 q13 q14 q15</p>
<p>其算法的特点是用总数除以消费者个数，余数按消费者顺序分配给消费者，故c0会多分配一个队列，而且队列分配是连续的。</p>
<p>AllocateMessageQueueAveragelyByCircle分配算法的队列负载机制如下：</p>
<p>c0：q0  q3 q6 q9 q12 q15</p>
<p>c1:   q1   q4 q7 q10 q13</p>
<p>c2:    q2   q5 q8 q11 q14</p>
<p>该分配算法的特点就是轮流一个一个分配。</p>
<blockquote>
<p>温馨提示：如果topic的队列个数小于消费者的个数，那有些消费者无法分配到消息。在RocketMQ中一个topic的队列数直接决定了最大消费者的个数，但topic队列个数的增加对RocketMQ的性能不会产生影响。</p>
</blockquote>
<p>在实际过程中，对主题进行扩容(增加队列个数)或者对消费者进行扩容、缩容是一件非常寻常的事情，那如果新增一个消费者，该消费者消费哪些队列呢？这就涉及到消息消费队列的重新分配，即<strong>消费队列重平衡机制</strong>。</p>
<p>在RocketMQ客户端中会每隔20s去查询当前topic的所有队列、消费者的个数，运用队列负载算法进行重新分配，然后与上一次的分配结果进行对比，如果发生了变化，则进行队列重新分配；如果没有发生变化，则忽略。</p>
<p>例如采取的分配算法如下图所示，现在增加一个消费者c3，那队列的分布情况是怎样的呢？<br><img src="https://img-blog.csdnimg.cn/20201018221426351.png#pic_center" alt="在这里插入图片描述"><br>根据新的分配算法，其队列最终的情况如下：</p>
<p>c0：q0 q1 q2 q3 </p>
<p>c1:   q4 q5 q6 q7</p>
<p>c2:    q8 q9 q10 q11</p>
<p>c3:    q12 q13 q14  q15</p>
<p>上述整个过程无需应用程序干预，由RocketMQ完成。大概的做法就是将将原先分配给自己但这次不属于的队列进行丢弃，新分配的队列则创建新的拉取任务。</p>
<h4 id="2-3-消费进度"><a href="#2-3-消费进度" class="headerlink" title="2.3 消费进度"></a>2.3 消费进度</h4><p>消费者消费一条消息后需要记录消费的位置，这样在消费端重启的时候，继续从上一次消费的位点开始进行处理新的消息。在RocketMQ中，消息消费位点的存储是以消费组为单位的。</p>
<p><strong>集群模式</strong>下，消息消费进度存储在broker端，$ { ROCKETMQ_HOME }/store/config/consumerOffset.json 是其具体的存储文件，其中内容截图如下：<br><img src="https://img-blog.csdnimg.cn/2020101822144865.png#pic_center" alt="在这里插入图片描述"><br>可见消费进度的Key为：topic@consumeGroup，然后每一个队列一个偏移量。</p>
<p><strong>广播模式</strong>的消费进度文件存储在用户的主目录，默认文件全路劲名：$ { USER_HOME }/.rocketmq_offsets。</p>
<h4 id="2-4-消费模型"><a href="#2-4-消费模型" class="headerlink" title="2.4 消费模型"></a>2.4 消费模型</h4><p>RocketMQ提供了并发消费、顺序消费两种消费模型。</p>
<p><strong>并发消费</strong>：对一个队列中消息，每一个消费者内部都会创建一个线程池，对队列中的消息多线程处理，即偏移量大的消息比偏移量小的消息有可能先消费。</p>
<p><strong>顺序消费</strong>：在某一项场景，例如MySQL binlog 场景，需要消息按顺序进行消费。在RocketMQ中提供了基于队列的顺序消费模型，即尽管一个消费组中的消费者会创建一个多线程，但针对同一个Queue，会加锁。</p>
<blockquote>
<p>温馨提示：并发消费模型中，消息消费失败默认会重试16次，每一次的间隔时间不一样；而顺序消费，如果一条消息消费失败，则会一直消费，直到消费成功。故在顺序消费的使用过程中，应用程序需要区分系统异常、业务异常，如果是不符合业务规则导致的异常，则重试多少次都无法消费成功，这个时候一定要告警机制，及时进行人为干预，否则消费会积压。</p>
</blockquote>
<h2 id="3、事务消息"><a href="#3、事务消息" class="headerlink" title="3、事务消息"></a>3、事务消息</h2><p>事务消息并不是为了解决分布式事务，而是提供消息发送与业务落库的一致性，其实现原理就是一次分布式事务的具体运用，请看如下示例：<br><img src="https://img-blog.csdnimg.cn/20201018221527456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述伪代码中，将订单存储关系型数据库中和将消息发送到MQ这是两个不同介质的两个操作，如果能保证消息发送、数据库存储这两个操作要么同时成功，要么同时失败，RocketMQ为了解决该问题引入了<strong>事务消息</strong>。</p>
<blockquote>
<p>温馨提示，本节主要的目的是让大家知晓各个术语的概念，由于事务消息的使用，将在该专栏的后续文章中详细介绍。</p>
</blockquote>
<h2 id="4、定时消息"><a href="#4、定时消息" class="headerlink" title="4、定时消息"></a>4、定时消息</h2><p>开源版本的RocketMQ目前并不支持任意精度的定时消息。所谓的定时消息就是将消息发送到Broker，但消费端不会立即消费，而是要到指定延迟时间后才能被消费端消费。</p>
<p>RocketMQ目前支持指定级别的延迟，其延迟级别如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h</span><br></pre></td></tr></table></figure>

<h2 id="5、消息过滤"><a href="#5、消息过滤" class="headerlink" title="5、消息过滤"></a>5、消息过滤</h2><p>消息过滤是指消费端可以根据某些条件对一个topic中的消息进行过滤，即只消费一个主题下满足过滤条件的消息。</p>
<p>RocketMQ目前主要的过滤机制是基于tag的过滤与基于消息属性的过滤，基于消息属性的过滤支持SQL92表达式，对消息进行过滤。</p>
<h2 id="6、小结"><a href="#6、小结" class="headerlink" title="6、小结"></a>6、小结</h2><p>本文的主要目的是介绍RocketMQ常见的术语，例如nameserver、broker、主题、消费组、消费者、队列负载算法、队列重平衡机制、并发消费、顺序消费、消费进度存储、定时消息、事务消息、消息过滤等基本概念，为后续的实战系列打下坚实基础。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ消息发送常见错误与解决方案</title>
    <url>/posts/6a2393aa.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将结合自己使用RocketMQ的经验，对消息发送常见的问题进行分享，基本会遵循出现问题，分析问题、解决问题。</p>
<h2 id="1、No-route-info-of-this-topic"><a href="#1、No-route-info-of-this-topic" class="headerlink" title="1、No route info of this topic"></a>1、No route info of this topic</h2><p>无法找到路由信息，其完整的错误堆栈信息如下：<br><img src="https://img-blog.csdnimg.cn/20200927212104148.png#pic_center" alt="在这里插入图片描述">而且很多读者朋友会说Broker端开启了自动创建主题也会出现上述问题。</p>
<p>RocketMQ的路由寻找流程如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020092721214148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">上面的核心关键点如下：</p>
<ul>
<li>如果Broker开启了自动创建Topic，在启动的时候会默认创建主题：TBW102，并会随着Broker发送到Nameserver的心跳包汇报给Nameserver，继而从Nameserver查询路由信息时能返回路由信息。</li>
<li>消息发送者在消息发送时首先会查本地缓存，如果本地缓存中存在，直接返回路由信息。</li>
<li>如果缓存不存在，则向Nameserver查询路由信息，如果Nameserver存在该路由信息，就直接返回。</li>
<li>如果Nameserver不存在该topic的路由信息，如果没有开启自动创建主题，则抛出 No route info of this topic。</li>
<li>如果开启了自动创建主题，则使用默认主题向Nameserver查询路由信息，并使用默认Topic的路由信息为自己的路由信息，将不会抛出 No route info of this topic。</li>
</ul>
<p>通常情况下 No route info of this topic 这个错误一般是在刚搭建RocketMQ，刚入门 RocketMQ遇到的比较多，通常的排查思路如下：</p>
<ul>
<li><p>可以通过rocketmq-console查询路由信息是否存在，或使用如下命令查询路由信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd $&#123;ROCKETMQ_HOME&#125;/bin</span><br><span class="line">sh ./mqadmin topicRoute -n 127.0.0.1:9876 -t dw_test_0003</span><br></pre></td></tr></table></figure>
<p>其输出结果如下所示：<br><img src="https://img-blog.csdnimg.cn/20200927212234119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>如果通过命令无法查询到路由信息，则查看Broker是否开启了自动创建topic，参数为：autoCreateTopicEnable,该参数默认为true。但在生产环境不建议开启。</p>
</li>
<li><p>如果开启了自动创建路由信息，但还是抛出这个错误，这个时候请检查客户端(Producer)连接的Nameserver地址是否与Broker中配置的nameserver地址是否一致。</p>
</li>
</ul>
<p>经过上面的步骤，基本就能解决该错误。</p>
<a id="more"></a>

<h2 id="2、消息发送超时"><a href="#2、消息发送超时" class="headerlink" title="2、消息发送超时"></a>2、消息发送超时</h2><p>消息发送超时，通常客户端的日志如下：<br><img src="https://img-blog.csdnimg.cn/20200927212258302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>客户端报消息发送超时，通常第一怀疑的对象是RocketMQ服务器，是不是Broker性能出现了抖动，无法抗住当前的量。</p>
<p>那我们如何来排查RocketMQ当前是否有性能瓶颈呢？</p>
<p>首先我们执行如下命令查看RocketMQ 消息写入的耗时分布情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /$&#123;USER.HOME&#125;/logs/rocketmqlogs/</span><br><span class="line">grep -n &#x27;PAGECACHERT&#x27; store.log | more</span><br></pre></td></tr></table></figure>

<p>输出结果如下所示：<br><img src="https://img-blog.csdnimg.cn/20200927212336142.png#pic_center" alt="在这里插入图片描述"><br>RocketMQ会每一分钟打印前一分钟内消息发送的耗时情况分布，我们从这里就能窥探RocketMQ消息写入是否存在明细的性能瓶颈，其区间如下：</p>
<ul>
<li>[&lt;=0ms] 小于0ms，即微妙级别的。</li>
<li>[0~10ms] 小于10ms的个数。</li>
<li>[10~50ms]　大于10ms小</li>
<li>于50ms的个数</li>
</ul>
<p>其他区间显示，绝大多数会落在微妙级别完成，按照笔者的经验如果100-200ms及以上的区间超过20个后，说明Broker确实存在一定的瓶颈，如果只是少数几个，说明这个是内存或pagecache的抖动，问题不大。</p>
<p>通常情况下超时通常与Broker端的处理能力关系不大，还有另外一个佐证，在RocketMQ broker中还存在快速失败机制，即当Broker收到客户端的请求后会将消息先放入队列，然后顺序执行，如果一条消息队列中等待超过200ms就会启动快速失败，向客户端返回[TIMEOUT_CLEAN_QUEUE]broker busy，这个在本文的第3部分会详细介绍。</p>
<p>在RocketMQ客户端遇到网络超时，通常可以考虑一些应用本身的垃圾回收，是否由于GC的停顿时间导致的消息发送超时，这个我在测试环境进行压力测试时遇到过，但生产环境暂时没有遇到过，大家稍微留意一下。</p>
<p>在RocketMQ中通常遇到网络超时，通常与网络的抖动有关系，但由于我对网络不是特别擅长，故暂时无法找到直接证据，但能找到一些间接证据，例如在一个应用中同时连接了kafka、RocketMQ集群，发现在出现超时的同一时间发现连接到RocketMQ集群内所有Broker，连接到kafka集群都出现了超时。</p>
<p><strong>但出现网络超时，我们总得解决，那有什么解决方案吗？</strong></p>
<p>我们对消息中间件的最低期望就是高并发低延迟，从上面的消息发送耗时分布情况也可以看出RocketMQ确实符合我们的期望，绝大部分请求都是在微妙级别内，故我给出的方案时，<strong>减少消息发送的超时时间，增加重试次数，并增加快速失败的最大等待时长</strong>。具体措施如下：</p>
<ul>
<li><p>增加Broker端快速失败的时长，建议为1000，在broker的配置文件中增加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">maxWaitTimeMillsInQueue</span>=<span class="string">1000</span></span><br></pre></td></tr></table></figure>

<p>主要原因是在当前的RocketMQ版本中，快速失败导致的错误为SYSTEM_BUSY，并不会触发重试，适当增大该值，尽可能避免触发该机制，详情可以参考本文第3部分内容，会重点介绍system_busy、broker_busy。</p>
</li>
<li><p>如果RocketMQ的客户端版本为4.3.0以下版本(不含4.3.0)<br>将超时时间设置消息发送的超时时间为500ms，并将重试次数设置为6次(这个可以适当进行调整，尽量大于3)，其背后的哲学是尽快超时，并进行重试，因为发现局域网内的网络抖动是瞬时的，下次重试的是就能恢复，并且RocketMQ有故障规避机制，重试的时候会尽量选择不同的Broker，相关的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;dw_test_producer_group&quot;</span>);</span><br><span class="line">producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">producer.setRetryTimesWhenSendFailed(<span class="number">5</span>);<span class="comment">//　同步发送模式：重试次数</span></span><br><span class="line">producer.setRetryTimesWhenSendAsyncFailed(<span class="number">5</span>);<span class="comment">// 异步发送模式：重试次数</span></span><br><span class="line">producer.start();</span><br><span class="line">producer.send(msg,<span class="number">500</span>);<span class="comment">//消息发送超时时间</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果RocketMQ的客户端版本为4.3.0及以上版本</p>
<p>如果客户端版本为4.3.0及其以上版本，由于其设置的消息发送超时时间为所有重试的总的超时时间，故不能直接通过设置RocketMQ的发送API的超时时间，而是需要对其API进行包装，重试需要在外层收到进行，例如示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SendResult <span class="title">send</span><span class="params">(DefaultMQProducer producer, Message msg, <span class="keyword">int</span> </span></span></span><br><span class="line"><span class="function"><span class="params">                              retryCount)</span> </span>&#123;</span><br><span class="line">    Throwable e = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; retryCount; i ++ ) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> producer.send(msg,<span class="number">500</span>); <span class="comment">//设置超时时间，为500ms，内部有重试机制</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">            e = e2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;消息发送异常&quot;</span>,e);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、System-busy、Broker-busy"><a href="#3、System-busy、Broker-busy" class="headerlink" title="3、System busy、Broker busy"></a>3、System busy、Broker busy</h2><p>在使用RocketMQ中，如果RocketMQ集群达到1W/tps的压力负载水平，System busy、Broker busy就会是大家经常会遇到的问题。例如如下图所示的异常栈。<br><img src="https://img-blog.csdnimg.cn/20200927212452995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">纵观RocketMQ与system busy、broker busy相关的错误关键字，总共包含如下5个：</p>
</li>
<li><p>[REJECTREQUEST]system busy</p>
</li>
<li><p>too many requests and system thread pool busy</p>
</li>
<li><p>[PC_SYNCHRONIZED]broker busy</p>
</li>
<li><p>[PCBUSY_CLEAN_QUEUE]broker busy</p>
</li>
<li><p>[TIMEOUT_CLEAN_QUEUE]broker busy</p>
<h4 id="3-1-原理分析"><a href="#3-1-原理分析" class="headerlink" title="3.1 原理分析"></a>3.1 原理分析</h4><p>我们先用一张图来阐述一下在消息发送的全生命周期中分别在什么时候会抛出上述错误。<br><img src="https://img-blog.csdnimg.cn/20200927212528727.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>根据上述5类错误日志，其触发的原有可以归纳为如下3种。</p>
</li>
<li><p>pagecache压力较大</p>
<p>其中如下三类错误属于此种情况</p>
<ul>
<li>[REJECTREQUEST]system busy</li>
<li>[PC_SYNCHRONIZED]broker busy</li>
<li>[PCBUSY_CLEAN_QUEUE]broker busy</li>
</ul>
<p>判断pagecache是否忙的依据就是在写入消息时，在向内存追加消息时加锁的时间，默认的判断标准是加锁时间超过1s，就认为是pagecache压力大，向客户端抛出相关的错误日志。</p>
</li>
<li><p>发送线程池挤压的拒绝策略<br>在RocketMQ中处理消息发送的是一个只有一个线程的线程池，内部会维护一个有界队列，默认长度为1W，如果当前队列中挤压的数量超过1w，执行线程池的拒绝策略，从而抛出[too many requests and system thread pool busy]错误。</p>
</li>
<li><p>Broker端快速失败</p>
<p>默认情况下Broker端开启了快速失败机制，就是在Broker端还未发生pagecache繁忙(加锁超过1s)的情况，但存在一些请求在消息发送队列中等待200ms的情况，RocketMQ会不再继续排队，直接向客户端返回system busy，但由于rocketmq客户端目前对该错误没有进行重试处理，所以在解决这类问题的时候需要额外处理。</p>
</li>
</ul>
<h4 id="3-2-PageCache繁忙解决方案"><a href="#3-2-PageCache繁忙解决方案" class="headerlink" title="3.2 PageCache繁忙解决方案"></a>3.2 PageCache繁忙解决方案</h4><p>一旦消息服务器出现大量pagecache繁忙(在向内存追加数据加锁超过1s)的情况，这个是比较严重的问题，需要人为进行干预解决，解决的问题思路如下：</p>
<ul>
<li><p>transientStorePoolEnable</p>
<p>开启transientStorePoolEnable机制，即在broker中配置文件中增加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">transientStorePoolEnable</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<p>transientStorePoolEnable的原理如下图所示：</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200927212644571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>  引入transientStorePoolEnable能缓解pagecache的压力背后关键如下：</p>
<ul>
<li><p>消息先写入到堆外内存中，该内存由于启用了内存锁定机制，故消息的写入是接近直接操作内存，性能能得到保证。</p>
</li>
<li><p>消息进入到堆外内存后，后台会启动一个线程，一批一批将消息提交到pagecache，即写消息时对pagecache的写操作由单条写入变成了批量写入，降低了对pagecache的压力。</p>
<p>引入transientStorePoolEnable会增加数据丢失的可能性，如果Broker JVM进程异常退出，提交到PageCache中的消息是不会丢失的，但存在堆外内存(DirectByteBuffer)中但还未提交到PageCache中的这部分消息，将会丢失。但通常情况下，RocketMQ进程退出的可能性不大，通常情况下，如果启用了transientStorePoolEnable，消息发送端需要有重新推送机制(补偿思想)。</p>
</li>
<li><p>扩容</p>
<p>如果在开启了transientStorePoolEnable后，还会出现pagecache级别的繁忙，那需要集群进行扩容，或者对集群中的topic进行拆分，即将一部分topic迁移到其他集群中，降低集群的负载。</p>
<blockquote>
<p>温馨提示：在RocketMQ出现pagecache繁忙造成的broker busy，RocketMQ Client会有重试机制。</p>
</blockquote>
<h4 id="3-3-TIMEOUT-CLEAN-QUEUE-解决方案"><a href="#3-3-TIMEOUT-CLEAN-QUEUE-解决方案" class="headerlink" title="3.3 TIMEOUT_CLEAN_QUEUE 解决方案"></a>3.3 TIMEOUT_CLEAN_QUEUE 解决方案</h4><p>由于如果出现TIMEOUT_CLEAN_QUEUE的错误，客户端暂时不会对其进行重试，故现阶段的建议是适当增加快速失败的判断标准，即在broker的配置文件中增加如下配置：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">＃该值默认为200，表示200ms</span></span><br><span class="line"><span class="attr">waitTimeMillsInSendQueue</span>=<span class="string">1000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提示，关于Broker busy，笔者发表过两篇文章，大家也可以结合着看：</p>
<p>1、<a href="https://mp.weixin.qq.com/s/N_ttVjBpqVUA0CGrOybNLA">RocketMQ 消息发送system busy、broker busy原因分析与解决方案</a> </p>
<p>2、<a href="https://mp.weixin.qq.com/s/1yFedcwtQ7mYcuHDvGCrqw">再谈RocketMQ broker busy</a> </p>
</blockquote>
</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>发送超时</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ消息轨迹-设计篇</title>
    <url>/posts/98d74d79.html</url>
    <content><![CDATA[<div id="vip-container"><p>RocketMQ消息轨迹主要包含两篇文章：设计篇与源码分析篇，本节将详细介绍RocketMQ消息轨迹-设计相关。</p>
<p>RocketMQ消息轨迹，主要跟踪消息发送、消息消费的轨迹，即详细记录消息各个处理环节的日志，从设计上至少需要解决如下三个核心问题：</p>
<ul>
<li>消费轨迹数据格式</li>
<li>记录消息轨迹(消息日志)</li>
<li>消息轨迹数据存储在哪？</li>
</ul>
<h2 id="1、消息轨迹数据格式"><a href="#1、消息轨迹数据格式" class="headerlink" title="1、消息轨迹数据格式"></a>1、消息轨迹数据格式</h2><p>RocketMQ4.5版本消息轨迹主要记录如下信息：</p>
<ul>
<li>traceType<br>跟踪类型，可选值：Pub(消息发送)、SubBefore(消息拉取到客户端，执行业务定义的消费逻辑之前)、SubAfter(消费后)。</li>
<li>timeStamp<br>当前时间戳。</li>
<li>regionId<br>broker所在的区域ID，取自BrokerConfig#regionId。</li>
<li>groupName<br>组名称，traceType为Pub时为生产者组的名称；如果traceType为subBefore或subAfter时为消费组名称。</li>
<li>requestId<br>traceType为subBefore、subAfter时使用，消费端的请求Id。</li>
<li>topic<br>消息主题。</li>
<li>msgId<br>消息唯一ID。</li>
<li>tags<br>消息tag。</li>
<li>keys<br>消息索引key，根据该key可快速检索消息。</li>
<li>storeHost<br>跟踪类型为PUB时为存储该消息的Broker服务器IP；跟踪类型为subBefore、subAfter时为消费者IP。</li>
<li>bodyLength<br>消息体的长度。</li>
<li>costTime<br>耗时。</li>
<li>msgType<br>消息的类型，可选值：Normal_Msg(普通消息),Trans_Msg_Half(预提交消息),Trans_msg_Commit(提交消息),Delay_Msg(延迟消息)。</li>
<li>offsetMsgId<br>消息偏移量ID,该ID中包含了broker的ip以及偏移量。</li>
<li>success<br>是发送成功。</li>
<li>contextCode<br>消费状态码，可选值：SUCCESS,TIME_OUT,EXCEPTION,RETURNNULL,FAILED。</li>
</ul>
<a id="more"></a>

<h2 id="2、记录消息轨迹"><a href="#2、记录消息轨迹" class="headerlink" title="2、记录消息轨迹"></a>2、记录消息轨迹</h2><p>消息中间件的两大核心主题：消息发送、消息消费，其核心载体就是消息，消息轨迹（消息的流转）主要是记录消息是何时发送到哪台Broker，发送耗时多少时间，在什么是被哪个消费者消费。记录消息的轨迹主要是集中在消息发送前后、消息消费前后，可以通过RokcetMQ的Hook机制。通过如下两个接口来定义钩子函数。<br><img src="https://img-blog.csdnimg.cn/20190714204429722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>通过实行上述两个接口，可以实现在消息发送、消息消费前后记录消息轨迹，为了不明显增加消息发送与消息消费的时延，记录消息轨迹最好使用异步发送模式。</p>
<h2 id="3、如何存储消息轨迹数据"><a href="#3、如何存储消息轨迹数据" class="headerlink" title="3、如何存储消息轨迹数据"></a>3、如何存储消息轨迹数据</h2><p>消息轨迹需要存储什么消息以及在什么时候记录消息轨迹的问题都以及解决，那接下来就得思考将消息轨迹存储在哪里？存储在数据库中或其他媒介中，都会加重消息中间件，使其依赖外部组件，最佳的选择还是存储在Broker服务器中，将消息轨迹数据也当成一条消息存储到Broker服务器。</p>
<p>既然把消息轨迹当成消息存储在Broker服务器，那存储消息轨迹的Topic如何确定呢？RocketMQ提供了两种方法来定义消息轨迹的Topic。</p>
<ul>
<li>系统默认Topic<br>如果Broker的traceTopicEnable配置设置为true，表示在该Broker上创建topic名为：RMQ_SYS_TRACE_TOPIC，队列个数为1，默认该值为false，表示该Broker不承载系统自定义用于存储消息轨迹的topic。</li>
<li>自定义Topic<br>在创建消息生产者或消息消费者时，可以通过参数自定义用于记录消息轨迹的Topic名称，不过要注意的是，rokcetmq控制台(rocketmq-console)中只支持配置一个消息轨迹Topic，故自定义Topic，在目前这个阶段或许还不是一个最佳实践，建议使用系统默认的Topic即可。</li>
</ul>
<p>通常为了避免消息轨迹的数据与正常的业务数据混合在一起，官方建议，在Broker集群中，新增加一台机器，只在这台机器上开启消息轨迹跟踪，这样该集群内的消息轨迹数据只会发送到这一台Broker服务器上，并不会增加集群内原先业务Broker的负载压力。</p>
<p>RocketMQ消息轨迹的设计细节就介绍到这里了，下一篇将从源码的角度对其实现细节进行详细的剖析；如果觉得本文对您有帮助的话，期待您的点赞，谢谢。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>消息轨迹</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentienl 动态数据源架构设计理念与改造实践</title>
    <url>/posts/2a5ec050.html</url>
    <content><![CDATA[<div id="vip-container"><p>在介绍集群限流之前需要首先掌握动态数据源的配置方式，本文将根据 Sentinel 官方提供的代码提出整体架构思路，并最终给出实践指导。</p>
<blockquote>
<p>温馨提示：本文主要分为动态数据源架构设计理念、从官方示例寻找改造思路、基于SpringBoot改造方案三个部分来详细剖析 Sentienl 动态数据源的改造方案，循序渐进，不仅解决问题本身，更是反映了作者研究一个问题的思路与方法。</p>
</blockquote>
<h2 id="1、架构设计理念"><a href="#1、架构设计理念" class="headerlink" title="1、架构设计理念"></a>1、架构设计理念</h2><p>在 Sentinel 中主要有如下几个角色：管理后台、限流熔断规则数据源、应用程序。</p>
<p>1）管理后台</p>
<p>管理后台主要用于可视化配置限流规则、熔断规则，其操作界面截图如下：<br><img src="https://img-blog.csdnimg.cn/20200425210307130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2）限流熔断规则数据源</p>
<p>用于存储限流熔断规则的数据容器，在 Sentinel 中对应动态数据源这个概念，动态数据源包含两层含义：</p>
<ul>
<li>数据容器<br>数据容器指的就是存储熔断、限流等规则配置的数据库，例如关系型数据库、Zookeeper等等，在实际生产过程中需要选用支持持久化功能的数据库，否则程序一重启，配置规则就会丢失，显然是不能接受的。</li>
<li>动态<br>动态二字主要强调的是配置规则的更改能动态及时生效，引入 Sentinel 限流 SDK 的应用程序在不需要重启的情况下动态感知配置规则发生变化并立即生效。Sentinel 目前对 apollo、consul、etcd、nacos、redis、spring-clould-config、zookeeper 等进行了适配支持。</li>
</ul>
<p>3）应用程序</p>
<p>希望通过 Sentinel 提供的限流、熔断功能对应用程序加以保护，需要引用 Sentinel 相关的 SDK，根据采集的调用信息判断当前是否符合限流规则。</p>
<p>后台管理系统、动态数据源、应用程序的关系如图所示：<br><img src="https://img-blog.csdnimg.cn/20200425210401161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h2 id="2、从官方示例寻找改造思路"><a href="#2、从官方示例寻找改造思路" class="headerlink" title="2、从官方示例寻找改造思路"></a>2、从官方示例寻找改造思路</h2><p>从官方的文档中可以明确获悉 sentinel-dashboard 即官方自带的后台管理系统只支持将限流、熔断等限流配置规则存储在内存中，一旦后台管理系统重启，配置的熔断规则将全部丢失，所以在生产实践过程中需要对 sentinel-dashboard 进行一定的改造，引入动态数据源，例如 Zookeeper，对限流等配置进行持久化存储。</p>
<p>有了上面的架构设计理念为我们的改造提供了方向，那如何具体改造呢？首先我们来看一下官方提供的 Demo 程序。官方提供的示例代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200425210450996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来我们将以 zookeeper 动态数据源来介绍基于 zookeeper 如何构建 Sentinel 动态数据源。</p>
<a id="more"></a>

<h4 id="2-1-限流熔断等规则存储"><a href="#2-1-限流熔断等规则存储" class="headerlink" title="2.1 限流熔断等规则存储"></a>2.1 限流熔断等规则存储</h4><p>首先查阅一下 ZookeeperConfigSender，该类主要的作用是将配置写入到 zookeeper 中，其关键代码截图如下：<br><img src="https://img-blog.csdnimg.cn/20200425210528331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这个类的测试目的很简单，先将限流规则持久化到 Zookeeper 中，充当的角色与 sentinel-dashboard 的角色一致，故这个类为我们改造后台管理系统带来很大的启发，即可以通过 zookeeper 存储 sentinel 限流规则，从 demo 示例可以看出限流规则在 zookeeper 中的目录结构，路径为 /{groupId} / {dataid} ，该节点的 value 值存储 json 字符串，存储所有的限流规则。</p>
<p><strong>实践指导,通常基于 zookeeper 的开发，主要是规划好目录结构，关于 Sentinel，我对给出一个初步的目录规划。</strong></p>
<p>在 zookeeper 中创建一个根节点，例如 /sentienl 用来表示限流相关的根目录。</p>
<ul>
<li>groupId 通常为一个独立的应用名称，例如应用的 appId，例如示例中的 provider-demo。</li>
<li>dataId 通常为配置类型，例如限流规则、熔断规则、热点规则等类别，例如限流规则使用 /flowRule ，熔断规则使用 /degradeRule，其 value 值使用 json 存储，将该应用下的所有限流规则用一个 json 对象表示，其存储格式类似于 [{},{}]。</li>
</ul>
<h4 id="2-2-客户端动态感知配置"><a href="#2-2-客户端动态感知配置" class="headerlink" title="2.2 客户端动态感知配置"></a>2.2 客户端动态感知配置</h4><p>实现存储规则的配置存储后接下来是需要客户端能动态感知规则的变化，从而是配置规则实时生效。</p>
<p>我们依然先来看一下官方示例，其核心代码如图所示：<br><img src="https://img-blog.csdnimg.cn/2020042521083764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这里尽管引入 groupId 与 dataId 的概念是方便与 nacos 进行切换，但就算不切换，基于 zookeeper 的编程，这种目录规划是非常有必要的。上面的示例代码有两个关键点：</p>
<ul>
<li>创建 ZookeeperDataSource，每一个 ZookeeperDataSource 负责监听一个节点。</li>
<li>需要调用 FlowRuleManager 的 register2Property 方法将数据源关联的数据注册到 FlowRuleManager 中，方便 Sentinel 内核根据数据源中存储的限流熔断等规则进行工作。</li>
</ul>
<p>客户端在启动的时候会调用 FlowRuleManager 相关方法加载限流相关的配置，那如果配置规则发生变化后，客户端如何动态感知呢？其关键就在于 ZookeeperDataSource 的实现中，其实现关键点如下：<br><img src="https://img-blog.csdnimg.cn/2020042521094273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">即在构建 ZookeeperDataSource 时会监听 /groupId/dataId 节点，即存放限流配置的节点，一旦数据发生变化，就会通知到客户端，从而调用 loadConfig 重新更新 Sentienl 客户端的限流配置，从而实现配置实时生效。</p>
<h2 id="3、Sentinel-引入Zookeeper-动态数据源实现方案"><a href="#3、Sentinel-引入Zookeeper-动态数据源实现方案" class="headerlink" title="3、Sentinel 引入Zookeeper 动态数据源实现方案"></a>3、Sentinel 引入Zookeeper 动态数据源实现方案</h2><p>从官方的示例中我们不难发现，引入 Zookeeper 数据源主要有两个步骤：将数据存储在Zookeeper中以及在客户端监听ZK从而实时生效两个步骤。</p>
<p>sentinel 官方提供了默认的后台管理系统实现：sentinel-dashboard，但其缺点非常明显：基于内存存储，无法用于实际生产过程。大家可能会向后台管理系统将配置信息存储在内存中，那接入的客户端如何从 sentinel-dashboard 的内存中获取配置信息呢，这是因为 sentinel-dashboard 里提供了简单的机器发现，并且内置了 sentinel 客户端之间、sentinel 客户端与 sentinel-dashboard 之间的通讯协议，具体由 sentinel-transport 模块实现，目前提供了基于 http 与 netty 的实现方式，故能将 sentinel-dashboard 内存中的配置信息推送到客户端，从而使客户端根据配置进行限流与熔断。</p>
<p>接下来回答本文的重点部分，基于 sentinel-dashboard 如何引入 zookeeper 等动态数据源呢？</p>
<h4 id="3-1-将配置规则存储在Zookeeper中"><a href="#3-1-将配置规则存储在Zookeeper中" class="headerlink" title="3.1 将配置规则存储在Zookeeper中"></a>3.1 将配置规则存储在Zookeeper中</h4><p>首先我们可以顺着 sentinel-dashboard 的提供的控制器，寻找其后台入口，改造目标也很明确，就是将数据持久化到 zookeeper中，例如增加流控规则的后台处理入口为：<br><img src="https://img-blog.csdnimg.cn/20200425211030452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">Sentinel 动态数据源架构设计理念与改造实践<br>只需要从这里开始改造，将其配置持久化到数据库中和 zookeeper中即可。</p>
<p>将数据存储在 zookeeper 中，其关键是设计好各个项目如何有组织有条理的在 zookeeper 中进行组织。我给出如下设计方案：<br><img src="https://img-blog.csdnimg.cn/20200425211059470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这样相关管理人员可以直接在 sentinel-dashboard 中配置限流规则，即按照应用为维度进行存储，每一个应用再按照维度，例如限流、熔断、热点、集群等维度进行配置，每一分类节点的值存储的是所有的配置，使用 [{},{}] 这种JSON格式进行存储。</p>
<h4 id="3-2-Sentinel-客户端规则加载封装"><a href="#3-2-Sentinel-客户端规则加载封装" class="headerlink" title="3.2 Sentinel 客户端规则加载封装"></a>3.2 Sentinel 客户端规则加载封装</h4><p>目前大部分项目都是基于 SpringBoot，故本文给出基于 SpringBoot 进行的客户端加载实现思路。</p>
<p>Sentinel 动态数据源架构设计理念与改造实践<br>客户端改造伪代码<br><img src="https://img-blog.csdnimg.cn/202004252111428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">其主要关键点如下：</p>
<ul>
<li>基于 Spring ApplicationReadyEvent 事件，实现限流规则的加载。</li>
<li>创建 ZookeeperDataSource 创建动态数据源。<br>并调用 Sentinel 提供的相关 API 完成限流规则的加载。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>架构设计</tag>
        <tag>动态数据源</tag>
        <tag>Zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentienl 流控效果之匀速排队与预热实现原理与实战建议</title>
    <url>/posts/c534f93a.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>温馨提示，如果大家对源码不感兴趣，可以直接跳到本文的总结部分，了解一下预热实现原理的一些实战建议。</p>
<p>首先先回顾一下 Sentinel 流控效果相关的类图：<br><img src="https://img-blog.csdnimg.cn/20200406112941248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>DefaultController 快速失败已经在上文详细介绍过，本文将详细介绍其他两种策略的实现原理。</p>
</blockquote>
<p>首先我们应该知道，一条流控规则(FlowRule)对应一个 TrafficShapingController 对象。</p>
<h2 id="1、RateLimiterController"><a href="#1、RateLimiterController" class="headerlink" title="1、RateLimiterController"></a>1、RateLimiterController</h2><p>匀速排队策略实现类，首先我们先来介绍一下该类的几个成员变量的含义：</p>
<ul>
<li>int maxQueueingTimeMs<br>排队等待的最大超时时间，如果等待超过该时间，将会抛出 FlowException。</li>
<li>double count<br>流控规则中的阔值，即令牌的总个数，以QPS为例，如果该值设置为1000，则表示1s可并发的请求数量。</li>
<li>AtomicLong latestPassedTime<br>上一次成功通过的时间戳。</li>
</ul>
<p>接下来我们详细来看一下其算法的实现：<br>RateLimiterController#canPass</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>);    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();                <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;                                                    <span class="comment">// @3</span></span><br><span class="line">        latestPassedTime.set(currentTime);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();   <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;                                                                        <span class="comment">// @5</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);                                     <span class="comment">// @6</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                waitTime = oldTime - TimeUtil.currentTimeMillis();                                            </span><br><span class="line">                <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                    latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">		<span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;                                                     <span class="comment">// @7</span></span><br><span class="line">                    Thread.sleep(waitTime);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先算出每一个请求之间最小的间隔，时间单位为毫秒。例如 cout 设置为 1000,表示一秒可以通过 1000个请求，匀速排队，那每个请求的间隔为 1 / 1000(s)，乘以1000将时间单位转换为毫秒，如果一次需要2个令牌，则其间隔时间为2ms，用 costTime 表示。</p>
<p>代码@2：计算下一个请求的期望达到时间，等于上一次通过的时间戳 + costTime ，用 expectedTime 表示。</p>
<p>代码@3：如果 expectedTime 小于等于当前时间，说明在期望的时间没有请求到达，说明没有按照期望消耗令牌，故本次请求直接通过，并更新上次通过的时间为当前时间。</p>
<p>代码@4：如果 expectedTime 大于当前时间，说明还没到令牌发放时间，当前请求需要等待。首先先计算需要等待是时间，用 waitTime 表示。</p>
<p>代码@5：如果计算的需要等待的时间大于允许排队的时间，则返回 false，即本次请求将被限流，返回 FlowException。</p>
<p>代码@6：进入排队，默认是本次请求通过，故先将上一次通过流量的时间戳增加 costTime，然后直接调用 Thread 的 sleep 方法，将当前请求先阻塞一会，然后返回 true 表示请求通过。</p>
<blockquote>
<p>匀速排队模式的实现的关键：主要是记录上一次请求通过的时间戳，然后根据流控规则，判断两次请求之间最小的间隔，并加入一个排队时间。</p>
</blockquote>
<h2 id="2、WarmUpController"><a href="#2、WarmUpController" class="headerlink" title="2、WarmUpController"></a>2、WarmUpController</h2><p>预热策略的实现，首先我们先来介绍一下该类的几个成员变量的含义：</p>
<ul>
<li>double count<br>流控规则设定的阔值。</li>
<li>int coldFactor<br>冷却因子。</li>
<li>int warningToken<br>告警token，对应 Guava 中的 RateLimiter 中的 </li>
<li>int maxToken<br>double slope<br>AtomicLong storedTokens<br>AtomicLong lastFilledTime</li>
</ul>
<h4 id="2-1-WarmUpController-构造函数"><a href="#2-1-WarmUpController-构造函数" class="headerlink" title="2.1 WarmUpController 构造函数"></a>2.1 WarmUpController 构造函数</h4><p>内部的构造函数，最终将调用 construct 方法。<br>WarmUpController#construct</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123; <span class="comment">// @1</span></span><br><span class="line">	<span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cold factor should be larger than 1&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">	<span class="keyword">this</span>.count = count;  </span><br><span class="line">	<span class="keyword">this</span>.coldFactor = coldFactor;   </span><br><span class="line">	warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);   <span class="comment">// @2</span></span><br><span class="line">	maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));  <span class="comment">// @3</span></span><br><span class="line">	slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解该方法，就需要理解 Guava 框架的 SmoothWarmingUp 相关的预热算法，其算法原理如图所示：<br><img src="https://img-blog.csdnimg.cn/20200406114151249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>关于该图的详细介绍，请参考笔者的另外一篇博文：<a href="https://blog.csdn.net/prestigeding/article/details/105262127">源码分析RateLimiter SmoothWarmingUp 实现原理</a>，对该图进行了详细解读。</p>
<p>代码@1：首先介绍该方法的参数列表：</p>
<ul>
<li>double count<br>限流规则配置的阔值，例如是按 TPS 类型来限流，如果限制为100tps，则该值为100。</li>
<li>int warmUpPeriodInSec<br>预热时间，单位为秒，通用在限流规则页面可配置。</li>
<li>int coldFactor<br>冷却因子，这里默认为3，与 RateLimiter 中的冷却因子保持一致，表示的含义为 coldIntervalMicros 与  stableIntervalMicros 的比值。</li>
</ul>
<p>代码@2：计算 warningToken 的值，与 Guava 中的 RateLimiter 中的 thresholdPermits 的计算算法公式相同，thresholdPermits = 0.5 * warmupPeriod / stableInterval，在Sentienl 中，而 stableInteral = 1 / count，thresholdPermits  表达式中的 0.5 就是因为 codeFactor 为3，因为 warm up period与 stable   面积之比等于 (coldIntervalMicros - stableIntervalMicros ) 与 stableIntervalMicros 的比值，这个比值又等于 coldIntervalMicros / stableIntervalMicros  - stableIntervalMicros / stableIntervalMicros 等于 coldFactor - 1。</p>
<p>代码@3：同样根据 Guava 中的 RateLimiter 关于 maxToken 也能理解。</p>
<a id="more"></a>

<h4 id="2-2-canPass-方法详解"><a href="#2-2-canPass-方法详解" class="headerlink" title="2.2 canPass 方法详解"></a>2.2 canPass 方法详解</h4><p>WarmUpController#canPass </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps(); <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();  <span class="comment">// @2</span></span><br><span class="line">    syncToken(previousQps);  <span class="comment">// @3</span></span><br><span class="line">	<span class="comment">// 开始计算它的斜率</span></span><br><span class="line">    <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">    <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">    <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;    <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">        <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line">        <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">        <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;   <span class="comment">// @5</span></span><br><span class="line">        <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先获取当前节点已通过的QPS。</p>
<p>代码@2：获取当前滑动窗口的前一个窗口收集的已通过QPS。</p>
<p>代码@3：调用 syncToken 更新 storedTokens 与 lastFilledTime 的值，即按照令牌发放速率发送指定令牌，将在下文详细介绍 syncToken 方法内部的实现细节。</p>
<p>代码@4：如果当前存储的许可大于warningToken的处理逻辑，主要是在预热阶段允许通过的速率会比限流规则设定的速率要低，判断是否通过的依据就是当前通过的TPS与申请的许可数是否小于当前的速率（这个值加入斜率，即在预热期间，速率是慢慢达到设定速率的。</p>
<p>代码@5：当前存储的许可小于warningToken，则按照规则设定的速率进行判定。</p>
<blockquote>
<p>不知大家有没有一个疑问，为什么 storedTokens 剩余许可数越大，限制其通过的速率竟然会越慢，这又怎么理解呢？大家可以思考一下这个问题，将在本文的总结部分进行解答。</p>
</blockquote>
<p>我们先来看一下 syncToken 的实现细节，即更新 storedTokens 的逻辑。<br>WarmUpController#syncToken </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    currentTime = currentTime - currentTime % <span class="number">1000</span>;    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">    <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;                          <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);   <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;  </span><br><span class="line">        <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);    <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        lastFilledTime.set(currentTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：这个是计算出当前时间秒的最开始时间。例如当前是 2020-04-06 08:29:01:056，该方法返回的时间为 2020-04-06 08:29:01:000。</p>
<p>代码@2：如果当前时间小于等于上次发放许可的时间，则跳过，无法发放令牌，即每秒发放一次令牌。</p>
<p>代码@3：具体方法令牌的逻辑，稍后详细介绍。</p>
<p>代码@4：更新剩余令牌，即生成的许可后要减去上一秒通过的令牌。</p>
<p>我们详细来看一下 coolDownTokens 方法。<br>WarmUpController#coolDownTokens </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">    <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加令牌的判断前提条件:</span></span><br><span class="line">    <span class="comment">// 当令牌的消耗程度远远低于警戒线的时候</span></span><br><span class="line">    <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;    <span class="comment">// @1</span></span><br><span class="line">        newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">            newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(newValue, maxToken);<span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果当前剩余的 token 小于警戒线，可以按照正常速率发放许可。</p>
<p>代码@2：如果当前剩余的 token 大于警戒线但前一秒的QPS小于 (count 与 冷却因子的比)，也发放许可（这里我不是太明白其用意）。</p>
<p>代码@3：这里是关键点，第一次运行，由于 lastFilledTime 等于0，这里将返回的是 maxToken，故这里一开始的许可就会超过 warningToken，启动预热机制，进行速率限制。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>WarmUpController 这个预热算法还是挺复杂的，接下来我们来总结一下它的特征。</p>
<p>不知大家有没有一个疑问，为什么 storedTokens 剩余许可数越大，限制其通过的速率竟然会越慢，这又怎么理解呢？</p>
<p>这里感觉有点逆向思维的味道，因为一开始就会将 storedTokens 的值设置为 maxToken，即开始就会超过 warningToken，从而一开始进入到预热阶段，此时的速率有一个爬坡的过程，类似于数学中的斜率，达到其他启动预热的效果。</p>
<p><strong>实战指南：注意 warmUpPeriodInSec 与 coldFactor 的设置，将会影响最终的限流效果。</strong></p>
<p>为了更加直观的理解，我们举例如下，warningToken 与 maxToken 的生成公式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);  </span><br><span class="line">maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));  </span><br></pre></td></tr></table></figure>
<p>coldFactor 设定为 3，例如限流规则中配置每秒允许通过的许可数量为 10，即 count 值等于 10，我们改变 warmUpPeriodInSec 的值来看一下 warningToken 与 maxToken 的值，以此来探究 Sentinel WarmUpController 的工作机制或工作效果。</p>
<table>
<thead>
<tr>
<th>warmUpPeriodInSec</th>
<th>warningToken</th>
<th>maxToken</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>5</td>
<td>10</td>
</tr>
<tr>
<td>2</td>
<td>10</td>
<td>20</td>
</tr>
<tr>
<td>3</td>
<td>15</td>
<td>30</td>
</tr>
<tr>
<td>4</td>
<td>20</td>
<td>40</td>
</tr>
</tbody></table>
<p>根据上面的算法，如果 warningToken  的值小于 count，则限流会变的更严厉，即最终的限流TPS会小于设置的TPS。即 warmUpPeriodInSec   设置过大过小都不合适，其标准是要使得 warningToken  的值大于 count。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>RateLimiterController</tag>
        <tag>匀速排队</tag>
        <tag>预热</tag>
        <tag>WarmUpController</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel Dubbo 适配器看限流与熔断(实战思考篇)</title>
    <url>/posts/fd3813a.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文是源码分析 Sentinel 系列的第十三篇，已经非常详细的介绍了 Sentinel 的架构体系、滑动窗口、调用链上下文、限流、熔断的实现原理，相信各位读者朋友们对Sentinel有一个较为体系化的认知了，这个时候是该开始如何在生产环境进行运用了。</p>
<blockquote>
<p>本文将以 Dubbo 服务调用为案例剖析场景，尝试对官方提供的 Dubbo 适配器做一个研究学习并对此做出自己的评价，抛出我的观点，期待与大家共同探讨，交流。</p>
</blockquote>
<p>一个 Dubbo RPC 的简易调用过程如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200510202405377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>消费者会维护一个服务提供者列表，然后再发一起一个服务调用的时候会首先根据负载均衡算法从中选择一个服务提供者，然后发起 RPC 调用，在请求真实发送之前会依次通过客户端设置的过滤器链(Filter)，然后经过网络传输到到达服务提供者，并执行完服务提供者端的 Filter，最后进入到业务逻辑执行并返回结果。</p>
<p>Sentinel 与 Dubbo 的整合就是利用了 Dubbo 的 Filter 机制，为 Dubbo 提供对应的 过滤器，无缝实现限流、熔断等功能，做到业务无感知，即业务代码无需使用 Sentinel 相关的 API。</p>
<p>接下来请大家带着在 Dubbo 中如何使用限流、熔断方面来看官方给出的解决方案。</p>
<blockquote>
<p>思考题：在看接下来的内容之前，建议大家稍作停顿，思考一下，在服务调用模型中，限流、熔断通常在哪个端做比较合适。</p>
</blockquote>
<h2 id="1、从消费端来看限流与熔断"><a href="#1、从消费端来看限流与熔断" class="headerlink" title="1、从消费端来看限流与熔断"></a>1、从消费端来看限流与熔断</h2><p><img src="https://img-blog.csdnimg.cn/20200510202451273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">从消费端的视角，虽然提供了服务端的负载均衡，但从客户端不管是向192.168.1.3还是向192.168.1.4发送RPC调用，都会经过同一个 Sentinel Dubbo Filter。这个看似简单明了，但这是我们接下来思考的最基本最核心的点。</p>
<p>我们先来看看官方提供的 Dubbo 适配器的核心实现：<br>SentinelDubboConsumerFilter#invoke<br><img src="https://img-blog.csdnimg.cn/20200510202524603.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>消费端这边使用到了两个资源名称，一个是接口级别，例如 com.demo.service.UserService，另外一是方法级别，例如 com.demo.servcie.UserServce#findUser(Ljava.lang.String)。<br>定义了两个资源后，Sentinel 会使用滑动窗口机制，为上述两个资源收集实时的调用信息，为后续的限流、熔断提供数据依据。</p>
<a id="more"></a>

<p>限流规则是依附于具体某一个项目的，例如如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020051020261021.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">限流、熔断都是根据资源级别，如果需要对消费端的调用进行限流的话，就需要为这两个资源配置对应的限流规则，如果不配置则默认通过，表示不限流。</p>
<h4 id="1-1-服务调用端-消费方-是否需要配置限流规则"><a href="#1-1-服务调用端-消费方-是否需要配置限流规则" class="headerlink" title="1.1 服务调用端(消费方)是否需要配置限流规则"></a>1.1 服务调用端(消费方)是否需要配置限流规则</h4><p>在 dubbo 的服务调用场景中，在消费端设置限流的规则的话，这个调用链是针对整个集群所有服务提供者的，例如当前集群中包含3个服务提供者，每个服务提供者用于1000tps的服务能力，那消费端的限流，应该配置的限流TPS应该为3000tps，如果设置为1000tps，则无法完整的利用服务端的能力，基于这样的情况，通常消费端无需配置限流规则。</p>
<p>那是不是说消费端就没必要配置限流规则呢？其实也不是，有如下这个场景，例如调用第三方外部的计费类服务接口，对方通常为特定的账户等级设置对应的TPS上限，如果超过该调用频率就会抛出错误，这种情况还是需要设置限流规则，确保消费端以不超过要求进行调用，避免业务异常。</p>
<h4 id="1-2-服务调用端-消费方-是否需要配置熔断"><a href="#1-2-服务调用端-消费方-是否需要配置熔断" class="headerlink" title="1.2 服务调用端(消费方)是否需要配置熔断"></a>1.2 服务调用端(消费方)是否需要配置熔断</h4><p>引入熔断的目的是避免服务端单节点响应慢而导致这个服务不稳定，例如示例中有3个服务提供者，如果192.168.1.3的服务提供者由于触发了BUG导致响应时间大大增加，导致发往该服务提供者的请求大概率超时，在这样的情况下希望在接下来某段时间内消费方发往这这个服务提供者的请求快速熔断降级，返回错误，由客户端重试其他服务提供者。其实现效果如下：<br><img src="https://img-blog.csdnimg.cn/20200510202651125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>当前的 Sentinel 默认是否能满足上述的需求呢？</p>
<p>我们以 Sentinel 基于异常比例熔断策略来进行阐述，如果资源的调用异常比例超过一定值是会触发降级熔断，抛出 DegradeException 异常。</p>
<p>由于总共只有三个服务提供者，其中发往192.168.1.3的请求大概率会由于超时失败，则异常比例会超过设置的熔断降级规则，会触发降级，造成的效果是整个服务调用都会发送熔断降级，即调用192.168.1.4,5两个请求都不会被熔断，造成整个服务调用不可用，与期望不一致。即还是会出现一个节点的不稳定而导致整个服务不稳定的情况。</p>
<p>其造成的根本原因是因为其资源的定义并没有包含服务提供者的信息，改进的初步方案：</p>
<ol>
<li>在过滤器中再定义一个资源，加上服务提供的IP与端口号，例如 SphU.entry(“com.d.s.UserService@ip:port”)，对单个服务提供者进行单独收集调用信息，并且需要提供一可配置的项，用来标记该类型的资源在做熔断判断可使用某一个资源的配置，例如配置为 com.d.s.UserService，表示用这个配置规则来判断熔断。</li>
<li>在熔断规则判断的时候，该资源使用被引用资源的熔断规则进行判断。</li>
</ol>
<p>最后来解答一下，熔断规则通常只需要配置在调用方即可。</p>
<h2 id="2、从服务来看限流与熔断"><a href="#2、从服务来看限流与熔断" class="headerlink" title="2、从服务来看限流与熔断"></a>2、从服务来看限流与熔断</h2><p>由于服务端看限流与熔断就比较简单，因为服务端与客户端存在一个非常大的区别是客户端存在负载均衡机制，一个消费端对于同一资源来说，会调用多个服务提供者，而服务提供者对于一个资源来就是其自身，故限流规则，熔断规则都是针对个体，其复杂度降低。</p>
<p>为了知识体系的完备性，我们来看一下 Sentinel Dubbo 在服务端的适配器的实现。</p>
<p>SentinelDubboProviderFilter#invoke<br><img src="https://img-blog.csdnimg.cn/20200510202746713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里有二个关键点：</p>
<ol>
<li>使用了 ContextUtil 的 entry 方法，定义本次调用的上下文环境名称为：resourceName，默认为接口名与方法名、参数列表，例如 com.d.s.UserServce#findUser(Ljava.lang.String),源头为消费端的应用名称。</li>
<li>定义两个资源，这里与消费端相同，就不做重复解读。</li>
</ol>
<p>关于这个 ContextUtil 的 entry 方法非常关键，因为 Sentinel 中数据节点的统计是以 ContextName 为维度的。</p>
<p>例如想对一个应用所有的操作 redis 操作统一设置为一个资源名，redisOpsResource，即想控制该应用整体的 redis 操作 tps，其场景如下：<br><img src="https://img-blog.csdnimg.cn/20200510202841580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>例如初衷设计为 opsReisTotal 的整个 tps 为 500，例如从UserService#findser链路的访问 redis tps 为 400，而从 Order#createOrder 链路访问 redis tps 为 400，此时 redis 的整体 tps 已经达到了 800 tps，但你会发现并不会触发限流，因为对资源 RredisOpResource 的调用信息统计是以 context name 为维度的，不同的 context name 互不影响，从而无法做到全局控制。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文结合 Sentinel 官方对于 Dubbo 提供的适配器并加以理解，提出了如下观点，欢迎大家留言探讨，相互交流，共同进步。</p>
<ol>
<li>限流规则根据不同的使用场景可以在客户端、服务端配置。</li>
<li>熔断规则通常在服务调用方配置即可。</li>
<li>Sentinel 目前的熔断还实现的比较简单，无法解决集群中因为某一个节点的访问慢而触发熔断，并使服务稳定的能力。</li>
<li>Sentienl 的实时统计是以调用上下文(Context Name)，即 ContextUtil.entry 方法定义的上下文为维度的，这点非常关键，不然容易踩坑。</li>
</ol>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>实战</tag>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel 系统自适应限流原理剖析与实战指导</title>
    <url>/posts/a815ae71.html</url>
    <content><![CDATA[<div id="vip-container"><p>看到标题中的几个关键字<strong>系统自适应</strong>限流是不是觉得高大上，这个自适应又是如何实现的呢？</p>
<h2 id="1、Sentinel-系统自适应概述"><a href="#1、Sentinel-系统自适应概述" class="headerlink" title="1、Sentinel 系统自适应概述"></a>1、Sentinel 系统自适应概述</h2><p>从官方了解到 Sentienl 系统自适应限流是一个全局的概念，对应用入口流量统一进行统一控制，结合应用的机器负载、CPU 使用率，总体平均响应时间、入口 QPS 和并发线程数等几个维度的监控指标从而决定是否调用进行限流操作。为了有一个直观的感受，我们可以从官方的运维平台看看其系统自适应限流的操作界面：<br><img src="https://img-blog.csdnimg.cn/2020052413411896.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>RT、线程数、入口QPS这三个指标是可以通过采集调用信息进行统计计算的，那系统LOAD、CPU使用率是如何获取的呢？大家可以带着这个问题进入本文的学习中来。</p>
<p>在详细分析系统自适应实现原理之前我们先来思考一下 Sentinel 引入该机制的目的。</p>
<p>官方文档针对这个问题有过仔细阐述，我们先来看看官方文档对其阐述。</p>
<p>引入系统自适应限流的主要的目的有如下两个：</p>
<ul>
<li>保证系统不被拖垮</li>
<li>在系统稳定的前提下保证系统的吞吐量。</li>
</ul>
<p>目前我们接触的限流的防护思路都是设定一个指标（阔值），例如系统的负载 load 超过某个阔值后就阻止或减少流量的继续进入，当系统负载降低到某一水平后则恢复流量的进入。通常都是被动的，其实际效果取决与阔值设置是否合理，但往往设置合理不是一件容易的事情。</p>
<p>那 Sentinel 提供的系统自适应是可以将设定的规则作为一个保护因子，而允许通过的流量由处理请求的能力来决定，即根据请求的响应时间、当前系统正在处理的请求速率来决定。</p>
<p>那 Sentinel 是如何实现的呢？接下来用源码的手段来揭晓其实现原理。</p>
<h2 id="2、系统自适应限流原理"><a href="#2、系统自适应限流原理" class="headerlink" title="2、系统自适应限流原理"></a>2、系统自适应限流原理</h2><p>Sentinel 执行系统限流的核心入口类为 SystemSlot，该类实现简单，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200524134158678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="SystemRuleManager#checkSystem"><br>从这里可以看出实现的关键在于SystemRuleManager，这里是直接调用 checkSystem 进行是否触发其限流，那我们接下来重点跟踪一下该方法的实现。</p>
<h4 id="2-1-自适应限流检测流程"><a href="#2-1-自适应限流检测流程" class="headerlink" title="2.1 自适应限流检测流程"></a>2.1 自适应限流检测流程</h4><p>系统自适应限流检测具体由 SystemRuleManager 的 checkSystem 方法实现，接下来详细剖析其实现细节。<br><img src="https://img-blog.csdnimg.cn/2020052413421556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：验证相关资源，主要包含三层验证：</p>
<ul>
<li>如果资源名称为空，则直接跳过，这个是容错机制。</li>
<li>如果系统自适应开关为打开，直接放行，该开关初始化时为 false，在加载到一条系统自适应配置规则时该状态会设置为 true，具体在 loadSystemConf 中。</li>
<li>如果资源的类型不是入口流量(EntryType.IN),则直接放行。<br><img src="https://img-blog.csdnimg.cn/20200524134428924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step2：从QPS为维度验证是否需要被限流，其实现关键点如下：</li>
<li>当前的qps，如果 ENTRY_NODE 为空则返回0，否则返回该统计节点的成功 qps，那 ENTRY_NODE 统计节点是“何许人也”，原来是 Sentinel 特定定义了一个资源，其名称为__total_inbound_traffic__，用来采集所有入口调用的信息，当资源进入类型为 ENTRY_TYPE_IN 时，会自动采集信息，其具体统计信息在 StatisticSlot 的 entry 方法中被调用，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20200524134513299.png#pic_center" alt="在这里插入图片描述"></li>
<li>如果当前调用的 QPS 大于设定的QPS，即触发限流，那这个 qps 又是在什么时候被设置的呢？也是在加载系统限流规则时被设置，如果一个应用同一个限流点（LOAD、QPS)设置了多条规则，最小值生效。<br><img src="https://img-blog.csdnimg.cn/20200524134545735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：关于线程数、响应时间限流模式与QPS类似，就不再重复介绍。<br><img src="https://img-blog.csdnimg.cn/20200524134621142.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step4：如果当前系统的负载超过了设定的阔值的处理逻辑，这里就是自适应的核心所在，并不是超过负载就限流，而是需要根据当前系统的请求处理能力进行综合判断，具体逻辑在 checkBbr 方法中实现。关于如何获得系统负载与 checkBbr 方法稍后会详细介绍。<br><img src="https://img-blog.csdnimg.cn/20200524134709868.png#pic_center" alt="在这里插入图片描述"><br>Step5：如果当前CPU的负载超过了设置的阔值，触发限流，那在JAVA中是如何获取CPU的使用率的呢？稍后详细介绍。</li>
</ul>
<a id="more"></a>

<h4 id="2-2-根据系统负载自适应算法详解"><a href="#2-2-根据系统负载自适应算法详解" class="headerlink" title="2.2 根据系统负载自适应算法详解"></a>2.2 根据系统负载自适应算法详解</h4><p>正如上面的第4步骤，根据系统 Load 的会采用 TCP BBR 算法来评估是否限流，具体实现代码如下：<br>SystemRuleManager#checkSystem<br><img src="https://img-blog.csdnimg.cn/2020052413473576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在 Sentinel 中估算系统的容量是以 1s 为度量长度，用该秒内通过的最大 qps 与 最小响应时间的乘积来表示，具体的计算细节：</p>
<ul>
<li>maxSuccessQps 的计算取当前采样窗口的最大值乘以1s内滑动窗口的个数，这里其实并不是十分准确。</li>
<li>minRt 最小响应时间取自当前采样窗口中的最小响应时间。<br>故得出了上述计算公式，除以1000是因为 minRt 的时间单位是毫秒，统一为秒。从这里可以看出根据系统负载做限流，最终的判断依据是线程数量。</li>
</ul>
<h4 id="2-3-JAVA如何获得操作系统负载情况"><a href="#2-3-JAVA如何获得操作系统负载情况" class="headerlink" title="2.3 JAVA如何获得操作系统负载情况"></a>2.3 JAVA如何获得操作系统负载情况</h4><p>在 Sentinel 中获取操作系统负载情况的类是：SystemStatusListener，每秒采集一次。<br>SystemStatusListener#run<br><img src="https://img-blog.csdnimg.cn/20200524134821496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>原来可以通过JDK中的 com.sun.management.OperatingSystemMXBean 获取操作系统相关的信息。<br>温馨提示：上述只对 Linux/Unix 操作系统有效，对 windows 无效。</p>
<h2 id="3、实践思考"><a href="#3、实践思考" class="headerlink" title="3、实践思考"></a>3、实践思考</h2><p>经过上面的分析，Sentinel 中的系统自适应其实指的是按照应用所在机器的操作系统负载，再结合应用本身的请求处理能力进行的自适应，操作系统的负载情况可以通过 top 命令输出，其示例如下：<br><img src="https://img-blog.csdnimg.cn/20200524134839941.png#pic_center" alt="在这里插入图片描述"><br>尽管 Sentienl 的系统规则配置类型分为 LOAD、CPU、RT、线程数、入口QPS等维度进行限流，但自适应主要是针对 LOAD 这种情况的。<br>Sentinel 系统级别的限流规则并不是针对某一个资源，而是针对应用所有定义EntryType.IN的资源，在使用时尤其需要注意，特别是如果一个机器上部署了多个应用，可能会造成应用本身负载不高，但所在的机器由于其他应用程序导致资源负载偏高，从而触发限流。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>系统自适应</tag>
        <tag>SystemSlot</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel 调用上下文环境实现原理</title>
    <url>/posts/e7bbdda0.html</url>
    <content><![CDATA[<div id="vip-container"><p>用源码与图解的方式详细探究 Sentinel 调用上下文环境是如何管理的。</p>
<p>本节将详细介绍 Sentienl 的上下文环境管理机制。</p>
<h2 id="1、Sentinel-Context-调用上下文环境管理"><a href="#1、Sentinel-Context-调用上下文环境管理" class="headerlink" title="1、Sentinel Context 调用上下文环境管理"></a>1、Sentinel Context 调用上下文环境管理</h2><p>我们从  sentinel-apache-dubbo-adapter 模块的 SentinelDubboProviderFilter 的实现中不难看出，在其入口处会首先调用 ContextUtil.enter(resourceName, application) 。那我们就从该方法开始来探究上下文环境管理机制。</p>
<p>说到 Sentinel 的调用上下文环境，那调用上下文环境中会保存哪些信息呢？我们先来看看 Context。</p>
<h4 id="1-1-Context-详解"><a href="#1-1-Context-详解" class="headerlink" title="1.1 Context 详解"></a>1.1 Context 详解</h4><p>Context 类图如下：<br><img src="https://img-blog.csdnimg.cn/2020011209183558.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p>Context<br>其核心属性与核心方法如下：</p>
<ul>
<li>String name<br>Sentinel 调用上下文环境的名称。</li>
<li>DefaultNode entranceNode<br>调用链的入口节点信息。</li>
<li>Entry curEntry<br>调用链中当前节点的信息。</li>
<li>boolean async<br>是否是异步调用上下文环境。</li>
<li>Entry<br>保存当前的调用信息，其主要核心属性：</li>
<li>private long createTime<br>资源调用的时间戳。</li>
<li>private Node curNode<br>该资源所对应的实时采集信息。</li>
<li>protected ResourceWrapper resourceWrapper<br>资源对象。</li>
</ul>
</li>
<li><p>CtEntry<br>同步调用调用信息封装对象。</p>
</li>
<li><p>AsyncEntry<br>异步调用调用信息的封装对象。</p>
</li>
</ul>
<p>对应的核心方法将在下文具体用到时再详细介绍。</p>
<h4 id="1-2-创建调用上下文环境"><a href="#1-2-创建调用上下文环境" class="headerlink" title="1.2 创建调用上下文环境"></a>1.2 创建调用上下文环境</h4><p>ContextUtil#enter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">enter</span><span class="params">(String name, String origin)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">	<span class="keyword">if</span> (Constants.CONTEXT_DEFAULT_NAME.equals(name)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ContextNameDefineException(</span><br><span class="line">                <span class="string">&quot;The &quot;</span> + Constants.CONTEXT_DEFAULT_NAME + <span class="string">&quot; can&#x27;t be permit to defined!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> trueEnter(name, origin);   <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先我们来看一下其参数：</p>
<ul>
<li>String name<br>上下文环境 Context 的名称。</li>
<li>String origin<br>该参数的含义在介绍集群限流时会详细介绍，从 dubbo 模块的适配来看，通常该值会传入当前应用的 application 名称。</li>
</ul>
<p>代码@2：通过调用内部的 trueEnter 方法。</p>
<p>在进入 trueEnter 方法之前，我们先来看一下 ContextUtil 中两个最核心的属性：<br><img src="https://img-blog.csdnimg.cn/20200112092204338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>首先使用 ThreadLocal 对象来存储线程上下文环境对象 Context。Map&lt;String, DefaultNode&gt; contextNameNodeMap ，其键为 context 的名称，用来缓存其对应的 EntranceNode 。</p>
<p>ContextUtil#trueEnter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Context <span class="title">trueEnter</span><span class="params">(String name, String origin)</span> </span>&#123;</span><br><span class="line">    Context context = contextHolder.get();   <span class="comment">// @1 </span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">	Map&lt;String, DefaultNode&gt; localCacheNameMap = contextNameNodeMap;</span><br><span class="line">        DefaultNode node = localCacheNameMap.get(name);   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (localCacheNameMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;   <span class="comment">// @3</span></span><br><span class="line">                 	setNullContext();</span><br><span class="line">               	 	<span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">           	 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                	<span class="keyword">try</span> &#123;</span><br><span class="line">                    		LOCK.lock();</span><br><span class="line">                    		node = contextNameNodeMap.get(name);   <span class="comment">// @4</span></span><br><span class="line">                    		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        		<span class="keyword">if</span> (contextNameNodeMap.size() &gt; Constants.MAX_CONTEXT_NAME_SIZE) &#123;  </span><br><span class="line">                            			setNullContext();</span><br><span class="line">                            			<span class="keyword">return</span> NULL_CONTEXT;</span><br><span class="line">                        		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           			 node = <span class="keyword">new</span> EntranceNode(<span class="keyword">new</span> StringResourceWrapper(name, EntryType.IN), <span class="keyword">null</span>);  <span class="comment">// @5</span></span><br><span class="line">                            			<span class="comment">// Add entrance node.</span></span><br><span class="line">                            			Constant.ROOT.addChild(node);                                                                                     <span class="comment">// @6</span></span><br><span class="line">						Map&lt;String, DefaultNode&gt; newMap = <span class="keyword">new</span> HashMap&lt;&gt;(contextNameNodeMap.size() + <span class="number">1</span>);</span><br><span class="line">                            			newMap.putAll(contextNameNodeMap);</span><br><span class="line">                            			newMap.put(name, node);</span><br><span class="line">                            			contextNameNodeMap = newMap;</span><br><span class="line">                        		&#125;</span><br><span class="line">                    		&#125;</span><br><span class="line">                	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    		LOCK.unlock();</span><br><span class="line">               		&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        context = <span class="keyword">new</span> Context(node, name);    <span class="comment">// @7</span></span><br><span class="line">        context.setOrigin(origin);</span><br><span class="line">        contextHolder.set(context);    <span class="comment">// @8</span></span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：从 threadLocal 中获取 Context 对象，线程首次获取时为空。</p>
<p>代码@2：根据 context 的名称尝试从缓存中去找对应的 Node，通常是 EntranceNode。即用来表示入口的节点Node 为 EntranceNode。</p>
<p>代码@3：如果 localCacheNameMap 已缓存的对象容量默认超过2000，则不纳入 Sentinel 限流，熔断等机制中来，即一个应用，默认不能定义 2000个 资源统计入口，以 一个 Dubbo 服务为例，一个 Dubbo 服务应用，如果超过2000个服务，则超过的部分不会应用 Sentinel 限流与熔断机制。</p>
<p>代码@4：锁应用的经典场景，dubbo check。</p>
<p>代码@5：为该 context name 创建一个对应的 EntranceNode。</p>
<p>代码@6：将创建的 EntranceNode 加入到根节点的子节点中，稍后重点讨论一下。</p>
<p>代码@7：创建 Context 对象，将 Context 对象中的入口节点设置为 新创建的 EntranceNode。</p>
<p>代码@8：将新创建的 Context 对象存入当前线程本地环境变量中(ThreadLocal)。</p>
<p>接下来先来探讨代码@6 Constants.ROOT.addChild(node)。</p>
<p>在 Sentinel 中，会定义一个固定根节点，其定义如下：<br><img src="https://img-blog.csdnimg.cn/20200112092324439.png" alt="在这里插入图片描述"><br>其资源名称为：machine-root。addChild 方法就是将节点添加到如下数据结构中：<br><img src="https://img-blog.csdnimg.cn/20200112092345428.png" alt="在这里插入图片描述"></p>
<h4 id="1-3-移除调用上下文环境"><a href="#1-3-移除调用上下文环境" class="headerlink" title="1.3 移除调用上下文环境"></a>1.3 移除调用上下文环境</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = contextHolder.get();</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span> &amp;&amp; context.getCurEntry() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        contextHolder.set(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退出当前上下文环境，这里有一个条件就是当前的上下文环境的当前调用节点已经退出，否则无法移除，故使用建议：ContextUtil . exit 一定要在持有的 Entry 退出之后再调用。</p>
<a id="more"></a>

<h4 id="1-4-异步上下文环境切换"><a href="#1-4-异步上下文环境切换" class="headerlink" title="1.4 异步上下文环境切换"></a>1.4 异步上下文环境切换</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runOnContext</span><span class="params">(Context context, Runnable f)</span> </span>&#123;</span><br><span class="line">	Context curContext = replaceContext(context);  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		f.run();  <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        replaceContext(curContext);  <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是异步调用上下文环境切换的实现原理，我们知道存在 ThreadLocal 中的数据是无法跨线程访问的，故一个线程中启动另外一个线程，上下文环境是无法直接被传递的，Sentinel 的思想是为先创建的线程再创建一个 Context，在运行子线程时，调用 runOnContext 来切换上下文环境。</p>
<p>Context 就介绍到这里了，我们接下来再来看一个与上下文环境管理密切相关的 Sentinel Slot 处理器：NodeSelectorSlot，通常也是 Sentinel Slot 处理链的第一个节点。</p>
<h2 id="2、NodeSelectorSlot"><a href="#2、NodeSelectorSlot" class="headerlink" title="2、NodeSelectorSlot"></a>2、NodeSelectorSlot</h2><h4 id="2-1-NodeSelectorSlot-调用链概述"><a href="#2-1-NodeSelectorSlot-调用链概述" class="headerlink" title="2.1 NodeSelectorSlot 调用链概述"></a>2.1 NodeSelectorSlot 调用链概述</h4><p>从该类的注释可以得出如下的结论：该类的作用是构建一颗虚拟调用树，我们接下来以一个Dubbo调用示例来说明。<br><img src="https://img-blog.csdnimg.cn/20200112092639143.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正如上图所示：应用 A 向应用 order-servie 服务发起一个 RPC 服务，下订单，order-service 应用引入了 sentinel-apache-dubbo-adapter 相关依懒，会执行 SentinelDubboProviderFilter 过滤器，调用 Sentinel 相关的方法，对资源进行保护，然后下单服务中，首先会操作数据库，将本次数据库操作定义为资源：insertOrderSQL，然后再操作 redis，redis 的操作命名为资源 setRedisOp。其对应在内存中会生成如下调用链的结构图。<br><img src="https://img-blog.csdnimg.cn/20200112092720275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>那上面这个调用链保存在线程上下文环境中，即 ThreadLocal 中。在 Sentinel 中使用 Node 来表示一个一个调用节点，其中 EntranceNode  表示调用链的入口，DefaultNode 表示普通节点，ClusterNode 表示集群节点，即同一个资源会统计整个集群中的信息。</p>
<p>从该类的注释我们可以得出上述的结论，接下来我们从源码的角度对其进行分析与理解。</p>
<h4 id="2-2-源码分析-NodeSelectorSlot"><a href="#2-2-源码分析-NodeSelectorSlot" class="headerlink" title="2.2 源码分析 NodeSelectorSlot"></a>2.2 源码分析 NodeSelectorSlot</h4><p>NodeSelectorSlot 中只声明了一个唯一的成员变量，其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, DefaultNode&gt; map = <span class="keyword">new</span> HashMap&lt;String, DefaultNode&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>定义一个 Map，其键为上下文环境 Context 的名称，通常是进入节点的名称，例如上面提到的 EntranceNode（ dubbo:provider:com.a.b.OrderService:saveOrder(java.lang.String)）。</p>
<blockquote>
<p>注意：一个 NodeSelectorSlot 对象会被多个线程使用，其共享的维度为资源，即多个线程进入同一个资源保护的代码时，执行的是同一个 NodeSelectorSlot 对象。详细实现请参考上文中 CtSph # lookProcessChain 部分详解。</p>
</blockquote>
<p>接下来重点看一下 NodeSelectorSlot 的核心方法 entry。</p>
<p>NodeSelectorSlot#entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, Object obj, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="comment">// @1</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    DefaultNode node = map.get(context.getName());   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;                                                       <span class="comment">// @3</span></span><br><span class="line">	    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;                                          <span class="comment">// @4</span></span><br><span class="line">	        node = map.get(context.getName());</span><br><span class="line">                <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">			node = <span class="keyword">new</span> DefaultNode(resourceWrapper, <span class="keyword">null</span>);    <span class="comment">// @5</span></span><br><span class="line">              	        HashMap&lt;String, DefaultNode&gt; cacheMap = <span class="keyword">new</span> HashMap&lt;String, DefaultNode&gt;(map.size());</span><br><span class="line">                	cacheMap.putAll(map);</span><br><span class="line">                	cacheMap.put(context.getName(), node);</span><br><span class="line">                	map = cacheMap;</span><br><span class="line">               	 	<span class="comment">// Build invocation tree</span></span><br><span class="line">                	((DefaultNode) context.getLastNode()).addChild(node);   <span class="comment">// @6</span></span><br><span class="line">          	&#125;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    context.setCurNode(node);                                                                  <span class="comment">// @7</span></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：我们先来看看其参数：</p>
<ul>
<li>Context context<br>调用上下文环境，该对象存储在 ThreadLocal，其名称在调用链的入口处设置。</li>
<li>ResourceWrapper resourceWrapper<br>资源的包装类，注意留意其 equals 与 hashCode 方法，判断两个对象是否相等的依据是资源名<br>称是否相同。</li>
<li>Object obj<br>参数。</li>
<li>int count<br>本次需要消耗的令牌数量。</li>
<li>boolean prioritized<br>请求是否按优先级排列。</li>
<li>Object… args<br>额外参数。</li>
</ul>
<p>代码@2：如果缓存中存在对应该上下文环境的节点，则直接使用，并将其节点设置当前调用上下文的当前节点中(Context)。</p>
<p>代码@3：如果节点为空，则进入到节点创建流程，此过程需要加锁，见代码@4。</p>
<p>代码@5：创建一个新的 DefaultNode 。</p>
<p>代码@6：构建调用链，由于 NodeSelectorSlot 是第一个进入的处理器，故此时 Context 的 curEntry 为 null ，故这里就是创建与的上下文环境名称对应的节点会被添加到 ContextUtil 的 entry 创建的调用链入口节点(EntranceNode)，然后顺便更新 Context 中的 Entry curEntry 属性，即再次验证了上面的图。</p>
<p>我们来总结一下 NodeSelectorSlot 作用：从官方的注释来看：构建一条调用链，更直接一点就是设置 Context 的 curEntry 属性。</p>
<p>关于 Sentinel 调用上下文环境实现原理就介绍到这里了。</p>
<p>思考题：首先在这里先“剧透”一下，Node 在 Sentinel 中的作用是持有资源的实时统计信息，将在下一篇文章介绍 StatisticSlot 时详细介绍。 NodeSelectorSlot 中的  Map&lt;String, DefaultNode&gt; 中的键为什么是 Context 的 名称呢？这样设计的目的是什么，能有什么好处？针对该问题将在笔者维护的知识星球中与各位星友展开讨论，欢迎您的加入。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>调用上下文</tag>
        <tag>NodeSelectorSlot</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel 集群限流设计原理</title>
    <url>/posts/a815ae71.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、集群限流使用场景"><a href="#1、集群限流使用场景" class="headerlink" title="1、集群限流使用场景"></a>1、集群限流使用场景</h2><p>首先一个服务有三个服务提供者，但这三台集群的硬件配置不一样，如图所示：<br><img src="https://img-blog.csdnimg.cn/20200503232733111.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>为了充分利用硬件的资源，诸如 Dubbo 都提供了基于权重的负载均衡机制，例如可以将8C16G的机器设置的权重是4C8G的两倍，这样充分利用硬件资源，假如现在需要引入 Sentinel 的限流机制，例如为一个 Dubbo 服务设置限流规则，这样由于三台集群分担的流量不均匀，会导致无法重复利用高配机器的资源。</p>
<p>假设经过压测，机器配置为C48G最高能承受的TPS为 1500，而机器配置为8C16G能承受的TPS为2800，那如果采取单机限流，其阔值只能设置为1500，因为如果超过1500，会将4C8G的机器压垮。</p>
<p>解决这种办法的方式就是针对整个集群进行限流，即为整个集群设置一个阔值，例如设置限流TPS为6000。</p>
<h2 id="2、集群限流与单机限流的异同思考"><a href="#2、集群限流与单机限流的异同思考" class="headerlink" title="2、集群限流与单机限流的异同思考"></a>2、集群限流与单机限流的异同思考</h2><p>限流的一个基本作用就是按照限流规则生成访问许可(Token)，然后根据当前实时的调用信息进行判断是否可以获得许可而决定是否放行。</p>
<p>集群与单机限流在实时调用信息收集方面应该差别不大，都可以基于滑动窗口进行统计信息的收集。</p>
<p>集群与单机限流的最主要区别在与许可的生成，单机模式的许可直接在本地生成，但集群限流必须有一个统一的 Token 发放机制，以此来协调当前集群内多机调用，从而基于当前“调用总数”进行限流。</p>
<h2 id="3、探究集群限流实现原理"><a href="#3、探究集群限流实现原理" class="headerlink" title="3、探究集群限流实现原理"></a>3、探究集群限流实现原理</h2><p>在探究集群限流实现原理之前先来回顾一下单机限流的执行流程图。<br><img src="https://img-blog.csdnimg.cn/20200503232832535.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合流程我们可以看出集群限流的几个关键点 ClusterBuilderSlot、FlowSlot。</p>
<h4 id="3-1-ClusterBuilderSlot-详解"><a href="#3-1-ClusterBuilderSlot-详解" class="headerlink" title="3.1 ClusterBuilderSlot 详解"></a>3.1 ClusterBuilderSlot 详解</h4><p>在对一个资源进行流控规则判断时，首先将进入到 NodeSelectorSlot，然后就会进入到 ClusterBuilderSlot，为了与单机限流模式，介绍 ClusterBuilderSlot 时与 NodeSelectorSlot 进行一个对比。</p>
<p>NodeSelectorSlot 的核心实现截图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200503232919521.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>温馨提示：从该系列之前的文章也能得知，一个 资源对应的一个 NodeSelectorSlot  实例，即多线程访问一个资源时，都会调用同一个 NodeSelectorSlot 实例。</p>
</blockquote>
<p>NodeSelectorSlot 的关键点如下：</p>
<ul>
<li>Map&lt;String, DefaultNode&gt; map<br>在 NodeSelectorSlot 中是以 context Id 为维度进行缓存的，例如官方给出的 Dubbo 适配方法，contexId 为 dubbo 服务的全路径名。即 Dubbo的入口节点对应的缓存 Key 为 context<br>id。</li>
<li>fireEntry 的 node 参数<br>由于 NodeSelectorSlot 是第一个过滤器，故第一次调用 fireEntry 方法时的 node 参数就是上面创建的 Node，即与 context 相关链的 Node，即所谓的入口节点即 Entrance Node。</li>
</ul>
<p>接下来重点关注一下 ClusterBuilderSlot 的关键点：<br><img src="https://img-blog.csdnimg.cn/20200503233012141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>ClusterBuilderSlot 的关键点如下：</p>
<ul>
<li>Map&lt;ResourceWrapper, ClusterNode&gt; clusterNodeMap<br>持有的集群节点缓存表，其键为 Entrance Node 所对应的资源ID，即 Context 中关联的节点信息。</li>
<li>Node originNode<br>所谓的 orginNode，即在调用 ContextUtil 中 enter(String name, String origin) 方法中的第二个参数，表示这条调用链的源头，在 Dubbo 中默认为 应用的 application。</li>
</ul>
<p>经过上面两个Slot，整个调用链就基本创建好了，接下来我们来看一下 FlowSlot 关于集群限流的相关处理逻辑。</p>
<h4 id="3-2-集群限流模式实现原理"><a href="#3-2-集群限流模式实现原理" class="headerlink" title="3.2 集群限流模式实现原理"></a>3.2 集群限流模式实现原理</h4><p><img src="https://img-blog.csdnimg.cn/20200503233045696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>FlowSlow FlowSlot 的核心处理逻辑主要是调用 FlowRuleChecker 的 canPassCheck 方法，正如上面看到的一样，根据配置规则，如果是集群模式，则调用的是其 passClusterCheck 方法，接下来我们将重点探讨该方法。<br><img src="https://img-blog.csdnimg.cn/20200503233111258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="FlowRuleChecker#passClusterCheck"><br>代码@1：获取一个 TokenService 服务类。这里实现关键点：</p>
<ul>
<li>如果当前节点的角色为 CLIENT，返回的 TokenService 为 DefaultClusterTokenClient。</li>
<li>如果当前节点的角色为 SERVER，返回的 TokenService 为 ClusterTokenServer，这里使用了SPI极致，可以通过查看 META-INF/services 目录下的 com.alibaba.csp.sentinel.cluster.TokenService 文件，默认服务端返回 DefaultTokenService。</li>
</ul>
<p>代码@2：如果无法获取到集群限流Token服务，如果该限流规则配置了可以退化为单机限流模式，则退化为单机限流。</p>
<p>代码@3：获取集群限流的流程ID，该 flowId 全局唯一。</p>
<p>代码@4：通过 TokenService 去申请 token，这里是与单机限流模式最大的差别。</p>
<p>接下来将分别从 DefaultClusterTokenClient、DefaultTokenService 分别探究集群限流相关的实现原理与细节，更好的指导我们如何使用集群限流功能。</p>
<h5 id="3-2-1-DefaultClusterTokenClient-详解"><a href="#3-2-1-DefaultClusterTokenClient-详解" class="headerlink" title="3.2.1 DefaultClusterTokenClient 详解"></a>3.2.1 DefaultClusterTokenClient 详解</h5><p>从我们的经验也得知，TokenClient 的主要职责就是发送请求到 TokenService 端，主要是网络相关的细节将不在此篇文章中给出，如果有兴趣，大家可以关注我的 Netty 专栏。</p>
<p>首先 Sentinel 提供了 SPI 机制，故允许用户自定义 TokenClient 的实现类，官方与 SPI 默认配置的文件如下：<br><img src="https://img-blog.csdnimg.cn/2020050323322512.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>关于 TokenClient 主要关注其初始化代码，因为我们需要关注一个非常重要的点：<br>DefaultClusterTokenClient#initNewConnection<br><img src="https://img-blog.csdnimg.cn/20200503233259244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在客户端启动的时候会创建与 TokenServer 之间的链接，即这边需要配置服务端的 IP 与端口号，那如何配置呢？其实配置方式完全由自己去实现对应的解析器，下面根据官方的 Demo 示例如下：<br><img src="https://img-blog.csdnimg.cn/20200503233319545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里需要说明的其配置项由 ClusterGroupEntity 来定义，其字段的定义如下：</p>
<ul>
<li>clientSet<br>客户端 Set 集合。</li>
<li>ip<br>Token 服务端的 IP。</li>
<li>machinedId<br>Token 服务端的机器ID。</li>
<li>port<br>Token 服务端的机器端口。</li>
</ul>
<p>其配置示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[&#123;&quot;clientSet&quot;:[&quot;112.12.88.66@8729&quot;,&quot;112.12.88.67@8727&quot;],&quot;ip&quot;:&quot;112.12.88.68&quot;,&quot;machineId&quot;:&quot;112.12.88.68@8728&quot;,&quot;port&quot;:11111&#125;]</span><br></pre></td></tr></table></figure>

<p>Client 端接下来就是向服务端发送请求，与网络相关的不在本文的讨论范围内，接下来将重点探讨服务端是如何发放许可的。</p>
<h5 id="3-2-2-DefaultTokenService-详解"><a href="#3-2-2-DefaultTokenService-详解" class="headerlink" title="3.2.2 DefaultTokenService 详解"></a>3.2.2 DefaultTokenService 详解</h5><p>Token Server 端收到客户的请求，其处理入口为 FlowRequestProcessor，其处理方法为：processRequest，最终会调用 DefaultTokenService 的 requestToken 方法。<br>DefaultTokenService#requestToken<br><img src="https://img-blog.csdnimg.cn/20200503233418165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：根据 ruleId 获取指定的限流规则。</p>
<p>代码@2：然后调用 ClusterFlowChecker 的 acquierClusterToken 方法，申请许可。</p>
<p>许可的发放流程主要由 ClusterFlowChecker 的 acquierClusterToken 方法实现。<br><img src="https://img-blog.csdnimg.cn/20200503233520315.png#pic_center" alt="在这里插入图片描述"><br>Step1：首先判断是否允许本次许可申请，这是因为 TokenServe 支持嵌入式，即支持在应用节点中嵌入一个 TokenServer，为了保证许可申请的请求不对正常业务造成比较大的影响，故对申请许可这个动作进行了限流。</p>
<p>一旦触发了限流，将向客户端返回 TOO_MANY_REQUEST 状态码，Sentinel 支持按 namespace 进行限流，具体由 GlobalRequestLimiter 实现，该类的内部同样基于滑动窗口进行收集，原理与 FlowSlot 相似，故这里不加以展开，默认的限流TPS为3W，有关于 Sentinel 相关的配置，将在后续文章专门梳理。<br><img src="https://img-blog.csdnimg.cn/20200503233607726.png#pic_center" alt="在这里插入图片描述"><br>Step2：根据流程ID获取指标采集器。<br><img src="https://img-blog.csdnimg.cn/20200503233630847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：计算 latestQps、globalThreashold、 nextRemaining 三个阔值，三个的含义分别如下：</p>
<ul>
<li>latestQps<br>获取当前正常访问的QPS。</li>
<li>globalThreashold<br>根据限流配置规则得出其总许可数量，其主要根据阔值的方式其有所不同，其配置阔值有两种方式：<br>1）FLOW_THRESHOLD_GLOBAL<br>总数，即集群中的许可等于限流规则中配置的 count 值。<br>2）FLOW_THRESHOLD_AVG_LOCAL<br>单机分摊模式，此时限流规则中配置的值只是单机的 count 值，集群中的许可数等于 count * 集群中客户端的个数。<br>注意：这里还可以通过 exceedCount 设置来运行超过其最大阔值，默认为1表示不允许超过。</li>
<li>nextRemainging<br>表示处理完本次请求后剩余的许可数量。<br><img src="https://img-blog.csdnimg.cn/20200503233707407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">Step4：如果剩余的许可数大于0，则本次申请成功，将当前的调用计入指标采集器中，然后返回给客户即可。</li>
</ul>
<p>接下来所有流程步骤都是基于没有剩余许可数的处理逻辑。<br><img src="https://img-blog.csdnimg.cn/20200503233730680.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step5：当前许可数不足的情况，并且该请求为高优先级的处理逻辑：</p>
<ul>
<li>获取当前等待的TPS（即1s为维度，当前等待的请求数量）</li>
<li>如果当前等待的TPS低于可借用未来窗口的许可阔值时，可通过，但设置其等待时间，可以通过 maxOccupyRatio 来设置借用的最大比值。<br><img src="https://img-blog.csdnimg.cn/20200503233758997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">Step6：如果当前许可不足，并且该请求为普通优先级的处理逻辑，增加阻塞相关指标的统计数，并返回 BLOCKED。</li>
</ul>
<p>TokenServer 返回申请许可之后，那 Token Client 如何处理呢？其处理代码在 FlowRuleChecker#applyTokenResult<br><img src="https://img-blog.csdnimg.cn/20200503233827875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们可以发现，如果服务端返回OK，则顺利通过，返回BLOCKED，则直接返回 false，会抛出 FlowException，如果是 token 限流，如果规则运行退化为单机限流模式，则进行单机限流。</p>
<p>集群限流的基本实现原理就介绍到这里了。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>集群限流的基本原理接介绍到这里了，与单机限流模式最大的区别就是集群限流模式的需要引入 TokenService，提供许可的发放服务，该服务可以嵌入应用节点，也可以独立于应用之外。这边借用官方文档上的两张图来简单介绍一下嵌入模式与独立模式的架构：<br><img src="https://img-blog.csdnimg.cn/20200503233858200.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200503233858165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>集群模式使用注意，如果使用的是集群模式限流，则如下两个配置则失效：<br><img src="https://img-blog.csdnimg.cn/20200503233920874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>最后抛出一个思考题：集群模式应该算是高大上，但我们项目中真的需要吗？集群限流模式有哪些缺点、哪些优点，欢迎大家留言探讨。</strong></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>集群限流</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之基础篇-Spring BeanDefinition初探</title>
    <url>/posts/4054ca58.html</url>
    <content><![CDATA[<div id="vip-container"><p>BeanDefinition，顾名思义，是一个对象(Bean)在Spring中描述，其核心类图：<br><img src="https://img-blog.csdn.net/20180528231257873?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180528231316723?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从类图我们详细了解BeanDefinition。<br>BeanDefinition接口继承自BeanMetadataElement和AttributeAccessor两个接口。<br>BeanMetadataElement：bean元数据，返回该bean的来源。<br>AttributeAccessor：Spring定义的属性访问器，对Bean的属性进行操作的API,例如设置属性、获取属性、判断是否存在该属性，返回bean所有的属性名称等。<br>下面重点分析一下BeanDefinition接口。</p>
<a id="more"></a>

<p>属性列表：<br>1）String SCOPE_SINGLETON，bean的作用范围，单例模式<br>2）String SCOPE_PROTOTYPE，bean的作用范围为prototype，在Spring生命周期中，会存在多个，由垃圾回收期管理其生命周期。<br>3）int ROLE_APPLICATION：bean的角色定义，默认，为应用程序定义。<br>4）int ROLE_SUPPORT：bean的角色定义，为应用程序定义的比较大的对象。<br>5）int ROLE_INFRASTRUCTURE：Spring内部定义的Bean对象。<br>核心方法详解：<br>1）void setBeanClassName(String beanClassName) ：该Bean的class name。<br>2）void setScope(String scope)：bean的生命周期，单例还是prototype。<br>3）void setLazyInit(boolean lazyInit)：lazyInit，是否延迟加载，如果设置为true,在需要用到时再初始化。<br>4）void setDependsOn(String… dependsOn)：dependsOn一般用于两个bean之间没有显示依赖，但后一个Bean需要用到前一个Bean执行初始方法后的结果。例如在&lt; bean id=”a” dependsOn=”b”/&gt; 时，在初始化a时首先先初始化b，在销毁b之前会先销毁a。<br>5）void setAutowireCandidate(boolean autowireCandidate)设置该对象是否可以被其他对象自动装配。<br>spring通过配置bean的autowire属性设置自动装配方式：<br>     no：不使用自动装配，必须通过ref元素指定依赖，为autowire默认值。<br>     byName：使用属性名自动装配，如果存在一个与指定属性名相同类型的bean则自动装配，如果有多个，则抛出异常。<br>     byType：根据类型自动状态，如果存在与指定属性类型相同的bean,则自动装配，如果有多个，则抛出异常。<br>     constructor：与byType类似，不同之处在于它使用的是构造器的参数类型。<br>     autodetect：通过bean的自省机制来决定是使用constructor还是byType来进行自动装配。如果有默认构造<br>                       器，则使用byType，否则使用constructor。<br>6）void setPrimary(boolean primary)，如果其他对象按照类型自动装配时发现有多个符合类型的多个实现bean，如果bean的primary属性为true，则以primary为true的优先，当然如果有多个primary为true，则抛出异常。<br>7）void setFactoryBeanName(String factoryBeanName)：设置bean的factoryBeanName。<br>8）void setFactoryMethodName(String factoryMethodName):设置bean工厂的方法名，Spring在实例化Bean对象时支持工厂方法设计模式，在初始化bean时不是通过bean的class发射创建 bean实例，而是根据factoryBeanName反射出工厂的实例，然后调用它的实例方法factoryMethodName来创建bean实例。<br>9）ConstructorArgumentValues getConstructorArgumentValues()：获取bean的构造方法参数。<br>10）MutablePropertyValues getPropertyValues()：获取实例bean的所有属性。<br>11）boolean isSingleton()：是否是单例。<br>12）boolean isPrototype()：是否是非单例。<br>13）boolean isAbstract()：是否是抽象的。</p>
<p>本文主要是根据BeanDefinition接口了解bean的一些特性,值得引起注意的是：lazy-init、depends-on、autowire-candidate、autowire、primary、factory-bean、factory-method。</p>
<blockquote>
<p>注：本文并没有尝试去罗列spring bean标签的全部属性。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>BeanDefinition</tag>
        <tag>内存溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>TreeMap之NavigableMap API 学习</title>
    <url>/posts/4757c2d8.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文主要学习TreeMap的核心API，下面是测试数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TreeMap&lt; Long, Long&gt; treeMap &#x3D; new TreeMap&lt;&gt;();</span><br><span class="line">for(int i &#x3D; 2; i &lt;&#x3D; 20; i &#x3D; i + 2) &#123;</span><br><span class="line">   treeMap.put(new Long(i), new Long(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、K lowerKey(K key) | Map.Entry&lt; K,V&gt; lowerEntry(K key)   </p>
<p>1）英文注释<br>Returns a key-value mapping associated with the greatest keystrictly less than the given key, or {@code null} if there is no such key.<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626214930370?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>   输出结果：<br>   4<br>   4<br>   null<br>3）中文解释<br>  返回第一个小于该key的键或Entry，不包含指定key。指定key不存在不影响结果，例如测试用例中的不存在键为5的键值对，但还是能返回Key:4，如果没有扎到小于key的键，则返回null。</p>
<a id="more"></a>

<p>2、K floorKey(K key) | Map.Entry&lt; K,V&gt; floorEntry(K key)</p>
<p>1）英文注释<br>Returns a key-value mapping associated with the greatest key less than or equal to the given key, or {@code null} if there is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215016389?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   6<br>   4<br>   null<br>3）中文解释<br>   返回小于等于指定key的键值，与lowerKey的区别是floorKey方法，如果TreeMap中包含指定的key，则返回指定key，否则返回第一个小于指定key的键。</p>
<p>3、K ceilingKey(K key) | Map.Entry&lt; K,V&gt; ceilingEntry(K key)</p>
<p>1）英文注释<br>Returns a key-value mapping associated with the least key greater than or equal to the given key, or {@code null} if there is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215110522?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   6<br>   6<br>   null<br>3）中文解释<br>   ceiling : 天花板，查找指定key的天花板，也就是说，查找第一个大于等于指定key的可以。</p>
<p>4、K higherKey(K key) | Map.Entry&lt; K,V&gt; higherEntry(K key)</p>
<p>1）英文注释<br>Returns a key-value mapping associated with the least key strictly greater than the given key, or {@code null} if there  is no such key。<br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215144375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>输出结果：<br>   8<br>   6<br>   null<br>3）中文解释<br>   返回第一个大于指定key的键，不包含指定key。而ceilingKey包含指定key。</p>
<p>5、Map.Entry&lt; K,V&gt; firstEntry()、Map.Entry&lt; K,V&gt; lastEntry()、Map.Entry&lt; K,V&gt; pollFirstEntry()、Map.Entry&lt; K,V&gt; pollLastEntry()<br>这四个方法很好理解，这里不做详细讲解。</p>
<p>6、NavigableMap&lt; K,V&gt; descendingMap()、 NavigableSet&lt; K&gt; descendingKeySet()<br>这两个方法，返回逆序。</p>
<p>7、NavigableMap&lt; K,V&gt; subMap(K fromKey, boolean fromInclusive,  K toKey,   boolean toInclusive)<br>1）英文注释<br><img src="https://img-blog.csdn.net/20180626215248417?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）测试结果<br><img src="https://img-blog.csdn.net/20180626215316903?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>  输出结果：<br>{4=4, 6=6, 8=8}<br>返回子集合(TreeMap),从fromKey,到toKey，boolean fromInclusive表示是否包含fromKey,boolean toInclusive是否包含toKey。<br>TreeMap#subMap</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123;</span><br><span class="line">        return subMap(fromKey, true, toKey, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8、NavigableMap&lt; K,V&gt; headMap(K toKey, boolean inclusive)<br>1）英文注释<br><img src="https://img-blog.csdn.net/20180626215421299?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）中文说明<br>   测试结果省略（推理后，也验证过），根据上面的学习过程，可以推导出，该方法相当于 subMap(firstKey, true, toKey, inclusive)。<br>TreeMap#headMap(Key toKey)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; headMap(K toKey) &#123;</span><br><span class="line">        return headMap(toKey, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>9、NavigableMap&lt; K,V&gt; tailMap(K fromKey, boolean inclusive)<br>1）英文描述<br><img src="https://img-blog.csdn.net/20180626215518663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>2）中文解释<br>返回从fromKey到lastKey的子集合，相当于subMap(fromKey,inclusive,lastKey,true)。<br>TreeMap#tailMap(K fromKey) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123;</span><br><span class="line">        return tailMap(fromKey, true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>TreepMap</tag>
      </tags>
  </entry>
  <entry>
    <title>java多线程Thread join与CountDownLatch源码分析</title>
    <url>/posts/7da5265a.html</url>
    <content><![CDATA[<div id="vip-container"><h1 id="1、Thread-join方法详解"><a href="#1、Thread-join方法详解" class="headerlink" title="1、Thread join方法详解"></a>1、Thread join方法详解</h1><p>首先，对于JAVA的一些基础知识，工作年限到了一定时间后，尽量不要一来就百度查询，比如thread join的作用，我们不妨先看一看join方法的源码，先试着自己理解，然后再去查询别人的理解，举一反三，美哉美哉。</p>
<a id="more"></a>

<p>join方法的声明与源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Waits at most &#123;<span class="doctag">@code</span> millis&#125; milliseconds for this thread to</span></span><br><span class="line"><span class="comment">     * die. A timeout of &#123;<span class="doctag">@code</span> 0&#125; means to wait forever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt; This implementation uses a loop of &#123;<span class="doctag">@code</span> this.wait&#125; calls</span></span><br><span class="line"><span class="comment">     * conditioned on &#123;<span class="doctag">@code</span> this.isAlive&#125;. As a thread terminates the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> this.notifyAll&#125; method is invoked. It is recommended that</span></span><br><span class="line"><span class="comment">     * applications not use &#123;<span class="doctag">@code</span> wait&#125;, &#123;<span class="doctag">@code</span> notify&#125;, or</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> notifyAll&#125; on &#123;<span class="doctag">@code</span> Thread&#125; instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  millis</span></span><br><span class="line"><span class="comment">     *         the time to wait in milliseconds</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  IllegalArgumentException</span></span><br><span class="line"><span class="comment">     *          if the value of &#123;<span class="doctag">@code</span> millis&#125; is negative</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span>  InterruptedException</span></span><br><span class="line"><span class="comment">     *          if any thread has interrupted the current thread. The</span></span><br><span class="line"><span class="comment">     *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is</span></span><br><span class="line"><span class="comment">     *          cleared when this exception is thrown.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先，join方法是线程对象的实例方法，并不同于sleep方法。并且被 synchronized关键字被修饰，说明要进入join方法，必须获得线程的对象锁。所以join(long millis)方法，指的是获取对象锁后需要等待的时间，并不是join方法等待的时间。</p>
<p>join的方法是在a线程中，调用 b.join()方法，实现的语义是，线程a等待线程b执行完毕后，再执行；join方法支持中断。实现的原理是在线程处于激活状态(isActive())方法时，调用 wait 方法或 wait(long milliseconds)方法。下面提供三个测试方法，进一步说明join方法语义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.study.thread;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * t.join学习</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test1();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// test2();</span></span><br><span class="line"></span><br><span class="line">        test3();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 join的基本语义，在其他线程执行完毕后，主线程才会结束</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 该测试用例说明：</span></span><br><span class="line"><span class="comment">     * 如果将t1.join 注释掉，则输出基本是</span></span><br><span class="line"><span class="comment">     *     main 线程启动.....</span></span><br><span class="line"><span class="comment">     *     main 线程结束......</span></span><br><span class="line"><span class="comment">     *         1</span></span><br><span class="line"><span class="comment">     *         2</span></span><br><span class="line"><span class="comment">     *         3</span></span><br><span class="line"><span class="comment">     * 如果增加t1.join则，主线程需要等待 t1线程运行结束后，才会退出，输出如下：</span></span><br><span class="line"><span class="comment">     *     main 线程启动.....</span></span><br><span class="line"><span class="comment">     *            1</span></span><br><span class="line"><span class="comment">     *         2</span></span><br><span class="line"><span class="comment">     *         3</span></span><br><span class="line"><span class="comment">     *     main 线程结束......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread1());</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(); <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试 t1.join(long miliseconds) 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread2());</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join(<span class="number">3000</span>); <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程启动.....&quot;</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread1());</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunThread3(t1));</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="comment">//确认t1,t2都在运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            t1.join(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;join方法执行后，经过&quot;</span> + ((end - start) / <span class="number">1000</span>) + <span class="string">&quot;秒结束&quot;</span>); <span class="comment">//这里不是1秒，需要等线程t2执行完毕才能被唤醒，</span></span><br><span class="line">                                                                               <span class="comment">//为什么呢，因为在线程t2中，占用了t1线程的对象锁，t1.join首先需要获取t1的对象锁。所以需要等t2执行完毕，                              </span></span><br><span class="line">                                                                              <span class="comment">//释放锁后才能开始执行join方法。</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程结束......&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RunThread3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread t;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunThread3</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">synchronized</span>(t) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i ++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:输出&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1 id="2、CountDownLatch源码分析"><a href="#2、CountDownLatch源码分析" class="headerlink" title="2、CountDownLatch源码分析"></a>2、CountDownLatch源码分析</h1><p>CountDownLatch，闭锁，能够实现Thread join 类似的语义，用在如下业务场景，比如协调者（主线程）创建多个线程去并发的完成一件事情，主线程创建并启动线程后，需要等待任务全部运行完毕后，主线程处理相关事情后再退出。</p>
<p>如下代码是我们经常会看到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;测试开始。。&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i ++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(  <span class="keyword">new</span> ThreadA()).start();<span class="comment">//处理任务</span></span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了防止主线程提早退出，我们一般会让主线程sleep,</span></span><br><span class="line">    Thread.sleep(<span class="number">100</span>* <span class="number">1000</span>);  <span class="comment">//这种不准确，实现方法不友好。</span></span><br><span class="line">   </span><br><span class="line">    System.out.println(<span class="string">&quot;测试结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">为了解决上述问题，CountDownLatch 能精确的解决上述问题。</span><br><span class="line">CountDownLatch使用实例：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnalA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch cdl;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RunnalA</span> <span class="params">(CountDownLatch cdl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cdl=cdl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>;i++) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;i:&quot;</span>+i);</span><br><span class="line">          &#125;</span><br><span class="line">         <span class="comment">// 线程运行完毕后，</span></span><br><span class="line">         cdl.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainCls</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptException </span>&#123;</span><br><span class="line">        CountDownLatch  cdl = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunnalA(cdl) ).start();</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//需要等10个线程全部运行完毕后，主线程才结束</span></span><br><span class="line">       cdl.await();<span class="comment">//等10个线程运行完毕后，主线程才会退出。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-CountDownLatch-方法实现原理"><a href="#2-1-CountDownLatch-方法实现原理" class="headerlink" title="2.1 CountDownLatch 方法实现原理"></a>2.1 CountDownLatch 方法实现原理</h2><p>首先，通过CountDownLatch的构造方法，设置锁的state变量，从分析ReentrantLock,ReentrantReadWriteLock 中我们应该知道state的意义。</p>
<p>然后await方法,使用获取共享锁的模式，由于state不为，则await方法调用，必然会在CLH队列中增加一个节点，然后线程阻塞。</p>
<p>countDown方法，每次将state减1，直到state=0时，唤醒线程，awiat方法成功获取锁，方法解除阻塞，继续执行。源码的分析就不做过多的解读，因为如下代码在学习ReentrantLock,ReentrantReadWriterLock锁时已经详细分析了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CountDownLatch对tryAcquireSharedd的实现，是 </span><br><span class="line"><span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;  如果getState()的值为<span class="number">0</span>,则不阻塞，直接返回。如果state大于<span class="number">0</span>，则在CLH队列中等待，由于我们在使用的时候，一定是先调用await方法，这样await方法在调用的时候，肯定是获取不到锁的，故在CLH队列中，会是这样的结构  head--&gt;Node[队列尾部，就是代表调用await方法的线程。]</span><br><span class="line"></span><br><span class="line">CountDownLatch的 countDown方法,内部就是调用releaseShared方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123; <span class="comment">//如果 state或减去1之后的值为0，则返回ture,表明可以唤醒由于调用                                                                                  //await方法调用的线程</span></span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>


</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>join</tag>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>java Reference 引用学习总结</title>
    <url>/posts/3c69fbc4.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、Java引用的类型"><a href="#1、Java引用的类型" class="headerlink" title="1、Java引用的类型"></a>1、Java引用的类型</h2><p>强引用、软引用(java.lang.ref.SoftReference)、弱引用(java.lang.ref.WeakReference)、虚引用(　java.lang.ref.PhantomReference　)。</p>
<p>java默认的引用类型为强引用，比如 Object a = new Object();其中 a 为强引用，new Object()为一个具体的对象。</p>
<p>至于软应用，弱引用，虚引用，就是 JAVA 虚拟机管理对象的范畴了，可以这样理解，SoftReference、WeakReference、PlantomReference 只是一种标记，JAVA 虚拟机在垃圾回收时，对上述不同的标记【引用的对象】采取不同的措施。采取措施如下：</p>
<ul>
<li><p>软引用(SoftReference)：当内存足够时，该引用【引用的对象】不会被回收，那什么是内存足够呢？进行年轻代的垃圾回收不会触发SoftReference所指向对象的回收,如果触发Full GC，那SoftReference所指向的对象将被回收。</p>
</li>
<li><p>弱引用(WeakReference) :当进行年轻代垃圾回收时，该引用指向的对象，就会被回收。</p>
</li>
<li><p>虚引用(PhantomeReference) 该引用指向的对象，无法对垃圾收集器收集对象时产生任何影响，唯一有用的是，如果被垃圾收集器收集的对象，被PhantomeReference标记，垃圾收集器会通过注册在PhantomeReference上的队列来通知应用程序，该引用指向的对象，已经被垃圾收集器回收。</p>
</li>
</ul>
<p>从上文的描述，也清楚的知道，上述应用是直接JVM打交道，更直接的说是与垃圾回收器直接的交互。</p>
<a id="more"></a>

<h2 id="2、java-lang-ref-Reference-详解"><a href="#2、java-lang-ref-Reference-详解" class="headerlink" title="2、java.lang.ref.Reference 详解"></a>2、java.lang.ref.Reference 详解</h2><h4 id="2-1-关键数据结构"><a href="#2-1-关键数据结构" class="headerlink" title="2.1 关键数据结构"></a>2.1 关键数据结构</h4><ul>
<li><p>private T referent;     /* Treated specially by GC */</p>
</li>
<li><p>private ReferenceQueue&lt;? super T&gt; queue;</p>
</li>
<li><p>private Reference next;<br>非常关键：Reference 本身可以当场一个 Reference 链表使用，在 ReferenceHandler 线程中从 pending 队列中，取出一个Reference, 如果该 Reference 相关的 queue 不为null,则执行入队操作，r.queue.enqueue(r); 参数为当前的引用，在入队列操作时，只要第一次进入队列，该引用的queue会被设置为 ReferenceQueue.ENQUEUE,也就算是再次调用进入队列操作，此时也无法再次与构造方法中传入的队 列绑定  在一起了。</p>
</li>
<li><p>private static Reference pending = null<br>关键中的关键；此队列维护着需要进入通知队列的引用，由 JVM 虚拟机垃圾回收器在检测到被引用指向的对象可达性发生改变后，如果该对象的引用（Referecnce）注册了引用队列 (ReferenceQueue),则 JVM 虚拟机垃圾收集器会将该引用加入到 pending 队列，注意这个 pending 队列是一个静态类变量。</p>
<p>为了便于理解上述的观点，先展示一下引用如何使用。</p>
<p>SoftReference sf = new SoftReference( new Object() );</p>
<p>其中sf 为引用，new Object为 sf指向的对象，其实也就是建立了 sf 到 new Object 对象的引用（关联），然后垃圾回收器发现 new Object 的可达性发生变化（其实就是变为不可达后），此时JVM虚拟机会根据引用对象 sf 的 queue 是否为空，如果为空，则直接将引用的状态变为 InActivie(非激活，离真正回收不远了)</p>
</li>
<li><p>ReferenceQueue queue = new ReferenceQueue();<br>  如果 SoftReference sf2 = new SoftRerence( new Object(),  queue );如果垃圾回收器检测到 new Object 的可达性发生变化后，会将该引用添加到 pending 引用链上，然后有专门的线程 ReferenceHandle 线程来将引用加入到引用链中（入队），也就是应用程序可以从 queue 中获取到所以垃圾回收器回收的对象的应用，也就是 queue是 垃圾回收器通知应用程序 被引用指向的对象已经被垃圾回收的消息。</p>
</li>
</ul>
<p>####　2.2 Reference 的状态</p>
<ul>
<li><p>Active<br>激活状态（可达），一般新建的引用就是该状态，该状态的属性特点  next = null; queue = ReferenceQueue.Null(默认值) 或者  构造方法指定的 queue  Reference( T referent, ReferenceQueue queue)。</p>
<p>当垃圾回收器检测到可达性发生变化（变为不可达时），如果 queue == ReferenceQueue.Null 的话，状态直接变为 InActive, 如果 queue 不为空，则加入到 Reference 的静态变量 pending 的队列中，并将状态设置为 Pending。</p>
</li>
<li><p>Pending</p>
<p>会有一个专门的线程 ReferenceHandler 来处理pengding链表中的引用[pending链表，应该是后进先出的特点]，将该引用入队（如果有注册队列，也可以看出是垃圾回收器以此来通知应用程序做些事情【请参考 WeakHashMap 的实现】）。在r.queue.enque(r) 方法中，有个关键点，保证一个引用，只能入队一次，入队后，该引用就与原来的引用队列失去关联；为了清晰展示次过程，将该代码附加上（来源于 java.lang.ref.Reference）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean enqueue(Reference&lt;? extends T&gt; r) &#123; &#x2F;* Called only by Reference class *&#x2F;</span><br><span class="line">        synchronized (r) &#123;</span><br><span class="line">            if (r.queue &#x3D;&#x3D; ENQUEUED) return false; &#x2F;&#x2F;关注这里</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                r.queue &#x3D; ENQUEUED;                &#x2F;&#x2F; 关注这里</span><br><span class="line">                r.next &#x3D; (head &#x3D;&#x3D; null) ? r : head;</span><br><span class="line">                head &#x3D; r;</span><br><span class="line">                queueLength++;</span><br><span class="line">                if (r instanceof FinalReference) &#123;</span><br><span class="line">                    sun.misc.VM.addFinalRefCount(1);</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notifyAll();</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
</li>
<li><p>Enqueue<br>进入队列中的Reference 中的 next 为队列中一个引用，或等于this(表示当前引用为最后一个), queue = ReferenceQueue.ENQUEUE。</p>
</li>
<li><p>InActive</p>
<p>queue = ReferenceQueue.NULL; next = this</p>
</li>
</ul>
<p>JAVA 四种引用的理解就到这了，其实 JAVA 中还有一种引用，java.lang.ref.FinalReference 应用，不过修饰符是 default, 包访问权限，主要用于 finalizer方法的执行，请关注下一篇博文。</p>
<p>再统一聊聊 java 引用中涉及到的引用的几个队列。</p>
<p>Reference中涉及到的队列(链表)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reference next;</span><br><span class="line"></span><br><span class="line">private static Reference pending &#x3D; null;</span><br><span class="line"></span><br><span class="line">private ReferenceQueue queue;</span><br></pre></td></tr></table></figure>

<p>每个引用可以关联一个引用队列，该引用队列由应用程序创建的，，然后垃圾回收器在检测到引用不可达时，将该引用加入到该队列，应用程序可以根据该引用队列来做些处理。（也就是该引用队列 成为 垃圾回收器与应用程序的通信机制）。</p>
<p>ReferenceQueue 自身的结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private volatile Reference&lt;? extends T&gt; head &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>首先，应用程序如下使用引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestReference &#123;</span><br><span class="line"></span><br><span class="line">           private static ReferenceQueue aQueue &#x3D; new ReferenceQueue();</span><br><span class="line"></span><br><span class="line">           public static void main(String args) &#123;</span><br><span class="line"></span><br><span class="line">                  Object a &#x3D; new Object();   &#x2F;&#x2F; 代码1</span><br><span class="line"></span><br><span class="line">                  WeakReference ref &#x3D; new WeakReference( a, aQueue );  </span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>然后在程序运行过程，内存不断消耗，直至触发垃圾回收操作。此时，垃圾收集器发现 代码1处的 a 所指向的对象，只有 ref引用它，从根路径不可达，故垃圾回收器，会将 ref 引用加入到  static Reference pending 链表中。</p>
<blockquote>
<p>注意，此代码是写在JVM实现中的】</p>
</blockquote>
<p>所处理的操作无非就是</p>
<p>1、如果pending 为空，则将当前引用(ref) 设置为pengding,,并且将 ref对象的next指针指向自己； 如果pending不为空，则将当前的引用(ref)的next指向pengding,然后pengding = 当前的引用ref,所以 pengding 其实就是 一个后进新出的链表单向链表结构。</p>
<p>2、由此总结出  ref 与 pengding链表关联的第一步  由JVM垃圾回收器完成。<br>从pengding 链表中取出引用，进行入队操作。该操作由专门的线程(ReferenceHandle 线程处理)，我重点将 ReferenceHandle线程的源代码贴出已供分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static class ReferenceHandler extends Thread &#123;</span><br><span class="line">        ReferenceHandler(ThreadGroup g, String name) &#123;</span><br><span class="line">            super(g, name);</span><br><span class="line">        &#125;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Reference r;</span><br><span class="line">                synchronized (lock) &#123;</span><br><span class="line">                    if (pending !&#x3D; null) &#123;        </span><br><span class="line">                        &#x2F;&#x2F; 如果pengding不为空，则取出pengding 的第一个引用，</span><br><span class="line">                        &#x2F;&#x2F; 然后重新设置pengding 的值（为原来的pending.next,见如下代码   a,b,c）</span><br><span class="line">                        r &#x3D; pending;                &#x2F;&#x2F; a 将pending取出，准备入队操作</span><br><span class="line">                        Reference rn &#x3D; r.next;  &#x2F;&#x2F; b 先获取原先pending 的 next</span><br><span class="line">                        pending &#x3D; (rn &#x3D;&#x3D; r) ? null : rn;  </span><br><span class="line">                        &#x2F;&#x2F; c  如果pending的next等于本身，则设在pending为空，否则为链表的下一个。</span><br><span class="line">                        &#x2F;&#x2F; 从这里更加看出 pending 是后进先出队列。</span><br><span class="line">                        r.next &#x3D; r;</span><br><span class="line">                    &#125; else &#123; </span><br><span class="line">                        &#x2F;&#x2F; 如果 pending 为空，则线程阻塞，等待垃圾回收器添加新的引用到 pending链表中</span><br><span class="line">                        try &#123;</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; catch (InterruptedException x) &#123; &#125;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                &#x2F;&#x2F; Fast path for cleaners</span><br><span class="line">                if (r instanceof Cleaner) &#123;</span><br><span class="line">                    ((Cleaner)r).clean();</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                ReferenceQueue q &#x3D; r.queue;</span><br><span class="line">                if (q !&#x3D; ReferenceQueue.NULL) q.enqueue(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>reference</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发锁机制-ReentrantLock Condtion准备篇</title>
    <url>/posts/aa807b75.html</url>
    <content><![CDATA[<div id="vip-container"><p>根据网上的说法，jdk并发包中的 Condition await 与 signal 实现了 Object.wait notify 语义。以下总结，是基于Condition await,singal方法的实现原理总结出来的：</p>
<ul>
<li>monitorObject.wait，该方法调用必须在临界区中（锁保护的代码段）被调用，线程如果在临界区中调用监视器的wait方法，然后线程会释放占有监视器monitorObject的锁，然后阻塞（等待条件的发生，该线程会保存在monitorObject的条件等待队列，当该线程收到信号或中断被唤醒后，首先需要尝试获取监视器的锁，然后继续执行操作，如果是被中断，需要在获取锁后，才会被中断。）</li>
<li>monitorObject.notify,该方法调用同样只能在临界区中被调用，锁的释放，在执行完临界区后，才会释放。根据Condition.singal实现机制，首先唤醒，是先将线程从条件等待队列放入到同步阻塞队列，然后执行完临界区代码后，释放锁，其他线程竞争锁。</li>
</ul>
<p>为了对Condition await 与 signal 方法有一个直接的了解，现给出一个简单的生产者、消费者测试示例：</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.study.concurent.bread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Lock;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		BreadContainerByObject container = <span class="keyword">new</span> BreadContainerByObject();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Producers(container)).start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Customer(container)).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BreadContainer</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Reentrant Condition实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadContainerByCondition</span> <span class="keyword">implements</span> <span class="title">BreadContainer</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="keyword">private</span> Condition NotFull = lock.newCondition();</span><br><span class="line">	<span class="keyword">private</span> Condition NotEmpty = lock.newCondition();</span><br><span class="line">	<span class="comment">// 面包容器</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Bread&gt; breads = <span class="keyword">new</span> ArrayList&lt;Bread&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">while</span>(breads.size() &gt;= MAX ) &#123; <span class="comment">//已经满了</span></span><br><span class="line">				NotFull.await();</span><br><span class="line">			&#125;</span><br><span class="line">			b.setId(num ++);</span><br><span class="line">			breads.add(b);</span><br><span class="line">			<span class="comment">//放入一个元素后，NotEmpty</span></span><br><span class="line">			NotEmpty.signalAll();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			lock.lock();</span><br><span class="line">			<span class="keyword">while</span>(breads.isEmpty()) &#123;<span class="comment">//如果为空</span></span><br><span class="line">				NotEmpty.await();</span><br><span class="line">			&#125;</span><br><span class="line">			Bread b = breads.remove(breads.size() -<span class="number">1</span>);</span><br><span class="line">			NotFull.signalAll();</span><br><span class="line">			<span class="keyword">return</span> b;	</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于 Object.notify Object.wait</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BreadContainerByObject</span> <span class="keyword">implements</span> <span class="title">BreadContainer</span></span>&#123;</span><br><span class="line">	<span class="comment">// 面包容器</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;Bread&gt; breads = <span class="keyword">new</span> ArrayList&lt;Bread&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">20</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bread b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (breads) &#123;</span><br><span class="line">			<span class="keyword">while</span>(breads.size() &gt;= MAX) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					breads.wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();<span class="comment">//这里不应该 将 InterruptedExcepiton 吞掉</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			b.setId(num ++);</span><br><span class="line">			breads.add(b);</span><br><span class="line">			breads.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Bread <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Bread b = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">synchronized</span> (breads) &#123;</span><br><span class="line">			<span class="keyword">while</span>(breads.size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					breads.wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">					e.printStackTrace();<span class="comment">//这里不应该 将 InterruptedExcepiton 吞掉</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			b = breads.remove(breads.size() -<span class="number">1</span>);</span><br><span class="line">			breads.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producers</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> BreadContainerByObject container;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producers</span><span class="params">(BreadContainerByObject container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			Bread b = <span class="keyword">new</span> Bread();</span><br><span class="line">			b.setFactoryName(Thread.currentThread().getName());</span><br><span class="line">			container.put(b);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 消费者</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> dingwei2</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> BreadContainerByObject container;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Customer</span><span class="params">(BreadContainerByObject container)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.container = container;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i ++ ) &#123;</span><br><span class="line">			Bread b = container.poll();</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费了&quot;</span> + b.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;serial&quot;)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bread</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String factoryName;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;面包:&quot;</span> + (id == <span class="keyword">null</span> ? <span class="number">0</span> : id.intValue()) + <span class="string">&quot;;生产工厂：&quot;</span> + getFactoryName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getFactoryName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> factoryName;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFactoryName</span><span class="params">(String factoryName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.factoryName = factoryName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Reentrant Condition ,细化了消息通知的粒度，比如使用了当队列中产品时，通过 NotEmpty 条件来唤醒消费者，当队列还有可用的空间存放产品时，使用 NotFull 条件来唤醒生产者，使用两个条件队列，确保被唤醒的线程的准确性，加入到同步队列的节点，在该节点获取到锁后，确实是满足条件的（特别在临界情况的时候)。而Object.wait, Object.notify ,  生产者，消费者在同一个条件队列中排队。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>并发琐</tag>
        <tag>wait</tag>
        <tag>notify</tag>
      </tags>
  </entry>
  <entry>
    <title>一文揭晓通信协议设计的奥妙，直接“秒杀“面试官</title>
    <url>/posts/cd43c662.html</url>
    <content><![CDATA[<div id="vip-container"><p>上一篇详细介绍了Netty的编解码的基本实现原理，本节将重点探讨网络编程中一种非常通用的协议设计方法论：<strong>协议头 + 消息体</strong>。</p>
<p>所谓的通信协议就是通信双方共同遵循的一种“约定”，用于通信发送方将内容按照“通信协议”所规定的格式组装成<strong>“二进制流”</strong>，通信接收方按照“通信协议”所规定的格式正确的从二进制流中解码出一个个原始请求。</p>
<p><strong>那通信协议如何设计呢？</strong></p>
<a id="more"></a>

<h2 id="1、通用的协议设计方法论"><a href="#1、通用的协议设计方法论" class="headerlink" title="1、通用的协议设计方法论"></a>1、通用的协议设计方法论</h2><p>在网络编程中，流行这一种经典的协议设计方法论：协议头 + 消息体。<br><img src="https://img-blog.csdnimg.cn/2021010315133342.png#pic_center" alt="在这里插入图片描述">其设计的关键点如下：</p>
<ul>
<li><strong>协议头的长度是固定的</strong>，通常为<strong>识别</strong>出<strong>一个业务的最小长度</strong>。</li>
<li>协议头中会包含一个<strong>长度字段</strong>，用来标识一个完整包的长度，用来表示长度字段的字节位数直接决定了一个包的最大长度，长度字段通常被设计为4个字节。</li>
<li>消息体中存储业务数据，例如如果是一个Dubbo协议，那消息体中可能会包含请求参数、调用的服务名等，而且字符串类的存储通常会采取字段长度、字段内容的组织方式。</li>
</ul>
<p>为了有一个更直观的展示，我以一个简单的RPC通信场景为例，实现类似Dubbo服务的远程服务调用，其通信协议可以简单设置成下图所示：<br><img src="https://img-blog.csdnimg.cn/2021010315383066.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>基于 Header + Boby 的通信协议设计模式后，通信接受方就能很好的从二进制流中非常容易的解码出一条一条原始的请求数据包，解码的基本套路如下(<strong>在面试中面试官非常喜欢问的“粘包”问题的破解之道</strong>)</p>
<ul>
<li>首先判断<strong>累积缓存区</strong>中是否存在一个<strong>完整的Head头部</strong>，例如上述示例中，一个包的Header的长度为6个字节，那首先判断累积缓存中可读字节数是否大于等于6，<strong>如果不足6个字节，跳过本次处理，等待更多数据到达累积缓存区</strong>。</li>
<li>尝试将头部6个字节读取，并且<strong>提取长度字段中存储的数值</strong>，即包长度，然后判断累积缓存区中可读字节数大于等于整个包的长度，<strong>如果累积缓存区不包含一个完整的数据包，则跳过本次处理，等待更多数据到达累积缓存区。</strong></li>
<li>如果包含一个完整的包，则按照通信协议的格式按序读取相关的内容。</li>
</ul>
<p>正是因为这种设计理念非常通用，Netty 对上述协议设计进行了统一封装：LengthFieldBasedFrameDecoder 闪亮登场了，<strong>接下来我们来看看Netty是如何进行封装的，揭晓更多的实现细节，让大家做到理论与实践相结合。</strong></p>
<h2 id="2、LengthFieldBasedFrameDecoder-详解"><a href="#2、LengthFieldBasedFrameDecoder-详解" class="headerlink" title="2、LengthFieldBasedFrameDecoder 详解"></a>2、LengthFieldBasedFrameDecoder 详解</h2><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p><img src="https://img-blog.csdnimg.cn/20210103161101564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来对其核心属性进行一个详细的解读：</p>
<ul>
<li>ByteOrder byteOrder<br>字节序列，Netty默认使用大端序列（主要是针对int、long等数值类型），所谓的大端序列，通常可以这样理解，接收端收到的字节流的顺序是从数值类型的高字节。</li>
<li>int maxFrameLength<br>一条消息最大的长度。</li>
<li>int lengthFieldOffset<br>代表长度字段的开始偏移量。</li>
<li>int lengthFieldLength<br>代表长度字段占用的字节长度。</li>
<li>int lengthFieldEndOffset<br>代表长度字段的结束偏移量，等于lengthFieldOffset + lengthFieldLength。</li>
<li>int lengthAdjustment<br>长度适配适配值。该值表示协议中长度字段与消息体字段直接的距离。</li>
<li>int initialBytesToStrip<br>跳过一个包中前面多少个字节不处理，<strong>通常是将协议头部跳过，只将消息体中内容传输到下游时使用</strong>。</li>
<li>boolean failFast<br>是否快速失败。</li>
<li> boolean discardingTooLongFrame<br>是否吞没（跳过）大帧包。</li>
<li>long tooLongFrameLength<br>当前在处理吞没大包的实际大小。</li>
<li>long bytesToDiscard</li>
</ul>
<p><strong>下一次解码之前，需要先忽略的字节数</strong>，当遇到超过maxFrameLength的包时使用。</p>
<p>上面的属性如果不太好理解，没关系，**因为本节的最后会有两张图勾画出协议的全貌(用图示的方式勾画出各个属性的位置与含义)**。</p>
<h4 id="2-2-decode-方法详解"><a href="#2-2-decode-方法详解" class="headerlink" title="2.2 decode 方法详解"></a>2.2 decode 方法详解</h4><p>接下来我们来看一下其decode方法，通过阅读源码的方法来理解其内部的工作原理。</p>
<p>LengthFieldBasedFrameDecoder#decode<br><img src="https://img-blog.csdnimg.cn/20210103162758778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：跳过无效数据包的处理逻辑。如果<strong>discardingTooLongFrame</strong>为true，表示正在处理<strong>大于**</strong>maxFrameLength<strong>的包，需要跳过这个超长的包，不对其解码，由于数据是陆续到达累积缓存区，并不能一次跳过整个无效包，故需引入 bytesToDiscard 变量，用于记录本次能跳过的字节，当 bytesToDiscard 为 0后表示一个无效包已全部跳过，需要处理正常数据包，此时discardingTooLongFrame 会重置为 false。<br><img src="https://img-blog.csdnimg.cn/20210103163914626.png" alt="LengthFieldBasedFrameDecoder#decode"><br>Step2：</strong>如果累积缓冲区的可读字节大小小于length字段的结束偏移量<strong>，返回null，结束解码，说明该累积缓存区中的数据还不完整。<br><img src="https://img-blog.csdnimg.cn/20210103164503153.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step3：尝试从累积缓存区中获取包的长度。其中表示 lengthFiedlOffset 表示长度字段的其实偏移量，在结合长度字段的长度 lengthFieldLength ，再结合字节序列</strong>（大端序列、小端序列）**。<br><img src="https://img-blog.csdnimg.cn/2021010316591174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step4：这里是包长度超过协议允许的最大包长度时的处理逻辑，再这里大家先姑且跳过 lengthAdjustment 属性的含义。</p>
<ul>
<li>如果当前累积缓存区中的可读字节大于 frameLength，大于当前包的长度，可以通过调用 skipBytes 方法跳过这包。</li>
<li>如果当前累积缓存区的可读自己小于 frmaeLength，需要分多次跳过，故先将累积区中的数据全部跳过，然后通过 bytesToDiscard 记录还需要跳过的字节数。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20210103173012169.png#pic_center" alt="在这里插入图片描述"><br>Step5：<strong>如果累积缓存区中的数据不包含一个完整的包，返回null，结束本次解码，等待更多的数据包到到来。</strong><br><img src="https://img-blog.csdnimg.cn/20210103174100193.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Step6：通过 ByteBuf 的 slince 方法，提取一个完整的包长度，解码出完整的数据包，完成一个数据包解码。</p>
<h4 id="2-3-图解-LengthFieldBasedFrame-协议"><a href="#2-3-图解-LengthFieldBasedFrame-协议" class="headerlink" title="2.3 图解 LengthFieldBasedFrame 协议"></a>2.3 图解 LengthFieldBasedFrame 协议</h4><p>在Netty 的 LengthFieldBasedFrameDecoder 中有一个 lengthAdjustment 属性，可以是正数，也可以是负数，其使用的代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">frameLength += lengthAdjustment + lengthFieldEndOffset</span><br></pre></td></tr></table></figure>
<p>lengthAdjustment 长度调整字段，可以为正数，也可以为负数，主要的作用是 长度字段中的值是否包含 Header 长度本身，严格意义上来说应该是包含 长度字段之前的字节序列。</p>
<p>1、lengthAdjustment &gt; 0<br><img src="https://img-blog.csdnimg.cn/20210103210634448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>2、lengthAdjustment &lt; 0<br>在大多数情况下，length字段表示消息正文的长度，但是有些协议，其长度表示的是整个消息的长度，故Netty为了适配这种情况，可以通过 lengthAdjustment 设置为负数，来调节数据帧的大小。<br><img src="https://img-blog.csdnimg.cn/20210103211439214.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>总结</strong>：lengthAdjustment 的出现是Netty<strong>为了适配现有的协议而设计出来的字段</strong>，即 Netty LengthFieldBasedFrameDecoder 是为了i给 header + body ，并且基于长度字段的协议一种通用的解决方案，可以通过 lengthAdjustment 来准确表示数据帧(业务数据的长度)，这里是一种<strong>逆向思维</strong>。</p>
<h2 id="3、协议设计子类的最佳实践"><a href="#3、协议设计子类的最佳实践" class="headerlink" title="3、协议设计子类的最佳实践"></a>3、协议设计子类的最佳实践</h2><p><strong>最佳实践：</strong> LengthFieldBasedFrameDecoder 的 decode 方法的职责是从二进制流中解码出一个完整的数据包，其返回类型还是 ByteBuf，故自定义的编码解码器的 decode 方法就是先调用父类的 decode 方法 得到 ByteBuf ，然后对 ByteBuf 中的数据解码出对象。</p>
<p>即 LengthFieldBasedFrameDecoder 并不负责将 ByteBuf 转换为协议对象，而是从二进制流中解码出一个数据帧，而将ByteBuf 转换为协议对象的职责由其子类实现，通常的编码风格如下：<br><img src="https://img-blog.csdnimg.cn/20210103212109895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<hr>
<p>更多文章建议关注『中间件兴趣圈』，回复【专栏】获取12个JAVA主流中间件源码剖析，并包含大量实战案例、架构设计理念；回复【PDF】可获取海量学习资料，助力突破职场瓶颈。</p>
<p><img src="https://img-blog.csdnimg.cn/20201231115902671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>netty</category>
        <category>网络编程</category>
        <category>通讯协议</category>
      </categories>
  </entry>
  <entry>
    <title>一文详解 Canal Instance 设计理念与定制开发思路</title>
    <url>/posts/c9e417fa.html</url>
    <content><![CDATA[<div id="vip-container"><p>从 Canal 系列的第一篇文章我们基本能了解到，Instance 是 Canal 数据同步的核心，在一个 Canal 实例中只有启动 Instace，才能实现数据的同步，那 Instance 到底是“何许人也”，本文将以源码为手段，试图揭开 Instance 的神秘面纱。</p>
<h2 id="1、Canal-Instance-类继承体系"><a href="#1、Canal-Instance-类继承体系" class="headerlink" title="1、Canal Instance 类继承体系"></a>1、Canal Instance 类继承体系</h2><p><img src="https://img-blog.csdnimg.cn/20200621210310965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>重要的类说明如下：</p>
<ul>
<li>CanalInstanceCanal Instance 接口，即定义 Instance 的基本特征，主要定义如下方法：<ul>
<li>String getDestination()<br>实例的目的地名称，在 Canal 中表示一个源实例名称，对应一个 MySQL 实例信息，例如 192.168.1.3:3306，这里为该实例取一个名称。</li>
<li>CanalEventParser getEventParser()<br>事件解析器，即 Binlog 解析器，负责解析 binlog 日志。</li>
<li>CanalEventSink getEventSink()<br>EventParse 与 EventStore 的连接器，主要处理数据的过滤、加工与分发，即提供了对 binlog 原始数据进行“加工”的切入点，EventStore 存储的就是经 EventSink处理过的数据。</li>
<li>CanalEventStore getEventStore()<br>事件存储器，即 Canal Instance 作为 MySQL 的 “Slave” 服务器，需要将同步过来的数据进行存储，然后被 Canal 的客户端最终会从 EventStore 中获取数据，目前 Canal 只实现了基于内存的 EventStore，那 Canal 是如何避免内存泄露，并且如何避免数据丢失的，这将是后续我们需要研究的重点。</li>
<li>CanalMetaManager getMetaManager()<br>Canal 元数据管理器，例如记录 消费端消费进度，即从 Canal EventStore 中处理数据的情况。</li>
<li><pre><code>CanalAlarmHandler getAlarmHandler()</code></pre>
告警服务。</li>
</ul>
</li>
<li>AbstractCanalInstance<br>CanalInstance的抽象实现类。</li>
<li>CanalInstanceWithManager<br>基于手动编程式的 CanaInstance，主要通过API的方式手动生成 CanalInstance 实例。 可以类比 Spring 基于编程API 的事务管理器。</li>
<li>CanalInstanceWithSpring<br>基于 Spring 方式构建 CanaInstance。</li>
<li>CanalInstanceGenerator<br>Canal Instance 的构造类体系，即通过该类提供的方法创建 CanalInstance 实例，提供基于 Spring、手动管理等方式。</li>
</ul>
<a id="more"></a>

<h2 id="2、CanalInstance-四大核心组件"><a href="#2、CanalInstance-四大核心组件" class="headerlink" title="2、CanalInstance 四大核心组件"></a>2、CanalInstance 四大核心组件</h2><p>从类层次了解 Canal Instance 显得不那么直观，接下来先抛出一个使用场景，再结合架构图进一步加深对 Canal Instance 的理解。</p>
<p>例如某公司的订单系统使用了分库分表，数据库的分别部署在 192.168.1.166:3306，192.168.1.168:3306 两个数据库，并且每一个数据库上会创建多个 schema，例如 order_db、user_db，那现在为了对订单提供多维度的查询，统计等功能，架构组因此提出通过订阅数据库 binlog 日志，将两个订单库中的订单数据，即将 order_db 中的数据同步到 elasticsearch，而 Canal 的设计初衷就是为了解决上述问题，故我们可以边思考这个场景，来反推一下 Canal Instance 的设计理念。</p>
<p>Canal Instance 的架构图如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200621210705154.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Canal 中数据的同步是由 CanalInstance 组件负责，一个 Canal Server 实例中可以创建多个 CanalInstance 实例。</p>
<p>每一个 CanalInstance 可以看成是对应一个 MySQL 实例，即案例中需要同步两个数据库实例，故最终需要创建两个 CanalInstance。其实也不难理解，因为 MySQL 的 binlog 就是以实例为维度进行存储的。Canal Instance 包含了 4个 核心组件 ：EventParse、EventSink、EventStore、CanaMetaManager，在这里主要是阐明其作用，后续文章会一一详细介绍，以便更好的指导实践。</p>
<ul>
<li>EventParse 组件<br>负责解析 binlog日志，其职责就是根据 binlog 的存储格式将有效数据提取出来，这个不难理解，我们也可以通过该模块，进一步了解一下 binglog 的存储格式。</li>
<li>EventSink 组件<br>结合数据同步案例，在一个数据库实例上通常会创建多个 Schema，但通常并不是所有的 schema 都需要被同步，如果直接将 EventParse 解析出来的数据全部传入EventStore 组件，将对 EventStore 带来不必要的性能消耗；另外本例中使用了分库分表，需要将多个库的数据同步到单一源，可能需要涉及到合并、归并等策略。以上等等等需求就是 EventSink 需要解决的问题域。</li>
<li>EventStore 组件<br>用来存储经 canal 转换的数据，被 Canal Client 进行消费的数据，目前 Canal 只提供了基于内存的存储实现。大家不妨先思考一下，采用基于内存的存储模式，如何避免内存溢出，其具体实现将在后续文章中详细剖析。</li>
<li>CanalMetaManager 组件<br>元数据存储管理器。在 Canal 中最基本的元数据至少应该包含 EventParse 组件解析的位点与消费端的消费位点。Canal Server 重启后要能从上一次未同步位置开始同步，否则会丢失数据。在将数据库数据同步到 es 的示例中，所谓的 canal 客户端就是从 Canal Server 即 EventStore 中获取数据，并将数据写入 es 中，并上报写入进度，这些信息都是由 CanalMetaManager 组件完成。</li>
</ul>
<p>从最新的版本来看，Canal 支持直接将解析后的数据发送到MQ，故 CanalInstance 中还持有另外一个组件：CanalMQConfig，关于 MQ 的一些配置，提供了多种策略实现 shcema、table 到 MQ Topic 的自动映射管理，为 Canal 的使用者带来更多便利，这部分内容会在后续文章中单独介绍，这里先暂时不过多讨论。</p>
<p>经过上面的了解，我想大家对 Canal Instance 有了一个相对全面的了解了吧，接下来我们再来关注一下 CanalInstance 的构造方式，这个对后续的实践有着非常重要的影响。</p>
<h2 id="3、CanalInstance-构造方式"><a href="#3、CanalInstance-构造方式" class="headerlink" title="3、CanalInstance 构造方式"></a>3、CanalInstance 构造方式</h2><p>Canal 中提供了两种方式对 Instance 进行初始化：Spring 与 手动编程方式。 CanalInstance 最最核心的就是上述提到的4个组件，即 CanalInstanceWithManager 类的具体职责就是管理上述核心组件，即提供对上述组件的加载、启动、停止，并协调，从其名字就能看出来，从其构造函数同样能得知：<br><img src="https://img-blog.csdnimg.cn/20200621210843366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>编程方式创建 Canal Instance 就变得简单起来，只需设置参数，并创建 CanalInstanceWithManger 方法即可，正如示例代码中使用的那样。<br><img src="https://img-blog.csdnimg.cn/2020062121090623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>另外 Canal 提供了对 Spring 的整合，将 canal Instance 的相关核心组件纳入 Spring 的管理，其实现类为： CanalInstanceWithSpring，对应的 Spring 配置示例如下图所示：</p>
<blockquote>
<p>温馨提示：基于 Canal 二次开发的编程技巧思考如下：Canal 框架本身将 Canal Server 做成了启动脚本，可以通过自定义 Instance，即从 instance 配置文件中加载配置，然后启动 Canal Server 解析 Binlog 日志，最终按照预定的配置进行工作，例如在生产环境搭建一些 Canal 集群，统一交由运维去手动维护，如果需要数据同步，则配置相应的 instance 文件，然后进行启动就生效，其实这种模式处于 Canal 的初阶阶段，更好的方式是对 Canal 进行二次开发，通过可视化的界面，通过界面的方式定义数据同步任务，例如将指定数据库实例上的指定 Schema 的 binglog 日志同步到指定消息集群的指定 topic，并且可重推、随时停止，重启，这样 Canal 的维护者无需关注底层的细节，只需要通过页面简单配置一下即可。</p>
</blockquote>
<p>本文就先介绍到这里了，本文的目的是了解 CanalInstance 在 Canal 中所处的定位，揭开其4大核心组件的作用与引入目的，为接下来逐个学习研究打下基础。</p>
<blockquote>
<p>源码研究 Canal 学习方法提示：目前 Canal 系列虽然在持续连载，目前笔者只能尽量做到周更，如果读者朋友们也正在研究 Canal，我觉得大家在读取本文后，可以继续深入研究其四大核心组件，并带着问题去研究，例如在学习元数据管理时是如何保证数据不丢失，重启后又是如何定位位点的。如果大家想更全局的去研究 Canal，我觉得除了阅读 Canal 官方的设计手册，还可以专门去看一下 CanalParameter 这个类，Canal 支持的所有配置属性，并且都有相应的注释，关于 Canal 的所有一切，都可以从这里窥探出端倪，然后可以选择感兴趣的内容加以继续深入学习。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
        <tag>CanalInstance</tag>
      </tags>
  </entry>
  <entry>
    <title>一次 RocketMQ 进程自动退出排查经验分享（实战篇）</title>
    <url>/posts/fc4470e5.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>公司一个 RocketMQ 集群由4主4从组成，突然其中3台服务器“竟然”在同一时间下线，其监控显示如下：<br><img src="https://img-blog.csdnimg.cn/20191026211319978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>依次查看三台机器的监控图形，时间戳几乎完美“吻合”，不可思议吧。</p>
<h2 id="2、故障分析"><a href="#2、故障分析" class="headerlink" title="2、故障分析"></a>2、故障分析</h2><p>出现问题，先二话不说，马上重启各服务器，尽快恢复集群，降低对业务的影响，接下来开始对日志进行分析。</p>
<p>Java 进程自动退出(rocketmq 本身就是一个java进程)，一种最常见的问题是由于内存溢出或由于内存泄漏导致进程发送Crash等。由于我们的启动参数中未配置-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=/opt/jvmdump 这两个参数，不能直接根据 是否生成 dump 文件，那退而求其次去查看其GC日志，将GC日志下载到本地，然后可以使用一个在线gc日志分析工具：<a href="https://gceasy.io/">https://gceasy.io/</a> ，将 gc 日志上传后会给出图形化的展示，其图如下：<br><img src="https://img-blog.csdnimg.cn/20191026211454570.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191026211519396.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现垃圾回收很正常。</p>
<p>既然 Java 进程不是由于内存溢出等问题导致的退出，那又会是什么原因呢？那我们来看一下那个点的broker的日志，其关键日志截图如下：<br><img src="https://img-blog.csdnimg.cn/20191026211607400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现 broker 日志中有打印出 shutdownHook，表示在进程退出之前执行了启动时注册时的退出钩子函数，说明 broker 是正常停止的，并且也不可能是 kill -9 命令，肯定是显示的执行了 shutodown 或 kill 命令，于是立马使用 history 命令 查看历史命令，都未在指定时间执行过该命令，并且切换到 root 命令后，同样使用 history 命令，并未发现端倪。</p>
<p>但我始终相信，肯定是执行了手动执行了 kill 命令导致进程退出的，经过网上查找查，得知可以通过查阅系统日志/var/log/messages 来查看系统命令的调用，于是乎把日志文件下载到本地，开始搜索 kill 关键字，发现如下日志：<br><img src="https://img-blog.csdnimg.cn/20191026211722459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现最近一次 kill 命令是在25号的凌晨1点多，停止 rocketmq 集群，并使用 bin/mqbroker -c conf/broker-b.conf &amp; 进行了重新启动。</p>
<p>这个命令是有问题的，没有使用 nohup ，如果会话失效，该进程就会被退出，为了验证，我们再查一下进程退出时的日志：</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20191026211818275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>发现在故障发生点确实有 Removed 相关的日志。</p>
<p>故障原因基本分析到位了，运维在启动的时候没有使用 nohup 来启动，故马上排查刚启动的集群的方式，重新重启刚启动的 Broker。</p>
<p>RocketMQ优雅重启小建议：</p>
<ol>
<li><p>首先将 broker 的写权限关闭，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.x.x:10911 -n 192.168.x.x:9876 -k brokerPermission -v 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 rocketmq-console 查看该broker的写入TPS，当写入TPS降为0后，再使用 kill pid 关闭 rocketmq 进程。温馨提示：将broker的写权限关闭后，非顺序消息不会立马拒绝，而是需要等客户端路由信息更新后，不会在往该broker上发送消息，故这个过程需要等待。</p>
</li>
<li><p>启动 rocketmq</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup bin&#x2F;mqbroker -c conf&#x2F;broker-a.conf  &#x2F;dev&#x2F;null  2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：nohup。</p>
</blockquote>
</li>
<li><p>恢复该节点的写权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;mqadmin updateBrokerConfig -b 192.168.x.x:10911 -n 192.168.x.x:9876 -k brokerPermission -v 6</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>本文的故障分析与处理就介绍到这里，本文重点讲解了故障的分析过程以及 RocketMQ Broker 优雅停机的方案。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>实战</tag>
        <tag>自动退出</tag>
      </tags>
  </entry>
  <entry>
    <title>使用流收集数据之toList、joining、groupBy(多字段分组)</title>
    <url>/posts/79082d0a.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将从Collectos中构建收集器入手，详细介绍java8提供了哪些收集器，重点介绍:toList、toSet、toCollection、joining、groupBy(包含多级分组)、reducing的核心实现原理与使用示例。</p>
<h2 id="1、toList、toSet、toCollection"><a href="#1、toList、toSet、toCollection" class="headerlink" title="1、toList、toSet、toCollection"></a>1、toList、toSet、toCollection</h2><p>首先对流中的数据进行计算，最终返回的数据类型为集合。Collectors中定义了如下3集合类收集器，其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Set&lt;T&gt;&gt; toSet()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, C extends Collection&lt;T&gt;&gt; Collector&lt;T, ?, C&gt; toCollection(Supplier&lt;C&gt; collectionFactory)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提示：建议根据上篇的理论，再来反推一下这些Collector中的核心属性的值，例如supplier、accumulator、combiner、characteristics。不过特别注意，toList、toCollection是不支持并行运行的，但toSet()方法支持并行运行。</p>
</blockquote>
<p>我们首先来看一个一直使用的示例，返回菜单中所有菜品的名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_toList</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = menu.stream().map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于toList方法的实现原理已经在 <a href="https://blog.csdn.net/prestigeding/article/details/90813819">java8读书笔记：探究java8流收集数据原理</a>中也详细介绍，故本篇不再重点介绍。</p>
<h2 id="2、joining"><a href="#2、joining" class="headerlink" title="2、joining"></a>2、joining</h2><p>Collectors定义了如下3个重载方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining()</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">    CharSequence prefix, CharSequence suffix)</span><br></pre></td></tr></table></figure>
<h3 id="2-1-joining"><a href="#2-1-joining" class="headerlink" title="2.1 joining"></a>2.1 joining</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;CharSequence, StringBuilder, String&gt;(</span><br><span class="line">        StringBuilder::<span class="keyword">new</span>, StringBuilder::append,</span><br><span class="line">        (r1, r2) -&gt; &#123; r1.append(r2); <span class="keyword">return</span> r1; &#125;,</span><br><span class="line">        StringBuilder::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Supplier&lt; A&gt; supplier()<br>其函数为StringBuilder::new，即通过该方法创建一个StringBuilder方法，作为累积器的初始值。</li>
<li>BiConsumer&lt;A, T&gt; accumulator<br>累积器：StringBuilder::append，即会对流中的元素执行追加。</li>
<li>BinaryOperator&lt; A&gt; combiner<br>组合器，也是调用append方法，进行字符串的规约。</li>
<li>Function&lt;A,R&gt; finisher<br>转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换</li>
<li>Set&lt; Characteristics&gt; characteristics<br>无任何行为。</li>
</ul>
<p>从上面的函数定义我们可以得出该方法的作用：针对字符串流，会对流中的元素执行字符的追加动作，流元素之间没有分隔符号，示例如下：<br><img src="https://img-blog.csdnimg.cn/20190609173712998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-2-joining-CharSequence-delimiter"><a href="#2-2-joining-CharSequence-delimiter" class="headerlink" title="2.2 joining(CharSequence delimiter)"></a>2.2 joining(CharSequence delimiter)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter) &#123;</span><br><span class="line">    <span class="keyword">return</span> joining(delimiter, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,</span><br><span class="line">                                                         CharSequence prefix,</span><br><span class="line">                                                         CharSequence suffix) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(</span><br><span class="line">            () -&gt; <span class="keyword">new</span> StringJoiner(delimiter, prefix, suffix),</span><br><span class="line">            StringJoiner::add, StringJoiner::merge,</span><br><span class="line">            StringJoiner::toString, CH_NOID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Supplier&lt; A&gt; supplier()<br>其函数为() -&gt; new StringJoiner(delimiter, prefix, suffix)，累积器的初始值为StringJoiner。</li>
<li>BiConsumer&lt;A, T&gt; accumulator<br>累积器：StringJoiner::append，即会对流中的元素执行追加。</li>
<li>BinaryOperator&lt; A&gt; combiner<br>组合器，StringJoiner::merge。</li>
<li>Function&lt;A,R&gt; finisher<br>转换器：由于累积器返回的最终对象为StringBuilder，并不是目标String类型，故需要调用StringBuilder#toString方法进行转换</li>
<li>Set&lt; Characteristics&gt; characteristics<br>无任何行为。</li>
</ul>
<p>其示例如下：<br><img src="https://img-blog.csdnimg.cn/20190609173901452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2 id="3、聚合相关收集器"><a href="#3、聚合相关收集器" class="headerlink" title="3、聚合相关收集器"></a>3、聚合相关收集器</h2><p>聚合相关收集器，主要包括minBy、maxBy、sum、avg等相关函数，其主要方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; minBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Optional&lt;T&gt;&gt; maxBy(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Integer&gt; summingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Long&gt; summingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; summingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingInt(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingLong(ToLongFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Double&gt; averagingDouble(ToDoubleFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>上面这些方法比较简单，下面举个简单的例子介绍其使用：<br><img src="https://img-blog.csdnimg.cn/20190609174021453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4 分组"></a>4 分组</h2><p>Collectors提供了3个groupingBy重载方法，我们一个一个来理解。</p>
<h3 id="4-1-从示例入手"><a href="#4-1-从示例入手" class="headerlink" title="4.1 从示例入手"></a>4.1 从示例入手</h3><p>我们从其中一个最简单的函数说起，从而慢慢引出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(</span><br><span class="line">             Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier)</span><br></pre></td></tr></table></figure>
<ul>
<li>Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt;<br>首先我们先来关注该方法的返回值Collector&lt;T, ?, Map&lt;K,List&lt; T&gt;&gt;，其最终返回的数据类型为：Map&lt;K, List&lt; T&gt;&gt;</li>
<li>Function&lt;? super T, ? extends K&gt; classifier<br>分类函数。</li>
</ul>
<p>示例如下：例如如下是购物车实体类，并且初始化数据如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShopCar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sellerId;</span><br><span class="line">    <span class="keyword">private</span> String sellerName;</span><br><span class="line">    <span class="keyword">private</span> String goodsName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> buyerId;</span><br><span class="line">    <span class="keyword">private</span> String buyerName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化数据如下：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;ShopCar&gt; <span class="title">initShopCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;天猫&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;京东&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">2</span> , <span class="string">&quot;ly&quot;</span>, <span class="number">2</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">1</span>, <span class="string">&quot;京东&quot;</span> , <span class="string">&quot;小米手机&quot;</span>, <span class="number">3</span> , <span class="string">&quot;zhl&quot;</span>, <span class="number">3</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;1号店&quot;</span> , <span class="string">&quot;华为手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">5</span>),</span><br><span class="line">            <span class="keyword">new</span> ShopCar(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;天猫&quot;</span> , <span class="string">&quot;苹果手机&quot;</span>, <span class="number">1</span> , <span class="string">&quot;dingw&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们看一下java8之前的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_group_jdk7</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;ShopCar&gt;&gt; shopBySellerNameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(ShopCar c : shopCars ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(shopBySellerNameMap.containsKey( c.getSellerName() )) &#123;</span><br><span class="line">            shopBySellerNameMap.get(c.getSellerName()).add(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;ShopCar&gt; aList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            shopBySellerNameMap.put(c.getSellerName(), aList);</span><br><span class="line">            aList.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(shopBySellerNameMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码应该很容易理解，根据商家名称进行分组，拥有相同商家的名称的购物车项组成一个集合，最终返回Map&lt;String, List&lt; ShopCar &gt;&gt;类型的数据。</p>
<p>那如何使用java8的流分组特性来编写对应的代码呢？下面的思考过程非常关键，经过前面的学习，我想大家应该也具备了如下分析与编写的能力？</p>
<p>首先其声明如下：public static &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)，那在本例中，T,K这两个参数代表什么意思呢？</p>
<ul>
<li>T : ShopCar</li>
<li>K : String (sellerName的类型)<br>其判断的主要依据为groupingBy方法返回的参数Collector&lt;T, ?, Map&lt;K, List&lt; T&gt;&gt;&gt;，代表&lt;T, A, R&gt;，其中最后一个泛型参数R对应的就是本例需要返回的Map&lt;K, List&lt; T&gt;&gt;，故分析出T,K代表的含义。</li>
</ul>
<p>然后再看其参数：Function&lt;? super T, ? extends K&gt; classifier,即接受的函数式编程接口为T -&gt; K，即通过ShopCar 返回一个String，又根据其名称可知，该函数为一个分类函数，故基本可以写成如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_group_jdk8</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;ShopCar&gt;&gt; shopBySellerNameMap =  </span><br><span class="line">                 shopCars</span><br><span class="line">                     .stream()</span><br><span class="line">                     .collect(Collectors.groupingBy(ShopCar::getSellerName));</span><br><span class="line">                   <span class="comment">//.collect(Collectors.groupingBy( (ShopCar c) -&gt; c.getSellerName() ))</span></span><br><span class="line">    print(shopBySellerNameMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其运行效果如下：<br><img src="https://img-blog.csdnimg.cn/20190609174540775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">为了加深对groupingBy方法的理解，接下来我们重点分析一下其源码的实现。</p>
<h3 id="4-2-源码分析groupingBy方法"><a href="#4-2-源码分析groupingBy方法" class="headerlink" title="4.2 源码分析groupingBy方法"></a>4.2 源码分析groupingBy方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier) &#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, toList());                                                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：分类参数，已经在上文中详细介绍。<br>代码@2：调用groupingBy重载方法，传入的参数为toList()，有点意思，传入的参数为Collectors.toList()，结合上文中的示例，需要返回值类型为：Map&lt;String, List&lt; ShopCar&gt;&gt;，与这里的List对应起来了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, A, D&gt; Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123;</span><br><span class="line">    <span class="keyword">return</span> groupingBy(classifier, HashMap::<span class="keyword">new</span>, downstream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该重载方法，再次调用3个参数的groupingBy方法，其中第二个参数为HashMap::new，即创建一个Map对象，我们重点关注3个参数的groupingBy。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt; Collector&lt;T, ?, M&gt; groupingBy(</span><br><span class="line">                          Function&lt;? <span class="keyword">super</span> T, ? extends K&gt; classifier, </span><br><span class="line">Supplier&lt;M&gt; mapFactory,</span><br><span class="line">Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) &#123; <span class="comment">// @1</span></span><br><span class="line">    Supplier&lt;A&gt; downstreamSupplier = downstream.supplier();        <span class="comment">// @2 start</span></span><br><span class="line">    BiConsumer&lt;A, ? <span class="keyword">super</span> T&gt; downstreamAccumulator = downstream.accumulator();</span><br><span class="line">    BiConsumer&lt;Map&lt;K, A&gt;, T&gt; accumulator = (m, t) -&gt; &#123;</span><br><span class="line">        K key = Objects.requireNonNull(classifier.apply(t), <span class="string">&quot;element cannot be mapped to a null key&quot;</span>);</span><br><span class="line">        A container = m.computeIfAbsent(key, k -&gt; downstreamSupplier.get());</span><br><span class="line">        downstreamAccumulator.accept(container, t);</span><br><span class="line">    &#125;; <span class="comment">// @2 end</span></span><br><span class="line"></span><br><span class="line">    BinaryOperator&lt;Map&lt;K, A&gt;&gt; merger = Collectors.&lt;K, A, Map&lt;K, A&gt;&gt;mapMerger(downstream.combiner());   <span class="comment">// @3</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Supplier&lt;Map&lt;K, A&gt;&gt; mangledFactory = (Supplier&lt;Map&lt;K, A&gt;&gt;) mapFactory;                            </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (downstream.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)) &#123;           <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, CH_ID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                            <span class="comment">// @5</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Function&lt;A, A&gt; downstreamFinisher = (Function&lt;A, A&gt;) downstream.finisher();</span><br><span class="line">        Function&lt;Map&lt;K, A&gt;, M&gt; finisher = intermediate -&gt; &#123;</span><br><span class="line">            intermediate.replaceAll((k, v) -&gt; downstreamFinisher.apply(v));</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            M castResult = (M) intermediate;</span><br><span class="line">            <span class="keyword">return</span> castResult;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;(mangledFactory, accumulator, merger, finisher, CH_NOID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数介绍：</p>
<ul>
<li>Function&lt;? super T, ? extends K&gt; classifier<br>分类函数。</li>
<li>Supplier&lt; M&gt; mapFactory<br>map构建函数。（）-&gt; Map</li>
<li>Collector&lt;? super T, A, D&gt; downstream<br>下游收集器，在上面的示例中，该参数为Collectos.toList()。</li>
</ul>
<p>代码@2：构建最终的累积器。其实现要点如下：</p>
<ul>
<li>对流中的元素，使用Function&lt;? super T, ? extends K&gt; classifier，获取对应的分类键值。</li>
<li>使用mangledFactory创建累积初始值，并调用Map#computeIfAbsent方法，放入的值为：downstreamSupplier.get()。可以类比上例中Map&lt;String, List&lt; T&gt;&gt;，请结合如下代码进行理解：<br><img src="https://img-blog.csdnimg.cn/20190609174846127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<p>代码@3：构建最终的组合器，这里使用的是Collectos.mapMerger，其内部的实现就是对每个元素，执行map#merge方法。</p>
<p>代码@4：如果收集器的行为为IDENTITY_FINISH，直接根据上面已创建的累积器、组合器，创建一个最终的收集器。</p>
<p>代码@5：如果收集器的行为不包含IDENTITY_FINISH，则需要最终调用原收集器的finisher方法。才能最终需要返回的类型。</p>
<p>groupingBy的原理就讲解到这里，我们接下来思考如下场景：<br>还是上面的购物车场景，现在要求先按照供应商名称分组，然后按照购买人分组（即多级分组），类似于SQL group by sellerId,buyerId。</p>
<p>思考过程：首先二级分类需要返回的数据类型为Map&lt;String /** sellerName*/,   Map&lt;String、/** buyerId*/，List&lt; ShopCar&gt;&gt; &gt;,而只有一个参数的groupingBy(Function&lt;? super T, ? extends K&gt; classifier)，只接受一个分类参数，其内部会调用两个参数的groupingBy(Function&lt;? super T, ? extends K&gt; classifier,Collector&lt;? super T, A, D&gt; downstream)，默认第二个参数为Collectors.toList()，故我们可以做的文章是改变这个默认值，传入符合业务场景的收集器，结合目前的需求，很显然，该参数应该是支持分组的收集器，即应该可以通过嵌套groupingBy方法，实现二级分组，其具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二级分组示例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> shopCars</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_level_group</span><span class="params">(List&lt;ShopCar&gt; shopCars)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Map&lt;String, List&lt;ShopCar&gt;&gt;&gt;  result = </span><br><span class="line">        shopCars.stream().collect(Collectors.groupingBy(ShopCar::getSellerName,</span><br><span class="line">                                    Collectors.groupingBy(ShopCar::getBuyerName)));</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>温馨提示：上面介绍的分组，主要的Map存储结构为HashMap，java8为ConcurrentMap对应类继承体系提供了对应的分组函数：groupingByConcurrent，其使用方法与groupingBy方法类型，故不重复介绍。</p>
<h2 id="5、-partitioningBy"><a href="#5、-partitioningBy" class="headerlink" title="5、 partitioningBy"></a>5、 partitioningBy</h2><p>分区，分区可以看出是分组的特殊化，接受的分类函数返回boolean类型，即是谓词Predicate&lt;? super T&gt; predicate。其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, D, A&gt; Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate, Collector&lt;? <span class="keyword">super</span> T, A, D&gt; downstream) </span><br></pre></td></tr></table></figure>
<p>由于其用法与分组类似，故这里就一笔带过了。</p>
<h2 id="6、-reducing"><a href="#6、-reducing" class="headerlink" title="6、 reducing"></a>6、 reducing</h2><p>规约。其函数声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity, Function&lt;? <span class="keyword">super</span> T, ? extends U&gt; mapper, BinaryOperator&lt;U&gt; op)</span><br></pre></td></tr></table></figure>
<p>其参数如下：</p>
<ul>
<li>U identity<br>规约初始值。</li>
<li>Function&lt;? super T, ? extends U&gt; mapper<br>累加器函数。</li>
<li>BinaryOperator<U> op<br>组合器函数。<br>关于Collectors.reducing，建议可以直接使用Stream自身提供的reducing方法。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Lambda</tag>
        <tag>流计算</tag>
      </tags>
  </entry>
  <entry>
    <title>从年末生产故障解锁RocketMQ集群部署最佳实践</title>
    <url>/posts/8956924f.html</url>
    <content><![CDATA[<div id="vip-container"><p>笔者比较“悲催”，临近年末由笔者维护的生产MQ集群中的一台物理机内存故障导致操作系统异常重启，持续10分钟中出现众多的应用发送客户端出现发送消息超时，导致事故并定性为S1，笔者的“年终奖”。。。</p>
<h2 id="1、故障描述"><a href="#1、故障描述" class="headerlink" title="1、故障描述"></a>1、故障描述</h2><p>RocketMQ 集群采取的部署架构为2主2从，其部署架构如下图所示：<br>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传<br><img src="https://img-blog.csdnimg.cn/20201227093130257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其部署架构中一个非常明显的特点是一台物理机上分别部署了 nameserver，broker 两个进程。</p>
<p>其中一台机器(192.168.3.100)的内存出现故障，导致机器重启，但Linux操作系统由于重启需要自检等因素，整个重启过程竟然持续了将近10分钟，客户端的发送超时持续10分钟，这显然是不能接受的！！！</p>
<p>RocketMQ的高可用设计何在？接下来我们将详细介绍其分析过程。</p>
<a id="more"></a>

<h2 id="2、故障分析"><a href="#2、故障分析" class="headerlink" title="2、故障分析"></a>2、故障分析</h2><p>当得知一台机器故障导致故障持续10分钟，我的第一反应是不应该呀，因为 RocketMQ 集群是分布式部署架构，天然支持故障发现与故障恢复，消息发送客户端能自动感知 Broker 异常的的时间绝对不会超过10分钟，那故障又是怎么发生的呢？</p>
<p>首先我们先来回顾一下RocketMQ的路由注册与发现机制。</p>
<h4 id="2-1-RocketMQ路由注册与剔除机制"><a href="#2-1-RocketMQ路由注册与剔除机制" class="headerlink" title="2.1 RocketMQ路由注册与剔除机制"></a>2.1 RocketMQ路由注册与剔除机制</h4><p><img src="https://img-blog.csdnimg.cn/20201227093154348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其路由注册、剔除机制说明如下：</p>
<ul>
<li>集群中所有Broker每隔30s向集群中所有的NameServer发送心跳包，注册Topic路由信息。</li>
<li>NameServer在收到Broker端的心跳包时首先会更新路由表，并记录收到心跳包的时间。</li>
<li>NameServer会启动一个定时任务每10s会扫描Broker，如果Nameserver连续120s未收到Broker的心跳包，会判定Broker已下线，将从路由表中将该Broker移除。</li>
<li>如果Nameserver与Broker端的长连接断开，NameServer会立即感知Broker下线并从路由表中将该Broker移除。</li>
<li>消息客户端(消息发送者、消息消费者)在任意时刻只会和其中一台NameServer建立连接，并每隔30s向NameServer查询路由信息，如果查询到结果会更新发送者的本地路由信息。</li>
</ul>
<p>从上述的路由注册、剔除机制来看，当一台Broker服务器宕机，消息发送者感知路由信息发生变化需要的时间是多长呢？</p>
<p>分如下两种情况分别讨论：</p>
<ul>
<li>NameServer与Broker服务器TCP连接断开，此时NameServer能立即感知路由信息变化，将其从路由表中移除，从而消息发送端应该在30s左右就能感知路由发送变化，在此30s内在发送端会出现消息发送失败,但结合发送规避机制，并不会对发送方带来重大故障，可接受。</li>
<li>如果NameServer与Broker服务器的TCP连接未断开，但Broker已无法提供服务(例如假死)，此时NameServer需要120s才能感知Broker宕机，此时消息发送端最多需要150s才能感知其路由信息的变化。</li>
</ul>
<p><strong>但问题来了，为什么在生产实际过程中一台Broker由于内存故障重启,10分钟后重启成功后业务才恢复，即业务才真正感知Broker宕机呢？</strong></p>
<p>既然出现了，我们就需要对其进行分析，给出解决方案，避免不会在生产环境出现同类型的错误。</p>
<h4 id="2-2-故障排查经过"><a href="#2-2-故障排查经过" class="headerlink" title="2.2 故障排查经过"></a>2.2 故障排查经过</h4><p>先查询客户端的日志(/home/{user}/logs/rocketmqlogs/rocketmq_client.log)，从中可以看到从客户端第一次报消息发送超时的时间是14:44，其日志输出如下：<br><img src="https://img-blog.csdnimg.cn/2020122709322326.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>由于192.168.3.100机器内存故障，故首先去查看该集群中其他nameserver中的日志，看正常机器中的NameServer感知broker-a故障的时长，其日志如下所示：<br><img src="https://img-blog.csdnimg.cn/20201227093237477.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从中可以看出192.138.3.101的nameserver基本在2分钟左右才感知其宕机，即虽然机器在重启，但可能由于操作系统要做硬件自检等其他原因，TCP连接并未断开，故nameserver在120s后才感知其宕机，从路由信息表中将该broker移除，那按照路由剔除机制，客户端应该在150秒的时间内感知其变化，那为什么没感知呢？</p>
<p>继续查看客户端路由信息，查看客户端感知路由信息发生变化的时间点，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093255965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从客户端日志来看，客户端在14:53:46才感知其变化，这又是为什么呢？</p>
<p><strong>原来客户端在更新路由信息时报超时异常，其截图如下所示：</strong>：<br><img src="https://img-blog.csdnimg.cn/20201227093317856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从发生故障到故障恢复期间，客户端一直尝试从已发生故障的NameServer去更新路由信息，但一直返回超时，这样就导致了客户端一直无法获取最新的路由信息，故一直无法感知已宕机的Broker。</p>
<p><strong>从日志分析来看，到目前来说就比较明朗了，客户端之所有没有在120s之内感知其路由信息的变化，是因为客户端一直尝试从已宕机的nameserver去更新路由信息，但由于一直无法请求成功，故客户端的缓存路由信息一直无法得到更新，造成了上面的现象</strong></p>
<p>那问题来了，按照我们对RocketMQ的认识，NameServer宕机，客户端会自动去从nameserver列表中选择下一个nameserver，<strong>那为什么这里并没有发生nameserver切换</strong>，而是等到14:53才切换呢？</p>
<p>接下来我们将目光投向NameServer的切换代码，其代码片段如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093337453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上图中的几个关键分析如下：</p>
<ul>
<li>客户端能通过缓存中的连接发送RPC请求的前提条件是channel的isActive方法返回true，即底层TCP连接处于激活状态。</li>
<li>在客户端向服务端发起RPC请求时，如果出现非超时类异常，会执行closeChannel方法，该方法会关闭连接并从连接缓存表中移除，这个非常关键，因为在切换NameServer时如果缓存中存在连接并连接处于激活状态，就不会切换nameserver。</li>
<li>如果发送RPC超时，rocketmq会根据clientCloseSocketIfTimeout参数来决定是否关闭连接，但遗憾的是该参数默认为false，并且并未提供修改的入口。</li>
</ul>
<p>那问题分析到这里，已经非常明了，由于机器内存故障触发重启并且重启前需要自检等因素，造成nameserver,broker无法再处理请求但底层TCP连接并未断开，导致发生超时错误，但客户端并不会关闭与故障机器nameserver的TCP连接，导致无法切换，等到机器重新启动后，TCP连接断开，故障机器重启完成后感知路由信息变化，故障恢复。</p>
<p><strong>经过上面的问题分析，其故障原因如下</strong>：<br>192.168.3.100机器在内存故障后重启，整个重启耗时10分钟，并且在重启过程中TCP连接未断开，192.168.3.101 nameserver在故障发送时2分钟左右才感知路由变化，但部分客户端时连接192.168.3.100的nameserver，客户端尝试从该nameserver查询路由信息，但一直返回超时，<strong>由于没有关闭连接，导致客户端并不会切换到</strong>3.101的nameserver，直到客户端与nameserver的TCP连接断开后，切换到另外一个3.101的nameserver，故障在指定时间内得以恢复。</p>
<p><strong>根本原因：其实是nameserver的假死导致路由信息无法更新。</strong></p>
<h2 id="3、最佳实践"><a href="#3、最佳实践" class="headerlink" title="3、最佳实践"></a>3、最佳实践</h2><p>经过上面的故障，个人觉得nameserver不应该与broker部署在一起，如果nameserver与broker并不部署在一起，上面的问题能得到有效避免，其部署架构如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201227093642967.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>这样的部署架构如果面对上面的故障，Broker假死的情况，能有效避免吗？答案是可以的。</strong></p>
<p>如果192.168.3.100的broker假死，那么3.110,3.111的nameserver都能在2分钟内感知broker-a宕机，然后客户端能成功从nameserver处获得最新的路由信息，如果nameserver假死，出现超时错误，只要broker不宕机，则通过缓存，还是能正常工作的，<strong>但如果nanmeserver,broker一起假死，则上述架构还是无法规避上面的问题</strong>。</p>
<p><strong>故本次的最佳实践主要包含如下两条</strong>：<br>1、nameserver与broker一定要分开部署，进行隔离。<br>2、nameserver与客户端的连接，应该在超时后，关闭连接，触发nameserver漂移，需要修改源码。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>RocketMQ</category>
        <category>故障分析</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>故障</tag>
        <tag>假死</tag>
        <tag>集群部署</tag>
      </tags>
  </entry>
  <entry>
    <title>再谈 RocketMQ broker busy(实战篇)</title>
    <url>/posts/cf8acd90.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将在 <a href="https://blog.csdn.net/prestigeding/article/details/92800672">RocketMQ 消息发送system busy、broker busy原因分析与解决方案</a> 的基础上，结合生产上的日志尝试再次理解 broker busy 以及探讨解决方案。</p>
<p>首先，broker busy 相关的日志关键字如下：</p>
<ul>
<li>[REJECTREQUEST]system busy</li>
<li>too many requests and system thread pool busy</li>
<li>[PC_SYNCHRONIZED]broker busy</li>
<li>[PCBUSY_CLEAN_QUEUE]broker busy</li>
<li>[TIMEOUT_CLEAN_QUEUE]broker busy</li>
</ul>
<p>上述前面4个关键字在上篇文章中已详细介绍，本文先对出现上述错误进行一个总结，具体的分析过程请查阅上篇文章。</p>
<p>本文先给出一张流程图，展示上述5种 broker busy 分别会在消息发送的哪个阶段抛出，以便大家能够清晰的了解其发生的原因。<br><img src="https://img-blog.csdnimg.cn/20191024084015845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>针对前4种 broker busy 出现的问题已经在上篇文章中详细介绍，主要是由于 Broker 在追加消息时持有的锁时间超过了设置的1s，Broker 为了自我保护，会抛出错误，客户端会选择其他 broker 服务器进行重试。如果对不是金融级服务，建议将 transientStorePoolEnable = true，可以有效避免前面 4 种 broker ，因为开启这个参数，消息首先会存储在堆外内存中，并且 RocketMQ 提供了内存锁定的功能，其追加性能能得到一定的保障，这样可以做到在内存使用层面的读写分离，即写消息是直接写入堆外内存，消费消息直接从 pagecache中读，然后定时将堆外内存的消息写入 pagecache。但这种方案随之带来的就是可能存在消息丢失，如果对消息非常严谨的话，建议扩容集群，或迁移topic到新的集群。</strong></p>
<a id="more"></a>

<p>同时在做 Broker 服务器巡检的时候，可以通过去通过如下命令去查看 broker 一次消息追加是否会超过 500 ms。<br><img src="https://img-blog.csdnimg.cn/20191024084128742.png" alt="在这里插入图片描述"><br>在这个图中我们看到在设置了 transientStorePoolEnable 为 true 的情况下，虽然一天只有一条超过500ms的消息，但也值得警惕了，由于对系统内核参数掌握程度不够，这种情况，估计只能走集群扩容的路子了。但如果一天消息量巨大而且出现频率不高的情况，由于有重试机制，倒不会带来太大的问题。如果出现太多的错误，<strong>建议集群扩容</strong>。</p>
<p>本文接下来想重点探讨一下 [TIMEOUT_CLEAN_QUEUE]broker busy 这种情况。</p>
<p>BrokerFastFailure#cleanExpiredRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">final</span> Runnable runnable = <span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().peek();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == runnable) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> RequestTask rt = castRunnable(runnable);</span><br><span class="line">            <span class="keyword">if</span> (rt == <span class="keyword">null</span> || rt.isStopRun()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> behind = System.currentTimeMillis() - rt.getCreateTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (behind &gt;= <span class="keyword">this</span>.brokerController.getBrokerConfig().getWaitTimeMillsInSendQueue()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().remove(runnable)) &#123;</span><br><span class="line">                    rt.setStopRun(<span class="keyword">true</span>);</span><br><span class="line">                    rt.returnResponse(RemotingSysResponseCode.SYSTEM_BUSY, String.format(<span class="string">&quot;[TIMEOUT_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: %sms, size of queue: %d&quot;</span>, behind, <span class="keyword">this</span>.brokerController.getSendThreadPoolQueue().size()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，抛出这种错误，在 broker 还没有发送“严重”的 pagecache 繁忙，即消息追加到内存中的最大时延没有超过 1s，通常追加是很快的，绝大部分都会低于1ms，但可能会由于出现一个超过200ms的追加时间，导致排队中的任务等待时间超过了200ms，则此时会触发broker 端的快速失败，让请求快速失败，便于客户端快速重试。但是这种请求并不是实时的，而是每隔10s 检查一遍。</p>
<p>值得注意的是，一旦出现 TIMEOUT_CLEAN_QUEUE，可能在一个点会有多个这样的错误信息，具体多少与当前积压在待发送队列中的个数有关。</p>
<p><strong>关于 [TIMEOUT_CLEAN_QUEUE]broker busy 我们也可以适当调整 waitTimeMillsInSendQueue，默认值为200ms，可以适当调整到400ms。</strong></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>broker busy</tag>
        <tag>TIMEOUT_CLEAN_QUEUE</tag>
        <tag>PCBUSY_CLEAN_QUEUE</tag>
      </tags>
  </entry>
  <entry>
    <title>初始 Kafka Consumer 消费者</title>
    <url>/posts/d9d4c345.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、KafkaConsumer-概述"><a href="#1、KafkaConsumer-概述" class="headerlink" title="1、KafkaConsumer 概述"></a>1、KafkaConsumer 概述</h2><p>根据 KafkaConsumer 类上的注释上来看 KafkaConsumer 具有如下特征：</p>
<ul>
<li><p>在 Kafka 中 KafkaConsumer 是线程不安全的。</p>
</li>
<li><p>2.2.1 版本的KafkaConsumer 兼容 kafka 0.10.0 和 0.11.0 等低版本。</p>
</li>
<li><p>消息偏移量与消费偏移量(消息消费进度)<br>Kafka 为分区中的每一条消息维护一个偏移量，即消息偏移量。这个偏移量充当该分区内记录的唯一标识符。消费偏移量(消息消费进度)存储的是消费组当前的处理进度。消息消费进度的提交在 kafka 中可以定时自动提交也可以手动提交。手动提交可以调用 ommitSync() 或 commitAsync 方法。</p>
</li>
<li><p>消费组 与 订阅关系<br>多个消费这可以同属于一个消费组，消费组内的所有消费者共同消费主题下的所有消息。一个消费组可以订阅多个主题。</p>
</li>
<li><p>队列负载机制<br>既然同一个消费组内的消费者共同承担主题下所有队列的消费，那他们如何进行分工呢？默认情况下采取平均分配，例如一个消费组有两个消费者c1、c2，一个 topic 的分区数为6，那 c1 会负责3个分区的消费，同样 c2 会负责另外3个分区的分配。</p>
<p>那如果其中一个消费者宕机或新增一个消费者，那队列能动态调整吗？</p>
<p>答案是会重新再次平衡，例如如果新增一个消费者 c3，则c1,c2,c3都会负责2个分区的消息消费，分区重平衡会在后续文章中重点介绍。消费者也可以通过 assign 方法手动指定分区，此时会禁用默认的自动分配机制。</p>
</li>
<li><p>消费者故障检测机制<br>当通过 subscribe 方法订阅某些主题时，此时该消费者还未真正加入到订阅组，只有当 consumeer#poll 方法被调用后，并且会向 broker 定时发送心跳包，如果 broker 在 session.timeout.ms 时间内未收到心跳包，则 broker 会任务该消费者已宕机，会将其剔除，并触发消费端的分区重平衡。</p>
<p>消费者也有可能遇到“活体锁”的情况，即它继续发送心跳，但没有任何进展。在这种情况下，为了防止消费者无限期地占用它的分区，可以使用max.poll.interval.ms 设置提供了一个活性检测机制。基本上，如果您调用轮询的频率低于配置的最大间隔，那么客户机将主动离开组，以便另一个消费者可以接管它的分区。当这种情况发生时,您可能会看到一个偏移提交失败(由调用{@link #commitSync()}抛出的{@link CommitFailedException}表示)。</p>
</li>
<li><p>kafka 对 poll loop 行为的控制参数<br>Kafka 提供了如下两个参数来控制 poll 的行为：</p>
<ul>
<li> max.poll.interval.ms<br>允许 两次调用 poll 方法的最大间隔，即设置每一批任务最大的处理时间。</li>
<li> max.poll.records<br>每一次 poll 最大拉取的消息条数。</li>
</ul>
<p>对于消息处理时间不可预测的情况下上述两个参数可能不够用，那将如何是好呢？</p>
<p>通常的建议将消息拉取与消息消费分开，一个线程负责 poll 消息，处理这些消息使用另外的线程，这里就需要手动提交消费进度。为了控制消息拉起的过快，您可能会需要用到 Consumer#pause(Collection) 方法，暂时停止向该分区拉起消息。RocketMQ 的推模式就是采用了这种策略。如果大家有兴趣的话，可以从笔者所著的《RocketMQ技术内幕》一书中详细了解。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="2、KafkaConsume-使用示例"><a href="#2、KafkaConsume-使用示例" class="headerlink" title="2、KafkaConsume 使用示例"></a>2、KafkaConsume 使用示例</h2><h3 id="2-1-自动提交消费进度"><a href="#2-1-自动提交消费进度" class="headerlink" title="2.1 自动提交消费进度"></a>2.1 自动提交消费进度</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092,localhost:9082,localhost:9072&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;C_ODS_ORDERCONSUME_01&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;auto.commit.interval.ms&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    props.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">    KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">    consumer.subscribe(Arrays.asList(<span class="string">&quot;TOPIC_ORDER&quot;</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        ConsumerRecords&lt;String, String&gt;  records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息消费中&quot;</span>);</span><br><span class="line">            System.out.printf(<span class="string">&quot;offset = %d, key = %s, value = %s%n&quot;</span>, record.offset(), record.key(), record.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-手动提交消费进度"><a href="#2-2-手动提交消费进度" class="headerlink" title="2.2 手动提交消费进度"></a>2.2 手动提交消费进度</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;group.id&quot;</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;enable.auto.commit&quot;</span>, <span class="string">&quot;false&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;key.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        props.setProperty(<span class="string">&quot;value.deserializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;</span>);</span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> minBatchSize = <span class="number">200</span>;</span><br><span class="line">        List&lt;ConsumerRecord&lt;String, String&gt;&gt; buffer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">100</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                buffer.add(record);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buffer.size() &gt;= minBatchSize) &#123;</span><br><span class="line">                <span class="comment">// insertIntoDb(buffer);</span></span><br><span class="line">                <span class="comment">// 省略处理逻辑</span></span><br><span class="line">                consumer.commitSync();</span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3、认识-Consumer-接口"><a href="#3、认识-Consumer-接口" class="headerlink" title="3、认识 Consumer 接口"></a>3、认识 Consumer 接口</h2><p>要认识 Kafka 的消费者，个人认为最好的办法就是从它的类图着手，下面给出 Consumer 接口的类图。<br><img src="https://img-blog.csdnimg.cn/20191124101227865.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来对起重点方法进行一个初步的介绍，从下篇文章开始将对其进行详细设计。</p>
<ul>
<li>Set&lt; TopicPartition&gt; assignment()<br>获取该消费者的队列分配列表。</li>
<li>Set&lt; String&gt; subscription()<br>获取该消费者的订阅信息。</li>
<li>void subscribe(Collection&lt; String&gt; topics)<br>订阅主题。</li>
<li>void subscribe(Collection&lt; String&gt; topics, ConsumerRebalanceListener callback)<br>订阅主题，并指定队列重平衡的监听器。</li>
<li>void assign(Collection&lt; TopicPartition&gt; partitions)<br>取代 subscription，手动指定消费哪些队列。</li>
<li>void unsubscribe()<br>取消订阅关系。</li>
<li>ConsumerRecords&lt;K, V&gt; poll(Duration timeout)<br>拉取消息，是 KafkaConsumer 的核心方法，将在下文详细介绍。</li>
<li>void commitSync()<br>同步提交消费进度，为本批次的消费提交，将在后续文章中详细介绍。</li>
<li>void commitSync(Duration timeout)<br>同步提交消费进度，可设置超时时间。</li>
<li>void commitSync(Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)<br>显示同步提交消费进度， offsets 指明需要提交消费进度的信息。</li>
<li>void commitSync(final Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, final Duration timeout)<br>显示同步提交消费进度，带超时间。</li>
<li>void seek(TopicPartition partition, long offset)<br>重置 consumer#poll 方法下一次拉消息的偏移量。</li>
<li>void seek(TopicPartition partition, OffsetAndMetadata offsetAndMetadata)<br>seek 方法重载方法。</li>
<li>void seekToBeginning(Collection&lt; TopicPartition&gt; partitions)<br>将 poll 方法下一次的拉取偏移量设置为队列的初始偏移量。</li>
<li>void seekToEnd(Collection&lt; TopicPartition&gt; partitions)<br>将 poll 方法下一次的拉取偏移量设置为队列的最大偏移量。</li>
<li>long position(TopicPartition partition)<br>获取将被拉取的偏移量。</li>
<li>long position(TopicPartition partition, final Duration timeout)<br>同上。</li>
<li>OffsetAndMetadata committed(TopicPartition partition)<br>获取指定分区已提交的偏移量。</li>
<li>OffsetAndMetadata committed(TopicPartition partition, final Duration timeout)<br>同上。</li>
<li>Map&lt;MetricName, ? extends Metric&gt; metrics()<br>统计指标。</li>
<li>List&lt; PartitionInfo&gt; partitionsFor(String topic)<br>获取主题的路由信息。</li>
<li>List&lt; PartitionInfo&gt; partitionsFor(String topic, Duration timeout)<br>同上。</li>
<li>Map&lt;String, List&lt; PartitionInfo&gt;&gt; listTopics()<br>获取所有 topic 的路由信息。</li>
<li>Map&lt;String, List&lt; PartitionInfo&gt;&gt; listTopics(Duration timeout)<br>同上。</li>
<li>Set&lt; TopicPartition&gt; paused()<br>获取已挂起的分区信息。</li>
<li>void pause(Collection&lt; TopicPartition&gt; partitions)<br>挂起分区，下一次 poll 方法将不会返回这些分区的消息。</li>
<li>void resume(Collection&lt; TopicPartition&gt; partitions)<br>恢复挂起的分区。</li>
<li>Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsetsForTimes(Map&lt;TopicPartition, Long&gt; timestampsToSearch)<br>根据时间戳查找最近的一条消息的偏移量。</li>
<li>Map&lt;TopicPartition, OffsetAndTimestamp&gt; offsetsForTimes(Map&lt;TopicPartition, Long&gt; timestampsToSearch, Duration timeout)<br>同上。</li>
<li>Map&lt;TopicPartition, Long&gt; beginningOffsets(Collection&lt; TopicPartition&gt; partitions)<br>查询指定分区当前最小的偏移量。</li>
<li>Map&lt;TopicPartition, Long&gt; beginningOffsets(Collection&lt; TopicPartition&gt; partitions, Duration timeout)<br>同上。</li>
<li>Map&lt;TopicPartition, Long&gt; endOffsets(Collection&lt; TopicPartition&gt; partitions)<br>查询指定分区当前最大的偏移量。</li>
<li>Map&lt;TopicPartition, Long&gt; endOffsets(Collection&lt; TopicPartition&gt; partitions, Duration timeout)<br>同上。</li>
<li>void close()<br>关闭消费者。</li>
<li>void close(Duration timeout)<br>关闭消费者。</li>
<li>void wakeup()<br>唤醒消费者。</li>
</ul>
<h2 id="4、初始-KafkaConsumer"><a href="#4、初始-KafkaConsumer" class="headerlink" title="4、初始 KafkaConsumer"></a>4、初始 KafkaConsumer</h2><p><img src="https://img-blog.csdnimg.cn/20191124122831676.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来笔者根据其构造函数，对一一介绍其核心属性的含义，为接下来讲解其核心方法打下基础。</p>
<ul>
<li>String groupId<br>消费组ID。同一个消费组内的多个消费者共同消费一个主题下的消息。</li>
<li>String clientId<br>发出请求时传递给服务器的id字符串。设置该值的目的是方便在服务器端请求日志中包含逻辑应用程序名称，从而能够跟踪ip/端口之外的请求源。该值可以设置为应用名称。</li>
<li>ConsumerCoordinator coordinator<br>消费协调器，后续会详细介绍。</li>
<li>Deserializer&lt; K&gt; keyDeserializer<br>key 序列化器。</li>
<li>Deserializer&lt; V&gt; valueDeserializer<br>值序列化器。</li>
<li>ConsumerNetworkClient client<br>网络通讯客户端。</li>
<li>SubscriptionState subscriptions<br>用于管理订阅状态的类，用于跟踪 topics, partitions, offsets 等信息。后续会详细介绍。</li>
<li>ConsumerMetadata metadata<br>消费者元数据信息，包含路由信息。</li>
<li>long retryBackoffMs<br>如果向 broker 发送请求失败后，发起重试之前需要等待的间隔时间，通过属性 retry.backoff.ms　指定。</li>
<li>long requestTimeoutMs<br>一次请求的超时时间。</li>
<li>int defaultApiTimeoutMs<br>为所有可能阻塞的API设置一个默认的超时时间。</li>
<li>List&lt; PartitionAssignor&gt; assignors<br>分区分配算法（分区负载算法）。</li>
</ul>
<p>Kafka Consumer 消费者就介绍到这里了，从下篇文章开始将开始详细介绍 Kafka 关于消息消费的方方面面。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>kafka</tag>
        <tag>KafkaConsumer</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Kafka Producer 生产者</title>
    <url>/posts/b579d244.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、KafkaProducer-概述"><a href="#1、KafkaProducer-概述" class="headerlink" title="1、KafkaProducer 概述"></a>1、KafkaProducer 概述</h2><p>根据 KafkaProducer 类上的注释上来看 KafkaProducer 具有如下特征：</p>
<ul>
<li>KafkaProducer 是线程安全的，可以被多个线程交叉使用。</li>
<li>KafkaProducer 内部包含一个缓存池，存放待发送消息，即 ProducerRecord 队列，与此同时会开启一个IO线程将 ProducerRecord 对象发送到 Kafka 集群。</li>
<li>KafkaProducer 的消息发送 API send 方法是异步，只负责将待发送消息 ProducerRecord 发送到缓存区中，立即返回，并返回一个结果凭证 Future。</li>
<li>acks<br>KafkaProducer 提供了一个核心参数 acks 用来定义消息“已提交”的条件(标准)，就是 Broker 端向客户端承偌已提交的条件，可选值如下：<ul>
<li>0<br>表示生产者不关系该条消息在 broker 端的处理结果，只要调用 KafkaProducer 的 send 方法返回后即认为成功，显然这种方式是最不安全的，因为 Broker 端可能压根都没有收到该条消息或存储失败。</li>
<li>all 或 -1<br>表示消息不仅需要 Leader 节点已存储该消息，并且要求其副本（准确的来说是 ISR 中的节点）全部存储才认为已提交，才向客户端返回提交成功。这是最严格的持久化保障，当然性能也最低。</li>
<li>1<br>表示消息只需要写入 Leader 节点后就可以向客户端返回提交成功。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>retries<br>kafka 在生产端提供的另外一个核心属性，用来控制消息在发送失败后的重试次数，设置为 0 表示不重试，重试就有可能造成消息在发送端的重复。</li>
<li>batch.size<br>  kafka 消息发送者为每一个分区维护一个未发送消息积压缓存区，其内存大小由batch.size指定，默认为 16K。<br>  但如果缓存区中不足100条，但发送线程此时空闲，是需要等到缓存区中积满100条才能发送还是可以立即发送呢？默认是立即发送，即 batch.size 的作用其实是客户端一次发送到broker的最大消息数量。</li>
<li>linger.ms<br>  ​    为了提高 kafka 消息发送的高吞吐量，即控制在缓存区中未积满 batch.size  时来控制 消息发送线程的行为，是立即发送还是等待一定时间，如果linger.ms 设置为 0表示立即发送，如果设置为大于0，则消息发送线程会等待这个值后才会向broker发送。该参数者会增加响应时间，但有利于增加吞吐量。有点类似于 TCP 领域的 Nagle 算法。</li>
<li>buffer.memory<br>用于控制消息发送者缓存的总内存大小，如果超过该值，往缓存区中添加消息会被阻塞，具体会在下文的消息发送流程中详细介绍，阻塞的最大时间可通过参数 max.block.ms 设置，阻塞超过该值会抛出超时异常。</li>
<li>key.serializer<br>指定 key 的序列化处理器。</li>
<li>value.serializer<br>指定 消息体的序列化处理器。</li>
<li>enable.idempotence<br>从 kafka0.11版本开始，支持消息传递幂等，可以做到消息只会被传递一次，通过 enable.idempotence 为 true 来开启。如果该值设置为 true，其 retries 将设置为 Integer.MAX_VALUE，acks 将被设置为 all。为了确保消息发送幂等性，必须避免应用程序端的任何重试，并且如果消息发送API如果返回错误，应用端应该记录最后成功发送的消息，避免消息的重复发送。</li>
</ul>
<p>从Kafka 0.11开始，kafka 也支持事务消息。</p>
<h2 id="2、KafkaProducer-类图"><a href="#2、KafkaProducer-类图" class="headerlink" title="2、KafkaProducer 类图"></a>2、KafkaProducer 类图</h2><p><img src="https://img-blog.csdnimg.cn/20191103130908591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在 Kafka  中，生产者通过接口 Producer 定义，通过该接口的方法，我们基本可以得知 KafkaProducer 将具备如下基本能力：</p>
<ul>
<li>void initTransactions()<br>初始化事务，如果需要使用事务方法，该方法必须首先被调用。</li>
<li>void beginTransaction()<br>开启事务。</li>
<li>void sendOffsetsToTransaction(Map&lt; TopicPartition, OffsetAndMetadata&gt; offsets,String consumerGroupId)<br>向消费组提交当前事务中的消息偏移量，将在介绍 Kafka 事务相关文章中详细介绍。</li>
<li>void commitTransaction()<br>提交事务。</li>
<li>void abortTransaction()<br>回滚事务。</li>
<li>Future&lt; RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record)<br>消息发送，该方法默认为异步发送，如果要实现同步发送的效果，对返回结果调用  get 方法即可，该方法将在下篇文章中详细介绍。</li>
<li>Future&lt; RecordMetadata&gt; send(ProducerRecord&lt;K, V&gt; record, Callback callback)<br> ​    消息发送，支持回调。</li>
<li>void flush()<br>忽略 linger.ms 的值，直接唤醒发送线程，将缓冲区中的消息全部发送到 broker。</li>
<li>List&lt; PartitionInfo&gt; partitionsFor(String topic)<br>获取 topic 的路由信息（分区信息）。</li>
<li>Map&lt; MetricName, ? extends Metric&gt; metrics()<br>获取由生产者收集的统计信息。</li>
<li>void close()<br>关闭发送者。</li>
<li>void close(Duration timeout)<br>定时关闭消息发送者。</li>
</ul>
<p>上面的方法我们会根据需要在后续文章中进行详细的介绍。接下来我们看一下 KafkaProducer 的核心属性的含义。</p>
<ul>
<li>String clientId<br>客户端ID。在创建 KafkaProducer 时可通过 client.id 定义 clientId，如果未指定，则默认 producer- seq，seq 在进程内递增，强烈建议客户端显示指定 clientId。</li>
<li>Metrics metrics<br>度量的相关存储容器，例如消息体大小、发送耗时等与监控相关的指标。</li>
<li>Partitioner partitioner<br>分区负载均衡算法，通过参数 partitioner.class 指定。</li>
<li>int maxRequestSize<br>调用 send 方法发送的最大请求大小，包括 key、消息体序列化后的消息总大小不能超过该值。通过参数 max.request.size 来设置。</li>
<li>long totalMemorySize<br>生产者缓存所占内存的总大小，通过参数 buffer.memory 设置。</li>
<li>Metadata metadata<br>元数据信息，例如 topic 的路由信息，由 KafkaProducer 自动更新。</li>
<li>RecordAccumulator accumulator<br>消息记录累积器，将在消息发送部分详细介绍。</li>
<li>Sender sender<br>用于封装消息发送的逻辑，即向 broker 发送消息的处理逻辑。</li>
<li>Thread ioThread<br>用于消息发送的后台线程，一个独立的线程，内部使用 Sender 来向 broker 发送消息。</li>
<li>CompressionType compressionType<br>压缩类型，默认不启用压缩，可通过参数 compression.type 配置。可选值：none、gzip、snappy、lz4、zstd。</li>
<li>Sensor errors<br>错误信息收集器，当成一个 metrics，用来做监控的。</li>
<li>Time time<br>用于获取系统时间或线程睡眠等。</li>
<li>Serializer&lt; K&gt; keySerializer<br>用于对消息的 key 进行序列化。</li>
<li>Serializer&lt; V&gt; valueSerializer<br>对消息体进行序列化。</li>
<li>ProducerConfig producerConfig<br>生产者的配置信息。</li>
<li>long maxBlockTimeMs<br>最大阻塞时间，当生产者使用的缓存已经达到规定值后，此时消息发送会阻塞，通过参数 max.block.ms 来设置最多等待多久。</li>
<li>ProducerInterceptors&lt;K, V&gt; interceptors<br>生产者端的拦截器，在消息发送之前进行一些定制化处理。</li>
<li>ApiVersions apiVersions<br>维护 api 版本的相关元信息，该类只能在 kafka 内部使用。</li>
<li>TransactionManager transactionManager<br>kafka 消息事务管理器。</li>
<li>TransactionalRequestResult initTransactionsResult<br>kafka 生产者事务上下文环境初始结果。</li>
</ul>
<p>经过上面的梳理，详细读者朋友对 KafkaProducer 消息生产者有了一个大概的认识，下一篇会重点介绍消息发送流程。接下来我们以一个简单的示例结束本文的学习。</p>
<h2 id="3、KafkaProducer-简单示例"><a href="#3、KafkaProducer-简单示例" class="headerlink" title="3、KafkaProducer 简单示例"></a>3、KafkaProducer 简单示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.demo.kafka;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.KafkaProducer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.Producer;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.ProducerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.producer.RecordMetadata;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaProducerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">&quot;bootstrap.servers&quot;</span>, <span class="string">&quot;localhost:9092,localhost:9082,localhost:9072,&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;acks&quot;</span>, <span class="string">&quot;all&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;key.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        props.put(<span class="string">&quot;value.serializer&quot;</span>, <span class="string">&quot;org.apache.kafka.common.serialization.StringSerializer&quot;</span>);</span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                Future&lt;RecordMetadata&gt;  future = producer.send(<span class="keyword">new</span> ProducerRecord&lt;String, String&gt;(<span class="string">&quot;TOPIC_ORDER&quot;</span>, Integer.toString(i), Integer.toString(i)));</span><br><span class="line">                RecordMetadata recordMetadata = future.get();</span><br><span class="line">                System.out.printf(<span class="string">&quot;offset:&quot;</span> + recordMetadata.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            producer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本文就介绍到这里，其主要的目的是了解Kafka 的 Producer，引出后续需要学习的内容，下一篇将重点讲述 Kafka 消息的发送流程，敬请关注。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>kafka</tag>
        <tag>KafkaProducer</tag>
      </tags>
  </entry>
  <entry>
    <title>图文并茂剖析Netty编解码以及背后的设计理念</title>
    <url>/posts/cd43c662.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文主要介绍网络通信中与通信息息相关的重要部分：通信协议的底层实现原理：<strong>编码与解码</strong>。</p>
<blockquote>
<p>温馨提示：源码分析或许比较枯燥，在浏览的过程中建议重点关注<strong>黑色</strong>字体与<strong>流程图</strong>，是<strong>根据源码进行的提炼</strong>，突出源码背后的<strong>设计理念</strong>。</p>
</blockquote>
<a id="more"></a>

<h2 id="1、Netty4编码解码概述"><a href="#1、Netty4编码解码概述" class="headerlink" title="1、Netty4编码解码概述"></a>1、Netty4编码解码概述</h2><p>Netty中定义的编码解码器核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20201230195200318.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Decoder(解码器) 继承自 Inbound 事件处理器，而Encoder(编码器)继承自Outbound事件处理器。</strong></p>
<p>其实不难理解，以服务端接收请求、返回响应结果的视角来看这个问题：</p>
<p>当服务端通过网络IO接收到字节序列时，从底层网络套接字中将字节流读取到接受缓存区(ByteBuf)，服务端的职责首先需要从<strong>二进制流中解码</strong>出一个<strong>完整的请求</strong>，然后“读懂请求”的含义进行对应的业务逻辑处理，处理完毕后首先需要将响应结果(通常为JSON字符串)<strong>编码成二级制流</strong>，通过网络进行传递，客户端收到二进制流后同样进行解码。</p>
<p><strong>解码</strong>：针对的是输入，故继承 InBound 入端事件。<br><strong>编码</strong>：针对的是输出，故继承 OutBound 出端事件。</p>
<p>了解了上述基本点后，接下来对上述核心类一一做个介绍：</p>
<ul>
<li>ByteToMessageDecoder<br>解码器，将字节流解码成消息(message)。</li>
<li>MessageToByteEncoder<br>编码器，将消息(message)编码成字节流。</li>
<li>MessageToMessageEncoder<br>编码器,将消息编码成”另一种消息“，更通用，”另一种消息“由泛型指定。</li>
<li>MessageToMessageDecoder<br>解码器，将消息解码成“另一种消息”，更通用，“另一种消息”由泛型指定。</li>
</ul>
<p>下面介绍Netty4<strong>自带的协议解码器</strong>，是<strong>ByteToMessageDecoder</strong>的子类。</p>
<ul>
<li>LineBasedFrameDecoder<br>基于换行符的分隔符，使用\n或\r\n分隔符来标志一个字节序列的结束。</li>
<li>DelimiterBasedFrameDecoder<br>基于自定义的分隔符，使用定义的分隔符来标志一个字节序列的结束。</li>
<li>FixedLengthFrameDecoder<br>固定长度的编码器。在实际使用时，如果单条消息不足定义的长度，通常需要人为填充。</li>
<li>LengthFieldBasedFrameDecoder<br>基于长度字段的协议，通过指定一个长度字段，该字段的存储字节固定，例如3个字节或4个字节等，然后该字段中存储消息的长度，这样在解码时可以非常方便的判断一条消息的长度，这是一个非常经典的client-server协议格式，下面会对其进行详细解读。</li>
</ul>
<h2 id="2、源码分析解码器实现原理"><a href="#2、源码分析解码器实现原理" class="headerlink" title="2、源码分析解码器实现原理"></a>2、源码分析解码器实现原理</h2><p>ByteToMessageDecoder 是 Netty 解码器实现的基类，典型的模板设计模式。</p>
<p><strong>解码器引入的目的</strong>是为了<strong>解决网络编程中的“粘包问题”</strong>，网络传输基于字节流，客户端多个线程通过一条长连接向服务端发送多个请求，服务端在处理命令之前如何正确拆解出一条完整的请求信息呢？</p>
<p>例如客户端A的三个线程t1、t2、t3 使用同一条连接(类比Dubbo客户端)发送了3个请求，内容分别为 A, BCD, E 。</p>
<p>服务端基于NIO来处理，当请求陆续到达服务端的接受缓存区，NIO 读事件触发，可能第一次网络读，从网络中读取的内容为AB字节序列(包含第一个请求包全部，第二个请求包部分)，紧接着再读取CDE序列，如果服务端每接受到一部分数据就当成一个完整的请求去处理的话，明显与客户端原始请求存在差别。</p>
<p>故为了解决服务端、客户端能对同一个字节流具有相同的理解语义，所谓的<strong>通信协议</strong>因此诞生了，通俗一点就是客户端、服务端如果界定一个完整请求包。</p>
<p>最常见的几种协议：</p>
<ul>
<li>每一行一个数据包，即在每一个请求包最后以 /r/n 结尾</li>
<li>固定长度，请求内容不足使用特殊字符填充</li>
<li>协议头 + 协议体 ，其中协议头定长，并且内部会含有一个表示包长度的字段。</li>
</ul>
<blockquote>
<p>上述具体协议，将在下篇文章中如何定制私有化协议(编码解码)</p>
</blockquote>
<p>接下来将通过阅读源码的方式探究Netty中解码的实现原理，<strong>并总结其核心设计关键点</strong>。</p>
<p>ByteToMessageDecoder Netty 网络解码器的模板父类， Netty 的扩展是基于事件链机制，即解码器实现的是 InBound 事件处理器。</p>
<p><strong>在阅读解码器实现原理的同时，大家可以关注一个解码器实现的事件方法，再次感悟一下不同场景应该选用实现哪个事件方法。</strong></p>
<h4 id="2-1-channelRead"><a href="#2-1-channelRead" class="headerlink" title="2.1 channelRead"></a>2.1 channelRead</h4><p>通道读时间，Netty底层通过Nio Socket 读取到的字节序列后通过传播 channelRead 事件，让上层的事件处理器对接受到的数据进行处理，解码器的职责就是从二进制流中解码出一条条消息。</p>
<p>其处理的代码如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201230214650227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上面的实现要点如下：<br>代码@1：对待处理数据类型进行判断，如果是ByteBuf，则尝试从流中解码请求，如果不是合适的类型，直接调用ctx.fireChannelRead 方法继续向事件链进行传播。</p>
<p>代码@2：构造CodecOutputList out对象，用来存储经过该解码器解码出来的的消息，其内部数据结构为List。</p>
<p>代码@3：如果该解码器中的接收缓冲区(累积缓存区)为空，表示第一次接码消息，设置 first 为 true，并直接将接收到的数据设置为接收缓存区。</p>
<p>代码@4：如果当前累积缓存区不为空，需要计算累积缓存区是否能容纳当前接收到的数据，如果无法存储，则需要对累积缓存区进行扩容，<strong>扩容的套路就是先申请一个容量大的缓存区，然后将原先的累积缓存区中的数据复制到新的缓存区，然后释放旧的缓存区。</strong></p>
<p>代码@5：调用callDecode方法对累积缓存区中的数据，进行尝试解码，将解码后的结果存放在out对象中(稍后会对该方法详细进行讲解)。</p>
<p>在调用完用户自定义的协议解码后，<strong>开始进行资源的回收逻辑</strong>。</p>
<p>代码@6：如果累积缓存区不为空，并且读写缓存区中所有的数据已全部处理，重置numReads与累积缓存区cumulation。</p>
<p>代码@7：如果 numReads 超过 discardAfterReads，需要对累积缓存去进行压缩</p>
<p><strong>设计目的：主要是避免内存泄漏，节省内存空间。 numReads 表示的含义是对累积缓存区解码的次数，如果多次解码都未全部将累积缓存区全部处理完成，当新的数据到达累积缓存区，极大可能需要进行扩容，从而造成累积缓存区的膨胀，如果不丢弃已处理的数据，及时释放内存空间，避免扩容，否则会导致累积缓存区无限扩容，内存资源得到极大的消耗。</strong></p>
<p>代码@8：将解码后的请求继续向事件链进行传播，例如业务处理器，业务处理器可以基于请求对象进行编码的根本原因就是首先进入的解码器，解码出一个一个请求后，业务处理器根据请求进行对应的业务逻辑处理。</p>
<p>代码@9：处理完后，对out结果list对象进行回收，这里使用了Netty的对象缓存机制（对象池）。</p>
<p>接下来探究一下 callDecode 的核心实现逻辑：<br><img src="https://img-blog.csdnimg.cn/20201230225925317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>该方法的实现要点如下：<br>代码@1：首先对参数进行一个详细介绍：</p>
<ul>
<li>ChannelHandlerContext ctx：事件处理器链当前处理器的上下文环境。</li>
<li>ByteBuf in：累积缓存区。</li>
<li>List&lt; Object &gt; out：解码后的结果列表。</li>
</ul>
<p>代码@2： while (in.isReadable()) ，NIO读取经典写法，判断读缓存区是否还有可读字节，从@3到@8都是对该缓存区的处理。</p>
<p>代码@3：由于这里处于一个循环中，一次循环后如果out解码结果列表不为空，<strong>会立即将解码后的请求</strong>通过调用 fireChannelRead 向后面的事件处理其传播。</p>
<p>代码@4：oldInputLength，当前累积缓存区可读大小。</p>
<p>代码@5：decode 该方法是一个抽象方法，尝试从累积缓存区中解码出完整的请求，由具体的<strong>协议实现类</strong>去实现。</p>
<p>代码@6,7：如果累积缓存区中不包含一条完整的请求，本次解码结束，等待更多数据到达接受缓存区(<strong>下一次读事件触发，继续通过网络读API从Socket中读取字节流</strong>)。</p>
<p>代码@8：如果singleDecode=true，表示不支持多次解码，故跳出。</p>
<p>为了加深理解上述流程，Netty 解码器的核心实现流程如下：<br><img src="https://img-blog.csdnimg.cn/20201230231134883.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="2-3-channelReadComplete-事件"><a href="#2-3-channelReadComplete-事件" class="headerlink" title="2.3 channelReadComplete 事件"></a>2.3 channelReadComplete 事件</h4><p>通道读完成事件，这是每一次读就绪事件处理完成后，会传播该事件。<br><img src="https://img-blog.csdnimg.cn/20201230231746117.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在每一次读处理完成后，Netty为了保证累积缓存区不至于浪费空间，进行一次压缩，其设计理念在上文已提到。</p>
<h4 id="2-4-channelInactive事件"><a href="#2-4-channelInactive事件" class="headerlink" title="2.4 channelInactive事件"></a>2.4 channelInactive事件</h4><p>通道在非激活状态时会触发该事件。<br><img src="https://img-blog.csdnimg.cn/20201230232436368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：尝试通过调用 channelInputClosed方法最后尝试进行解码。<br>代码@2：如果累积缓存区不为空，释放累积缓存区。<br>代码@3：传播一次通道读事件。<br>代码@4：如果代码@1在通道非激活时还解码到新数据了，则传播一次通道完成度事件。<br>代码@5：根据callChannelInactive参数，决定是否传播通道非激活事件。<br><img src="https://img-blog.csdnimg.cn/20201230232809664.png#pic_center" alt="在这里插入图片描述"><br>代码@1：如果累积缓冲区不为空，则调用callDecode方法，对累积缓存区进行解码，因为累积缓存区中的数据的读取已经和底层网络通道无关了，通道关闭后，该部分数据还是要尽量处理。</p>
<p>代码@2：再解码一次，由于这个方法，是直接调用抽象方法decode，最终解码的结果放在out中，解码后，如果有消息，最终还会触发一次通道读事件和通道读完成事件。</p>
<h4 id="2-5-handlerRemoved-事件"><a href="#2-5-handlerRemoved-事件" class="headerlink" title="2.5 handlerRemoved 事件"></a>2.5 handlerRemoved 事件</h4><p>handlerRemoved事件，该事件的触发有两种情况：</p>
<ul>
<li>在调用handlerAdd事件失败后，接着调用handlerRemoved事件。</li>
<li>在通道关闭后，DefaultChannelPipeline 的 HeadContext 的 channelUnregistered 中传播完通道事件取消注册事件后，会销毁注册在该通道上的事件注册器，此时也会触发handlerRemoved事件。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201230233351223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从实现来看，也非常简单，就是将累积缓存区中未处理的数据传播到其下游的事件处理器，传播之后再从事件链中移除，体现了其“高度负责”的一面。</p>
<p><strong>对于解码的核心设计理念再做一个总结：</strong></p>
<ul>
<li>引入累积缓存区，存储从网络底层接受的数据。</li>
<li>对累积缓存区中的数据尝试解码，如果能解码出一条请求，就解码并将数据传入到后续处理器。</li>
<li>如果累积缓存区中不包含一条完整的消息，则结束本次解码，等待后续更多的数据到达缓存区。</li>
</ul>
<p><strong>那问题又来了，如何判别累积缓存区中是否包含一条完整的消息呢？如何进行协议的设计呢？</strong></p>
<p><strong>此部分内容将在下文：如何使用Netty设计一款通信协议。</strong></p>
<h2 id="3、源码分析编码器实现原理"><a href="#3、源码分析编码器实现原理" class="headerlink" title="3、源码分析编码器实现原理"></a>3、源码分析编码器实现原理</h2><p>Netty将消息(请求对象、响应结果) 按特定格式转换为二进制流。<br>MessageToByteEncoder的核心类图如下：<br><img src="https://img-blog.csdnimg.cn/20201230234244975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其核心属性如下：</p>
<ul>
<li>private final TypeParameterMatcher matcher<br>参数类型匹配器，其实就是匹配MessageToByteEncoder的泛型参数。</li>
<li>private final boolean preferDirect<br>在解码时，是否倾向与使用堆外内存。</li>
</ul>
<p>MessageToByteEncoder是outbound处理器，只需 wrtie 事件做处理。<br><img src="https://img-blog.csdnimg.cn/2020123023464832.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>代码@1：如果待处理的对象类型符合该编码器期待的类型，则对数据进行编码，否则直接调用ctx.write方法@6，传播write事件。<br>代码@2：根据是否使用堆外内存，使用内存分配器分配堆内存或堆外内存， 其bufer默认的大小为256字节。<br>代码@3：根据协议将数据编码到ByteBuf中，由协议设计者去实现。<br>代码@4：<strong>对输入参数进行回收</strong>。<strong>因为经过该方法的处理，已经将输入参数转换为其他形式的数据，该数据的生命周期结束了</strong>，尝试回收(引用计数法)。<br>代码@5：如果byteBuf可读，则将这些数据传播到下一个事件处理器处理。<br>代码@7：对内存进行回收。</p>
<hr>
<p>更多文章建议关注『中间件兴趣圈』，获取12个JAVA主流中间件源码剖析，并包含大量实战案例、架构设计理念。</p>
<p><img src="https://img-blog.csdnimg.cn/20201231115902671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>netty4</category>
      </categories>
      <tags>
        <tag>netty</tag>
        <tag>编码</tag>
        <tag>通信协议</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 Flink 实现解决数据库分库分表任务拆分</title>
    <url>/posts/57908f75.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、场景描述"><a href="#1、场景描述" class="headerlink" title="1、场景描述"></a>1、场景描述</h2><p>例如订单库进行了分库分表，其示例如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201115203825639.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>现在的需求是希望创建一个任务就将数据同步到MQ集群，而不是为每一个数据库实例单独创建一个任务，将其数据导入到MQ集群，因为同步任务除了库不同之外，表的结构、数据映射规则都是一致的。</p>
<h2 id="2、flinkx-的解决方案详解"><a href="#2、flinkx-的解决方案详解" class="headerlink" title="2、flinkx 的解决方案详解"></a>2、flinkx 的解决方案详解</h2><h4 id="2-1-fink-Stream-API-开发基本流程"><a href="#2-1-fink-Stream-API-开发基本流程" class="headerlink" title="2.1 fink Stream API 开发基本流程"></a>2.1 fink Stream API 开发基本流程</h4><p>使用 Flink Stream API 编程的通用步骤如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201115203839996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<blockquote>
<p>温馨提示：有关 Stream API 的详细内容将在后续的文章中展开，本文主要是关注 InputFormatSourceFunction，重点关注数据源的拆分。</p>
</blockquote>
<h4 id="2-2-flinkx-Reader-数据源-核心类图"><a href="#2-2-flinkx-Reader-数据源-核心类图" class="headerlink" title="2.2 flinkx Reader(数据源)核心类图"></a>2.2 flinkx Reader(数据源)核心类图</h4><p><img src="https://img-blog.csdnimg.cn/20201115203855115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在 flinkx 中将不同的数据源封装成一个个 Reader，其基类为 BaseDataReader，上图中主要罗列了如下几个关键的类体系：</p>
<ul>
<li><p>InputFormat<br>flink 核心API，主要是对输入源进行数据切分、读取数据的抽象，其核心接口说明如下：</p>
<ul>
<li><p>void configure(Configuration parameters)<br>对输入源进行额外的配置，该方法在 Input 的生命周期中只需调用一次。</p>
</li>
<li><p>BaseStatistics getStatistics(BaseStatistics cachedStatistics)<br>返回 input 的统计数据，如果不需要统计，在实现的时候可以直接返回 null。</p>
</li>
<li><p>T[] createInputSplits(int minNumSplits)<br>对输入数据进行数据切片，使之支持并行处理，数据切片相关类体系见：InputSplit。</p>
</li>
<li><p>InputSplitAssigner getInputSplitAssigner(T[] inputSplits)<br>获取 InputSplit 分配器，主要是在具体执行任务时如何获取下一个 InputSplit，其声明如下图所示：<br><img src="https://img-blog.csdnimg.cn/20201115204001187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_right#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>void open(T split)<br>根据指定的数据分片 (InputSplit) 打开数据通道。为了加深对该方法的理解，下面看一下 Flinkx 关于 jdbc、es 的写入示例：<br><img src="https://img-blog.csdnimg.cn/20201115203933977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_right#pic_center" alt="在这里插入图片描述"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>boolean reachedEnd()<br>数据是否已结束，在 Flink 中通常 InputFormat 的数据源通常表示有界数据 (DataSet)。</p>
</li>
<li><p>OT nextRecord(OT reuse)</p>
<p>从通道中获取下一条记录。</p>
</li>
<li><p>void close()<br>关闭。</p>
</li>
<li><p>InputSplit<br>数据分片根接口，只定义了如下方法：</p>
<ul>
<li>int getSplitNumber()<br>获取当前分片所在所有分片中的序号。</li>
</ul>
<p>本文先简单介绍一下其通用实现子类：GenericInputSplit。</p>
<ul>
<li>int partitionNumber<br>当前 split 所在的序号</li>
<li>int totalNumberOfPartitions<br>总分片数</li>
</ul>
<p>为了方便理解我们可以思考一下如下场景，对于一个数据量超过千万级别的表，在进行数据切分时可以考虑使用10个线程，即切割成 10分，那每一个数据线程查询数据时可以 id % totalNumberOfPartitions = partitionNumber，进行数据读取。</p>
</li>
<li><p>SourceFunction<br>Flink 源的抽象定义。</p>
<ul>
<li><p>RichFunction<br>富函数，定义了生命周期、可获取运行时环境上下文。</p>
</li>
<li><p>ParallelSourceFunction<br>支持并行的 source function。</p>
</li>
<li><p>RichParallelSourceFunction</p>
<p>并行的富函数</p>
</li>
<li><p>InputFormatSourceFunction</p>
<p>Flink 默认提供的 RichParallelSourceFunction 实现类，可以当成是RichParallelSourceFunction 的通用写法，其内部的数据读取逻辑由 InputFormat 实现。</p>
</li>
</ul>
</li>
<li><p>BaseDataReader</p>
<p>flinkx 数据读取基类，在 flinkx 中将所有的数据读取源封装成 Reader 。</p>
</li>
</ul>
<h4 id="2-3-flinkx-Reader构建-DataStream-流程"><a href="#2-3-flinkx-Reader构建-DataStream-流程" class="headerlink" title="2.3 flinkx Reader构建 DataStream 流程"></a>2.3 flinkx Reader构建 DataStream 流程</h4><p>经过了上面类图的梳理，大家应该 flink 中提到的上述类的含义有了一个大概的理解，但如何运用呢？接下来将通过查阅 flinkx 的 DistributedJdbcDataReader(BaseDataReader的子类)的 readData 调用流程，体会一下其使用方法。<br><img src="https://img-blog.csdnimg.cn/20201115204021519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>基本遵循创建 InputFormat、从而创建对应的 SourceFunction，然后通过 StreamExecutionEnvironment 的 addSource 方法将 SourceFunction 创建对应的 DataStreamSource。</p>
<a id="more"></a>

<h4 id="2-4-flinkx-针对数据库分库分表任务拆分解决方案"><a href="#2-4-flinkx-针对数据库分库分表任务拆分解决方案" class="headerlink" title="2.4 flinkx 针对数据库分库分表任务拆分解决方案"></a>2.4 flinkx 针对数据库分库分表任务拆分解决方案</h4><p>正如本文开头部分的场景描述那样，某订单系统被设计成4库8表，每一个库(Schema)中包含2个表，如何提高数据导出的性能呢，如何提高数据的抽取性能呢？通常的解决方案如下：</p>
<ol>
<li>首先按库按表进行拆分，即4库8表，可以进行切分8份，每一个数据分配处理一个实例中的1个表。</li>
<li>单个表的数据抽取再进行拆分，例如按ID进行取模进一步分解。</li>
</ol>
<p>flinkx 就是采取上面的策略，我们来看一下其具体做法。<br><img src="https://img-blog.csdnimg.cn/20201115204036878.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：首先先根据数据库实例、表进行拆分，按表维度组织成一个 DataSource 列表，后续将基于这个原始数据执行拆分算法。</p>
<p>接下来具体的任务拆分在 InputFormat 中实现，本实例在 DistributedJdbcInputFormat 的 createInputSplitsInternal 中。</p>
<p>DistributedJdbcInputFormat#createInputSplitsInternal </p>
<p><img src="https://img-blog.csdnimg.cn/20201115204049462.png#pic_center" alt="在这里插入图片描述"><br>Step2：根据分区创建 inputSplit 数组，这里分区的概念就相当于上文提到方案中的第一条。</p>
<p>DistributedJdbcInputFormat#createInputSplitsInternal<br><img src="https://img-blog.csdnimg.cn/20201115204101452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：如果指定了 splitKey 的任务拆分算法，首先 DistributedJdbcInputSplit 继承自 GenericInputSplit，总分区数为 numPartitions，然后生成数据库的参数，这里主要是生成 SQL Where 语句中的 splitKey mod totalNumberOfPartitions = partitionNumber，其中 splitKey 为分片键，例如 id，而 totalNumberOfPartitions 表示分区总数，partitionNumber 表示当前分片的序号，通过 SQL 取模函数进行数据拆分。</p>
<p>DistributedJdbcInputFormat#createInputSplitsInternal<br><img src="https://img-blog.csdnimg.cn/20201115204119134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step4：如果未指定表级别的数据拆分键，则拆分策略是对 sourceList 进行拆分，即一些分区处理其中几个表。</p>
<p>关于 flinkx 中关于任务切分的介绍就到这里了。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>本文主要是基于 flinkx 介绍 MySQL 分库分表情况下如何基于 flink 进行任务切分，简单介绍了 Flink 中关于基本的编程范式、InputFormat、SourceFunction 的基本类体系。</p>
<blockquote>
<p>温馨提示：本文并没有太详细对 Flink API 进行深入研究，后续会单独对 Flink 内容进行逐一剖析，但 Flink 系列的文章组织，其文章的组织并不具备顺序性，笔者会在不断实践 Flink 的过程中对 FLink 进行剖析。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>flink</category>
      </categories>
      <tags>
        <tag>flink</tag>
        <tag>分库分表</tag>
        <tag>InputSplit</tag>
      </tags>
  </entry>
  <entry>
    <title>复合Lambda表达式</title>
    <url>/posts/4c12373d.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、比较器复合"><a href="#1、比较器复合" class="headerlink" title="1、比较器复合"></a>1、比较器复合</h2><p><img src="https://img-blog.csdnimg.cn/20190515201329740.png" alt="在这里插入图片描述"><br>上面是JDK8中java.util.Comparator接口，相比jdk1.7增加了好多方法，也许你会觉得奇怪，为什么接口中还能定义方法，原因是JDK8中，可以为接口添加默认实现，使用default关键字定义。</p>
<p>例如，我们可以这样定义一个比较器：<br>Comparator&lt; Apple&gt;  c = Comparator.comparing(Apple::getWeight());<br>其等价为：<br>Comparator&lt; Apple&gt;  c = Comparator.comparing(  (a) -&gt; a.getWeight()  );</p>
<p>为什么可以这样写呢？因为Comparator定义了如下静态方法：<br><img src="https://img-blog.csdnimg.cn/20190515202531959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="1-1-逆序"><a href="#1-1-逆序" class="headerlink" title="1.1 逆序"></a>1.1 逆序</h4><p>Comparator定义了一个静态方法，reversed，故我们不需要重新再定义一个比较器，我们可以这样就能实现逆序排序：<br>List&lt; Apple&gt; apples = new ArrayList&lt;&gt;();<br>apples.sort(  Comparator.comparing(Apple::getWeight()).reversed()  );</p>
<h4 id="1-2-比较器链"><a href="#1-2-比较器链" class="headerlink" title="1.2 比较器链"></a>1.2 比较器链</h4><p>如果要支持多重排序呢？例如先根据苹果的重量，如果重量相同就按照颜色排序，那如何来实现呢？<br>apples.sort(  Comparator.comparing(Apple::getWeight()).thenComparing(  Apple::getColor()  ) );<br>之所以可以使用上述表达式，是因为Comparator定义了如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default &lt;U extends Comparable&lt;? super U&gt;&gt; Comparator&lt;T&gt; thenComparing( Function&lt;? super T, ? extends U&gt; keyExtractor)</span><br><span class="line">&#123;</span><br><span class="line">    return thenComparing(comparing(keyExtractor));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提示：Comparator中定义很多thenComparing重载方法,在具体使用过程中，可以先看看其函数声明。</p>
</blockquote>
<a id="more"></a>

<h4 id="2、谓词复合"><a href="#2、谓词复合" class="headerlink" title="2、谓词复合"></a>2、谓词复合</h4><p>提到谓词复合，我们就不得不提Predicate&lt; T &gt;函数式编程接口，其类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190515203712938.png" alt="在这里插入图片描述"></p>
<ul>
<li>and：与</li>
<li>negate：非</li>
<li>or：或</li>
</ul>
<blockquote>
<p>温馨提示：and 和 or 方法是按照在表达式链中的位置，从左向右确定优先级的。因此， a.or(b).and(c) 可以看作 (a || b) &amp;&amp; c 。</p>
</blockquote>
<p>使用示例：从苹果列表中找出所有红色的，并且重量超过150的苹果：</p>
<p>apples.filter(   (a -&gt; “red”.equals(a.getColor()) ).and(  a -&gt; a.getWeight() &gt; 150  )   );</p>
<p>a -&gt; “red”.equals(a.getColor())  是 (Apple a ) -&gt; “red”.equals(a.getColor())的简写。</p>
<h2 id="3、函数复合"><a href="#3、函数复合" class="headerlink" title="3、函数复合"></a>3、函数复合</h2><p>函数复合，其对应的函数式编程接口为Function&lt;T,R&gt;，其类图如下：<br><img src="https://img-blog.csdnimg.cn/20190515204237920.png" alt="在这里插入图片描述"></p>
<ul>
<li>addThen<br>andThen 方法会返回一个函数，它先对输入应用一个给定函数，再对输出应用另一个函数。<br>例如：<br>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;<br>Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;<br>Function&lt;Integer, Integer&gt; h = f.andThen(g);<br>int result = h.apply(1);  // 其结果返回4，类似与数学公式  f(g(x))。</li>
<li>compose<br>先把给定的函数用作 compose 的参数里面给的那个函数，然后再把函数本身用于结果。与addThen的函数应用方向相反，同样举例说明如下：<br>Function&lt;Integer, Integer&gt; f = x -&gt; x + 1;<br>Function&lt;Integer, Integer&gt; g = x -&gt; x * 2;<br>Function&lt;Integer, Integer&gt; h = f.compose(g);<br>int result = h.apply(1);  // 其结果返回3，类似与数学公式  g(f(x))。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Lambda</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>基于 raft 协议的 RocketMQ DLedger 多副本日志复制设计原理</title>
    <url>/posts/9ef855bf.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、RocketMQ-DLedger-多副本日志复制流程图"><a href="#1、RocketMQ-DLedger-多副本日志复制流程图" class="headerlink" title="1、RocketMQ DLedger 多副本日志复制流程图"></a>1、RocketMQ DLedger 多副本日志复制流程图</h2><h3 id="1-1-RocketMQ-DLedger-日志转发-append-请求流程图"><a href="#1-1-RocketMQ-DLedger-日志转发-append-请求流程图" class="headerlink" title="1.1 RocketMQ DLedger 日志转发(append) 请求流程图"></a>1.1 RocketMQ DLedger 日志转发(append) 请求流程图</h3><p><img src="https://img-blog.csdnimg.cn/20190928183406295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-2-RocketMQ-DLedger-日志仲裁流程图"><a href="#1-2-RocketMQ-DLedger-日志仲裁流程图" class="headerlink" title="1.2 RocketMQ DLedger 日志仲裁流程图"></a>1.2 RocketMQ DLedger 日志仲裁流程图</h3><p><img src="https://img-blog.csdnimg.cn/20190928183709529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-3-RocketMQ-DLedger-从节点日志复制流程图"><a href="#1-3-RocketMQ-DLedger-从节点日志复制流程图" class="headerlink" title="1.3 RocketMQ DLedger 从节点日志复制流程图"></a>1.3 RocketMQ DLedger 从节点日志复制流程图</h3><p><img src="https://img-blog.csdnimg.cn/20190928183733569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2 id="2、RocketMQ-DLedger-多副本日志复制实现要点"><a href="#2、RocketMQ-DLedger-多副本日志复制实现要点" class="headerlink" title="2、RocketMQ DLedger 多副本日志复制实现要点"></a>2、RocketMQ DLedger 多副本日志复制实现要点</h2><p><img src="https://img-blog.csdnimg.cn/20190928183915385.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图是一个简易的日志复制的模型：图中客户端向 DLedger 集群发起一个写请求，集群中的 Leader 节点来处理写请求，首先数据先存入 Leader 节点，然后需要广播给它的所有从节点，从节点接收到 Leader 节点的数据推送对数据进行存储，然后向主节点汇报存储的结果，Leader 节点会对该日志的存储结果进行仲裁，如果超过集群数量的一半都成功存储了该数据，主节点则向客户端返回写入成功，否则向客户端写入写入失败。</p>
<p>接下来我们来探讨日志复制的核心设计要点。</p>
<h3 id="2-1-日志编号"><a href="#2-1-日志编号" class="headerlink" title="2.1 日志编号"></a>2.1 日志编号</h3><p>为了方便对日志进行管理与辨别，raft 协议为一条一条的消息进行编号，每一条消息达到主节点时会生成一个全局唯一的递增号，这样可以根据日志序号来快速的判断数据在主从复制过程中数据是否一致，在 DLedger 的实现中对应 DLedgerMemoryStore 中的 ledgerBeginIndex、ledgerEndIndex，分别表示当前节点最小的日志序号与最大的日志序号，下一条日志的序号为 ledgerEndIndex + 1 。</p>
<p>与日志序号还与一个概念绑定的比较紧密，即当前的投票轮次。</p>
<h3 id="2-2-追加与提交机制"><a href="#2-2-追加与提交机制" class="headerlink" title="2.2 追加与提交机制"></a>2.2 追加与提交机制</h3><p>请思考如下问题，Leader 节点收到客户端的数据写入请求后，通过解析请求，提取数据部分，构建日志对象，并生成日志序号，用 seq 表示，然后存储到 Leader 节点中，然后将日志广播(推送)到其从节点，由于这个过程中存在网络时延，如果此时客户端向主节点查询 seq 的日志，由于日志已经存储在 Leader 节点中了，如果直接返回给客户端显然是有问题的，那该如何来避免这种情况的发生呢？</p>
<p>为了解决上述问题，DLedger 的实现(应该也是 raft 协议的一部分)引入了已提交指针(committedIndex)。即当主节点收到客户端请求时，首先先将数据存储，但此时数据是未提交的，此过程可以称之为追加，此时客户端无法访问，只有当集群内超过半数的节点都将日志追加完成后，才会更新 committedIndex 指针，得以是数据能否客户端访问。</p>
<p>一条日志要能被提交的充分必要条件是日志得到了集群内超过半数节点成功追加，才能被认为已提交。</p>
<h3 id="2-3-日志一致性如何保证"><a href="#2-3-日志一致性如何保证" class="headerlink" title="2.3 日志一致性如何保证"></a>2.3 日志一致性如何保证</h3><p>从上文得知，一个拥有3个节点的 DLedger 集群，只要主节点和其中一个从节点成功追加日志，则认为已提交，客户端即可通过主节点访问。由于部分数据存在延迟，在 DLedger 的实现中，读写请求都将由 Leader 节点来负责。那落后的从节点如何再次跟上集群的步骤呢？</p>
<p>要重新跟上主节点的日志记录，首先要知道的是如何判断从节点已丢失数据呢？</p>
<p>DLedger 的实现思路是，DLedger 会按照日志序号向从节点源源不断的转发日志，从节点接收后将这些待追加的数据放入一个待写队列中。关键中的关键：从节点并不是从挂起队列中处理一个一个的追加请求，而是首先查阅从节点当前已追加的最大日志序号，用 ledgerEndIndex 表示，然后尝试追加 (ledgerEndIndex + 1)的日志，用该序号从代写队列中查找，如果该队列不为空，并且没有 (ledgerEndIndex + 1)的日志条目，说明从节点未接收到这条日志，发生了数据缺失。然后从节点在响应主节点 append 的请求时会告知数据不一致，然后主节点的日志转发线程其状态会变更为COMPARE，将向该从节点发送COMPARE命令，用来比较主从节点的数据差异，根据比较的差异重新从主节点同步数据或删除从节点上多余的数据，最终达到一致。于此同时，主节点也会对PUSH超时推送的消息发起重推，尽最大可能帮助从节点及时更新到主节点的数据。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
        <tag>raft</tag>
        <tag>DLedger</tag>
      </tags>
  </entry>
  <entry>
    <title>寻找一把进入 Alibaba Sentinel 的钥匙(文末附流程图)</title>
    <url>/posts/550fbf45.html</url>
    <content><![CDATA[<div id="vip-container"><p>经过前面几篇文章的铺垫，我们正式来探讨 Sentinel 的 entry 方法的实现流程。</p>
<p>即探究进入 Alibaba Sentinel 核心的一把钥匙。<br>无论是从 Sentinel 适配 Dubbo 也好，还是 SphU 源码中的注释中能看出，对一个资源进行限流或熔断，通常需要调用 SphU 的 entry 方法，例如如下示例代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Entry entry = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		entry = SphU.entry(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (BlockException blockException) &#123;</span><br><span class="line">		<span class="comment">// when goes there, it is blocked</span></span><br><span class="line">		<span class="comment">// add blocked handle logic here</span></span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable bizException) &#123;</span><br><span class="line">		<span class="comment">// business exception</span></span><br><span class="line">		Tracer.trace(bizException);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="comment">// ensure finally be executed</span></span><br><span class="line">		<span class="keyword">if</span> (entry != <span class="keyword">null</span>)&#123;</span><br><span class="line">			entry.exit();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那本文将来探讨 SphU.entry 的实现原理。SphU 类定义了很多 entry 重载方法，我们就以下面这个方法为例来探究其实现原理。</p>
<h2 id="1、SphU-entry-流程分析"><a href="#1、SphU-entry-流程分析" class="headerlink" title="1、SphU.entry 流程分析"></a>1、SphU.entry 流程分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Entry <span class="title">entry</span><span class="params">(String name, EntryType type, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span>  BlockException </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">	<span class="keyword">return</span> Env.sph.entry(name, type, count, args);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：我们先来简单介绍其核心参数的含义：</p>
<ul>
<li>String name<br>资源的名称。</li>
<li>EntryType type<br>进入资源的方式，主要包含 EntryType.IN、EntryType.OUT。</li>
<li>int count<br>可以理解为本次进入需要消耗的“令牌数”。</li>
<li>Object… args<br>其他参数。</li>
</ul>
<p>代码@2：调用 Env.sph.entry 的方法，其最终会调用 CtSph 的 entry 方法。</p>
<p>接下来我们将重点查看 CtSph 的 entry 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Entry <span class="title">entry</span><span class="params">(String name, EntryType type, <span class="keyword">int</span> count, Object... args)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    StringResourceWrapper resource = <span class="keyword">new</span> StringResourceWrapper(name, type); <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> entry(resource, count, args);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：由于该方法用来表示资源的方式为一个字符串，故创建一个 StringResourceWrapper  对象来表示一个 Sentinel 中的资源，另外一个实现为 MethodResourceWrapper，用来表示方法类的资源。</p>
<p>代码@2：继续调用 CtSph 的另外一个 entry 重载方法，最终会调用 entryWithPriority 方法。</p>
<p>CtSph#entryWithPriority </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">entryWithPriority</span><span class="params">(ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="comment">// @1</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    Context context = ContextUtil.getContext();  <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> NullContext) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Using default context.</span></span><br><span class="line">        context = InternalContextUtil.internalEnter(Constants.CONTEXT_DEFAULT_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (!Constants.ON) &#123;   <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    ProcessorSlot&lt;Object&gt; chain = lookProcessChain(resourceWrapper);   <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">new</span> CtEntry(resourceWrapper, <span class="keyword">null</span>, context);</span><br><span class="line">    &#125;</span><br><span class="line">    Entry e = <span class="keyword">new</span> CtEntry(resourceWrapper, chain, context);     <span class="comment">// @5</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">	    chain.entry(context, resourceWrapper, <span class="keyword">null</span>, count, prioritized, args);   <span class="comment">// @6</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (BlockException e1) &#123;                                                                    <span class="comment">// @7</span></span><br><span class="line">	    e.exit(count, args);</span><br><span class="line">        <span class="keyword">throw</span> e1;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e1) &#123;</span><br><span class="line">        RecordLog.info(<span class="string">&quot;Sentinel unexpected exception&quot;</span>, e1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：我们先来介绍一下该方法的参数：</p>
<ul>
<li>ResourceWrapper resourceWrapper<br>资源的包装类型，可以是字符串类型的资源描述，也可以是方法类的。</li>
<li>int count<br>此次需要消耗的令牌。</li>
<li>boolean prioritized<br>是否注重优先级。</li>
<li>Object… args<br>额外参数。</li>
</ul>
<p>代码@2：获取方法调用的上下文环境，上下环境对象存储在线程本地变量：ThreadLocal 中，这里先“剧透”一下，上下文环境中存储的是整个调用链，后续文章会重点介绍。</p>
<p>代码@3：Sentinel 提供一个全局关闭的开关，如果关闭，返回的 CtEntry 中的 chain 为空，从这里可以看出，如果 chain 为空，则不会触发 Sentinel 流控相关的逻辑，从侧面也反应了该属性的重要性。</p>
<p>代码@4：为该资源加载处理链链，这里是最最重要的方法，将在下文详细介绍。</p>
<p>代码@5：根据资源ID、处理器链、上下文环境构建 CtEntry 对象。</p>
<p>代码@6：调用 chain 的 entry 方法。</p>
<p>代码@7：如果出现 BlockException ，调用 CtEntry 的 exit 方法。</p>
<h2 id="2、Sentienl-ProcessorSlot-处理链"><a href="#2、Sentienl-ProcessorSlot-处理链" class="headerlink" title="2、Sentienl ProcessorSlot 处理链"></a>2、Sentienl ProcessorSlot 处理链</h2><p>我们接下来重点看一下 lookProcessChain 方法的实现细节。<br>CtSph#lookProcessChain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ProcessorSlot&lt;Object&gt; <span class="title">lookProcessChain</span><span class="params">(ResourceWrapper resourceWrapper)</span> </span>&#123;</span><br><span class="line">    ProcessorSlotChain chain = chainMap.get(resourceWrapper);  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">	    chain = chainMap.get(resourceWrapper);</span><br><span class="line">            <span class="keyword">if</span> (chain == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Entry size limit.</span></span><br><span class="line">                <span class="keyword">if</span> (chainMap.size() &gt;= Constants.MAX_SLOT_CHAIN_SIZE) &#123;        <span class="comment">// @2</span></span><br><span class="line">		    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                chain = SlotChainProvider.newSlotChain();                                      <span class="comment">// @3</span></span><br><span class="line">                Map&lt;ResourceWrapper, ProcessorSlotChain&gt; newMap = <span class="keyword">new</span> HashMap&lt;ResourceWrapper, ProcessorSlotChain&gt;(</span><br><span class="line">                        chainMap.size() + <span class="number">1</span>);</span><br><span class="line">                newMap.putAll(chainMap);</span><br><span class="line">                newMap.put(resourceWrapper, chain);</span><br><span class="line">                chainMap = newMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> chain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：chainMap 一个全局的缓存表，即同一个资源 ResourceWrapper (同一个资源名称) 会共同使用同一个 ProcessorSlotChain ，即不同的线程在访问同一个资源保护的代码时，这些线程将共同使用 ProcessorSlotChain  中的各个 ProcessorSlot 。注意留意 ResourceWrapper 的 equals 方法与 hashCode 方法。</p>
<p>代码@2：这里重点想突出，如果同时在进入的资源个数超过 MAX_SLOT_CHAIN_SIZE，默认为 6000，会返回 null，则不对本次请求执行限流，熔断计算，而是直接跳过，这个点还是值得我们注意的。</p>
<p>代码@3：通过 SlotChainProvider 创建对应的处理链。</p>
<p>SlotChainProvider#newSlotChain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProcessorSlotChain <span class="title">newSlotChain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (slotChainBuilder != <span class="keyword">null</span>) &#123;     <span class="comment">// @1</span></span><br><span class="line">		<span class="keyword">return</span> slotChainBuilder.build();</span><br><span class="line">        &#125;</span><br><span class="line">	slotChainBuilder = SpiLoader.loadFirstInstanceOrDefault(SlotChainBuilder.class, DefaultSlotChainBuilder.class);   <span class="comment">// @2</span></span><br><span class="line">	<span class="keyword">if</span> (slotChainBuilder == <span class="keyword">null</span>) &#123;                                                                                                                                        <span class="comment">// @3</span></span><br><span class="line">		RecordLog.warn(<span class="string">&quot;[SlotChainProvider] Wrong state when resolving slot chain builder, using default&quot;</span>);</span><br><span class="line">                slotChainBuilder = <span class="keyword">new</span> DefaultSlotChainBuilder();</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		RecordLog.info(<span class="string">&quot;[SlotChainProvider] Global slot chain builder resolved: &quot;</span></span><br><span class="line">                + slotChainBuilder.getClass().getCanonicalName());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> slotChainBuilder.build();                                                                                                                                   <span class="comment">// @4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果 slotChainBuilder 不为空，则直接调用其 build 方法构建处理器链。</p>
<p>代码@2：如果为空，首先通过 JAVA 的 SPI 机制，尝试加载自定义的 Slot Chain 构建器实现类。如果需要实现自定义的 Chain 构建器，只需实现  SlotChainBuilder 接口，然后将其放在 classpath 下即可，如果存在多个，以找到的第一个为准。</p>
<p>代码@3：如果从 SPI 机制中加载失败，则使用默认的构建器：DefaultSlotChainBuilder。</p>
<p>代码@4：调用其 build 方法构造 Slot Chain。</p>
<p>那接下来我们先来看看 Sentinel 的 SlotChainBuilder 类体系，然后看看 DefaultSlotChainBuilder 的 build 方法。</p>
<h4 id="2-1-SlotChainBuilder-类体系"><a href="#2-1-SlotChainBuilder-类体系" class="headerlink" title="2.1 SlotChainBuilder  类体系"></a>2.1 SlotChainBuilder  类体系</h4><p><img src="https://img-blog.csdnimg.cn/2020010513491784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主要有三个实现类，对应热点、接口网关以及普通场景。我们接下来将重点介绍 DefaultSlotChainBuilder ，关于热点限流与网关限流将在后面的文章中详细探讨。</p>
<h4 id="2-2-DefaultSlotChainBuilder-build-方法"><a href="#2-2-DefaultSlotChainBuilder-build-方法" class="headerlink" title="2.2 DefaultSlotChainBuilder build 方法"></a>2.2 DefaultSlotChainBuilder build 方法</h4><p>DefaultSlotChainBuilder#build</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSlotChainBuilder</span> <span class="keyword">implements</span> <span class="title">SlotChainBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProcessorSlotChain <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ProcessorSlotChain chain = <span class="keyword">new</span> DefaultProcessorSlotChain();</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> NodeSelectorSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> ClusterBuilderSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> LogSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> StatisticSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> AuthoritySlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> SystemSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> FlowSlot());</span><br><span class="line">        chain.addLast(<span class="keyword">new</span> DegradeSlot());</span><br><span class="line">        <span class="keyword">return</span> chain;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就问大家激不激动，开不开心，从这些 Slot 的名字基本就能得出其含义。</p>
<ul>
<li>NodeSelectorSlot<br>主要用于构建调用链。</li>
<li>ClusterBuilderSlot<br>用于集群限流、熔断。</li>
<li>LogSlot<br>用于记录日志。</li>
<li>StatisticSlot<br>用于实时收集实时消息。</li>
<li>AuthoritySlot<br>用于权限校验的。</li>
<li>SystemSlot<br>用于验证系统级别的规则。</li>
<li>FlowSlot<br>实现限流机制。</li>
<li>DegradeSlot<br>实现熔断机制。</li>
</ul>
<a id="more"></a>

<blockquote>
<p>经过上面的方法，就构建一条 Slot 处理链。其实到这里我们就不难发现，调用 ProcessorSlotChain 的 entry 方法，就是依次调用这些 slot 的方法。关于 ProcessorSlotChain 的类层次结构就不再多说明了，其实现比较简单，大家如果有兴趣的话，可以关注这部分的实现，这里代表一类场景：一对多、责任链的设计模式。</p>
<h2 id="3、Sentinel-SphU-entry-处理流程图"><a href="#3、Sentinel-SphU-entry-处理流程图" class="headerlink" title="3、Sentinel SphU.entry 处理流程图"></a>3、Sentinel SphU.entry 处理流程图</h2><p>经过上面的探索，我们其实已经找到了 Sentinel 的关于限流、熔断核心处理逻辑的入口，就是 FlowSlot、DegradeSlot。接下来我们以一张流程图来结束本文的讲解。<br><img src="https://img-blog.csdnimg.cn/20200105135205468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>本文的目的就是打开 Sentinel 的大门，即寻找实时数据收集、限流、熔断实现机制的入口，从而正式探寻 Sentienl 的核心实现原理，更多精彩请继续期待该专栏的后续内容。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序算法java版实现</title>
    <url>/posts/42760d48.html</url>
    <content><![CDATA[<div id="vip-container"><p>快速排序思想：从待排序序列中找到一个关键字（默认为第一个元素） 然后将比关键字少的数据排列在左边，大于关键字的排在右边，然后对关键字左右两边的序列继续上面步骤，直至关键字两边的序列都已经排好序。具体算法如下：</p>
<p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</p>
<p> 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。<br> 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。<br> 一趟快速排序的算法是：<br> 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br> 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br> 3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br> 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br> 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,<br> 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</p>
<p> 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</p>
<blockquote>
<p>温馨提示：上述算法的描述来源与百度，大家也可以按照上面的算法，用自己熟悉的语言尝试实现一遍。</p>
</blockquote>
<p>一言不合继续用代码说话。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> persistent.prestige.console.algorithm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，</span></span><br><span class="line"><span class="comment"> * 然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。</span></span><br><span class="line"><span class="comment"> * 值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</span></span><br><span class="line"><span class="comment"> * 一趟快速排序的算法是：</span></span><br><span class="line"><span class="comment"> * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</span></span><br><span class="line"><span class="comment"> * 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</span></span><br><span class="line"><span class="comment"> * 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</span></span><br><span class="line"><span class="comment"> * 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</span></span><br><span class="line"><span class="comment"> * 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,</span></span><br><span class="line"><span class="comment"> * 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</span></span><br><span class="line"><span class="comment"> * 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lenovo</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(hign &lt;= low) <span class="keyword">return</span>; <span class="comment">// 如果hign 小于等于 low ,说明待排序队列只包含一个元素，无法再排序</span></span><br><span class="line">		<span class="keyword">int</span> keyIdx = asort(a, low, hign); </span><br><span class="line">		<span class="keyword">if</span>( ! (keyIdx == low &amp;&amp; low == hign) ) &#123; <span class="comment">// keyIdx == low &amp;&amp; low == hign 则说明不可分</span></span><br><span class="line">			<span class="keyword">if</span>(keyIdx == low ) &#123; <span class="comment">//说明左边已经排好序了</span></span><br><span class="line">				quickSort(a, low + <span class="number">1</span>, hign);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span>  (keyIdx == hign ) &#123;  <span class="comment">// 说明右边已经排序好了</span></span><br><span class="line">				quickSort(a, low, hign -<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				quickSort(a, low , keyIdx -<span class="number">1</span>); <span class="comment">// 关键字左边排序</span></span><br><span class="line">				quickSort(a, keyIdx + <span class="number">1</span>, hign); <span class="comment">// 关键字右边排序</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 快速排序   一趟排序算法实现</span></span><br><span class="line"><span class="comment">	 * 一趟快速排序的算法是：(来源于百度百科)</span></span><br><span class="line"><span class="comment">	 * 1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；</span></span><br><span class="line"><span class="comment">	 * 2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；</span></span><br><span class="line"><span class="comment">	 * 3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；</span></span><br><span class="line"><span class="comment">	 * 4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；</span></span><br><span class="line"><span class="comment">	 * 5）重复第3、4步，直到i=j； (3,4步中，没找到符合条件的值，即3中A[j]不小于key,</span></span><br><span class="line"><span class="comment">	 * 4中A[i]不大于key的时候改变j、i的值，使得j=j-1，i=i+1，直至找到为止。</span></span><br><span class="line"><span class="comment">	 * 找到符合条件的值，进行交换的时候i， j指针位置不变。另外，i==j这一过程一定正好是i+或j-完成的时候，此时令循环结束）。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a			待排序数组</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> low       待排序起始下标</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> hign      待排序结束下标  (low hign) 限制排序数组范围</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span>          本轮排序后，关键字所在位置(下标)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">asort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> hign)</span> </span>&#123;</span><br><span class="line"> 		<span class="keyword">int</span> key = a[low];</span><br><span class="line">		loop :</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// low 与 hign 相等时退出</span></span><br><span class="line">			<span class="keyword">while</span>( hign &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">				<span class="keyword">if</span>( a[hign] &lt; key ) &#123;</span><br><span class="line">					swap(a, low, hign);   <span class="comment">// 从后向前找，找到第一个比关键字小的元素后交换元素后跳出本次比较</span></span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				hign --;</span><br><span class="line">				<span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">			&#125;</span><br><span class="line">			low ++; </span><br><span class="line">			<span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">			<span class="keyword">while</span>( low &lt; a.length ) &#123;</span><br><span class="line">				<span class="keyword">if</span>( a[low] &gt; key ) &#123;   <span class="comment">// 从前向后找，找到第一个比关键字大的元素时交换元素后跳出本次比较</span></span><br><span class="line">					swap(a, low, hign);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				low ++; </span><br><span class="line">				<span class="keyword">if</span>(low == hign) <span class="keyword">break</span> loop;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> low;<span class="comment">//关键字所在的位置</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 交换数组中两个元素的位置</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> tmp = a[i];</span><br><span class="line">		a[i] = a[j];</span><br><span class="line">		a[j] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">&quot;待排序数据：(5,8,2,10,6,9,21,18,19,7)&quot;</span>);</span><br><span class="line">		<span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">19</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		quickSort(a, <span class="number">0</span>, a.length -<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序后结果：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">			System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot; ---------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;待排序数据：(5,8,2,10,5,9,21,18,8,7)&quot;</span>);</span><br><span class="line">		a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">21</span>,<span class="number">18</span>,<span class="number">8</span>,<span class="number">7</span>&#125;;</span><br><span class="line">		quickSort(a, <span class="number">0</span>, a.length -<span class="number">1</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;排序后结果：&quot;</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">			System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>我的另一种参与 RocketMQ 开源社区的方式</title>
    <url>/posts/97996927.html</url>
    <content><![CDATA[<div id="vip-container"><p>首先先“SHOW”一波我在 RocketMQ 开源社区所获得的成就：2019年RocketMQ社区授予我优秀布道师荣誉称号，证书很高大上，奖品丰厚哦。<br><img src="https://img-blog.csdnimg.cn/20200608190532198.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>布道师是什么？开源项目不是都在追求如何成为一名 Committer？其实这个就是参与开源项目的两种不同方式。如何参与一个开源项目，容我慢慢道来。</p>
<p>@<a href="%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">TOC</a></p>
<h2 id="1、与-RocketMQ-相识、相知到“在一起”"><a href="#1、与-RocketMQ-相识、相知到“在一起”" class="headerlink" title="1、与 RocketMQ 相识、相知到“在一起”"></a>1、与 RocketMQ 相识、相知到“在一起”</h2><p>在2017年听到阿里巴巴将 RocketMQ 捐赠给 Apache基金会成为 Apache 的顶级项目，我内心是无比激动，因为终于可以一睹一款高性能的消息中间件的实现原理。</p>
<p>通过阅读 RocketMQ 官方文档，以下几个特别的点吸引了我的注意，让我下定决心深入研究一番。</p>
<ul>
<li>RocketMQ 为什么性能高效，到底运用了什么“厉害”的技术</li>
<li>RocketMQ 如何实现刷盘（可以类比一下数据库方面的刷盘、redo、undo日志）</li>
<li>RocketMQ 文件存储设计理念、基于文件的 Hash 索引是怎么实现的</li>
<li>定时消息、消息过滤等实现原理</li>
<li>如何进行网络编程（Netty实战）</li>
</ul>
<p>心动不如行动，下定决心后便开始了我的源码分析 RocketMQ 之旅，大概在4个多月的时间中连续发表了30余篇文章，从 Nameserver、消息发送高可用设计、消息存储、消息消费、消息过滤、事务消息等各个方面对其进行了体系化的剖析，边写边分享，边分享边传播，终于得到了机械工业出版社华章分社的杨福川老师的认可，邀请我出书。</p>
<p>在杨老师和张工的帮助与指点下，经过将近半年的努力，书稿基本完稿。</p>
<p>由于我当时是一位名不经传的新人，按照出版行业的惯例，需要找一些该领域内专家大牛帮忙做序或写写推荐语。</p>
<p>当时我是初生牛犊不怕虎，蹦出了一个非常大胆的想法，是不是可以联系 RocketMQ 官方的一些大佬，最终我直接锁定了 RocketMQ 创始人冯嘉大神，希望他能帮我作序推荐。</p>
<p>令人惊喜的是冯嘉大神非常平易见人，得知我的来意后，他说了这样一句话：“我是非常愿意为写书的朋友作序，但需要评估一下书稿的质量，如果质量OK，非常愿意效劳”。</p>
<p>我备受鼓舞，在和出版社初步沟通后，将试读稿件再加上消息存储整章的内容发给冯嘉大神后，经冯嘉大神认真审稿后，决定帮忙推荐作序，真的让我备受鼓舞。</p>
<p>随着《RocketMQ技术内幕》一书的正式出版上市，并得到广大读者朋友的认可，与官方的联系也越来越多，后面在 RocketMQ 中国社区负责人青峰大佬的筹备下，我还参与了 RocketMQ 官方社区的源码解析直播活动、官方文档审稿等工作，并在社区得到了不错的反响。</p>
<p><strong>说到这里大家是不是觉得非常奇怪，是不是都认为你只是在写文章，写书，没有真正参与开源社区呀，没有贡献代码，这个算哪门子参与开源社区？</strong></p>
<p>其实我一开始连我自己也没有意识到我正在参与一个开源项目，直到我在冯嘉大神为我写的序言中看到他给了我一个新的称号：<strong>RocketMQ布道师</strong>，从而才真正了解到参与开源的另外一种方式：做一个开源项目的传播者，让更多人更容易的使用它，即降低大众对它的使用门槛。</p>
<p>我后面也特意去查了一下开源项目的布道师是一个什么的角色，或者说什么样的人能被称之为布道师。个人的理解就是首先认可并热爱这项技术，并持续输出高质量的技术类文章、文档等有助于技术传播的素材，让更多人更容易理解并使用它。</p>
<p>有了新的称号，那就得更加努力，朝着优秀努力，在2019年我又陆续发表了20几篇关于RocketMQ相关的文章，这些文章含金量极高，不仅及时跟进了RocketMQ4.3之后的新特性：消息轨迹、ACL、主从切换等机制，更是发表了数篇实战类文章，详细指出在生产环境下一些使用误区，更是输出了几篇生产环境真实故障与解决方案。最终于2019年 RocketMQ 官方社区授予我优秀布道师荣誉称号。</p>
<p>RocketMQ 成就了现在的我，我也会继续努力，为传播RocketMQ尽一份力所能及的力量。2020年，继续努力。</p>
<h2 id="2、如何成为开源项目的-Committer"><a href="#2、如何成为开源项目的-Committer" class="headerlink" title="2、如何成为开源项目的 Committer"></a>2、如何成为开源项目的 Committer</h2><p>有一些粉丝在问我，您对 RocketMQ 研究的这么深入，为什么不考虑贡献代码，成为一名 Committer 呢？这是因为参与开源项目需要具备一些基本条件，当下我的实际情况不符合，那成为一个开源项目的 Committer 有些什么条件呢？</p>
<a id="more"></a>

<ul>
<li><p>扎实的Java基础功底<br>一个开源项目的底层都会涉及到存储，这就要求具备一定的数据结构基础，JAVA集合框架中的类自然成为了我们突破数据结构最好的老师，其次是java并发，即多线程、并发容器、锁等课题，这方面可以好好学习一下JUC框架。最后最好是具备一些网络方面的知识，例如NIO、Netty。</p>
</li>
<li><p>持续输出能力<br>成为一个开源项目的 contributions 非常容易，提交一个PR并被通过即可，甚至于提交一个文档被接受也同样可以，难的是持续贡献，最终被开源项目的PMC认为对该项目有着突出贡献。</p>
</li>
</ul>
<p>我比较“苦逼”，在带娃方面我的资源只有我和我老婆，父母在老家无法分身，故下班后我没有连续的空闲时间专心投入一项任务中，而开源最需要的是精益求精，不只是需要完成功能，而是要编写结构优良的代码，设计所占据的时间比代码开发时间要多的多，故我个人认为我暂时不方便走代码贡献这条道路。但我零碎时间还是充足的，故现阶段我会好好利用这些零碎时间，继续通过写文章的方式为开源项目贡献自己的一份力量。</p>
<p><strong>接下来我们回到本节的主题，那如何参与一个开源项目呢？</strong></p>
<p>在参与一个开源项目之前，我觉得第一个最基本的步骤还是要打牢基础，这里的基础至少要包括 JAVA集合、JAVA并发（JUC)这两项，这是最最基本的，至少要阅读其源码，理解其设计理念，至于NIO，Netty 这些可以后续在需要使用时再去专门学习，有针对性的学习，结合使用需求，或许学习动力更强劲，学习效率更高效。</p>
<p>当具备一定的基础后，如何从零开始参与进开源项目呢？通常有如下几个方法：</p>
<ul>
<li>看看官方文档，特别是设计手册，从整体上把握其设计理念。</li>
<li>写写源码分析类文章，从整体上把控这个框架，这个花费时间较多，如果框架正在起步阶段，不建议该方法；如果框架比较成熟，非常建议采用该方法。</li>
<li>尝试看看开源项目中的 issues，看能不能解决，从问题入手，快速融入该项目。</li>
<li>尝试写写单元测试用例，测试驱动开发，借此学习该框架。</li>
</ul>
<p>后面的事情就是坚持不懈，朝着目标不断前进，中途可以放慢速度，但千万别放弃，因为只有坚持，才能胜利，只要前进，就离目标更近。</p>
<p>参与开源，一个最基本的条件是拥有大量的连续时间，想要成为一个开源框架的 Committer ,唯有坚持不懈，持续投入，持续产出。</p>
<p><strong>布道师与代码贡献者都是参与开源项目的方式，大家可以结合自己的实际情况选择不同的方式，都能为一个开源社区贡献自己的力量，也能得到开源社区的认可，间接打造自身影响力，最终助力职场。</strong></p>
<p>最后再次感谢RocketMQ社区对我的鼓励，最后用我的一句座右铭与大家共勉：心动不如行动，越努力越幸运，唯有坚持不懈。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>程序人生</tag>
        <tag>rocketmq</tag>
        <tag>开源</tag>
      </tags>
  </entry>
  <entry>
    <title>排序二叉树JAVA版实现</title>
    <url>/posts/3b6094a6.html</url>
    <content><![CDATA[<div id="vip-container"><p>1、排序二叉树特点</p>
<ul>
<li>根节点的值大于等于左子树的节点</li>
<li>根节点的值小于等于它右子树的节点。</li>
</ul>
<p>2、遍历二叉树的方法</p>
<ul>
<li>先序遍历：先遍历根节点，然后遍历左子树，再遍历右子树</li>
<li>中序遍历：先遍历左子树，然后遍历根节点，再遍历右子树</li>
<li>后续遍历  </li>
</ul>
<p><strong>如果要保证节点从小到大排序，采用中序遍历</strong>；</p>
<p>一言不合就写代码实现，提供详细的可视化角度（代码可运行）。</p>
<p>目前代码中，已经实现 新增单个元素、删除单个元素、中序遍历整颗树。</p>
<a id="more"></a>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package persistent.prestige.study.datastructures.tree;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line">import java.util.List;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 二叉树学习</span><br><span class="line"> * </span><br><span class="line">在数据结构里，</span><br><span class="line">就是对一棵二叉树所有结点的访问</span><br><span class="line">前序遵循“根左右”</span><br><span class="line">中序遵循“左根右”</span><br><span class="line">后序遵循“左右根”</span><br><span class="line">根：根节点</span><br><span class="line">左：左子女</span><br><span class="line">右：右子女</span><br><span class="line">如：一棵二叉树 ：</span><br><span class="line">           A</span><br><span class="line">          &#x2F; \</span><br><span class="line">         B   C</span><br><span class="line">        &#x2F; \ </span><br><span class="line">       D   E</span><br><span class="line">前序访问顺序就是：ABDEC（根一定第一个）</span><br><span class="line">中序访问顺序就是：DBEAC（根一定在中间）</span><br><span class="line">后序访问顺序就是：DEBCA（根一定在最后）</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * </span><br><span class="line"> * @author prestigeding@126.com</span><br><span class="line"> *</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BinaryTree&lt;E&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * </span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private static final long serialVersionUID &#x3D; -3970337667739333043L;</span><br><span class="line">	</span><br><span class="line">	private Comparator&lt;E&gt; comparator;</span><br><span class="line"></span><br><span class="line">	private TreeNode&lt;E&gt; root;</span><br><span class="line"></span><br><span class="line">	public BinaryTree() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public BinaryTree(Comparator&lt;E&gt; comparator) &#123;</span><br><span class="line">		super();</span><br><span class="line">		this.comparator &#x3D; comparator;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 增加元素</span><br><span class="line">	 * @param e</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public boolean add(E e) &#123;</span><br><span class="line">		if(e &#x3D;&#x3D; null) return false;</span><br><span class="line">		</span><br><span class="line">		if(root &#x3D;&#x3D; null ) &#123;</span><br><span class="line">			root &#x3D; new TreeNode&lt;E&gt;(e, null);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		add0(root, e);</span><br><span class="line">		return true;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * </span><br><span class="line">	 * </span><br><span class="line">	 *                          10</span><br><span class="line">	 *                     &#x2F;          \</span><br><span class="line">	 *                    3           18</span><br><span class="line">	 *                  &#x2F;   \        &#x2F;   \               </span><br><span class="line">	 *                 2     4      13    21       </span><br><span class="line">	 *                         \</span><br><span class="line">	 *                          9</span><br><span class="line">	 *                        &#x2F;   \</span><br><span class="line">	 *                       8     9 </span><br><span class="line">	 * </span><br><span class="line">	 * </span><br><span class="line">	 * @param root</span><br><span class="line">	 * @param e</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private TreeNode&lt;E&gt; add0(TreeNode&lt;E&gt; root, E e) &#123;</span><br><span class="line">		final TreeNode&lt;E&gt; curNode &#x3D; root;</span><br><span class="line">		</span><br><span class="line">		int cmp &#x3D; compare(e, curNode.value);</span><br><span class="line">		if(cmp &lt; 0 ) &#123; &#x2F;&#x2F;表示待插入的节点值，比当前节点值小</span><br><span class="line">			if(curNode.left &#x3D;&#x3D; null) &#123;</span><br><span class="line">				&#x2F;&#x2F;创建当前节点的左节点</span><br><span class="line">				TreeNode&lt;E&gt; newNode &#x3D; new TreeNode&lt;E&gt;(e, curNode);</span><br><span class="line">				curNode.left &#x3D; newNode;</span><br><span class="line">				return newNode;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return add0(curNode.left, e);&#x2F;&#x2F;遍历左子树</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; else &#123; &#x2F;&#x2F; 大于等于0，右子树</span><br><span class="line">			if(curNode.right &#x3D;&#x3D; null ) &#123;</span><br><span class="line">				&#x2F;&#x2F;创建当前节点的右节点</span><br><span class="line">				TreeNode&lt;E&gt; newNode &#x3D; new TreeNode&lt;E&gt;(e, curNode);</span><br><span class="line">				curNode.right &#x3D; newNode;</span><br><span class="line">				return newNode;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				return add0(curNode.right, e);&#x2F;&#x2F;遍历右子树</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 比较两个元素的大小</span><br><span class="line">	 * @param e1</span><br><span class="line">	 * @param e2</span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	private int compare(E e1, E e2) &#123;</span><br><span class="line">		return comparator &#x3D;&#x3D; null ?  ((Comparable&lt;E&gt;) e1 ).compareTo(e2) : comparator.compare(e1, e2);  </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * </span><br><span class="line">	 * 删除元素</span><br><span class="line">	 * @param e  </span><br><span class="line">	 * @return  如果返回ture,表示删除成功,如果返回false,表示删除失败，没有找到元素</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public boolean remove(E e) &#123;</span><br><span class="line">		if( e &#x3D;&#x3D; null ) return false;</span><br><span class="line">		</span><br><span class="line">		TreeNode&lt;E&gt; cur &#x3D; root;</span><br><span class="line">		int cmp;</span><br><span class="line">		while (cur !&#x3D; null ) &#123;</span><br><span class="line">			if(e.equals(cur.value)) &#123;</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			cmp &#x3D; compare(e, root.value);</span><br><span class="line">			if(cmp &lt; 0 ) &#123; &#x2F;&#x2F;表示待删除的节点值，比当前节点值小</span><br><span class="line">				cur &#x3D; cur.left;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				cur &#x3D; cur.right;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		if(cur !&#x3D; null ) &#123; &#x2F;&#x2F;找到了元素，需要删除该元素</span><br><span class="line">			TreeNode&lt;E&gt; cLeft &#x3D; cur.left;</span><br><span class="line">			TreeNode&lt;E&gt; cRight &#x3D; cur.right;</span><br><span class="line">			</span><br><span class="line">			if(cLeft !&#x3D; null ) &#123; &#x2F;&#x2F;如果被删除节点的左子树不为空，则将左子树放入当前节点的位置</span><br><span class="line">				remove0(cLeft, cur);</span><br><span class="line">				if(cLeft.right !&#x3D; null &amp;&amp;  cur.right !&#x3D; null) &#123; &#x2F;&#x2F;需要移动相应节点</span><br><span class="line">					TreeNode&lt;E&gt; wNode &#x3D; cLeft.right;</span><br><span class="line">					cLeft.right &#x3D; cur.right;</span><br><span class="line">					wNode.parent &#x3D; null;</span><br><span class="line">					TreeNode&lt;E&gt; newNode &#x3D; add0(cLeft, wNode.value);</span><br><span class="line">					newNode.left &#x3D; wNode.left;</span><br><span class="line">					newNode.right &#x3D; wNode.right;</span><br><span class="line">					wNode &#x3D; null;</span><br><span class="line">				&#125;</span><br><span class="line">				</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				remove0(cRight, cur);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;将当前节点释放，，help GC</span><br><span class="line">			cur.value &#x3D; null;</span><br><span class="line">			cur.right &#x3D; null;</span><br><span class="line">			cur.left &#x3D; null;</span><br><span class="line">			cur.parent &#x3D; null;</span><br><span class="line">			cur &#x3D; null;</span><br><span class="line">			</span><br><span class="line">			return true;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		return false;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		 </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	private void remove0(TreeNode&lt;E&gt; newNode, TreeNode&lt;E&gt; cur) &#123;</span><br><span class="line">		TreeNode&lt;E&gt; parent &#x3D; cur.parent;</span><br><span class="line">		newNode.parent &#x3D; parent;</span><br><span class="line">		if(cur.parent.left &#x3D;&#x3D; cur) &#123;</span><br><span class="line">			cur.parent.left &#x3D; newNode;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			cur.parent.right &#x3D; newNode;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 中序遍历</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public void middleOrderTraversal() &#123;</span><br><span class="line">		System.out.println(&quot;----------中序遍历开始---------\n&quot;);</span><br><span class="line">		if (root &#x3D;&#x3D; null) &#123;</span><br><span class="line">			System.out.print(&quot;二叉树&quot;);</span><br><span class="line">			System.out.println(&quot;----------中序遍历结束---------\n&quot;);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		middleOrderTraversal0(root);</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;\n----------中序遍历结束---------\n&quot;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 中序遍历</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private void middleOrderTraversal0(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line">		if (root &#x3D;&#x3D; null)</span><br><span class="line">			return;</span><br><span class="line"></span><br><span class="line">		final TreeNode&lt;E&gt; cur &#x3D; root;</span><br><span class="line">		if (cur.left !&#x3D; null) &#123;</span><br><span class="line">			middleOrderTraversal0(cur.left);</span><br><span class="line">			System.out.print(toObjectString(cur.value) + &quot;,&quot;);</span><br><span class="line">			middleOrderTraversal0(cur.right);</span><br><span class="line">		&#125; else if (cur.right !&#x3D; null) &#123;</span><br><span class="line">			System.out.print(cur.value + &quot;,&quot;);</span><br><span class="line">			middleOrderTraversal0(cur.right);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			&#x2F;&#x2F; 此时输出节点</span><br><span class="line">			System.out.print(cur.value + &quot;,&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public TreeNode&lt;E&gt; getRoot() &#123;</span><br><span class="line">		return root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setRoot(TreeNode&lt;E&gt; root) &#123;</span><br><span class="line">		this.root &#x3D; root;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private String toObjectString(E value) &#123;</span><br><span class="line">		return value &#x3D;&#x3D; null ? &quot;&quot; : value.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 二叉数</span><br><span class="line">	 * </span><br><span class="line">	 * @author Administrator</span><br><span class="line">	 *</span><br><span class="line">	 * @param &lt;E&gt;</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">	private final static class TreeNode&lt;E&gt; implements Serializable &#123;</span><br><span class="line"></span><br><span class="line">		private static final long serialVersionUID &#x3D; 6540618639489225256L;</span><br><span class="line"></span><br><span class="line">		public E value;</span><br><span class="line">		public TreeNode&lt;E&gt; left;</span><br><span class="line">		public TreeNode&lt;E&gt; right;</span><br><span class="line"></span><br><span class="line">		public TreeNode&lt;E&gt; parent;</span><br><span class="line"></span><br><span class="line">		public TreeNode(E value, TreeNode&lt;E&gt; parent) &#123;</span><br><span class="line">			super();</span><br><span class="line">			this.value &#x3D; value;</span><br><span class="line">			this.parent &#x3D; parent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public TreeNode(E value, TreeNode&lt;E&gt; left, TreeNode&lt;E&gt; right, TreeNode&lt;E&gt; parent) &#123;</span><br><span class="line">			super();</span><br><span class="line">			this.value &#x3D; value;</span><br><span class="line">			this.left &#x3D; left;</span><br><span class="line">			this.right &#x3D; right;</span><br><span class="line">			this.parent &#x3D; parent;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Override</span><br><span class="line">		public String toString() &#123;</span><br><span class="line">			if(value !&#x3D; null)</span><br><span class="line">				return value.toString();</span><br><span class="line">			</span><br><span class="line">			return super.toString();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;** *******************测试 start ***************************&#x2F;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		System.out.println(&quot;测试开始&quot;);</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;		BinaryTree&lt;Integer&gt; t &#x3D; new BinaryTree&lt;Integer&gt;();</span><br><span class="line">&#x2F;&#x2F;		t.setRoot(t.initTree());</span><br><span class="line">&#x2F;&#x2F;		t.middleOrderTraversal();</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;先研究一下 Comparator o1 &gt; o2 的排序逻辑</span><br><span class="line">		&#x2F;&#x2F;testSort();</span><br><span class="line">		</span><br><span class="line">&#x2F;*		 *                          10</span><br><span class="line">		 *                     &#x2F;              \</span><br><span class="line">		 *                    3                18</span><br><span class="line">		 *                  &#x2F;   \            &#x2F;   \               </span><br><span class="line">		 *                 2     4          13    21       </span><br><span class="line">		 *                         \       &#x2F;  \  </span><br><span class="line">		 *                          9     11    15  </span><br><span class="line">		 *                        &#x2F;   \</span><br><span class="line">		 *                       8     9 </span><br><span class="line">*&#x2F;</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F; add 方法测试</span><br><span class="line">		BinaryTree&lt;Integer&gt; t &#x3D; new BinaryTree&lt;Integer&gt;();</span><br><span class="line">		</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(10));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(18));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(3));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(2));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(4));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(8));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(9));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(9));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(21));</span><br><span class="line">&#x2F;&#x2F;		t.add(new Integer(13));</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		t.add(new Integer(10));</span><br><span class="line">		t.add(new Integer(18));</span><br><span class="line">		t.add(new Integer(3));</span><br><span class="line">		t.add(new Integer(9));</span><br><span class="line">		t.add(new Integer(8));</span><br><span class="line">		t.add(new Integer(2));</span><br><span class="line">		t.add(new Integer(21));</span><br><span class="line">		t.add(new Integer(4));</span><br><span class="line">		t.add(new Integer(9));</span><br><span class="line">		t.add(new Integer(13));</span><br><span class="line">		t.add(new Integer(11));</span><br><span class="line">		t.add(new Integer(15));</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;查看数结构，中序遍历</span><br><span class="line">		t.middleOrderTraversal();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;测试删除</span><br><span class="line">		System.out.println(&quot;删除节点18&quot;);</span><br><span class="line">		t.remove(new Integer(18));</span><br><span class="line">		System.err.println(&quot;删除节点18号的排序二叉树&quot;);</span><br><span class="line">		t.middleOrderTraversal();</span><br><span class="line">		</span><br><span class="line">		System.out.println(&quot;测试结束&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 当用升序排序时，则 o1 &gt; o2 时要返回大于0的数</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public static void testSort() &#123;</span><br><span class="line">		</span><br><span class="line">		List&lt;Integer&gt; a &#x3D; new ArrayList&lt;Integer&gt;();</span><br><span class="line">		a.add(1);</span><br><span class="line">		a.add(8);</span><br><span class="line">		a.add(9);</span><br><span class="line">		a.add(3);</span><br><span class="line">		a.add(5);</span><br><span class="line">		</span><br><span class="line">		Collections.sort(a, new Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public int compare(Integer o1, Integer o2) &#123;</span><br><span class="line">				</span><br><span class="line">				return o1.intValue() &gt; o2.intValue() ? 1 : -1;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		System.out.println(a);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 用来测试的，后续会完善 加入元素</span><br><span class="line">	 * </span><br><span class="line">	 * </span><br><span class="line">	 *                          </span><br><span class="line">	 *                          10</span><br><span class="line">	 *                     &#x2F;          \</span><br><span class="line">	 *                    3           18</span><br><span class="line">	 *                  &#x2F;   \        &#x2F;   \               </span><br><span class="line">	 *                 2     4      13    21       </span><br><span class="line">	 *                         \</span><br><span class="line">	 *                          9</span><br><span class="line">	 *                        &#x2F;   \</span><br><span class="line">	 *                       8     9 </span><br><span class="line">	 *                       </span><br><span class="line">	 *                       </span><br><span class="line"></span><br><span class="line">	 * @return</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	@Deprecated</span><br><span class="line">	public TreeNode&lt;Integer&gt; initTree() &#123;</span><br><span class="line">		TreeNode&lt;Integer&gt; _root &#x3D; new TreeNode&lt;Integer&gt;(new Integer(10), null); &#x2F;&#x2F; 根节点</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l3 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(3), _root);</span><br><span class="line">		_root.left &#x3D; l3;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l2 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(2), l3);</span><br><span class="line">		l3.left &#x3D; l2;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l4 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(4), l3);</span><br><span class="line">		l3.right &#x3D; l4;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l91 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(9), l4);</span><br><span class="line">		l4.right &#x3D; l91;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l8 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(8), l91);</span><br><span class="line">		l91.left &#x3D; l8;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l92 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(9), l91);</span><br><span class="line">		l91.right &#x3D; l92;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l18 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(18), _root);</span><br><span class="line">		_root.right &#x3D; l18;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l13 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(13), l18);</span><br><span class="line">		l18.left &#x3D; l13;</span><br><span class="line"></span><br><span class="line">		TreeNode&lt;Integer&gt; l21 &#x3D; new TreeNode&lt;Integer&gt;(new Integer(21), l18);</span><br><span class="line">		l18.right &#x3D; l21;</span><br><span class="line"></span><br><span class="line">		return _root;</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;** *******************测试 end ***************************&#x2F;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>探究java8流收集数据原理</title>
    <url>/posts/bfa9fca1.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文揭示如何学习一门新技术，从示例入手，重点阐述Stream#collect方法的实现原理，为更好的使用java8中流来收集数据。</p>
<p>我们在前面的文章中反复使用的场景：获取菜单中所有菜品的名称，返回一个集合，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_toList</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; names = menu.stream().map(Dish::getName)</span><br><span class="line">                        .collect(Collectors.toList()); <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(String s : names) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Stream.collect这个终端操作进行数据收集，至于如何收集，则由该方法的参数来决定(Collector)，即行为参数化。</p>
<p>代码@1：collect(Collectors.toList()) 的意思就是返回List，这里涉及到两个关键，一个是Stream#collect方法，另外一个就是其参数Collectors.toList()。</p>
<p>接下来我们将以上述两个突破点来揭开如何使用java8的流来收集数据。</p>
<h2 id="1、Stream-collect"><a href="#1、Stream-collect" class="headerlink" title="1、Stream#collect"></a>1、Stream#collect</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ReferencePipeline#collect</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> P_OUT, A, R&gt; collector)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    A container;</span><br><span class="line">    <span class="keyword">if</span> (isParallel()</span><br><span class="line">            &amp;&amp; (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))</span><br><span class="line">            &amp;&amp; (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) &#123;   <span class="comment">// @2</span></span><br><span class="line">        container = collector.supplier().get();                                                                 <span class="comment">// @3</span></span><br><span class="line">        BiConsumer&lt;A, ? <span class="keyword">super</span> P_OUT&gt; accumulator = collector.accumulator();</span><br><span class="line">        forEach(u -&gt; accumulator.accept(container, u));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;                                                                                                     <span class="comment">// @4</span></span><br><span class="line">        container = evaluate(ReduceOps.makeRef(collector));                                                                                              </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)                    <span class="comment">// @5</span></span><br><span class="line">           ? (R) container</span><br><span class="line">           : collector.finisher().apply(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：函数声明，该方法返回的结果类型为R，传入的行为参数接口为Collector。<br>代码@2：判断是否符合并行化累积与规约的条件。</p>
<ul>
<li>是否是并行流，例如上例中创建流的代码为menu.stream()，该方法的流是非并行化流，如果要支持并行化执行，需要满足的第一个条件就是需要使用menu.parallelStream()方法返回的流。</li>
<li>Collector(收集器，行为化参数)中收集器行为集合中是否包含Characteristics.CONCURRENT(并行执行)，如果不包含该行为，则不支持并行执行。</li>
<li>原始流是否有顺序 或 者 收集器的行为集合中明确包含Characteristics.UNORDERED(不要求顺序性)。<br>上述三个条件必须同时满足，才能并行执行，否则串行执行。</li>
</ul>
<p>代码@3：并行执行收集动作。</p>
<p>代码@4：串行执行收集动作。</p>
<p>代码@5：如果收集器收集行为集合中包含Characteristics.IDENTITY_FINISH，则直接返回原始值，否则使用Collector.finishier()方式对计算的值进行函数式计算。</p>
<p>通过上面的代码，我们应该对Characteristics枚举类型中的3个值不难得出如下类型：</p>
<ul>
<li>CONCURRENT<br>收集器行为，表示收集其中的累积函数是否支持并行执行。</li>
<li>Characteristics.UNORDERED<br>收集器行为，表示整个收集期间，没有顺序要求。</li>
<li>Characteristics.IDENTITY_FINISH<br>收集器行为，表示可以忽略Collector.finsher()定义的最终转换函数，直接返回累积之后的结果即可。</li>
</ul>
<blockquote>
<p>疑问？代码@3,这段代码不是很好理解，该怎么继续往下深入呢？</p>
</blockquote>
<p>针对上面看不太懂的代码，我的处理办法是先转移思路，看一下Collector接口以及示例中Collectos.toList()返回的收集器是什么(重点关注返回的Collector中具体属性)。</p>
<a id="more"></a>

<h2 id="2、Collector接口"><a href="#2、Collector接口" class="headerlink" title="2、Collector接口"></a>2、Collector接口</h2><p><img src="https://img-blog.csdnimg.cn/20190604211337662.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>收集器中的泛型参数说明如下：</p>
<ul>
<li>T ：累积器中一个操作数类型</li>
<li>A： 累积器中的初始值类型</li>
<li>R：返回值的类型，例如List&lt; R &gt;。</li>
</ul>
<p>其属性一览如下：</p>
<ul>
<li>Supplier&lt; A &gt; supplier()<br>该函数式接口，大家应该都非常熟悉了，其函数声明如下：() -&gt; T，通常用于构建对象，那这里是构建什么对象呢？这是下一个待解疑问。</li>
<li>BiConsumer&lt;A, T&gt; accumulator()<br>从名字命名来看，应该是返回累积器，（T,U）-&gt; void。通常用于输入两个参数，对其进行处理，但返回void类型。</li>
<li>BinaryOperator&lt; A &gt; combiner()<br>从名字命令来看，应该是组合器（请参考流计算函数reduce)。</li>
<li>Function&lt;A, R&gt; finisher()<br>最终函数，如果收集器行为包含IDENTITY_FINISH，则无需使用该函数对累积器产生的结果进行处理，否则使用该函数对累积器结果进行最后的处理。</li>
<li>Set&lt; Characteristics &gt; characteristics()<br>累积器行为，在上文已做详细介绍。</li>
</ul>
<p>其supplier函数到底是干什么的呢？对上面的方法都是基于名字来推测的（当然JDK代码非常优雅，根据名字去猜测，准确度还是很高的），但如何确认呢？这个时候我们还是结合Collectos.toList()方法返回的Collector来做进一步推断。</p>
<h2 id="3、Collectors-toList"><a href="#3、Collectors-toList" class="headerlink" title="3、Collectors.toList()"></a>3、Collectors.toList()</h2><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collector&lt;T, ?, List&lt;T&gt;&gt; toList() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CollectorImpl&lt;&gt;((Supplier&lt;List&lt;T&gt;&gt;) ArrayList::<span class="keyword">new</span>, List::add,</span><br><span class="line">                               (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;,</span><br><span class="line">                               CH_ID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Collector的第一个参数Supplier，在这里为ArrayList::new，即调用supper.get()方法将返回一个List。</li>
<li>Collector的第二个参数accumulator:累积器，这里是List:add方法。</li>
<li>Collector的第三个参数combiner:组合器，这里就是(left, right) -&gt; {left.addAll(right);return left;}</li>
<li>Collector的第四个函数characteristics：收集器的行为，这里为CH_IL，其选项为：IDENTITY_FINISH。</li>
</ul>
<p>有了上面这些知识，我们再来看如下这段代码：<br><img src="https://img-blog.csdnimg.cn/2019060421180264.png" alt="在这里插入图片描述"><br>1、A container：累积器的初始值，如果使用Collectors.toList()，则这里会返回List<T>的对象。<br>2、获取collector中定义的累积器。<br>3、遍历流，执行累积器动作，其中形式参数u，代表流中的一个个元素。</p>
<p>至于forEach方法，底层流的具体实现，本文就不再往深探究。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>java8 使用流来收集数据的基本用法：</p>
<ul>
<li>使用流stream的collect对象进行数据收集，其参数为Collector函数是编程接口，具体的收集逻辑由该接口来指定。</li>
<li>流的收集其具备基本的属性即作用：<ul>
<li>Supplier&lt; A &gt; supplier()<br>通过该函数式编程接口，返回累积器的初始值。</li>
<li>BiConsumer&lt;A, T&gt; accumulator<br>累积器函数。</li>
<li>BinaryOperator&lt; A &gt; combiner<br>组合器，可以参考函数式编程接口的reduce方法。</li>
<li>Set&lt; Characteristics &gt; characteristics<br>收集器行为。</li>
</ul>
</li>
<li>java8中的Collectors提供了很多默认的收集器，例如Collectors.toList()方法，下一节我们会根据该类，详细介绍在java8中默认提供的收集器，指导我们如何使用java8中的流来收集数据。</li>
</ul>
<p>下一节，将以Collectos类为入口，详细介绍java8中默认提供的收集器，已经如何使用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Lambda</tag>
        <tag>流计算</tag>
      </tags>
  </entry>
  <entry>
    <title>数值流、Stream创建与Optional类的使用</title>
    <url>/posts/fcb673e6.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、数值流"><a href="#1、数值流" class="headerlink" title="1、数值流"></a>1、数值流</h2><p>不知大家还记不得，在介绍函数式编程接口中为了避免基础数据类型的装箱/拆箱带来的性能损耗，特意为函数式接口引入了基础数据类型的函数式编程接口，例如IntPredicate、LongPredicate、DoublePredicate。同样，流API也考虑到基本数据类型的装箱/拆箱会带来性能损耗，引入了数值流，例如IntStream、LongStream、DoubleStream。</p>
<h3 id="1-1-原始数据特化流"><a href="#1-1-原始数据特化流" class="headerlink" title="1.1 原始数据特化流"></a>1.1 原始数据特化流</h3><p>java8中提供了3个原始数据特化流，分别为IntStream、LongStream、DoubleStream。本文将以IntStream进行讲解，其他流类似，只是数据类型分别代表Long或Double。</p>
<h4 id="1-1-1-映射到数据流"><a href="#1-1-1-映射到数据流" class="headerlink" title="1.1.1 映射到数据流"></a>1.1.1 映射到数据流</h4><p>首先我们还是从一个示例开始本节的学习：计算菜单中所有菜品的卡路里之和。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_reduce_caluli</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">                    .map(Dish::getCalories)</span><br><span class="line">                    .reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(<span class="string">&quot;菜品中的总卡路里：&quot;</span> + calories);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面包含了一个基本数据类型的装箱/拆箱动作，java8的流API提供了mapToInt方法，直接返回int类型的流</p>
<p>我们先稍微看一下mapToInt的方法声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">mapToInt</span><span class="params">(ToIntFunction&lt;? <span class="keyword">super</span> T&gt; mapper)</span></span></span><br></pre></td></tr></table></figure>
<p>接受一个T-&gt;int的函数式编程接口，直接返回IntStream流对象，而且IntStream本身提供了一些常用的聚合函数，例如sum。<br>使用IntStream来实现计算菜单中所有菜品的卡路里之和，其示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_reduce_caluli_intStream</span><span class="params">(List&lt;Dish&gt; menu)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> calories = menu.stream()</span><br><span class="line">            .mapToInt(Dish::getCalories)</span><br><span class="line">            .sum();</span><br><span class="line">    System.out.println(<span class="string">&quot;菜品中的总卡路里：&quot;</span> + calories);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-2-转换回对象流"><a href="#1-1-2-转换回对象流" class="headerlink" title="1.1.2 转换回对象流"></a>1.1.2 转换回对象流</h4><p>使用了特化流例如IntStream后，将不能再自动转换为其对应的封装对象流Stream&lt; T &gt;了，我们可以随意从IntStream对象中对应的通用方法的函数声明，例如IntStream#map函数的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">IntStream <span class="title">map</span><span class="params">(IntUnaryOperator mapper)</span></span>;</span><br></pre></td></tr></table></figure>
<p>只能接受int -&gt; int的函数式编程接口，如果想将IntStream转回到Stream&lt; Integer &gt;，该如何处理呢？</p>
<p>IntStream提供了boxed()方法来实现将基础数据类型转换回对应的包装类型的流。</p>
<h4 id="1-1-3-常用函数"><a href="#1-1-3-常用函数" class="headerlink" title="1.1.3 常用函数"></a>1.1.3 常用函数</h4><p>Stream中定义的方法，IntStream也可以使用，例如map、flatMap、distinict等，IntStream除这些之外，还提供了常用的聚合函数，例如sum、min、max、average(平均数)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">OptionalDouble <span class="title">average</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">OptionalInt <span class="title">max</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">OptionalInt <span class="title">min</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>有关Optional相关的类将在下文详细介绍。</p>
<p>另外除了上面提到的聚合函数，IntStream还提供了两个与数值范围的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">range</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">rangeClosed</span><span class="params">(<span class="keyword">int</span> startInclusive, <span class="keyword">int</span> endExclusive)</span></span>;</span><br></pre></td></tr></table></figure>
<p>rangeClosed与range的区别就是rangeClosed包含结束边界，举一个简单示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_range</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = IntStream.range(<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">                        .filter( i -&gt; i % <span class="number">2</span> == <span class="number">0</span> )</span><br><span class="line">                         .count();</span><br><span class="line">    System.out.println(<span class="string">&quot;count:&quot;</span> + count);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算【1，100）中包含的偶数个数，将输出49。如果将range(1,100)修改为rangeClosed(1,100)，在输出的个数为50。</p>
<h2 id="2、构建流"><a href="#2、构建流" class="headerlink" title="2、构建流"></a>2、构建流</h2><h3 id="2-1-通过值构建流"><a href="#2-1-通过值构建流" class="headerlink" title="2.1 通过值构建流"></a>2.1 通过值构建流</h3><p>java 8的Stream提供了两个重载的of函数来显示的构建流，其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T t)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-通过数组构建流"><a href="#2-2-通过数组构建流" class="headerlink" title="2.2 通过数组构建流"></a>2.2 通过数组构建流</h3><p>通过Arrays.stream构建流，其声明如下：<br>Arrays#stream</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-通过文件流"><a href="#2-3-通过文件流" class="headerlink" title="2.3 通过文件流"></a>2.3 通过文件流</h3><p>可以通过文件流创建流，在java.nio.file.Files类中定义了如下创建流的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">list</span><span class="params">(Path dir)</span> <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">walk</span><span class="params">(Path start, <span class="keyword">int</span> maxDepth, FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">walk</span><span class="params">(Path start, FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Path&gt; <span class="title">find</span><span class="params">(Path start, <span class="keyword">int</span> maxDepth,BiPredicate&lt;Path, BasicFileAttributes&gt; matcher,   </span></span></span><br><span class="line"><span class="function"><span class="params">    FileVisitOption... options)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path, Charset cs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">lines</span><span class="params">(Path path)</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure>
<p>下面我们举一个示例：找出一个文件中不同词的个数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_file_stram</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span>(Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;d:/tmp/words.txt&quot;</span>), Charset.defaultCharset())) &#123;  </span><br><span class="line">        uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot;&quot;</span> )))</span><br><span class="line">                .distinct()</span><br><span class="line">                .count();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;不重复字符个数：&quot;</span> + uniqueWords);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="2-4-函数生成流：创建无限流"><a href="#2-4-函数生成流：创建无限流" class="headerlink" title="2.4 函数生成流：创建无限流"></a>2.4 函数生成流：创建无限流</h3><p>Stream API提供了两个静态方法从函数生成流：iterate、generate，我们先来看一下其函数声明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="2-4-1-iterate"><a href="#2-4-1-iterate" class="headerlink" title="2.4.1 iterate"></a>2.4.1 iterate</h4><p>iterate方法的第一个参数类型为T，表示其初始值，第二个参数如下：<br><img src="https://img-blog.csdnimg.cn/20190602202005106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即其函数式声明为为T-T。其示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, a -&gt; a + <span class="number">2</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：由于是无限流，故千万记得使用limit截断流，否则会无限循环下去。</p>
</blockquote>
<h4 id="2-4-2-generate"><a href="#2-4-2-generate" class="headerlink" title="2.4.2 generate"></a>2.4.2 generate</h4><p>其参数为Supplier&lt; T &gt;，其定义如下：<br><img src="https://img-blog.csdnimg.cn/20190602202222354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>即构造一个T类型的对象，举例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_iterate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Stream.iterate(<span class="number">0</span>, a -&gt; a + <span class="number">2</span>)</span><br><span class="line">            .limit(<span class="number">10</span>)</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-集合对象的stream"><a href="#2-5-集合对象的stream" class="headerlink" title="2.5 集合对象的stream"></a>2.5 集合对象的stream</h3><p>这个在前面的示例中用的最多，就不做过多介绍。</p>
<h2 id="3、Optional类"><a href="#3、Optional类" class="headerlink" title="3、Optional类"></a>3、Optional类</h2><p>为了更优雅的处理null值，避免空指针错误，java8中引入Optional类。<br><img src="https://img-blog.csdnimg.cn/20190602202332539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来对这些方法一一做个介绍。</p>
<ul>
<li>public static&lt; T&gt; Optional&lt; T&gt; empty()<br>创建一个Optional对象，其内部持有的对象为null。</li>
<li>public static &lt; T &gt; Optional&lt; T &gt; of(T value)<br>使用value的值，创建一个Optional对象。</li>
<li>public static &lt; T &gt; Optional&lt; T &gt; ofNullable(T value)<br>使用v去创建一个Optional对象，如果value为null，则返回empty()。</li>
<li>public T get()<br>从Optional对象获取内嵌的对象，如果为空，则抛出NoSuchElementException。</li>
<li>public boolean isPresent()<br>判断Optional对象中包含的值是否存在。</li>
<li>public void ifPresent(Consumer<? super T> consumer)
如果Optional包裹的对象存在，则消费该对象。Consumer<?>的函数式编程接口：T -&gt; void。</li>
<li>public Optional&lt; T &gt; filter(Predicate&lt;? super T&gt; predicate)<br>如果Optional中包裹的对象为空，则返回自身，否则如果包裹的对象满足predicate表达式，则返回自身，否则返回empty()。</li>
<li>public&lt; U &gt; Optional&lt; U &gt; map(Function&lt;? super T, ? extends U&gt; mapper)<br>如果Optional对象中包裹的对象为空，则返回empty()，否则运用(T-U)，包裹U,当然如果U为空，则返回empty()。</li>
<li>public&lt; U &gt; Optional&lt; U &gt; flatMap(Function&lt;? super T, Optional&lt; U &gt;&gt; mapper)<br>如果Option对象中包裹的对象为空，则返回empty()，否则使用对Optional中的包裹的对象value应用Function，最终返回Optional对象。</li>
<li>public T orElse(T other)<br>返回Optional中包裹的对象，如果其值为空，则返回other。</li>
<li>public T orElseGet(Supplier&lt;? extends T&gt; other)<br>返回Optional中包裹的对象，如果其值为空，则返回 Supplier函数式编辑接口中创建的值。</li>
<li>public &lt; X extends Throwable&gt; T orElseThrow(Supplier&lt; ? extends X&gt; exceptionSupplier) throws X<br>返回Optional中包裹的对象，如果其值为空，则抛出自定义一次，由Supplier函数式编程接口返回。</li>
</ul>
<p> 其示例代码如下：<br> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test_option</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    Optional&lt;String&gt; value = Optional.ofNullable(data.get(<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">    <span class="comment">// 如果存在userName值，则输出</span></span><br><span class="line">    value.ifPresent(System.out::println);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本文就介绍到这里了，本文详细介绍了java8中的数值流、Stream的创建以及java8中Optional类的使用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Lambda</tag>
        <tag>流计算</tag>
      </tags>
  </entry>
  <entry>
    <title>数据异构之 Canal 初探（技巧篇）</title>
    <url>/posts/4d11b991.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>源码分析 Canal 系列开始了，一个全新的系列，即能探讨 canal 本身的实现原理，也是笔者源码阅读技巧的展示。</p>
</blockquote>
<h2 id="1、应用场景"><a href="#1、应用场景" class="headerlink" title="1、应用场景"></a>1、应用场景</h2><p>提到 Canal，大家应该都能想到这是一个用于解析 MySQL binlog 日志的工具，并将 MySQL 数据库中数据同步到其他存储介质中，例如 Elasticsearch。</p>
<p>即 Canal 一个非常常用的使用场景：数据异构，一种更高级别的数据读写分离架构设计方法。</p>
<p>随着业务不断的发展，企业发展到一定阶段，发现单体的关系型数据库已无法支撑业务高速发展带来数据不断累积的压力，从而会诞生出一种设计架构：分库分表。分库分表对缓解单库数据库压力确实是一种非常好的解决方案，但又衍生出另外一种困境，关联查询不友好，甚至跨库JOIN就更加如此。</p>
<p>举例说明如下： 例如一个订单系统，通常有两类用户需要去查询订单，一类是顾客，一类是商家，在对数据库进行分库分表时，如果以顾客(buy_id)进行分库的话，同一个商家的订单数据会分布在不同的库中，如果以商家(shop_id)进行分库的话，同一个用户购买的所有订单数据将会分布子啊不同的库中，这样进行关联查询，就必然需要跨库进行join，其成本都会偏高。而且上面的场景只能满足一方的需求，那如何是好呢？</p>
<p>Canal 这个时候就闪亮登场了，在电商设计中，其实商家、顾客会被拆分成两个不同的服务，我们可以为两个不同的服务搭建不同的数据库集群，我们可以用户订单库、商家订单库进行分库，以用户订单库为主库，当用户在订单系统下单后，数据进入到用户订单库中，然后可以通过 canal 监听数据库的binlog日志，然后将数据再同步到商家订单库，而用户订单库以用户ID为维度进行分库，商家订单库以商家ID做分库，完美解决问题。</p>
<h2 id="2、架构设计原理"><a href="#2、架构设计原理" class="headerlink" title="2、架构设计原理"></a>2、架构设计原理</h2><p>在了解到 Canal 的基本使用场景后，我们通过 canal 官方文档，去探究一下其核心架构设计理念，以此打开进入 Canal 的神秘世界中。</p>
<a id="more"></a>

<p>首先我们简单看一下 MySQL 的主从同步原理：<br><img src="https://img-blog.csdnimg.cn/20200614170111529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上面的图中可以看成主从复制主要分成三个步骤：</p>
<ul>
<li><p>master将改变记录到二进制日志(binary log ) 中（ 这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</p>
</li>
<li><p>slave将master的binary log events拷贝到它的中继日志(relay log)</p>
</li>
<li><p>slave重做中继日志中的事件，将改变反映它自己的数据。</p>
</li>
</ul>
<p>基于 MySQL 这种数据同步机制，那 Canal 的设计目标主要就是实现数据的同步，即数据的复制，从上面的图自然而然的想到了如下的设计：<br><img src="https://img-blog.csdnimg.cn/20200614170239924.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>原理相对比较简单：</p>
<ul>
<li><p>canal 模拟 mysql slave 的交互协议，伪装自己为 mysql slave，向 mysql master 发送 dump 协议</p>
</li>
<li><p>mysql master 收到 dump 请求，开始推送 binary log 给 slave (canal)</p>
</li>
<li><p>canal解析 binary log 对象(原始为byte流)</p>
</li>
</ul>
<p>接下来我们来看一下 Canale 的整体组成部分：<br><img src="https://img-blog.csdnimg.cn/20200614170338258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>说明：</p>
<ul>
<li><p>server代表一个canal运行实例，对应于一个jvm</p>
</li>
<li><p>instance对应于一个数据队列 （1个server对应1..n个instance)</p>
</li>
</ul>
<p>instance模块：</p>
<ul>
<li><p>eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</p>
</li>
<li><p>eventSink (Parser和Store链接器，进行数据过滤，加工，分发的工作)</p>
</li>
<li><p>eventStore (数据存储)</p>
</li>
<li><p>metaManager (增量订阅&amp;消费信息管理器)</p>
</li>
</ul>
<blockquote>
<p>这些组件我暂时不打算深入去研究，因为在目前这个阶段我自己也不清楚，但这个是我后续需要学习研究的重点。</p>
</blockquote>
<h2 id="3、在-IntelliJ-IDEA-中运行-Canal-Demo"><a href="#3、在-IntelliJ-IDEA-中运行-Canal-Demo" class="headerlink" title="3、在 IntelliJ IDEA 中运行 Canal Demo"></a>3、在 IntelliJ IDEA 中运行 Canal Demo</h2><p>在 Linux 环境中安装 canal 比较简单，大家可以安装官方手册一步一步操作即可，在这里我就不重复介绍，本节主要的目的是希望在开发工具中运行 Canal 的 Demo，以便后续在研究源码的过程中遇到难题时可以进行 Debug。</p>
<blockquote>
<p>温馨提示：大家在学习过程中，可以根据官方文档先安装一遍 canal，对理解 Canal 的核心组件有着非常重要的帮助。</p>
</blockquote>
<p>首先先从 canal 源码中寻找官方提供的 Demo，其示例代码在 example 包中，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200614170556995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但是另外稍微遗憾的是 canal 提供提供的示例代码中只包含了 client 端相关的代码，并没有包含服务端(server)，故我们将目光放到其单元测试中，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200614170614672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下来我根据官方的一些提示，结合自己的理解，编写出如下测试代码，在 IDEA 开发工具中实现运行 Canal 相关的 Demo。下面的代码已通过测试，可直接使用。</p>
<p>1、Canal Server Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.otter.canal.server;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.core.CanalInstance;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.core.CanalInstanceGenerator;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.manager.CanalInstanceWithManager;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.manager.model.Canal;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.instance.manager.model.CanalParameter;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.server.embedded.CanalServerWithEmbedded;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.server.netty.CanalServerWithNetty;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CanalServerTestMain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String ZK_CLUSTER_ADDRESS      = <span class="string">&quot;127.0.0.1:2181&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DESTINATION   = <span class="string">&quot;example&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String DETECTING_SQL = <span class="string">&quot;select 1&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_ADDRESS = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME      = <span class="string">&quot;canal&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD      = <span class="string">&quot;canal&quot;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String FILTER        = <span class="string">&quot;.\\*\\\\\\\\..\\*&quot;</span>;</span><br><span class="line">    <span class="comment">/** 默认 500s 后关闭 */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUN_TIME = <span class="number">120</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer header        = ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">private</span> CanalServerWithNetty nettyServer;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CanalServerTestMain test = <span class="keyword">new</span> CanalServerTestMain();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.setUp();</span><br><span class="line">            System.out.println(<span class="string">&quot;start&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sleep&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(RUN_TIME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ee) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            test.tearDown();</span><br><span class="line">            System.out.println(<span class="string">&quot;end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CanalServerWithEmbedded embeddedServer = <span class="keyword">new</span> CanalServerWithEmbedded();</span><br><span class="line">        embeddedServer.setCanalInstanceGenerator(<span class="keyword">new</span> CanalInstanceGenerator() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> CanalInstance <span class="title">generate</span><span class="params">(String destination)</span> </span>&#123;</span><br><span class="line">                Canal canal = buildCanal();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> CanalInstanceWithManager(canal, FILTER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        nettyServer = CanalServerWithNetty.instance();</span><br><span class="line">        nettyServer.setEmbeddedServer(embeddedServer);</span><br><span class="line">        nettyServer.setPort(<span class="number">11111</span>);</span><br><span class="line">        nettyServer.start();</span><br><span class="line">        <span class="comment">// 启动 instance</span></span><br><span class="line">        embeddedServer.start(<span class="string">&quot;example&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nettyServer.stop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Canal <span class="title">buildCanal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Canal canal = <span class="keyword">new</span> Canal();</span><br><span class="line">        canal.setId(<span class="number">1L</span>);</span><br><span class="line">        canal.setName(DESTINATION);</span><br><span class="line">        canal.setDesc(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        CanalParameter parameter = <span class="keyword">new</span> CanalParameter();</span><br><span class="line">        <span class="comment">//parameter.setZkClusters(Arrays.asList(ZK_CLUSTER_ADDRESS));</span></span><br><span class="line">        parameter.setMetaMode(CanalParameter.MetaMode.MEMORY);</span><br><span class="line">        parameter.setHaMode(CanalParameter.HAMode.HEARTBEAT);</span><br><span class="line">        parameter.setIndexMode(CanalParameter.IndexMode.MEMORY);</span><br><span class="line">        parameter.setStorageMode(CanalParameter.StorageMode.MEMORY);</span><br><span class="line">        parameter.setMemoryStorageBufferSize(<span class="number">32</span> * <span class="number">1024</span>);</span><br><span class="line">        parameter.setSourcingType(CanalParameter.SourcingType.MYSQL);</span><br><span class="line">        parameter.setDbAddresses(Arrays.asList(<span class="keyword">new</span> InetSocketAddress(MYSQL_ADDRESS, <span class="number">3306</span>),</span><br><span class="line">                <span class="keyword">new</span> InetSocketAddress(MYSQL_ADDRESS, <span class="number">3306</span>)));</span><br><span class="line">        parameter.setDbUsername(USERNAME);</span><br><span class="line">        parameter.setDbPassword(PASSWORD);</span><br><span class="line">        parameter.setSlaveId(<span class="number">1234L</span>);</span><br><span class="line">        parameter.setDefaultConnectionTimeoutInSeconds(<span class="number">30</span>);</span><br><span class="line">        parameter.setConnectionCharset(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        parameter.setConnectionCharsetNumber((<span class="keyword">byte</span>) <span class="number">33</span>);</span><br><span class="line">        parameter.setReceiveBufferSize(<span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">        parameter.setSendBufferSize(<span class="number">8</span> * <span class="number">1024</span>);</span><br><span class="line">        parameter.setDetectingEnable(<span class="keyword">false</span>);</span><br><span class="line">        parameter.setDetectingIntervalInSeconds(<span class="number">10</span>);</span><br><span class="line">        parameter.setDetectingRetryTimes(<span class="number">3</span>);</span><br><span class="line">        parameter.setDetectingSQL(DETECTING_SQL);</span><br><span class="line">        canal.setCanalParameter(parameter);</span><br><span class="line">        <span class="keyword">return</span> canal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Canal Client Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.otter.canal.example;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnectors;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.client.CanalConnector;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.common.utils.AddressUtils;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.Message;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.Column;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.otter.canal.protocol.CanalEntry.EventType;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCanalClientExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建链接</span></span><br><span class="line">        CanalConnector connector = CanalConnectors.newSingleConnector(<span class="keyword">new</span> InetSocketAddress(AddressUtils.getHostIp(),</span><br><span class="line">                <span class="number">11111</span>), <span class="string">&quot;example&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> batchSize = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">int</span> emptyCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connector.connect();</span><br><span class="line">            connector.subscribe(<span class="string">&quot;.*\\..*&quot;</span>);</span><br><span class="line">            connector.rollback();</span><br><span class="line">            <span class="keyword">int</span> totalEmptyCount = <span class="number">3000</span>;</span><br><span class="line">            <span class="keyword">while</span> (emptyCount &lt; totalEmptyCount) &#123;</span><br><span class="line">                Message message = connector.getWithoutAck(batchSize); <span class="comment">// 获取指定数量的数据</span></span><br><span class="line">                <span class="keyword">long</span> batchId = message.getId();</span><br><span class="line">                <span class="keyword">int</span> size = message.getEntries().size();</span><br><span class="line">                <span class="keyword">if</span> (batchId == -<span class="number">1</span> || size == <span class="number">0</span>) &#123;</span><br><span class="line">                    emptyCount++;</span><br><span class="line">                    System.out.println(<span class="string">&quot;empty count : &quot;</span> + emptyCount);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    emptyCount = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">// System.out.printf(&quot;message[batchId=%s,size=%s] \n&quot;, batchId, size);</span></span><br><span class="line">                    printEntry(message.getEntries());</span><br><span class="line">                &#125;</span><br><span class="line">                connector.ack(batchId); <span class="comment">// 提交确认</span></span><br><span class="line">                <span class="comment">// connector.rollback(batchId); // 处理失败, 回滚数据</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;empty too many times, exit&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            connector.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printEntry</span><span class="params">(List&lt;CanalEntry.Entry&gt; entrys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CanalEntry.Entry entry : entrys) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONBEGIN || entry.getEntryType() == CanalEntry.EntryType.TRANSACTIONEND) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            CanalEntry.RowChange rowChage = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rowChage = CanalEntry.RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;ERROR ## parser of eromanga-event has an error , data:&quot;</span> + entry.toString(),</span><br><span class="line">                        e);</span><br><span class="line">            &#125;</span><br><span class="line">            CanalEntry.EventType eventType = rowChage.getEventType();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;================&gt; binlog[%s:%s] , name[%s,%s] , eventType : %s&quot;</span>,</span><br><span class="line">                    entry.getHeader().getLogfileName(), entry.getHeader().getLogfileOffset(),</span><br><span class="line">                    entry.getHeader().getSchemaName(), entry.getHeader().getTableName(),</span><br><span class="line">                    eventType));</span><br><span class="line">            <span class="keyword">for</span> (CanalEntry.RowData rowData : rowChage.getRowDatasList()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (eventType == CanalEntry.EventType.DELETE) &#123;</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (eventType == EventType.INSERT) &#123;</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&gt; before&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getBeforeColumnsList());</span><br><span class="line">                    System.out.println(<span class="string">&quot;-------&gt; after&quot;</span>);</span><br><span class="line">                    printColumn(rowData.getAfterColumnsList());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printColumn</span><span class="params">(List&lt;Column&gt; columns)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Column column : columns) &#123;</span><br><span class="line">            System.out.println(column.getName() + <span class="string">&quot; : &quot;</span> + column.getValue() + <span class="string">&quot;    update=&quot;</span> + column.getUpdated());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行 client 的效果如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020061417091623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在数据库中变更一条数据，以便产生新的binlog日志，其输出结果如下：<br><img src="https://img-blog.csdnimg.cn/20200614170932906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>能在 IDEA 中搭建并运行 Demo，是我们踏入 canal 的第一步，后续将根据官方文档中的内容为提纲，尝试逐步解开 canal 的实现原理，以便更好的指导实践。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
        <tag>binlog</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 Alibaba sentinel 滑动窗口实现原理(文末附原理图)</title>
    <url>/posts/a618bda.html</url>
    <content><![CDATA[<div id="vip-container"><p>要实现限流、熔断等功能，首先要解决的问题是如何实时采集服务(资源)调用信息。例如将某一个接口设置的限流阔值 1W/tps，那首先如何判断当前的 TPS 是多少？Alibaba Sentinel 采用滑动窗口来实现实时数据的统计。</p>
<blockquote>
<p>温馨提示：如果对源码不太感兴趣，可以先跳到文末，看一下滑动窗口的设计原理图，再决定是否需要阅读源码。</p>
</blockquote>
<h2 id="1、滑动窗口核心类图"><a href="#1、滑动窗口核心类图" class="headerlink" title="1、滑动窗口核心类图"></a>1、滑动窗口核心类图</h2><p><img src="https://img-blog.csdnimg.cn/20191229144055643.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们先对上述核心类做一个简单的介绍，重点关注核心类的作用与核心属性（重点需要探究其核心数据结构）。</p>
<ul>
<li>Metric<br>指标收集核心接口，主要定义一个滑动窗口中成功的数量、异常数量、阻塞数量，TPS、响应时间等数据。</li>
<li>ArrayMetric<br>滑动窗口核心实现类。</li>
<li>LeapArray<br>滑动窗口顶层数据结构，包含一个一个的窗口数据。</li>
<li>WindowWrap<br>每一个滑动窗口的包装类，其内部的数据结构用 MetricBucket 表示。</li>
<li>MetricBucket<br>指标桶，例如通过数量、阻塞数量、异常数量、成功数量、响应时间，已通过未来配额（抢占下一个滑动窗口的数量）。</li>
<li>MetricEvent<br>指标类型，例如通过数量、阻塞数量、异常数量、成功数量、响应时间等。</li>
</ul>
<h2 id="2、滑动窗口实现原理"><a href="#2、滑动窗口实现原理" class="headerlink" title="2、滑动窗口实现原理"></a>2、滑动窗口实现原理</h2><h4 id="2-1-ArrayMetric"><a href="#2-1-ArrayMetric" class="headerlink" title="2.1 ArrayMetric"></a>2.1 ArrayMetric</h4><p>滑动窗口的入口类为 ArrayMetric ，我们先来看一下其核心代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LeapArray&lt;MetricBucket&gt; data;   <span class="comment">// @1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayMetric</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;    <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">new</span> OccupiableBucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayMetric</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs, <span class="keyword">boolean</span> enableOccupy)</span> </span>&#123;   <span class="comment">// @3</span></span><br><span class="line">	<span class="keyword">if</span> (enableOccupy) &#123;</span><br><span class="line">		<span class="keyword">this</span>.data = <span class="keyword">new</span> OccupiableBucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">this</span>.data = <span class="keyword">new</span> BucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：ArrayMetric 类唯一的属性，用来存储各个窗口的数据，这个是接下来我们探究的重点。</p>
<p>代码@2，代码@3  该类提供了两个构造方法，其核心参数为：</p>
<ul>
<li>int intervalInMs<br>表示一个采集的时间间隔，例如1秒，1分钟。</li>
<li>int sampleCount<br>在一个采集间隔中抽样的个数，默认为 2，例如当 intervalInMs = 1000时，抽象两次，则一个采集间隔中会包含两个相等的区间，一个区间就是滑动窗口。</li>
<li>boolean enableOccupy<br>是否允许抢占，即当前时间戳已经达到限制后，是否可以占用下一个时间窗口的容量，这里对应 LeapArray 的两个实现类，如果允许抢占，则为 OccupiableBucketLeapArray，否则为   BucketLeapArray。</li>
</ul>
<blockquote>
<p>注意，LeapArray 的泛型类为 MetricBucket，意思就是指标桶，可以认为一个 MetricBucket 对象可以存储一个抽样时间段内所有的指标，例如一个抽象时间段中通过数量、阻塞数量、异常数量、成功数量、响应时间，其实现的奥秘在 LongAdder 中，本文先不对该类进行详细介绍，后续文章会单独来探究其实现原理。</p>
</blockquote>
<p>这次，我们先不去看子类，反其道而行，先去看看其父类。</p>
<h4 id="2-2-LongAdder"><a href="#2-2-LongAdder" class="headerlink" title="2.2 LongAdder"></a>2.2 LongAdder</h4><h5 id="2-2-1-类图与核心属性"><a href="#2-2-1-类图与核心属性" class="headerlink" title="2.2.1 类图与核心属性"></a>2.2.1 类图与核心属性</h5><p><img src="https://img-blog.csdnimg.cn/20191229144447580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>LeapArray 的核心属性如下：</p>
<ul>
<li>int windowLengthInMs<br>每一个窗口的时间间隔，单位为毫秒。</li>
<li>int sampleCount<br>抽样个数，就一个统计时间间隔中包含的滑动窗口个数，在 intervalInMs 相同的情况下，sampleCount 越多，抽样的统计数据就越精确，相应的需要的内存也越多。</li>
<li>int intervalInMs<br>一个统计的时间间隔。</li>
<li>AtomicReferenceArray&lt;WindowWrap&lt; T&gt;&gt; array<br>一个统计时间间隔中滑动窗口的数组，从这里也可以看出，一个滑动窗口就是使用的 WindowWrap&lt; MetricBucket &gt; 来表示。</li>
</ul>
<p>上面的各个属性的含义是从其构造函数得出来的，请其看构造函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LeapArray</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;</span><br><span class="line">    AssertUtil.isTrue(sampleCount &gt; <span class="number">0</span>, <span class="string">&quot;bucket count is invalid: &quot;</span> + sampleCount);</span><br><span class="line">    AssertUtil.isTrue(intervalInMs &gt; <span class="number">0</span>, <span class="string">&quot;total time interval of the sliding window should be positive&quot;</span>);</span><br><span class="line">    AssertUtil.isTrue(intervalInMs % sampleCount == <span class="number">0</span>, <span class="string">&quot;time span needs to be evenly divided&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.windowLengthInMs = intervalInMs / sampleCount;</span><br><span class="line">    <span class="keyword">this</span>.intervalInMs = intervalInMs;</span><br><span class="line">    <span class="keyword">this</span>.sampleCount = sampleCount;</span><br><span class="line">    <span class="keyword">this</span>.array = <span class="keyword">new</span> AtomicReferenceArray&lt;&gt;(sampleCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们继续来看 LeapArray 中的方法，深入探究滑动窗口的实现细节。</p>
<h5 id="2-2-2-currentWindow-详解"><a href="#2-2-2-currentWindow-详解" class="headerlink" title="2.2.2 currentWindow() 详解"></a>2.2.2 currentWindow() 详解</h5><p>该方法主要是根据当前时间来确定处于哪一个滑动窗口中，即找到上图中的 WindowWrap，该方法内部就是调用其重载方法，参数为系统的当前时间，故我们重点来看一下重载方法的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123; </span><br><span class="line">	<span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);  <span class="comment">// @1</span></span><br><span class="line">	<span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis); <span class="comment">// @2</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="keyword">true</span>) &#123; <span class="comment">// 死循环查找当前的时间窗口，这里之所有需要循环，是因为可能多个线程都在获取当前时间窗口。</span></span><br><span class="line">		WindowWrap&lt;T&gt; old = array.get(idx);  <span class="comment">// @3</span></span><br><span class="line">       		 <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;  <span class="comment">// @4</span></span><br><span class="line">			WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">           		 <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;  <span class="comment">// @5</span></span><br><span class="line">				<span class="keyword">return</span> window;</span><br><span class="line">           		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Thread.yield();</span><br><span class="line">           		 &#125;</span><br><span class="line">       		 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123; <span class="comment">// @6</span></span><br><span class="line">			<span class="keyword">return</span> old;</span><br><span class="line">       		 &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;  <span class="comment">// @7</span></span><br><span class="line">			<span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">               			 <span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					updateLock.unlock();</span><br><span class="line">              			&#125;</span><br><span class="line">           		 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				Thread.yield();</span><br><span class="line">            		&#125;</span><br><span class="line">        	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123; <span class="comment">// @8</span></span><br><span class="line">            		<span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：计算当前时间会落在一个采集间隔 ( LeapArray ) 中哪一个时间窗口中，即在 LeapArray 中属性 AtomicReferenceArray &lt;WindowWrap&lt; T&gt;&gt; array 的下标。其实现算法如下：</p>
<ul>
<li>首先用当前时间除以一个时间窗口的时间间隔，得出当前时间是多少个时间窗口的倍数，用 n 表示。</li>
<li>然后我们可以看出从一系列时间窗口，从 0 开始，一起向前滚动 n 隔得到当前时间戳代表的时间窗口的位置。现在我们要定位到这个时间窗口的位置是落在 LeapArray 中数组的下标，而一个 LeapArray 中包含 sampleCount 个元素，要得到其下标，则使用 n % sampleCount 即可。</li>
</ul>
<p>代码@2：计算当前时间戳所在的时间窗口的开始时间，即要计算出 WindowWrap 中 windowStart 的值，其实就是要算出小于当前时间戳，并且是 windowLengthInMs 的整数倍最大的数字，Sentinel 给出是算法为 ( timeMillis - timeMillis % windowLengthInMs )。</p>
<p>代码@3：尝试从 LeapArray 中的 WindowWrap 数组查找指定下标的元素。</p>
<p>代码@4：如果指定下标的元素为空，则需要创建一个 WindowWrap 。 其中 WindowWrap 中的 MetricBucket 是调用其抽象方法 newEmptyBucket (timeMillis)，由不同的子类去实现。</p>
<p>代码@5：这里使用了 CAS 机制来更新 LeapArray 数组中的 元素，因为同一时间戳，可能有多个线程都在获取当前时间窗口对象，但该时间窗口对象还未创建，这里就是避免创建多个，导致统计数据被覆盖，如果用 CAS 更新成功的线程，则返回新建好的 WindowWrap ，CAS 设置不成功的线程继续跑这个流程，然后会进入到代码@6。</p>
<p>代码@6：如果指定索引下的时间窗口对象不为空并判断起始时间相等，则返回。</p>
<p>代码@7：如果原先存在的窗口开始时间小于当前时间戳计算出来的开始时间，则表示 bucket 已被弃用。则需要将开始时间重置到新时间戳对应的开始时间戳，重置的逻辑将在下文详细介绍。</p>
<p>代码@8：应该不会进入到该分支，因为当前时间算出来时间窗口不会比之前的小。</p>
<h5 id="2-2-3-isWindowDeprecated-详解"><a href="#2-2-3-isWindowDeprecated-详解" class="headerlink" title="2.2.3 isWindowDeprecated() 详解"></a>2.2.3 isWindowDeprecated() 详解</h5><p>接下来我们来看一下窗口的过期机制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWindowDeprecated</span><span class="params">(<span class="comment">/*@NonNull*/</span> WindowWrap&lt;T&gt; windowWrap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isWindowDeprecated(TimeUtil.currentTimeMillis(), windowWrap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWindowDeprecated</span><span class="params">(<span class="keyword">long</span> time, WindowWrap&lt;T&gt; windowWrap)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> time - windowWrap.windowStart() &gt; intervalInMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断滑动窗口是否生效的依据是当系统时间与滑动窗口的开始时间戳的间隔大于一个采集时间，即表示过期。即从当前窗口开始，通常包含的有效窗口为 sampleCount 个有效滑动窗口。</p>
<h5 id="2-2-4-getPreviousWindow-详解"><a href="#2-2-4-getPreviousWindow-详解" class="headerlink" title="2.2.4 getPreviousWindow() 详解"></a>2.2.4 getPreviousWindow() 详解</h5><p>根据当前时间获取前一个有效滑动窗口，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">getPreviousWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis - windowLengthInMs); <span class="comment">// @1</span></span><br><span class="line">    timeMillis = timeMillis - windowLengthInMs;</span><br><span class="line">    WindowWrap&lt;T&gt; wrap = array.get(idx);</span><br><span class="line">    <span class="keyword">if</span> (wrap == <span class="keyword">null</span> || isWindowDeprecated(wrap)) &#123;                 <span class="comment">// @2</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">if</span> (wrap.windowStart() + windowLengthInMs &lt; (timeMillis)) &#123;   <span class="comment">// @3</span></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实现的关键点如下：<br>代码@1：用当前时间减去一个时间窗口间隔，然后去定位所在 LeapArray 中 数组的下标。<br>代码@2：如果为空或已过期，则返回 null。<br>代码@3：如果定位的窗口的开始时间再加上 windowLengthInMs 小于 timeMills ，说明失效，则返回 null，通常是不会走到该分支。</p>
<h5 id="2-2-5-滑动窗口图示"><a href="#2-2-5-滑动窗口图示" class="headerlink" title="2.2.5 滑动窗口图示"></a>2.2.5 滑动窗口图示</h5><p>经过上面的分析，虽然还有一个核心方法 (resetWindowTo) 未进行分析，但我们应该可以画出滑动窗口的实现的实现原理图了。<br><img src="https://img-blog.csdnimg.cn/20191229144957318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来对上面的图进行一个简单的说明：下面的示例以采集间隔为 1 s，抽样次数为 2。</p>
<a id="more"></a>

<p>首先会创建一个 LeapArray，内部持有一个数组，元素为 2,一开始进行采集时，数组的第一个，第二个下标都会 null，例如当前时间经过 calculateTimeIdx 定位到下标为 0，此时没有滑动窗口，会创建一个滑动窗口，然后该滑动窗口会采集指标，随着进入 1s 的后500ms，后会创建第二个抽样窗口。</p>
<p>然后时间前进 1s，又会定位到下标为 0 的地方，但此时不会为空，因为有上一秒的采集数据，故需要将这些采集数据丢弃 ( MetricBucket value )，然后重置该窗口的 windowStart，这就是 resetWindowTo 方法的作用。</p>
<p>在 ArrayMetric 的构造函数出现了 LeapArray 的两个实现类型 BucketLeapArray 与 OccupiableBucketLeapArray。</p>
<p>其中 BucketLeapArray 比较简单，在这里就不深入研究了， 我们接下来将重点探讨一下 OccupiableBucketLeapArray 的实现原理，即支持抢占未来的“令牌”。</p>
<h2 id="3、OccupiableBucketLeapArray-详解"><a href="#3、OccupiableBucketLeapArray-详解" class="headerlink" title="3、OccupiableBucketLeapArray 详解"></a>3、OccupiableBucketLeapArray 详解</h2><p>所谓的 OccupiableBucketLeapArray ，实现的思想是当前抽样统计中的“令牌”已耗尽，即达到用户设定的相关指标的阔值后，可以向下一个时间窗口，即借用未来一个采样区间。接下来我们详细来探讨一下它的核心实现原理。</p>
<p>3.1 类图<br><img src="https://img-blog.csdnimg.cn/20191229145158240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们重点关注一下 OccupiableBucketLeapArray 引入了一个 FutureBucketLeapArray 的成员变量，其命名叫 borrowArray，即为借用的意思。</p>
<h4 id="3-2-构造函数"><a href="#3-2-构造函数" class="headerlink" title="3.2 构造函数"></a>3.2 构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OccupiableBucketLeapArray</span><span class="params">(<span class="keyword">int</span> sampleCount, <span class="keyword">int</span> intervalInMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(sampleCount, intervalInMs);</span><br><span class="line">    <span class="keyword">this</span>.borrowArray = <span class="keyword">new</span> FutureBucketLeapArray(sampleCount, intervalInMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造函数可以看出，不仅创建了一个常规的 LeapArray，对应一个采集周期，还会创建一个  borrowArray ，也会包含一个采集周期。</p>
<h4 id="3-3-newEmptyBucket"><a href="#3-3-newEmptyBucket" class="headerlink" title="3.3 newEmptyBucket"></a>3.3 newEmptyBucket</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MetricBucket <span class="title">newEmptyBucket</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">	MetricBucket newBucket = <span class="keyword">new</span> MetricBucket();   <span class="comment">// @1</span></span><br><span class="line">	MetricBucket borrowBucket = borrowArray.getWindowValue(time);  <span class="comment">// @2</span></span><br><span class="line">	<span class="keyword">if</span> (borrowBucket != <span class="keyword">null</span>) &#123;  </span><br><span class="line">		newBucket.reset(borrowBucket);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newBucket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 newEmptyBucket 是在获取当前窗口时，对应的数组下标为空的时会创建。<br>代码@1：首先新建一个 MetricBucket。<br>代码@2：在新建的时候，如果曾经有借用过未来的滑动窗口，则将未来的滑动窗口上收集的数据 copy 到新创建的采集指标上，再返回。</p>
<h4 id="3-4-resetWindowTo"><a href="#3-4-resetWindowTo" class="headerlink" title="3.4 resetWindowTo"></a>3.4 resetWindowTo</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WindowWrap&lt;MetricBucket&gt; <span class="title">resetWindowTo</span><span class="params">(WindowWrap&lt;MetricBucket&gt; w, <span class="keyword">long</span> time)</span> </span>&#123;      </span><br><span class="line">    w.resetTo(time);</span><br><span class="line">    MetricBucket borrowBucket = borrowArray.getWindowValue(time);</span><br><span class="line">    <span class="keyword">if</span> (borrowBucket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.value().reset();</span><br><span class="line">        w.value().addPass((<span class="keyword">int</span>)borrowBucket.pass());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        w.value().reset();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遇到过期的滑动窗口时，需要对滑动窗口进行重置，这里的思路和 newEmptyBucket 的核心思想是一样的，即如果存在已借用的情况，在重置后需要加上在未来已使用过的许可，就不一一展开了。</p>
<h4 id="3-5-addWaiting"><a href="#3-5-addWaiting" class="headerlink" title="3.5 addWaiting"></a>3.5 addWaiting</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWaiting</span><span class="params">(<span class="keyword">long</span> time, <span class="keyword">int</span> acquireCount)</span> </span>&#123;</span><br><span class="line">	WindowWrap&lt;MetricBucket&gt; window = borrowArray.currentWindow(time);</span><br><span class="line">	window.value().add(MetricEvent.PASS, acquireCount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上面的分析，先做一个大胆的猜测，该方法应该是当前滑动窗口中的“令牌”已使用完成，借用未来的令牌。将在下文给出证明。</p>
<p>滑动窗口的实现原理就介绍到这里了。大家可以按照上面的代码结合下图做一个理解。<br><img src="https://img-blog.csdnimg.cn/20191229145357710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>思考题，大家可以画一下 OccupiableBucketLeapArray 滑动窗口的图示。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 RateLimiter SmoothBursty 实现原理(文末附流程图)</title>
    <url>/posts/f4f9d0d8.html</url>
    <content><![CDATA[<div id="vip-container"><p>上篇详细介绍了<a href="https://blog.csdn.net/prestigeding/article/details/104884255">Sentinel FlowSlot 限流实现原理(文末附流程图与总结)</a>的限流实现机制，但主要介绍的策略限流的快速失败机制，在Sentinel 中除了快速失败，还提供了匀速排队，预热等限流策略，但我发现 Sentinel 的匀速排队、预热机制是基于 guava 的 RateLimiter，为了更加彻底的理解 Sentienl 限流相关的内容，从本文开始先来学习一下 RateLimiter 的相关实现原理。</p>
<blockquote>
<p>温馨提示：文章的末尾会总结 SmoothBursty 的核心流程图与实现原理，本文将展示笔者是如何一步一步揭晓其实现原理的方法。</p>
<p>@<a href="%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">TOC</a></p>
</blockquote>
<h2 id="1、RateLimiter-类设计图"><a href="#1、RateLimiter-类设计图" class="headerlink" title="1、RateLimiter 类设计图"></a>1、RateLimiter 类设计图</h2><p><img src="https://img-blog.csdnimg.cn/20200322143507663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>RateLimiter<br>限流抽象类，定义限流器的基本接口。</li>
<li>SmoothRateLimiter<br>平滑限流实现器，也是一个抽象类。</li>
<li>SmoothWarmingUp<br>自带预热机制的限流器实现类型。</li>
<li>SmoothBursty<br>适应于突发流量的限流器。</li>
</ul>
<p>上述类这些属性，在讲解 SmoothBursty、SmoothWarmingUp 时再详细介绍。</p>
<blockquote>
<p>温馨提示：可以看看这些类上的注释，先初步了解其设计思想。</p>
</blockquote>
<h2 id="2、寻找入口"><a href="#2、寻找入口" class="headerlink" title="2、寻找入口"></a>2、寻找入口</h2><p>我们首先从 guava 的测试用例中尝试寻找一下 RateLimiterTest。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RateLimiter limiter = RateLimiter.create(stopwatch, <span class="number">5.0</span>);</span><br><span class="line">    limiter.acquire(); <span class="comment">// R0.00, since it&#x27;s the first request</span></span><br><span class="line">    limiter.acquire(); <span class="comment">// R0.20</span></span><br><span class="line">    limiter.acquire(); <span class="comment">// R0.20</span></span><br><span class="line">    assertEvents(<span class="string">&quot;R0.00&quot;</span>, <span class="string">&quot;R0.20&quot;</span>, <span class="string">&quot;R0.20&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里基本可以看出，首先通过 RateLimiter.create 的静态方法创建一个限流器，然后应用程序在执行业务逻辑之前先调研限流器的 acquire 方法申请许可，接下来我们将循着这个流程来探讨其实现思路。</p>
<h2 id="3、探究-SmoothBursty-实现原理"><a href="#3、探究-SmoothBursty-实现原理" class="headerlink" title="3、探究 SmoothBursty 实现原理"></a>3、探究 SmoothBursty 实现原理</h2><h4 id="3-1-SmoothBursty-创建流程"><a href="#3-1-SmoothBursty-创建流程" class="headerlink" title="3.1 SmoothBursty 创建流程"></a>3.1 SmoothBursty 创建流程</h4><p>从上面的示例来看，应用程序首先通过 RateLimiter 的静态方法创建一个限流器，其代码如下：<br>RateLimiter#create</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond)</span> </span>&#123; <span class="comment">// @1</span></span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span>);                                  <span class="comment">// @2</span></span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);                                                                    <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先先介绍方法的参数：</p>
<ul>
<li>SleepingStopwatch stopwatch<br>秒表，主要是实现当前从启动开始已消耗的时间，有点类似计算一个操作耗时，实现精度纳秒。</li>
<li>double permitsPerSecond<br>每秒的许可数，即通常我们说的限流TPS。</li>
</ul>
<p>代码@2：创建 SmoothBursty 对象。</p>
<p>代码@3：调用 setRate API 设置其速率器。<br>接下来我们对其进行展开。</p>
<h5 id="3-1-1-SmoothBursty-构造函数"><a href="#3-1-1-SmoothBursty-构造函数" class="headerlink" title="3.1.1 SmoothBursty 构造函数"></a>3.1.1 SmoothBursty 构造函数</h5><p>SmoothBursty 构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SmoothBursty(SleepingStopwatch stopwatch, <span class="keyword">double</span> maxBurstSeconds) &#123;</span><br><span class="line">    <span class="keyword">super</span>(stopwatch);</span><br><span class="line">    <span class="keyword">this</span>.maxBurstSeconds = maxBurstSeconds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是为 stopWatch 与 maxBurstSeconds 赋值，其中 maxBurstSeconds 为允许的突发流量的时间，这里默认为 1.0，表示一秒，会影响最大可存储的许可数。</p>
<h5 id="3-1-2-RateLimiter-setRate-方法详解"><a href="#3-1-2-RateLimiter-setRate-方法详解" class="headerlink" title="3.1.2 RateLimiter setRate 方法详解"></a>3.1.2 RateLimiter setRate 方法详解</h5><p>RateLimiter#setRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond)</span> </span>&#123;</span><br><span class="line">    checkArgument(</span><br><span class="line">        permitsPerSecond &gt; <span class="number">0.0</span> &amp;&amp; !Double.isNaN(permitsPerSecond), <span class="string">&quot;rate must be positive&quot;</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123; <span class="comment">// @1</span></span><br><span class="line">      doSetRate(permitsPerSecond, stopwatch.readMicros()); <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：该方法需要获取该类的监视器，在同步代码块中执行，实现线程安全性。</p>
<p>代码@2：调用 doSetRate 设置速率，将调用其具体实现类 SmoothRateLimiter 的 doSetRate 方法。</p>
<p>SmoothRateLimiter#doSetRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123; <span class="comment">// @1</span></span><br><span class="line">    resync(nowMicros);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;  <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;                                              </span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);                                      <span class="comment">// @4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先来介绍一下该方法的参数的含义：</p>
<ul>
<li>double permitsPerSecond<br>每秒的许可数，即TPS。</li>
<li>long nowMicros<br>系统已运行时间。</li>
</ul>
<p>代码@2：基于当前时间重置 SmoothRateLimiter 内部的 storedPermits (已存储的许可数量) 与 nextFreeTicketMicros (下一次可以免费获取许可的时间) 值，所谓的免费指的是无需等待就可以获取设定速率的许可，该方法对理解限流许可的产生非常关键，稍后详细介绍。</p>
<a id="more"></a>

<p>代码@3：根据 TPS 算出一个稳定的获取1个许可的时间。以一秒发放5个许可，即限速为5TPS，那发放一个许可的世界间隔为 200ms，stableIntervalMicros 变量是以微妙为单位。</p>
<p>代码@4：调用 SmoothRateLimiter 的抽象方法 doSetRate 设置速率，这里会调用 SmoothBursty 的 doSetRate 方法。</p>
<p>在介绍 SmoothBursty 的 doSetRate 方法之前，我们先来看看 resync 方法的实现细节。</p>
<p>SmoothRateLimiter#resync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;  <span class="comment">// @1 </span></span><br><span class="line">      <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();  <span class="comment">// @2</span></span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);    <span class="comment">// @3</span></span><br><span class="line">      nextFreeTicketMicros = nowMicros;   <span class="comment">// @4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果当前已启动时间大于 nextFreeTicketMicros（下一次可以免费获取许可的时间），则需要重新计算许可，即又可以向许可池中添加许可。</p>
<p>代码@2：根据当前时间可增加的许可数量，在 SmoothBursty 的  coolDownIntervalMicros 方法返回的就是上文提到的 stableIntervalMicros (发放一个许可所需要的时间)，故本次可以增加的许可数的算法也好理解，即用当前时间戳减去 nextFreeTicketMicros 的差值，再除以发送一个许可所需要的时间即可。</p>
<p>代码@3：计算当前可用的许可。</p>
<p>代码@4：更新下一次可增加计算许可的时间。</p>
<p>接下来再继续看 SmoothBursty 的 doSetRate 方法。</p>
<p>SmoothBursty#doSetRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        storedPermits = maxPermits;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是初始化 storedPermits 的值，该限速器支持在运行过程中动态改变 permitsPerSecond 的值。</p>
<h4 id="3-2-SmoothBursty-acquire-工作流程"><a href="#3-2-SmoothBursty-acquire-工作流程" class="headerlink" title="3.2 SmoothBursty acquire 工作流程"></a>3.2 SmoothBursty acquire 工作流程</h4><p>RateLimiter 中的 acquire 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);    <span class="comment">// @1</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);   <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据当前剩余的许可与本次申请的许可来判断本次申请需要等待的时长，如果返回0则表示无需等待。</p>
<p>代码@2：如果需要等待的时间不为0，表示触发限速，睡眠指定时间后唤醒。</p>
<p>代码@3：返回本次申请等待的时长。</p>
<p>接下来重点介绍 reserve 方法的实现原理。</p>
<p>RateLimiter#reserve</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;  <span class="comment">// @1</span></span><br><span class="line">      <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros()); <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：限速器主要维护的重要数据字段( storedPermits )，对其进行维护时都需要先获取锁。</p>
<p>代码@2：调用内部方法 reserveAndGetWaitLength 来计算需要等待时间。</p>
<p>继续跟踪 reserveAndGetWaitLength 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据当前拥有的许可数量、当前时间判断待申请许可最早能得到满足的最早时间，用momentAvailable 表示。</p>
<p>代码@2：然后计算 momentAvailable 与 nowMicros 的差值与0做比较，得出需要等待的时间。</p>
<p>继续跟踪 reserveEarliestAvailable方法，该方法在 RateLimiter 中一个抽象方法，具体实现在其子类 SmoothRateLimiter 中。</p>
<p>SmoothRateLimiter#reserveEarliestAvailable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend; <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);  <span class="comment">// @4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);  <span class="comment">// @5</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;    <span class="comment">// @6</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：在尝试申请许可之前，先根据当前时间即发放许可速率更新 storedPermits 与 nextFreeTicketMicros（下一次可以免费获取许可的时间）。</p>
<p>代码@2：计算本次能从 storedPermits 中消耗的许可数量，取需要申请的许可数量与当前可用的许可数量的最小值，用 storedPermitsToSpend 表示。</p>
<p>代码@3：如果需要申请的许可数量( requiredPermits )大于当前剩余许可数量( storedPermits )，则还需要等待新的许可生成，用 freshPermits 表示，即如果该值大于0，则表示本次申请需要阻塞一定时间。</p>
<p>代码@4：计算本次申请需要等待的时间，storedPermitsToWaitTime 方法在 SmoothBursty 的实现中默认返回 0，即 SmoothBursty 的等待时间主要来自按照速率生成 freshPermits 个许可的时间，生成一个许可的时间为 stableIntervalMicros，故需要等待的时长为 freshPermits * stableIntervalMicros。</p>
<p>代码@5：更新 nextFreeTicketMicros 为当前时间加上需要等待的时间。</p>
<p>代码@6：更新 storedPermits 的值，即减少本次已消耗的许可数量。</p>
<p>代码@7：请注意这里返回的 returnValue 的值，并没有包含由于剩余许可需要等待创建新许可的时间，即允许一定的突发流量，故本次计算需要的等待时间将对下一次请求生效，这也是框架作者将该限速器取名为 SmoothBursty 的缘由。</p>
<p>SmoothBursty 的 acquire 方法就介绍到这里了。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>由于源码分析会显得枯燥与不直观，我们先给出如下流程图：<br><img src="https://img-blog.csdnimg.cn/20200322144556364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>SmoothBursty 的核心设计思想基本与令牌桶类似，但还是有些不同。<br>基本思想：</p>
<ol>
<li>SmoothBursty 以指定的速率生成许可，在 SmoothBursty 中用 storedPermits 表示。</li>
<li>当一个请求需要申请许可时，如果需要申请的许可数小于 storedPermits ，则消耗指定许可，直接返回，无需等待。</li>
<li>当一个请求需要申请的许可大于 storedPermits 时，则计算需要等待的时间，更新下一次许可可发放时间，直接返回，即当请求消耗掉所有许可后，当前请求并不会阻塞，而是影响下一个请求，即支持突发流量。</li>
</ol>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>RateLimiter</tag>
        <tag>SmoothBursty</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 RocketMQ DLedger 多副本存储实现</title>
    <url>/posts/f03d9942.html</url>
    <content><![CDATA[<div id="vip-container"><p>RocketMQ DLedger 的存储实现思路与 RocketMQ 的存储实现思路相似，本文就不再从源码角度详细剖析其实现，只是点出其实现关键点。我们不妨简单回顾一下 CommitLog 文件、ConsumeQueue 文件设计思想。</p>
<p>其文件组成形式如下：<br><img src="https://img-blog.csdnimg.cn/20190831215052708.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正如上图所示，多个 commitlog 文件组成一个逻辑上的连续文件，使用 MappedFileQueue 表示，单个 commitlog 文件使用 MappedFile 表示。</p>
<blockquote>
<p>温馨提示：如果想详细了解 RocketMQ 关于存储部分的讲解，可以关注笔者的《RocketMQ 技术内幕》一书。</p>
</blockquote>
<h2 id="1、DLedger-存储相关类图"><a href="#1、DLedger-存储相关类图" class="headerlink" title="1、DLedger 存储相关类图"></a>1、DLedger 存储相关类图</h2><p><img src="https://img-blog.csdnimg.cn/20190831215151796.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-1-DLedgerStore"><a href="#1-1-DLedgerStore" class="headerlink" title="1.1 DLedgerStore"></a>1.1 DLedgerStore</h3><p>存储抽象类，定义如下核心方法：</p>
<ul>
<li>public abstract DLedgerEntry appendAsLeader(DLedgerEntry entry)<br>向主节点追加日志(数据)。</li>
<li>public abstract DLedgerEntry appendAsFollower(DLedgerEntry entry, long leaderTerm, String leaderId)<br>向从节点同步日志。</li>
<li>public abstract DLedgerEntry get(Long index)<br>根据日志下标查找日志。</li>
<li>public abstract long getCommittedIndex()<br>获取已提交的下标。</li>
<li>public abstract long getLedgerEndTerm()<br>获取 Leader 当前最大的投票轮次。</li>
<li>public abstract long getLedgerEndIndex()<br>获取 Leader 下一条日志写入的下标（最新日志的下标）。</li>
<li>public abstract long getLedgerBeginIndex()<br>获取 Leader 第一条消息的下标。</li>
<li>public void updateCommittedIndex(long term, long committedIndex)<br>更新commitedIndex的值，为空实现，由具体的存储子类实现。</li>
<li>protected void updateLedgerEndIndexAndTerm()<br>更新 Leader 维护的 ledgerEndIndex 和 ledgerEndTerm 。</li>
<li>public void flush()<br>刷写，空方法，由具体子类实现。</li>
<li>public long truncate(DLedgerEntry entry, long leaderTerm, String leaderId)<br>删除日志，空方法，由具体子类实现。</li>
<li>public void startup()<br>启动存储管理器，空方法，由具体子类实现。</li>
<li>public void shutdown()<br>关闭存储管理器，空方法，由具体子类实现。</li>
</ul>
<h3 id="1-2-DLedgerMemoryStore"><a href="#1-2-DLedgerMemoryStore" class="headerlink" title="1.2 DLedgerMemoryStore"></a>1.2 DLedgerMemoryStore</h3><p>Dledger 基于内存实现的日志存储。</p>
<h3 id="1-3-DLedgerMmapFileStore"><a href="#1-3-DLedgerMmapFileStore" class="headerlink" title="1.3  DLedgerMmapFileStore"></a>1.3  DLedgerMmapFileStore</h3><p>基于文件内存映射机制的存储实现。其核心属性如下：</p>
<ul>
<li>long ledgerBeginIndex =  -1<br>日志的起始索引，默认为 -1。<br>l- ong ledgerEndIndex = -1<br>下一条日志下标，默认为 -1。</li>
<li>long committedIndex = -1<br>已提交的日志索引。</li>
<li>long ledgerEndTerm<br>当前最大的投票轮次。</li>
<li>DLedgerConfig dLedgerConfig<br>DLedger 的配置信息。</li>
<li>MemberState memberState<br>状态机。</li>
<li>MmapFileList dataFileList<br>日志文件(数据文件)的内存映射Queue。</li>
<li>MmapFileList indexFileList<br>索引文件的内存映射文件集合。（可对标 RocketMQ MappedFIleQueue )。</li>
<li>ThreadLocal&lt; ByteBuffer&gt; localIndexBuffer<br>本地线程变量，用来缓存索引ByteBuffer。</li>
<li>ThreadLocal&lt; ByteBuffer&gt; localEntryBuffer<br>本地线程变量，用来缓存数据索引ByteBuffer。</li>
<li>FlushDataService flushDataService<br>数据文件刷盘线程。</li>
<li>CleanSpaceService cleanSpaceService<br>清除过期日志文件线程。</li>
<li>boolean isDiskFull = false<br>磁盘是否已满。</li>
<li>long lastCheckPointTimeMs<br>上一次检测点（时间戳）。</li>
<li>AtomicBoolean hasLoaded<br>是否已经加载，主要用来避免重复加载(初始化)日志文件。</li>
<li>AtomicBoolean hasRecovered<br> ​    是否已恢复。</li>
</ul>
<a id="more"></a>

<h2 id="2、DLedger-存储-对标-RocketMQ-存储"><a href="#2、DLedger-存储-对标-RocketMQ-存储" class="headerlink" title="2、DLedger 存储 对标 RocketMQ 存储"></a>2、DLedger 存储 对标 RocketMQ 存储</h2><p>存储部分主要包含存储映射文件、消息存储格式、刷盘、文件加载与文件恢复、过期文件删除等，由于这些内容在 RocketMQ 存储部分都已详细介绍，故本文点到为止，其对应的参考映射如下：<br><img src="https://img-blog.csdnimg.cn/20190831215536527.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在 RocketMQ 中使用 MappedFile 来表示一个物理文件，而在 DLedger 中使用 DefaultMmapFIle 来表示一个物理文件。</p>
<p>在 RocketMQ 中使用 MappedFile 来表示多个物理文件(逻辑上连续)，而在 DLedger 中则使用MmapFileList。</p>
<p>在 RocketMQ 中使用 DefaultMessageStore 来封装存储逻辑，而在 DLedger 中则使用DLedgerMmapFileStore来封装存储逻辑。</p>
<p>在 RocketMQ 中使用 Commitlog$FlushCommitLogService 来实现 commitlog 文件的刷盘，而在 DLedger 中则使用DLedgerMmapFileStore$FlushDataService来实现文件刷盘。</p>
<p>在 RocketMQ 中使用 DefaultMessageStore$CleanCommitlogService 来实现 commitlog 过期文件的删除，而 DLedger 中则使用 DLedgerMmapFileStore$CleanSpaceService来实现。</p>
<p>由于其实现原理相同，上述部分已经在《RocketMQ 技术内幕》第4章中详细剖析，故这里就不重复分析了。</p>
<h2 id="3、DLedger-数据存储格式"><a href="#3、DLedger-数据存储格式" class="headerlink" title="3、DLedger 数据存储格式"></a>3、DLedger 数据存储格式</h2><p><img src="https://img-blog.csdnimg.cn/2019083121572821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>存储格式字段的含义如下：</p>
<ul>
<li>magic<br>魔数，4字节。</li>
<li>size<br>条目总长度，包含 Header(协议头) + 消息体，占4字节。</li>
<li>entryIndex<br>当前条目的 index，占8字节。</li>
<li>entryTerm<br>当前条目所属的 投票轮次，占8字节。</li>
<li>pos<br>该条目的物理偏移量，类似于 commitlog 文件的物理偏移量，占8字节。</li>
<li>channel<br>保留字段，当前版本未使用，占4字节。</li>
<li>chain crc<br>当前版本未使用，占4字节。</li>
<li>body crc<br>body 的 CRC 校验和，用来区分数据是否损坏，占4字节。</li>
<li>body size<br>用来存储 body 的长度，占4个字节。</li>
<li>body<br>具体消息的内容。</li>
</ul>
<p>源码参考点：DLedgerMmapFileStore#recover、DLedgerEntry、DLedgerEntryCoder。</p>
<h2 id="4、DLedger-索引存储格式"><a href="#4、DLedger-索引存储格式" class="headerlink" title="4、DLedger 索引存储格式"></a>4、DLedger 索引存储格式</h2><p><img src="https://img-blog.csdnimg.cn/20190831215844719.png" alt="在这里插入图片描述"><br>即一个索引条目占32个字节。</p>
<h2 id="5、思考"><a href="#5、思考" class="headerlink" title="5、思考"></a>5、思考</h2><p>DLedger 存储相关就介绍到这里，为了与大家增加互动，特提出如下两个思考题，欢迎与作者互动，这些问题将在该系列的后面文章专题探讨。</p>
<p>1、DLedger 如果整合 RocketMQ 中的 commitlog 文件，使之支持多副本？<br>2、从老版本如何升级到新版本，需要考虑哪些因素呢？</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
        <tag>DLedger</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 Sentinel DegradeSlot 熔断实现原理</title>
    <url>/posts/45a744cd.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、DegradeSlot-概述"><a href="#1、DegradeSlot-概述" class="headerlink" title="1、DegradeSlot 概述"></a>1、DegradeSlot 概述</h2><p>Sentinel 中的熔断实现类为 DegradeSlot。DegradeSlot 的类定义如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200412153916327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>由此可见，熔断主要实现逻辑定义在 DegradeRuleManager 的 checkDegrade 方法中。<br>DegradeRuleManager#checkDegrade<br><img src="https://img-blog.csdnimg.cn/20200412153949610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">代码@1：首先从 degradeRules 熔断规则缓存中获取资源的熔断规则。</p>
<p>代码@2：遍历熔断规则列表。</p>
<p>代码@3：调用熔断规则 DegradeRule 的  passCheck，如果该方法返回 false，则表示需要熔断，则抛出 DegradeException 异常。</p>
<p>即实现熔断的核心逻辑在 DegradeRule 中。</p>
<a id="more"></a>

<h2 id="2、DegradeRule-详解"><a href="#2、DegradeRule-详解" class="headerlink" title="2、DegradeRule 详解"></a>2、DegradeRule 详解</h2><p>在介绍 DegradeRule 之前我们先来看看 sentinel-dashboard 关于熔断降级规则的配置：<br><img src="https://img-blog.csdnimg.cn/20200412154228974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我们可以直观的得知，降级规则可以根据如下三个指标进行设置：RT(响应时间)、异常比例、异常数。</p>
<h4 id="2-1-DegradeRule-类图"><a href="#2-1-DegradeRule-类图" class="headerlink" title="2.1 DegradeRule 类图"></a>2.1 DegradeRule 类图</h4><p><img src="https://img-blog.csdnimg.cn/20200412154252374.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>double count<br>上面配置规则中对应的配置值，例如当降级策略为RT时，表示设置的响应时间值，其他类似。</li>
<li>int timeWindow<br>降级发生后多久进行恢复，即结束降级，单位为毫秒。</li>
<li>int grade<br>降级策略，可以选值如下：<br>1）DEGRADE_GRADE_RT<br>响应时间。<br>2）DEGRADE_GRADE_EXCEPTION_RATIO<br>异常数比例。<br>3）DEGRADE_GRADE_EXCEPTION_COUNT<br>异常数量。</li>
<li>int rtSlowRequestAmount<br>触发 RT 响应熔断出现的最小连续慢响应请求数量。</li>
<li>int minRequestAmount<br>触发熔断最小的请求数量。</li>
</ul>
<h4 id="2-2-passCheck方法详解"><a href="#2-2-passCheck方法详解" class="headerlink" title="2.2 passCheck方法详解"></a>2.2 passCheck方法详解</h4><p>根据当前请求的情况触发熔断的判断逻辑由 passCheck 方法实现。在介绍这个方法之前，我们根据该方法调用上下文得知，该方法返回 false，则触发熔断。<br>DegradeRule#passCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cut.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果当前正在处于熔断降级中，将直接返回 false，请求将被限流。</p>
<p>DegradeRule#passCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClusterNode clusterNode = ClusterBuilderSlot.getClusterNode(<span class="keyword">this</span>.getResource());</span><br><span class="line">    <span class="keyword">if</span> (clusterNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：根据资源名称获得对应的集群类节点，有关集群限流将在后续文章中详细介绍。</p>
<p>DegradeRule#passCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_RT) &#123;</span><br><span class="line">    <span class="keyword">double</span> rt = clusterNode.avgRt();</span><br><span class="line">    <span class="keyword">if</span> (rt &lt; <span class="keyword">this</span>.count) &#123;</span><br><span class="line">        passCount.set(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (passCount.incrementAndGet() &lt; rtSlowRequestAmount) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>step3：降级策略为基于响应时间的判断规则，其核心实现关键点：</p>
<ul>
<li>首先获取节点的平均响应时间。</li>
<li>如果当前平均响应时间小于阔值，则放行，并重置 passCount 为 0。</li>
<li>如果当前平均响应时间大于阔值，但连续次数小于 rtSlowRequestAmount，依然放行，只有当连续 rtSlowRequestAmount 次响应慢才会触发降级。</li>
</ul>
<p>DegradeRule#passCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_RATIO) &#123;</span><br><span class="line">    <span class="keyword">double</span> exception = clusterNode.exceptionQps();</span><br><span class="line">    <span class="keyword">double</span> success = clusterNode.successQps();</span><br><span class="line">    <span class="keyword">double</span> total = clusterNode.totalQps();</span><br><span class="line">    <span class="keyword">if</span> (total &lt; minRequestAmount) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">double</span> realSuccess = success - exception;</span><br><span class="line">    <span class="keyword">if</span> (realSuccess &lt;= <span class="number">0</span> &amp;&amp; exception &lt; minRequestAmount) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (exception / success &lt; count) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：降级策略为根据异常比例，其判断规则核心如下：</p>
<ul>
<li>分别获取成功QPS，异常QPS，总TPS。</li>
<li>如果当前总 QPS 小于 minRequestAmount，则直接返回成功，表示暂不进行熔断规则判断。</li>
<li>如果成功数小于异常数并且异常数量小于 minRequestAmount，则返回true，表示暂不进熔断规则的判断。</li>
<li>如果异常比例小于阔值，同样返回 true，表示暂不进熔断规则的判断。</li>
</ul>
<p>DegradeRule#passCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (grade == RuleConstant.DEGRADE_GRADE_EXCEPTION_COUNT) &#123;</span><br><span class="line">    <span class="keyword">double</span> exception = clusterNode.totalException();</span><br><span class="line">    <span class="keyword">if</span> (exception &lt; count) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5：降级策略为根据异常数量，这策略只是简单的判断错误数量即可。</p>
<p>DegradeRule#passCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cut.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">    ResetTask resetTask = <span class="keyword">new</span> ResetTask(<span class="keyword">this</span>);</span><br><span class="line">    pool.schedule(resetTask, timeWindow, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6：如果符合触发熔断的规则，则原子更新 cut，并且开启一个调度任务，在指定时间过后进行降级恢复。</p>
<p>Sentinel 的熔断机制实现比较简单，就介绍到这了，下一篇将介绍 Sentinel 基于集群的限流策略。</p>
<p><strong>好了，我亲爱的读者朋友，以上就是本文的全部内容了，对Sentinel 的熔断实现原理是否已Get。原创不易，莫要白票，请你为本文点赞个吧，这将是我写作更多优质文章的最强动力。</strong></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>熔断</tag>
        <tag>源码</tag>
        <tag>DegradeSlot</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 Sentinel 之 Dubbo适配原理</title>
    <url>/posts/2496ec4.html</url>
    <content><![CDATA[<div id="vip-container"><p>在<a href="https://blog.csdn.net/prestigeding/article/details/103544443">Alibaba Sentinel 限流与熔断初探(技巧篇)</a> 的示例中我选择了 sentinel-demo-apache-dubbo 作为突破点，故本文就从该项目入手，看看 Sentinel 是如何对 Dubbo 做的适配，让项目使用方无感知，只需要引入对应的依即可。</p>
<p>sentinel-apache-dubbo-adapter 比较简单，展开如下：<br><img src="https://img-blog.csdnimg.cn/20191222163854410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的代码应该比较简单，在正式进入源码研究之前，我先抛出如下二个问题：</p>
<ul>
<li>1、限流、熔断相关的功能是在 Dubbo 的客户端实现还是服务端实现？为什么？</li>
<li>2、如何对 Dubbo 进行功能扩展而无需改动业务代码？</li>
</ul>
<p>Dubbo 提供了 Filter 机制对功能进行无缝扩展，有关 Dubbo Filter 机制，大家可以查阅笔者的源码研究 Dubbo 系列：<a href="https://mp.weixin.qq.com/s/uv7ev-D-9wo3Oct3NCcKTQ">Dubbo Filter机制概述</a>。</p>
<p>接下来我们带着上面的问题1开始本章的研究。</p>
<h2 id="1、源码分析-SentinelDubboConsumerFilter"><a href="#1、源码分析-SentinelDubboConsumerFilter" class="headerlink" title="1、源码分析 SentinelDubboConsumerFilter"></a>1、源码分析 SentinelDubboConsumerFilter</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &quot;consumer&quot;)</span>   <span class="comment">// @1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelDubboConsumerFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SentinelDubboConsumerFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RecordLog.info(<span class="string">&quot;Sentinel Apache Dubbo consumer filter initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        Entry interfaceEntry = <span class="keyword">null</span>;</span><br><span class="line">        Entry methodEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resourceName = DubboUtils.getResourceName(invoker, invocation, DubboConfig.getDubboConsumerPrefix());   <span class="comment">// @2</span></span><br><span class="line">            interfaceEntry = SphU.entry(invoker.getInterface().getName(),</span><br><span class="line">                ResourceTypeConstants.COMMON_RPC, EntryType.OUT);     <span class="comment">// @3</span></span><br><span class="line">            methodEntry = SphU.entry(resourceName, ResourceTypeConstants.COMMON_RPC, EntryType.OUT);    <span class="comment">// @4</span></span><br><span class="line"></span><br><span class="line">            Result result = invoker.invoke(invocation);            <span class="comment">// @5</span></span><br><span class="line">            <span class="keyword">if</span> (result.hasException()) &#123;                                     <span class="comment">// @6</span></span><br><span class="line">                Throwable e = result.getException();</span><br><span class="line">                <span class="comment">// Record common exception.</span></span><br><span class="line">                Tracer.traceEntry(e, interfaceEntry);</span><br><span class="line">                Tracer.traceEntry(e, methodEntry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123;        </span><br><span class="line">            <span class="keyword">return</span> DubboFallbackRegistry.getConsumerFallback().handle(invoker, invocation, e);  <span class="comment">// @7</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;    </span><br><span class="line">            Tracer.traceEntry(e, interfaceEntry);</span><br><span class="line">            Tracer.traceEntry(e, methodEntry);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (methodEntry != <span class="keyword">null</span>) &#123;   <span class="comment">// @8</span></span><br><span class="line">                methodEntry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interfaceEntry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：通过 @Activate 注解定义该 Filter 在客户端生效。</p>
<p>代码@2：在 Sentinel 中一个非常核心的概念就是资源，即要定义限流的目标，当出现什么异常（匹配用户配置的规则）对什么进行熔断操作，Dubbo 服务中的资源通常是 Dubbo 服务，分为服务接口级或方法级，故该方法返回 Dubbo 的资源名，其主要实现特征如下：</p>
<ul>
<li>如果启用用户定义资源的前缀，默认为 false ，可以通过配置属性：csp.sentinel.dubbo.resource.use.prefix 来定义是否需要启用前缀。如果启用前缀，消费端的默认前缀为 dubbo:consumer:，可以通过配置属性 csp.sentinel.dubbo.resource.consumer.prefix 来自定义消费端的资源前缀。</li>
<li>Dubbo 资源的名称表示方法为：interfaceName + “:” + methodName + “(“ + “paramTyp1参数列表，多个用 , 隔开” + “)”。</li>
</ul>
<p>代码@3：调用 Sentinel 核心API  SphU.entry 进入 Dubbo InterfaceName。从方法的名称我们也能很容易的理解，就是使用 Sentienl API 进入资源名为 Dubbo 接口提供者类全路径限定名，即认为调用该方法，Sentienl 会收集该资源的调用信息，然后Sentinel 根据运行时收集的信息，再配合限流规则，熔断等规则进行计算是否需要限流或熔断。本节我们不打算深入研究 SphU 的核心方法研究，先初步了解该方法：</p>
<ul>
<li><p>String name 资源的名称。</p>
</li>
<li><p>int resourceType 资源的类型，在 Sentinel 中目前定义了 如下五中资源：</p>
<ul>
<li>ResourceTypeConstants.COMMON<br>同样类型。</li>
<li>ResourceTypeConstants.COMMON_WEB<br>WEB 类资源。</li>
<li>ResourceTypeConstants.COMMON_RPC<br>RPC 类型。</li>
<li>ResourceTypeConstants.COMMON_API_GATEWAY<br>接口网关。</li>
<li>ResourceTypeConstants.COMMON_DB_SQL<br>数据库 SQL 语句。</li>
</ul>
</li>
<li><p>EntryType type<br>进入资源的方式，主要分为 EntryType.OUT、EntryType.IN，只有 EntryType.IN 方式才能对资源进行阻塞。</p>
</li>
</ul>
<p>代码@4：调用 Sentinel 核心API SphU.entry 进入 Dubbo method 级别。</p>
<p>代码@5：调用 Dubbo 服务提供者方法。</p>
<p>代码@6：如果出现调用异常，可以通过 Sentinel 的 Tracer.traceEntry 跟踪本次调用资源进入的情况，详细 API 将在该系列的后续文章中详细介绍。</p>
<p>代码@7：如果是由于触发了限流、熔断等操作，抛出了阻塞异常，可通过 注册 ConsumerFallback 来实现消费者快速失败，将在下文详细介绍。</p>
<p>代码@8： SphU.entry 与 资源的 exit 方法需要成对出现，否则会出现统计错误。</p>
<a id="more"></a>

<h2 id="2、源码分析-SentienlDubboProviderFilters"><a href="#2、源码分析-SentienlDubboProviderFilters" class="headerlink" title="2、源码分析 SentienlDubboProviderFilters"></a>2、源码分析 SentienlDubboProviderFilters</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Activate(group = &quot;provider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SentinelDubboProviderFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SentinelDubboProviderFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RecordLog.info(<span class="string">&quot;Sentinel Apache Dubbo provider filter initialized&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">invoke</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">        <span class="comment">// Get origin caller.</span></span><br><span class="line">        String application = DubboUtils.getApplication(invocation, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        Entry interfaceEntry = <span class="keyword">null</span>;</span><br><span class="line">        Entry methodEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String resourceName = DubboUtils.getResourceName(invoker, invocation, DubboConfig.getDubboProviderPrefix());   <span class="comment">// @1</span></span><br><span class="line">            String interfaceName = invoker.getInterface().getName();</span><br><span class="line">            <span class="comment">// Only need to create entrance context at provider side, as context will take effect</span></span><br><span class="line">            <span class="comment">// at entrance of invocation chain only (for inbound traffic).</span></span><br><span class="line">            ContextUtil.enter(resourceName, application);</span><br><span class="line">            interfaceEntry = SphU.entry(interfaceName, ResourceTypeConstants.COMMON_RPC, EntryType.IN);  <span class="comment">// @2</span></span><br><span class="line">            methodEntry = SphU.entry(resourceName, ResourceTypeConstants.COMMON_RPC,</span><br><span class="line">                EntryType.IN, invocation.getArguments());</span><br><span class="line">            Result result = invoker.invoke(invocation);</span><br><span class="line">            <span class="keyword">if</span> (result.hasException()) &#123;</span><br><span class="line">                Throwable e = result.getException();</span><br><span class="line">                <span class="comment">// Record common exception.</span></span><br><span class="line">                Tracer.traceEntry(e, interfaceEntry);</span><br><span class="line">                Tracer.traceEntry(e, methodEntry);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BlockException e) &#123; </span><br><span class="line">            <span class="keyword">return</span> DubboFallbackRegistry.getProviderFallback().handle(invoker, invocation, e);   <span class="comment">// @3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RpcException e) &#123;</span><br><span class="line">            Tracer.traceEntry(e, interfaceEntry);</span><br><span class="line">            Tracer.traceEntry(e, methodEntry);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (methodEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                methodEntry.exit(<span class="number">1</span>, invocation.getArguments());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                interfaceEntry.exit();</span><br><span class="line">            &#125;</span><br><span class="line">            ContextUtil.exit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dubbo 服务提供者与消费端的适配套路差不多，这里就重点阐述一下其不同点。<br>代码@1：如果启用前缀，默认服务提供者的资源会加上前缀：dubbo:provider:，可以通过在配置文件中配置属性 csp.sentinel.dubbo.resource.provider.prefix 改变其默认值。</p>
<p>代码@2：服务端调用 SphU.entry 时其进入类型为 EntryType.IN。</p>
<p>代码@3：同样可以在 抛出阻塞异常(BlockException) 时指定快速失败回调处理逻辑。</p>
<h2 id="3、Sentienl-Dubbo-FallBack-机制"><a href="#3、Sentienl-Dubbo-FallBack-机制" class="headerlink" title="3、Sentienl Dubbo FallBack 机制"></a>3、Sentienl Dubbo FallBack 机制</h2><p>Sentinel Dubbo FallBack 机制比较简单，就是提供一个全局的 FallBack 回调，可以分别为服务提供端，服务消费端指定。只需实现 DubboFallback 接口，其声明如下：<br><img src="https://img-blog.csdnimg.cn/2019122216430790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后需要调用 DubboFallbackRegistry 的 setConsumerFallback 和 setProviderFallback 方法分别注册消费端，服务端相关的监听器。通常只需要在启动应用的时候，将其进行注册即可。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>本文只是以 Sentienl 对 Dubbo 的适配实现来了解 Sentinel 核心相关的 API，其核心实现就是利用 Dubbo 的 Filter 机制进行无缝的过滤拦截。但本文只是提到 Sentinel 如下核心方法：</p>
<ul>
<li>SphU.entry</li>
<li>Entry.exit</li>
<li>Tracer.traceEntry</li>
</ul>
<p>上述这些方法，将在后面的文章中进行深入探究，即从下一篇文章开始，我们将真正进入 Sentinel 的世界中，让我们一探究竟限流、熔断通常是如何实现的。</p>
<p>本文就介绍到这里了，点赞是一种美德，您的点赞是我持续分享的最大动力，谢谢。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>Dubbo适配</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 Sentinel 实时数据采集实现原理</title>
    <url>/posts/5f8f7185.html</url>
    <content><![CDATA[<div id="vip-container"><p>本篇将重点关注 Sentienl 实时数据收集，即 Sentienl 具体是如何收集调用信息，以此来判断是否需要触发限流或熔断。</p>
<p>Sentienl 实时数据收集的入口类为 StatisticSlot。</p>
<p>我们先简单来看一下 StatisticSlot 该类的注释，来看一下该类的整体定位。</p>
<p>StatisticSlot，专用于实时统计的 slot。在进入一个资源时，在执行 Sentienl 的处理链条中会进入到该 slot 中，需要完成如下计算任务：</p>
<ul>
<li>集群维度计算资源的总统计信息，用于集群限流，后续文章将详细探讨。</li>
<li>来自不同调用方/来源的群集节点的统计信息。</li>
<li>特定调用上下文环境的统计信息。</li>
<li>统计所有入口的统计信息。</li>
</ul>
<p>接下来用源码分析的手段来详细分析 StatisticSlot 的实现原理。</p>
<h2 id="1、源码分析-StatisticSlot"><a href="#1、源码分析-StatisticSlot" class="headerlink" title="1、源码分析 StatisticSlot"></a>1、源码分析 StatisticSlot</h2><h4 id="1-1-StatisticSlot-entry-详解"><a href="#1-1-StatisticSlot-entry-详解" class="headerlink" title="1.1 StatisticSlot entry 详解"></a>1.1 StatisticSlot entry 详解</h4><p>StatisticSlot#entry </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,<span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123; </span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// Do some checking.</span></span><br><span class="line">                fireEntry(context, resourceWrapper, node, count, prioritized, args);  <span class="comment">// @1</span></span><br><span class="line">        	<span class="comment">// Request passed, add thread count and pass count.</span></span><br><span class="line">        	node.increaseThreadNum();                                                             <span class="comment">// @2</span></span><br><span class="line">       		node.addPassRequest(count);</span><br><span class="line">		<span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;                           <span class="comment">// @3</span></span><br><span class="line">			<span class="comment">// Add count for origin node.</span></span><br><span class="line">            		context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">            		context.getCurEntry().getOriginNode().addPassRequest(count);</span><br><span class="line">       		 &#125;</span><br><span class="line">		<span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;                <span class="comment">// @4</span></span><br><span class="line">			<span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">            		Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">           	 	Constants.ENTRY_NODE.addPassRequest(count);</span><br><span class="line">        	&#125;</span><br><span class="line">		<span class="comment">// Handle pass event with registered entry callback handlers.</span></span><br><span class="line">        	<span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;   <span class="comment">// @5</span></span><br><span class="line">            		handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (PriorityWaitException ex) &#123;                                                                                                                                <span class="comment">// @6</span></span><br><span class="line">		node.increaseThreadNum();</span><br><span class="line">		<span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// Add count for origin node.</span></span><br><span class="line">            		context.getCurEntry().getOriginNode().increaseThreadNum();</span><br><span class="line">       	 	&#125;</span><br><span class="line">		<span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">			<span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">            		Constants.ENTRY_NODE.increaseThreadNum();</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">// Handle pass event with registered entry callback handlers.</span></span><br><span class="line">        	<span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">            		handler.onPass(context, resourceWrapper, node, count, args);</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (BlockException e) &#123;     <span class="comment">// @7                                                                                                              </span></span><br><span class="line">        	<span class="comment">// Blocked, set block exception to current entry.</span></span><br><span class="line">        	context.getCurEntry().setError(e);</span><br><span class="line">		<span class="comment">// Add block count.</span></span><br><span class="line">        	node.increaseBlockQps(count);</span><br><span class="line">        	<span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            		context.getCurEntry().getOriginNode().increaseBlockQps(count);</span><br><span class="line">        	&#125;</span><br><span class="line">		<span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">            		<span class="comment">// Add count for global inbound entry node for global statistics.</span></span><br><span class="line">            		Constants.ENTRY_NODE.increaseBlockQps(count);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="comment">// Handle block event with registered entry callback handlers.</span></span><br><span class="line">        	<span class="keyword">for</span> (ProcessorSlotEntryCallback&lt;DefaultNode&gt; handler : StatisticSlotCallbackRegistry.getEntryCallbacks()) &#123;</span><br><span class="line">            		handler.onBlocked(e, context, resourceWrapper, node, count, args);</span><br><span class="line">        	&#125;</span><br><span class="line">		<span class="keyword">throw</span> e;</span><br><span class="line">    	&#125; <span class="keyword">catch</span> (Throwable e) &#123;   <span class="comment">// @8</span></span><br><span class="line">        	<span class="comment">// Unexpected error, set error to current entry.</span></span><br><span class="line">        	context.getCurEntry().setError(e);</span><br><span class="line">		<span class="comment">// This should not happen.</span></span><br><span class="line">        	node.increaseExceptionQps(count);</span><br><span class="line">        	<span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            		context.getCurEntry().getOriginNode().increaseExceptionQps(count);</span><br><span class="line">        	&#125;</span><br><span class="line">		<span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">            		Constants.ENTRY_NODE.increaseExceptionQps(count);</span><br><span class="line">        	&#125;</span><br><span class="line">        	<span class="keyword">throw</span> e;</span><br><span class="line">    	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先调用 fireEntry，先调用 Sentinel Slot Chain 中其他的处理器，执行完其他处理器的逻辑，例如 FlowSlot、DegradeSlot，因为 StatisticSlot 的职责是收集统计信息。</p>
<p>代码@2：如果后续处理器成功执行，则将正在执行线程数统计指标加一，并将通过的请求数量指标增加对应的值。下文会对 Sentinel Node 体系进行详细的介绍，在 Sentinel 中使用 Node 来表示调用链中的某一个节点，每个节点关联一个资源，资源的实时统计信息就存储在 Node 中，故该部分也是调用 DefaultNode 的相关方法来改变线程数等，将在下文会向详细介绍。</p>
<p>代码@3：如果上下文环境中保存了调用的源头（调用方）的节点信息不为空，则更新该节点的统计数据：线程数与通过数量。</p>
<p>代码@4：如果资源的进入类型为 EntryType.IN，表示入站流量，更新入站全局统计数据(集群范围 ClusterNode)。</p>
<p>代码@5：执行注册的进入Handler，可以通过 StatisticSlotCallbackRegistry 的 addEntryCallback 注册相关监听器。</p>
<p>代码@6：如果捕获到 PriorityWaitException ，则认为是等待过一定时间，但最终还是算通过，只需增加线程的个数，但无需增加节点通过的数量，具体原因我们在详细分析限流部分时会重点讨论，也会再次阐述 PriorityWaitException 的含义。</p>
<p>代码@7：如果捕获到 BlockException，则主要增加阻塞的数量。</p>
<p>代码@8：如果是系统异常，则增加异常数量。</p>
<p>我想上面的代码应该不难理解，但涉及到统计指标数据的变化，都是调用 DefaultNode node 相关的方法，从这里也可以看出，Node 将是实时统计数据的直接持有者，那毋容置疑接下来将重点来学习 Node，为了知识体系的完备性，我们先来看一下 StatisticSlot 的 exit 方法。</p>
<a id="more"></a>

<h4 id="1-2-StatisticSlot-exit-详解"><a href="#1-2-StatisticSlot-exit-详解" class="headerlink" title="1.2 StatisticSlot exit 详解"></a>1.2 StatisticSlot exit 详解</h4><p>StatisticSlot#exit </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exit</span><span class="params">(Context context, ResourceWrapper resourceWrapper, <span class="keyword">int</span> count, Object... args)</span> </span>&#123;</span><br><span class="line">	DefaultNode node = (DefaultNode)context.getCurNode();</span><br><span class="line">	<span class="keyword">if</span> (context.getCurEntry().getError() == <span class="keyword">null</span>) &#123;         <span class="comment">// @1</span></span><br><span class="line">		<span class="comment">// Calculate response time (max RT is TIME_DROP_VALVE).</span></span><br><span class="line">		<span class="keyword">long</span> rt = TimeUtil.currentTimeMillis() - context.getCurEntry().getCreateTime();</span><br><span class="line">		<span class="keyword">if</span> (rt &gt; Constants.TIME_DROP_VALVE) &#123;</span><br><span class="line">			rt = Constants.TIME_DROP_VALVE;</span><br><span class="line">        	&#125;</span><br><span class="line">		<span class="comment">// Record response time and success count.</span></span><br><span class="line">		node.addRtAndSuccess(rt, count);</span><br><span class="line">		<span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			context.getCurEntry().getOriginNode().addRtAndSuccess(rt, count);</span><br><span class="line">       	        &#125;</span><br><span class="line">        node.decreaseThreadNum();</span><br><span class="line">	       <span class="keyword">if</span> (context.getCurEntry().getOriginNode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">		    context.getCurEntry().getOriginNode().decreaseThreadNum();</span><br><span class="line">                &#125;</span><br><span class="line">	       <span class="keyword">if</span> (resourceWrapper.getEntryType() == EntryType.IN) &#123;</span><br><span class="line">                   Constants.ENTRY_NODE.addRtAndSuccess(rt, count);</span><br><span class="line">                   Constants.ENTRY_NODE.decreaseThreadNum();</span><br><span class="line">               &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Error may happen.</span></span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// Handle exit event with registered exit callback handlers.</span></span><br><span class="line">        Collection&lt;ProcessorSlotExitCallback&gt; exitCallbacks = StatisticSlotCallbackRegistry.getExitCallbacks();</span><br><span class="line">        <span class="keyword">for</span> (ProcessorSlotExitCallback handler : exitCallbacks) &#123;      <span class="comment">// @2</span></span><br><span class="line">		handler.onExit(context, resourceWrapper, count, args);</span><br><span class="line">         &#125;</span><br><span class="line">	fireExit(context, resourceWrapper, count);     <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：成功执行，则重点关注响应时间，其实现亮点如下：<br>计算本次响应时间，将本次响应时间收集到 Node 中。<br>将当前活跃线程数减一。</p>
<p>代码@2：执行退出时的 callback。可以通过 StatisticSlotCallbackRegistry 的 addExitCallback 方法添加退出回调函数。</p>
<p>代码@3：传播 exit 事件。</p>
<p>接下来我们将重点介绍 DefaultNode，即 Sentinel 的 Node 体系，持有资源的实时调用信息。</p>
<h2 id="2、Sentienl-Node-体系"><a href="#2、Sentienl-Node-体系" class="headerlink" title="2、Sentienl Node 体系"></a>2、Sentienl Node 体系</h2><p>2.1 Node 类体系图<br><img src="https://img-blog.csdnimg.cn/20200119210911647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们先简单介绍一下上述核心类的作用与核心接口或核心属性的含义。</p>
<ul>
<li>OccupySupport<br>支持抢占未来的时间窗口，有点类似借用“未来”的令牌。其核心方法如下：<ul>
<li>long tryOccupyNext(long currentTime, int acquireCount, double threshold)<br>尝试抢占未来的令牌，返回值为调用该方法的线程应该 sleep 的时间。<br>1、long currentTime<br>​        当前时间。<br>2、int acquireCount<br>本次需要申请的令牌个数。<br>​          3、double threshold<br>​              设置的阔值。</li>
</ul>
</li>
<li>long waiting()<br>获取当前已申请的未来的令牌的个数。</li>
<li>void addWaitingRequest(long futureTime, int acquireCount)<br>申请未来时间窗口中的令牌。</li>
<li>void addOccupiedPass(int acquireCount)<br>增加申请未来令牌通过的个数。</li>
<li>double occupiedPassQps()<br>当前抢占未来令牌的QPS。</li>
<li>Node<br>持有实时统计信息的节点。定义了收集统计信息与获取统计信息的接口，上面方法根据方法名称即可得知其含义，故这里就不一一罗列了。</li>
<li>StatisticNode<br>实现统计信息的默认实现类。</li>
<li>DefaultNode<br>用于在特定上下文环境中保存某一个资源的实时统计信息。</li>
<li>ClusterNode<br>实现基于集群限流模式的节点，将在集群限流模式部分详细介绍。</li>
<li>EntranceNode<br>用来表示调用链入口的节点信息。</li>
</ul>
<p>本文将详细介绍 DefaultNode 与  StatisticNode，重点阐述调用树与实时统计信息。DefaultNode 是 StatisticNode 的子类，我们先从 StatisticNode 开始 Node 体系的探究。</p>
<h2 id="2、StatisticNode-详解"><a href="#2、StatisticNode-详解" class="headerlink" title="2、StatisticNode 详解"></a>2、StatisticNode 详解</h2><h4 id="2-1-核心类图"><a href="#2-1-核心类图" class="headerlink" title="2.1 核心类图"></a>2.1 核心类图</h4><p><img src="https://img-blog.csdnimg.cn/20200119211057921.png" alt="在这里插入图片描述"><br>我们对其核心属性进行一一解读：</p>
<ul>
<li>Metric rollingCounterInSecond = new ArrayMetric(SampleCountProperty.SAMPLE_COUNT, IntervalProperty.INTERVAL)<br>每秒的实时统计信息，使用 ArrayMetric 实现，即基于滑动窗口实现，正是上篇文章详细介绍的，默认1s 采样 2次。即一个统计周期中包含两个滑动窗口。</li>
<li>Metric rollingCounterInMinute = new ArrayMetric(60, 60 * 1000, false)<br>每分钟实时统计信息，同样使用 ArrayMetric  实现，即基于滑动窗口实现。每1分钟，抽样60次，即包含60个滑动窗口，每一个窗口的时间间隔为 1s 。</li>
<li>LongAdder curThreadNum = new LongAdder()<br>当前线程计数器。</li>
<li>long lastFetchTime = -1<br>上一次获取资源的有效统计数据的时间，即调用 Node 的 metrics() 方法的时间。</li>
</ul>
<p>关于 ArrayMetric 滑动窗口设计与实现原理，请参考笔者的另一篇博文：<a href="https://mp.weixin.qq.com/s/tn8rSHyv_hiJi6QDhfxuIA">Alibaba Seninel 滑动窗口实现原理(文末附原理图)</a></p>
<p>接下来我们挑选几个具有代表性的方法进行探究。</p>
<h4 id="2-2-addPassRequest"><a href="#2-2-addPassRequest" class="headerlink" title="2.2 addPassRequest"></a>2.2 addPassRequest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPassRequest</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">	rollingCounterInSecond.addPass(count);</span><br><span class="line">	rollingCounterInMinute.addPass(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加通过请求数量。即将实时调用信息向滑动窗口中进行统计。addPassRequest 即报告成功的通过数量。就是分别调用 秒级、分钟即对应的滑动窗口中添加数量，然后限流规则、熔断规则将基于滑动窗口中的值进行计算。</p>
<h4 id="2-3-totalRequest"><a href="#2-3-totalRequest" class="headerlink" title="2.3 totalRequest"></a>2.3 totalRequest</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">totalRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rollingCounterInMinute.pass() + rollingCounterInMinute.block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前时间戳的总请求数，获取分钟级时间窗口中的统计信息。</p>
<h4 id="2-4-successQps"><a href="#2-4-successQps" class="headerlink" title="2.4 successQps"></a>2.4 successQps</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">successQps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> rollingCounterInSecond.success() / rollingCounterInSecond.getWindowIntervalInSec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功TPS，用秒级统计滑动窗口中统计的个数 除以 窗口的间隔得出其 tps，即抽样个数越大，其统计越精确。</p>
<blockquote>
<p>温馨提示：上面的方法在学习了上文的滑动窗口设计原理后将显得非常简单，大家在学习的过程中，可以总结出一个规律，什么时候时候使用秒级滑动窗口，什么时候使用分钟级滑动窗口。</p>
</blockquote>
<h4 id="2-5-metrics"><a href="#2-5-metrics" class="headerlink" title="2.5 metrics"></a>2.5 metrics</h4><p>由于 Sentienl 基于滑动窗口来实时收集统计信息，并存储在内存中，并随着时间的推移，旧的滑动窗口将失效，故需要提供一个方法，及时将所有的统计信息进行汇总输出，供监控客户端定时拉取，转储都其他客户端，例如数据库，方便监控数据的可视化，这也通常是中间件用于监控指标的监控与采集的通用设计方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Long, MetricNode&gt; <span class="title">metrics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">    currentTime = currentTime - currentTime % <span class="number">1000</span>;   <span class="comment">// @1</span></span><br><span class="line">    Map&lt;Long, MetricNode&gt; metrics = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    List&lt;MetricNode&gt; nodesOfEverySecond = rollingCounterInMinute.details();   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">long</span> newLastFetchTime = lastFetchTime;</span><br><span class="line">    <span class="comment">// Iterate metrics of all resources, filter valid metrics (not-empty and up-to-date).</span></span><br><span class="line">    <span class="keyword">for</span> (MetricNode node : nodesOfEverySecond) &#123; </span><br><span class="line">        <span class="keyword">if</span> (isNodeInTime(node, currentTime) &amp;&amp; isValidMetricNode(node)) &#123;    <span class="comment">// @3</span></span><br><span class="line">	    metrics.put(node.getTimestamp(), node);</span><br><span class="line">            newLastFetchTime = Math.max(newLastFetchTime, node.getTimestamp());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastFetchTime = newLastFetchTime;</span><br><span class="line">    <span class="keyword">return</span> metrics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取当前时间对应的滑动窗口的开始时间，可以对比上文计算滑动窗口的算法。</p>
<p>代码@2：获取一分钟内的所有滑动窗口中的统计数据，使用 MetricNode 表示。</p>
<p>代码@3：遍历所有节点，刷选出不是当前滑动窗口外的所有数据。这里的重点是方法：isNodeInTime。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isNodeInTime</span><span class="params">(MetricNode node, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> node.getTimestamp() &gt; lastFetchTime &amp;&amp; node.getTimestamp() &lt; currentTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里只刷选出不是当前窗口的数据，即 metrics 方法返回的是“过去”的统计数据。</p>
<p>接下来我们再来看看 DefaultNode 相关的几个特性方法。</p>
<h2 id="3、DefaultNode-详解"><a href="#3、DefaultNode-详解" class="headerlink" title="3、DefaultNode  详解"></a>3、DefaultNode  详解</h2><h4 id="3-1-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h4><p><img src="https://img-blog.csdnimg.cn/20200119211434219.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>DefaultNode 是 StatisticNode 的子类，其额外增加的属性如下：</p>
<ul>
<li>private ResourceWrapper id<br>资源id，即 DefaultNode 才真正与资源挂钩，可以将 DefaultNode 看出是调用链中的一个节点，并且与资源关联。</li>
<li>private volatile Set&lt; Node &gt; childList<br>子节点结合。以此来维持其调用链。</li>
<li>private ClusterNode clusterNode<br>集群节点，同样为 StatisticNode 的子类，表示与资源集群相关的环境。</li>
</ul>
<p>接下来我们将来看一下 DefaultNode 的核心方法。</p>
<h4 id="3-2-increaseBlockQps"><a href="#3-2-increaseBlockQps" class="headerlink" title="3.2 increaseBlockQps"></a>3.2 increaseBlockQps</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseBlockQps</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.increaseBlockQps(count);</span><br><span class="line">    <span class="keyword">this</span>.clusterNode.increaseBlockQps(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultNode 的此类方法，通常是先调用 StatisticNode 的方法，然后再调用 clusterNode 的相关方法，最终就是使用在对应的滑动窗口中增加或减少计量值。</p>
<p>其他方法也比较简单，就不再细看了，我们可以通过 DefaultNode 的 printDefaultNode 方法来打印该节点的调用链。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>滑动窗口</tag>
        <tag>实时数据收集</tag>
        <tag>StatisticSlot</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo Invoker概述----服务发现、集群、负载均衡、路由体系</title>
    <url>/posts/22a2e460.html</url>
    <content><![CDATA[<div id="vip-container"><p>Invoker,负载网络调用组件，底层依懒与网络通信，Invoker主要负责服务调用，自然与路由（比如集群）等功能息息相关，本节先从整体上把控一下Dubbo服务调用体系，服务发现、集群、负载均衡、路由机制等整个知识体系，梳理整理Dubbo Invoker整个类图如下：<br><img src="https://img-blog.csdn.net/20180610171223710?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>主要有如下接口群</p>
<ol>
<li>Invocation(调用上下文环境)</li>
</ol>
<ul>
<li>Invocation：<br>1、String getMethodName()    获取调用方法名。<br>2、Class&lt; ? &gt;[] getParameterTypes()    获取被调用方法的参数列表（参数类型）<br>3、Object[] getArguments()    获取被调用方法的参数值数组。<br>4、Map&lt; String, String&gt; getAttachments()    获取附加属性。<br>5、String getAttachment(String key)    根据key获取附加属性值。<br>6、String getAttachment(String key, String defaultValue)    根据key获取附加属性，如果不存在，取默认值。<br>7、Invoker&lt; ?&gt; getInvoker() 获取当前的invoker。</li>
<li>RpcInvocation rpc服务调用实现类<pre><code>Invocation执行调用上下文环境，就是用一个Bean存储当前调用方法的参数，其本质就是一个普通的Bean而已。</code></pre>
</li>
<li>MockInvocation<pre><code>用于mock单元测试用。</code></pre>
</li>
<li>DecodeableRpcInvocation 带解码功能的rpc调用上下文<pre><code>该实现主要能从RPC服务调用请求中解析二进制流（二进制包）得到RPC服务调用上下文（方法调用元数据）。</code></pre>
</li>
</ul>
<a id="more"></a>

<ol start="2">
<li>Invoker 服务调用器，Dubbo中调用服务的抽象。<br>Invoer的抽象接口，继承自com.alibaba.dubbo.common.Node接口</li>
</ol>
<ul>
<li>Node：<br>1、URL getUrl();      获取URL，在dubbo中，注册中心、服务提供者、服务消费者、监控中心等都使用URL描述。<br>2、boolean isAvailable()    ：判断是否可用。<br>3、void destroy()    ：资源销毁。</li>
<li>Invoker:<br>1、Class<T> getInterface()    :获取服务提供者的接口。<br>Result invoke(Invocation invocation) throws RpcException    ：调用服务，返回调用结果。</li>
<li>AbstractInvoker Invoker默认实现（模板类）<br>   该方法主要实现public Result invoke(Invocation inv) throws RpcException,定义执行invoker的基础流程（模板），然后根据不同的实现子类（不同的协议）执行各自个性化的执行任务。其抽象方法：protected abstract Result doInvoke(Invocation invocation) throws Throwable，具体实现将在后文中分析。</li>
<li>DubboInvoker dubbo协议调用器具体实现。</li>
<li>InjvmInvoker injvm协议调用其具体实现（本地协议）</li>
</ul>
<ol start="3">
<li>AbstractClusterInvoker 集群模式调用模板类<br>  该类为Dubbo集群模式的调用模板类，主题解决一个服务服务有多个服务提供者，此时消息消费端在调用服务时如何选择具体的服务提供者。该类需要组织多个服务提供者，并按照指定算法选择一服务提供者进行调用。</li>
</ol>
<ul>
<li>AvailableClusterInvoker<br>通过&lt; dubbo:service cluster = “available” …/&gt; 或 &lt; dubbo:reference cluster=”available” …/&gt;<br>集群策略：总是选择第一个可用的服务提供者。</li>
<li>BroadcastClusterInvoker<br>通过&lt; dubbo:service cluster = “broadcast” …/&gt; 或 &lt; dubbo:reference cluster=”broadcast” …/&gt;<br>集群策略：广播模式，向所有服务提供者都发送请求，任何一个调用失败，则认为失败。</li>
<li>FailbackClusterInvoker<br>通过&lt; dubbo:service cluster = “failback” …/&gt; 或 &lt; dubbo:reference cluster=”failback” …/&gt;<br>集群策略：服务调用失败后，定时重试，重试次数无线次，重试频率：5s。并不会切换服务提供者。</li>
<li>FailfastClusterInvoker<br>通过&lt; dubbo:service cluster = “failfast” …/&gt; 或 &lt; dubbo:reference cluster=”failfast” …/&gt;<br>集群策略：服务调用后，快速失败，直接抛出异常，并不重试，也不受retries参数的制约，适合新增、修改类操作。</li>
<li>FailoverClusterInvoker<br>通过&lt; dubbo:service cluster = “failover” …/&gt; 或 &lt; dubbo:reference cluster=”failover” …/&gt;<br>集群策略：服务调用后，如果出现失败，则重试其他服务提供者，默认重试2次，总共执行3次，重试次数由retries配置，dubbo集群默认方式。</li>
<li>FailsafeClusterInvoker<br>通过&lt; dubbo:service cluster = “failsafe” …/&gt; 或 &lt; dubbo:reference cluster=”failsafe” …/&gt;<br>集群策略：服务调用后，只打印错误日志，然后直接返回。</li>
<li>ForkingClusterInvoker<br>通过&lt; dubbo:service cluster = “forking” …/&gt; 或 &lt; dubbo:reference cluster=”forking” …/&gt;<br>集群策略：并发调用多个服务提供者，取第一个返回的结果。可以通过forks设置并发调用的服务台提供者个数。</li>
</ul>
<p>更多的集群策略，可以参考/dubbo-cluster/src/main/resources/META-/com.alibaba.dubbo.rpc.cluster.Cluster文件。<br><img src="https://img-blog.csdn.net/2018061017153961?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ol start="4">
<li>LoadBalance 集群负载算法<br>当一个服务有多个服务提供者时，消费端在进行服务调用时选择服务服务提供者的负载均衡算法。<br>LoadBalance定义的接口为：<br>&lt; T&gt; Invoker<T> select(List&lt; Invoker<T>&gt; invokers, URL url, Invocation invocation) throws RpcException;</li>
</ol>
<ul>
<li>ConsistentHashLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”consistenthash” …/&gt;或&lt; dubbo:provider loadbalance = “consistenthash” …/&gt;<br>负载均衡算法：一致性Hash算法，在AbstractClusterInvoker中从多个服务提供者中选择一个服务提供者时被调用。</li>
<li>LeastActiveLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”leastactive” …/&gt;或&lt; dubbo:provider loadbalance = “leastactive” …/&gt;<br>负载均衡算法：最小活跃调用。</li>
<li>RandomLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”random” …/&gt;或&lt; dubbo:service loadbalance = “random” …/&gt;<br>负载均衡算法：随机，如果weight（权重越大，机会越高）</li>
<li>RoundRobinLoadBalance<br>可以通过&lt; dubbo:service loadbalance=”roundrobin” …/&gt;或&lt; dubbo:provider loadbalance = “roundrobin” …/&gt;<br>负载均衡算法：加权轮询算法。</li>
</ul>
<ol start="5">
<li>Directory（目录服务，Invoker的目录服务）<br>该接口主要的作用是服务提供者的目录服务，管理多个服务提供者。</li>
</ol>
<ul>
<li>Directory<br>1、Class&lt; T&gt; getInterface() 获取该服务接口类别。<br>2、List&lt; Invoker&lt; T&gt;&gt; list(Invocation invocation) throws RpcException 根据调用上下文获取当前所有该服务的服务提供者。</li>
</ul>
<p>4.2 AbstractDirectory 目录服务实现的抽象列（模板类）<br>4.3 StaticDirectory 静态目录服务<br>    所谓静态目录服务就是在创建StaticDirectory时指定一个服务提供者集合，则该目录服务实例在其生命周期中，只会返回这些服务提供者。</p>
<ul>
<li>RegistryDirectory 动态目录服务（基于注册中心）、<br>从注册中心动态获取发现服务提供，默认消息消费者并不会指定特定的服务提供者URL，所以会向注册中心订阅服务的服务提供者（监听注册中心providers目录），利用RegistryDirectory自动获取注册中心服务器列表。</li>
</ul>
<ol start="6">
<li>Router 路由功能<br>根据消息消费者URL，结合路由表达式或JS引擎，从Directory中选择符合路由规则的Invoker，再执行负载均衡算法。</li>
</ol>
<ul>
<li>Router<br>1、URL getUrl();    获取消息消费者URL。<br>2、&lt; T&gt; List&lt; Invoker&lt; T&gt;&gt; route(List&lt;  Invoker&lt; T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException  根据消息消费者URL，从invokers中筛选合适的Invokers。</li>
<li>ConditionRouter 基于条件表达式的路由实现。</li>
<li>ScriptRouter 基于JS引擎的路由实现。</li>
</ul>
<p>单个Invoker的实现，例如DubboInvoker、InJVMInvoker底层调用网络通道发送请求命令（oneway、同步、异步调用方式），其网络底层细节将在后续专门讲解网络实现篇章重点分析，接下来的篇章，主要从源码的角度剖析集群、负载均衡、动态路由目录服务（RegistryDirectory ）的实现细节。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>invoker</tag>
        <tag>服务发现</tag>
        <tag>负载均衡</tag>
        <tag>路由体系</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo tps过滤器器实现原理</title>
    <url>/posts/b3d9d24a.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将重点分析一下dubbo限流的另外一个方式，tps过滤器。<br>@Activate(group = Constants.PROVIDER, value = Constants.TPS_LIMIT_RATE_KEY)</p>
<ul>
<li>过滤器作用<br>服务调用tps过滤器</li>
<li>使用场景<br>对Dubbo服务提供者实现限流(tps)。</li>
<li>阻断条件<br>当服务调用者超过其TPS时，直接返回rpc exception。<br>接下来从源码的角度分析Tps过滤器的实现机制。</li>
</ul>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TpsLimitFilter implements Filter &#123;</span><br><span class="line">    private final TPSLimiter tpsLimiter &#x3D; new DefaultTPSLimiter();</span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (!tpsLimiter.isAllowable(invoker.getUrl(), invocation)) &#123;  </span><br><span class="line">            throw new RpcException(</span><br><span class="line">                    &quot;Failed to invoke service &quot;  +  invoker.getInterface().getName() +  &quot;.&quot; + invocation.getMethodName() + &quot; because exceed max service tps.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tps limit 生效的条件是，服务提供者的url中包含了tps=””这个属性，还可以通过&lt;dubbo:parameter=”tps.interval” value=”60000”/&gt;来设置TPS的统计时长，默认为1分钟，表示如果在1分钟之内的调用次数超过配置的tps，则阻断本次RPC服务调用。<br>其TPS控制代码主要由DefaultTPSLimiter实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DefaultTPSLimiter implements TPSLimiter &#123;</span><br><span class="line">    private final ConcurrentMap&lt;String, StatItem&gt; stats &#x3D; new ConcurrentHashMap&lt;String, StatItem&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    public boolean isAllowable(URL url, Invocation invocation) &#123;</span><br><span class="line">        int rate &#x3D; url.getParameter(Constants.TPS_LIMIT_RATE_KEY, -1);    &#x2F;&#x2F; @1</span><br><span class="line">        long interval &#x3D; url.getParameter(Constants.TPS_LIMIT_INTERVAL_KEY,</span><br><span class="line">                Constants.DEFAULT_TPS_LIMIT_INTERVAL);                         </span><br><span class="line">        String serviceKey &#x3D; url.getServiceKey();                                            &#x2F;&#x2F; @2</span><br><span class="line">        if (rate &gt; 0) &#123;</span><br><span class="line">            StatItem statItem &#x3D; stats.get(serviceKey);</span><br><span class="line">            if (statItem &#x3D;&#x3D; null) &#123;</span><br><span class="line">                stats.putIfAbsent(serviceKey,</span><br><span class="line">                        new StatItem(serviceKey, rate, interval));</span><br><span class="line">                statItem &#x3D; stats.get(serviceKey);</span><br><span class="line">            &#125;</span><br><span class="line">            return statItem.isAllowable();                                                     &#x2F;&#x2F; @3</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            StatItem statItem &#x3D; stats.get(serviceKey);</span><br><span class="line">            if (statItem !&#x3D; null) &#123;</span><br><span class="line">                stats.remove(serviceKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取服务提供者url中的参数tps、tps.interval属性。<br>代码@2：获取服务key，并创建或获取对应的StatItem。<br>代码@3：调用StatItem的isAllowable()方法来判断是否可用。<br>StatItem#isAllowable</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean isAllowable() &#123;</span><br><span class="line">        long now &#x3D; System.currentTimeMillis();</span><br><span class="line">        if (now &gt; lastResetTime + interval) &#123;    &#x2F;&#x2F; @1</span><br><span class="line">            token.set(rate);</span><br><span class="line">            lastResetTime &#x3D; now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int value &#x3D; token.get();   </span><br><span class="line">        boolean flag &#x3D; false;</span><br><span class="line">        while (value &gt; 0 &amp;&amp; !flag) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">            flag &#x3D; token.compareAndSet(value, value - 1);  </span><br><span class="line">            value &#x3D; token.get();</span><br><span class="line">        &#125;</span><br><span class="line">        return flag;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该类的核心思想：是漏桶算法。<br>代码@1：如果当前时间大于（上一次刷新时间+统计间隔），重新复位token为rate，表示重新生成一批token。<br>代码@2：每使用一次，消耗一个token，如果能成功消耗一个token则返回true，如果没有可消耗的token，则直接返回false。</p>
<p>Tps过滤器的实现原理其实比较简单，大家可以从这里体会到ConcurrentHashMap、漏桶算法的简易实现。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>execute</tag>
        <tag>active</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo异步调用与事件回调机制</title>
    <url>/posts/70022ae6.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将详细分析Dubbo服务异步调用与事件回调机制。</p>
<h2 id="1、异步调用与事件回调机制"><a href="#1、异步调用与事件回调机制" class="headerlink" title="1、异步调用与事件回调机制"></a>1、异步调用与事件回调机制</h2><h3 id="1-1-异步回调"><a href="#1-1-异步回调" class="headerlink" title="1.1 异步回调"></a>1.1 异步回调</h3><p><img src="https://img-blog.csdn.net/20180906120834523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906120855286?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<a id="more"></a>

<h3 id="1-2-事件回调"><a href="#1-2-事件回调" class="headerlink" title="1.2 事件回调"></a>1.2 事件回调</h3><p><img src="https://img-blog.csdn.net/20180906120921491?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906120940317?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906120956173?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180906121011994?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="2、源码分析异步调用与事件回调机制"><a href="#2、源码分析异步调用与事件回调机制" class="headerlink" title="2、源码分析异步调用与事件回调机制"></a>2、源码分析异步调用与事件回调机制</h2><p>在Dubbo中，引入特定的过滤器FutureFilter来处理异步调用相关的逻辑，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Activate(group &#x3D; Constants.CONSUMER)</span><br><span class="line">public class FutureFilter implements Filter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>group=CONSUMER说明该过滤器属于消费端过滤器。<br>接下来从从invoke方法详细分析其实现逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result invoke(final Invoker&lt;?&gt; invoker, final Invocation invocation) throws RpcException &#123;</span><br><span class="line">        final boolean isAsync &#x3D; RpcUtils.isAsync(invoker.getUrl(), invocation);     &#x2F;&#x2F; @1</span><br><span class="line">        fireInvokeCallback(invoker, invocation);                                                     &#x2F;&#x2F; @2</span><br><span class="line">        &#x2F;&#x2F; need to configure if there&#39;s return value before the invocation in order to help invoker to judge if it&#39;s</span><br><span class="line">        &#x2F;&#x2F; necessary to return future.</span><br><span class="line">        Result result &#x3D; invoker.invoke(invocation);                                                 &#x2F;&#x2F; @3</span><br><span class="line">        if (isAsync) &#123;</span><br><span class="line">            asyncCallback(invoker, invocation);                                                       &#x2F;&#x2F; @4</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            syncCallback(invoker, invocation, result);                                              &#x2F;&#x2F; @5</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先从URL中获取是否是异步调用标志，其配置属性为&lt; dubbo:service async=””/&gt;获取其子标签&lt; dubbo:method async=””/&gt;。<br>代码@2：同步调用oninvoke事件,执行invoke方法之前的事件。<br>代码@3：继续沿着调用链调用,最终会到具体的协议Invoker，例如DubboInvoker，发生具体的服务调用，跟踪一下同步、异步调用的实现细节。<br>代码@4：如果调用方式是异步模式，则异步调用onreturn或onthrow事件。<br>代码@5：如果调用方式是同步模式，则同步调用onreturn或onthrow事件。</p>
<h3 id="2-1-源码分析FutureFilter-fireInvokeCallback"><a href="#2-1-源码分析FutureFilter-fireInvokeCallback" class="headerlink" title="2.1 源码分析FutureFilter#fireInvokeCallback"></a>2.1 源码分析FutureFilter#fireInvokeCallback</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void fireInvokeCallback(final Invoker&lt;?&gt; invoker, final Invocation invocation) &#123;</span><br><span class="line">        final Method onInvokeMethod &#x3D; (Method) StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), </span><br><span class="line">Constants.ON_INVOKE_METHOD_KEY));      &#x2F;&#x2F; @1</span><br><span class="line">        final Object onInvokeInst &#x3D; StaticContext.getSystemContext().get(StaticContext.getKey(invoker.getUrl(), invocation.getMethodName(), </span><br><span class="line">Constants.ON_INVOKE_INSTANCE_KEY));   &#x2F;&#x2F; @2</span><br><span class="line">        if (onInvokeMethod &#x3D;&#x3D; null &amp;&amp; onInvokeInst &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @3</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (onInvokeMethod &#x3D;&#x3D; null || onInvokeInst &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">            throw new IllegalStateException(&quot;service:&quot; + invoker.getUrl().getServiceKey() + &quot; has a onreturn callback config , but no such &quot; + (onInvokeMethod &#x3D;&#x3D; null ? &quot;method&quot; : </span><br><span class="line">                         &quot;instance&quot;) + &quot; found. url:&quot; + invoker.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">        if (!onInvokeMethod.isAccessible()) &#123;</span><br><span class="line">            onInvokeMethod.setAccessible(true);</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] params &#x3D; invocation.getArguments();</span><br><span class="line">        try &#123;</span><br><span class="line">            onInvokeMethod.invoke(onInvokeInst, params);        &#x2F;&#x2F; @5</span><br><span class="line">        &#125; catch (InvocationTargetException e) &#123;</span><br><span class="line">            fireThrowCallback(invoker, invocation, e.getTargetException());    &#x2F;&#x2F; @6</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            fireThrowCallback(invoker, invocation, e);                         &#x2F;&#x2F; @7</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：StaticContext.getSystemContext()中根据key:serviceKey + “.” + method + “.” + “oninvoke.method” 获取配置的oninvoke.method方法名。其中serviceKey为[group]/interface:[version]，其中group与version可能为空，忽略。</p>
<p>代码@2：同样根据key:serviceKey + “.” + method + “.” + “oninvoke.instance” 从StaticContext.getSystemContext()获取oninvoke.method方法所在的实例名对象，也就是说该调用哪个对象的oninvoke.method指定的方法。这里就有一个疑问，这些数据是在什么时候存入StaticContext中的呢？下文会详细分析。</p>
<p>代码@3、@4：主要检测&lt; dubbo:method oninvoke=””/&gt;配置的正确性，其正确的配置方式如下：“实例名.方法名”，例如：<br><img src="https://img-blog.csdn.net/20180906121257970?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>代码@5：根据发射机制，调用oninvoke中指定的实例的指定方法，注意，这里传入的参数为调用远程RPC服务的参数。</p>
<blockquote>
<p>注意：从这里可以看出，如果要实现事件通知，也即在调用远程RPC服务之前，之后、抛出异常时执行回调函数，该回调事件的方法的参数列表需要与被调用服务的参数列表一致。</p>
</blockquote>
<p>代码@6、@7，如果在执行调用前方法(oninvoke)事件方法失败，则会同步调用onthrow中定义的方法（如有定义）。关于dubbo:method oninvoke属性的解析以及在什么时候会向StaticContext.getSystemContext()中添加信息，将在下文统一介绍。</p>
<h3 id="2-2-源码分析DubboInvoker关于同步异步调用处理"><a href="#2-2-源码分析DubboInvoker关于同步异步调用处理" class="headerlink" title="2.2 源码分析DubboInvoker关于同步异步调用处理"></a>2.2 源码分析DubboInvoker关于同步异步调用处理</h3><p>在上文提到FutureFilter#invoke中的第三步调用invoker.invoker方法时，我们应该会有兴趣了解一下真实的invoker是如何处理同步、异步请求的。<br>我们以dubbo协议DubboInvoker来重点分析一下其实现原理：<br>DubboInvoker#doInvoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">            boolean isAsync &#x3D; RpcUtils.isAsync(getUrl(), invocation);            &#x2F;&#x2F; @1</span><br><span class="line">            boolean isOneway &#x3D; RpcUtils.isOneway(getUrl(), invocation);</span><br><span class="line">            int timeout &#x3D; getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">            if (isOneway) &#123;</span><br><span class="line">                boolean isSent &#x3D; getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);</span><br><span class="line">                currentClient.send(inv, isSent);                                             &#x2F;&#x2F; @2</span><br><span class="line">                RpcContext.getContext().setFuture(null);</span><br><span class="line">                return new RpcResult();</span><br><span class="line">            &#125; else if (isAsync) &#123;</span><br><span class="line">                ResponseFuture future &#x3D; currentClient.request(inv, timeout);                 &#x2F;&#x2F; @3</span><br><span class="line">                RpcContext.getContext().setFuture(new FutureAdapter&lt;Object&gt;(future));</span><br><span class="line">                return new RpcResult();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                RpcContext.getContext().setFuture(null);     &#x2F;&#x2F; @4</span><br><span class="line">                return (Result) currentClient.request(inv, timeout).get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (TimeoutException e) &#123;</span><br><span class="line">            throw new RpcException(RpcException.TIMEOUT_EXCEPTION, &quot;Invoke remote method timeout. method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125; catch (RemotingException e) &#123;</span><br><span class="line">            throw new RpcException(RpcException.NETWORK_EXCEPTION, &quot;Failed to invoke remote method: &quot; + invocation.getMethodName() + &quot;, provider: &quot; + getUrl() + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先获取async属性，如果为true表示异步请求，如果配置了return=”false”表示调用模式为oneway，只发调用，不关注其调用结果。</p>
<p>代码@2：处理oneway的情况。如果设置了sent=true，表示等待网络数据发出才返回，如果sent=false，只是将待发送数据发到IO写缓存区就返回。</p>
<p>代码@3：处理异步的情况，代码@4处理同步调用的情况，细看其实都是通过调用网络客户端client的request,最终调用HeaderExchangeChannel#request方法：<br><img src="https://img-blog.csdn.net/20180906121506329?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>这里是通过Future模式来实现异步调用的，同步调用也是通过异步调用来实现，只是同步调用发起后，直接调用future#get的方法来同步等待结果的返回，而异步调用只返回Future Response，在用户需要关心其结果时才调用get方法。</p>
<h3 id="2-3-源码分析asyncCallback与syncCallback"><a href="#2-3-源码分析asyncCallback与syncCallback" class="headerlink" title="2.3 源码分析asyncCallback与syncCallback"></a>2.3 源码分析asyncCallback与syncCallback</h3><p>前面介绍了方法执行之前oninvoker事件的调用分析，接下来分析RPC服务调用完成后，onreturn和onthrow方法的调用逻辑。异步回调与同步回调的区别就是调用onreturn (fireReturnCallback) 和onthrow(fireThrowCallback)调用的地方不同，如果是同步调用，也就是在完成RPC服务调用后，立即调用相关的回调方法，如果是异步调用的话，RPC服务完成后，通过Future模式异步执行。</p>
<p>其实关于onreturn、onthrow属性的解析，执行与oninvoker属性的解析完全一样，再这里也就不重复介绍了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>异步调用</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo前置篇-寻找注册中心、服务提供者、服务消费者功能入口</title>
    <url>/posts/62f3002e.html</url>
    <content><![CDATA[<div id="vip-container"><p> 本节主要阐述如下两个问题：</p>
<ol>
<li><p>Dubbo自定义标签实现。</p>
</li>
<li><p>dubbo通过Spring加载配置文件后，是如何触发注册中心、服务提供者、服务消费者按照Dubbo的设计执行相关的功能。</p>
<p>所谓的执行相关功能如下：</p>
</li>
</ol>
<ul>
<li><p>注册中心启动，监听消息提供者的注册服务、接收消息消费者的服务订阅（服务注册与发现机制）。</p>
</li>
<li><p>服务提供者向注册中心注册服务。</p>
</li>
<li><p>服务消费者向注册中心订阅服务。</p>
<p>接下来从使用dubbo的角度，从配置文件入手：</p>
</li>
</ul>
<h2 id="1、Dubbo服务提供者的一般配置如下："><a href="#1、Dubbo服务提供者的一般配置如下：" class="headerlink" title="1、Dubbo服务提供者的一般配置如下："></a>1、Dubbo服务提供者的一般配置如下：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span><br><span class="line">&lt;dubbo:application name&#x3D;&quot;uop&quot; owner&#x3D;&quot;uce&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 使用zookeeper注册中心暴露服务地址 --&gt;</span><br><span class="line">&lt;dubbo:registry protocol&#x3D;&quot;zookeeper&quot; address&#x3D;&quot;zookeeper:&#x2F;&#x2F;192.168.xx.xx:2181?backup&#x3D;192.168.xx.xx:2182,192.168.xx.xx:2183&quot; &#x2F;&gt;</span><br><span class="line">&lt;!--dubbox中引入Kryo和FST这两种高效Java序列化实现，来逐步取代原生dubbo中的hessian2,如果使用kryo记得添加依赖 --&gt;</span><br><span class="line">&lt;dubbo:protocol name&#x3D;&quot;dubbo&quot; serialization&#x3D;&quot;kryo&quot;  port&#x3D;&quot;20990&quot;  &#x2F;&gt;</span><br><span class="line">&lt;!-- 定义服务提供者默认属性值 --&gt;</span><br><span class="line">&lt;dubbo:provider timeout&#x3D;&quot;5000&quot; threadpool&#x3D;&quot;fixed&quot;  threads&#x3D;&quot;100&quot; accepts&#x3D;&quot;1000&quot; token&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;!-- 暴露服务接口 一个服务可以用多个协议暴露，一个服务也可以注册到多个注册中心--&gt;</span><br><span class="line">&lt;!--Provider上尽量多配置Consumer端的属性，让Provider实现者一开始就思考Provider服务特点、服务质量的问题--&gt;</span><br><span class="line">&lt;dubbo:service interface&#x3D;&quot;com.yingjun.dubbox.api.UserService&quot; ref&#x3D;&quot;userService&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>
<p>上面通过dubbo提供的dubbo:application、dubbo:registry、dubbo:protocol、dubbo:provider、dubbo:service分别定义dubbo应用程序名、注册中心、协议、服务提供者参数默认值、服务提供者，这些配置后面的实现原理是什么呢？是如何启动并发挥相关作用的呢？</p>
<a id="more"></a>

<h2 id="2、Spring自定义标签即命令空间实现"><a href="#2、Spring自定义标签即命令空间实现" class="headerlink" title="2、Spring自定义标签即命令空间实现"></a>2、Spring自定义标签即命令空间实现</h2><p>dubbo自定义标签与命名空间其实现代码在模块dubbo-config中，其核心实现如下：</p>
<h3 id="2-1-DubboNamespaceHandler"><a href="#2-1-DubboNamespaceHandler" class="headerlink" title="2.1 DubboNamespaceHandler"></a>2.1 DubboNamespaceHandler</h3><p>dubbo 命名空间实现 handler，其全路径：com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler，其源码实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DubboNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        Version.checkDuplicate(DubboNamespaceHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        registerBeanDefinitionParser(&quot;application&quot;, new DubboBeanDefinitionParser(ApplicationConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;module&quot;, new DubboBeanDefinitionParser(ModuleConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;registry&quot;, new DubboBeanDefinitionParser(RegistryConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;monitor&quot;, new DubboBeanDefinitionParser(MonitorConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;provider&quot;, new DubboBeanDefinitionParser(ProviderConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;consumer&quot;, new DubboBeanDefinitionParser(ConsumerConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;protocol&quot;, new DubboBeanDefinitionParser(ProtocolConfig.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;service&quot;, new DubboBeanDefinitionParser(ServiceBean.class, true));</span><br><span class="line">        registerBeanDefinitionParser(&quot;reference&quot;, new DubboBeanDefinitionParser(ReferenceBean.class, false));</span><br><span class="line">        registerBeanDefinitionParser(&quot;annotation&quot;, new AnnotationBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，dubbo自定义的标签主要包括：application、module、registry、monitor、provider、consumer、protocol、service、reference、annotation，其具体解析实现类主要包括：DubboBeanDefinitionParser(基于xml配置文件)、AnnotationBeanDefinitionParser(基于注解)，下文会详细分析上述两个解析类的实现。</p>
<h3 id="2-2-定义dubbo-xsd-文件"><a href="#2-2-定义dubbo-xsd-文件" class="headerlink" title="2.2 定义dubbo.xsd 文件"></a>2.2 定义dubbo.xsd 文件</h3><p> 在dubbo-config-spring模块下的 src/main/resouce/META-INF中分别定义dubbo.xsd、spring.handlers、spring.schemas。<br> 关于Spring如何新增命名空间与标签，在源码分析ElasticJob时已经详细介绍过，再这里就不做 过多重复，如需了解，请查看：<a href="https://blog.csdn.net/prestigeding/article/details/79751023">https://blog.csdn.net/prestigeding/article/details/79751023</a></p>
<h2 id="3、Bean解析机制-Spring基础知识"><a href="#3、Bean解析机制-Spring基础知识" class="headerlink" title="3、Bean解析机制(Spring基础知识)"></a>3、Bean解析机制(Spring基础知识)</h2><p> 我们应该知道，Spirng的配置支持xml配置文件与注解的方式,故Dubbo也支持两种配置方式，xml与注解方式。</p>
<h3 id="3-1-xml配置方式解析"><a href="#3-1-xml配置方式解析" class="headerlink" title="3.1 xml配置方式解析"></a>3.1 xml配置方式解析</h3><p><img src="https://img-blog.csdn.net/20180528231944883?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> BeanDefinitionParser：Spring定义的bean解析器，要实现自定义标签，则需要实现该接口，然后通过NamespaceHandlerSupport将Bean定义解析器注册到Spring bean解析器中。从接口中可以看出，其终极目标就是将Element element(xml节点)解析成BeanDefinition，有关于Spring BeanDefinition，请参考：<a href="https://blog.csdn.net/prestigeding/article/details/80490206">https://blog.csdn.net/prestigeding/article/details/80490206</a><br> DubboBeanDefinitionParser构造函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DubboBeanDefinitionParser(Class&lt;?&gt; beanClass, boolean required) &#123;</span><br><span class="line">        this.beanClass &#x3D; beanClass;</span><br><span class="line">        this.required &#x3D; required;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> beanClass：该xml标签节点最终会被Spring实例化的类名。<br> required：该标签的ID是否必须。<br>| 标签名称          |       类名        |<br>| —————– | :—————: |<br>| dubbo:application | ApplicationConfig |<br>| dubbo:module      |   ModuleConfig    |<br>| dubbo:registry    |  RegistryConfig   |<br>| dubbo:monitor     |   MonitorConfig   |<br>| dubbo:provider    |  ProviderConfig   |<br>| dubbo:consumer    |  ConsumerConfig   |<br>| dubbo:protocol    |  ProtocolConfig   |<br>| dubbo:service     |    ServiceBean    |<br>| dubbo:reference   |   ReferenceBean   |<br> 注，包名：com.alibaba.dubbo.config<br> bean解析器的主要目的就是将上述标签，解析成对应的BeanDifinition，以便Spring构建上述类的实例。<br>本节不拷贝DubboBeanDefinitionParser根据xml定义的标签与属性转换成BeanDefinitionParser的每一行代码，本节只给出其大体关键点。<br> Step1：解析id属性，如果DubboBeanDefinitionParser对象的required属性为true，如果id为空，则根据如下规则构建一个id。</p>
<ul>
<li><p>如果name属性不为空，则取name的值，如果已存在，则为 name + 序号,例如  name,name1,name2。</p>
</li>
<li><p>如果name属性为空，如果是dubbo:protocol标签，则取protocol属性，其他的则取interface属性，如果不为空，则取该值，但如果已存在，和name处理相同，在后面追加序号。</p>
</li>
<li><p>如果第二步还未空，则取beanClass的名称，如果已存在，则追加序号。</p>
<p>Step2：根据不同的标签解析特殊属性。</p>
</li>
<li><p>dubbo:protocol,添加protocol属性(BeanDefinition)。</p>
</li>
<li><p>dubbo:service,添加ref属性。</p>
</li>
<li><p>dubbo:provider，嵌套解析,dubbo:provider标签有两个可选的子标签,dubbo:service、dubbo:parameter,这里需要嵌套解析dubbo:service标签<br>知识点：dubbo:provider是配置服务提供者的默认参数，在dubbo spring配置文件中可以配置多个dubbo:provider,那dubbo:service标签如何选取一个合适的dubbo:provider作为其默认参数呢？有两种办法：</p>
</li>
</ul>
<ol>
<li>将dubbo:service标签直接声明在dubbo:provider方法</li>
<li>在dubbo:service中通过provider属性指定一个provider配置，如果不填，并且存在多个dubbo:provider配置，则会抛出错误。</li>
</ol>
<ul>
<li>dubbo:customer：解析嵌套标签，其原理与dubbo:provider解析一样。</li>
</ul>
<p>Step3：解析标签，将属性与值填充到BeanDefinition的propertyValues中。最终返回BeanDefinition实例，供Spring实例化Bean。</p>
<p>上述已经解答了Dubbo自定义标签的解析实现，主要完成了ApplicationConfig、RegistryConfig、ServiceBean、ReferenceBean实例的初始化，那什么时候构建与注册中心的连接、服务提供者什么时候会向注册中心注册服务，服务消费者向注册中心订阅服务呢？</p>
<p>通过上述步骤，我们已经知道已经成功解析注册中心、服务提供者、服务消费者的配置元信息，并将其实例化，按照我们的思路，配置对象生成后，下一步应该是实现Dubbo服务的注册与发现机制，但代码中无法找到相关代码。</p>
<p>据我目前所掌握的知识，Spring在对象实例化，一般有两种方式来对Bean做一些定制化处理。</p>
<ol>
<li><p>实现BeanPostProcessor Spring后置处理器，在Bean初始化前后执行相关操作。</p>
</li>
<li><p>Bean实现InitializingBean接口(init-method)</p>
<p>浏览表格中所有Bean的声明，发现了两个类非常特殊：<br><img src="https://img-blog.csdn.net/20180528232923748?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>ServiceBean(服务提供者)与ReferenceBean(服务消费者)比较特殊，实现了Spring与Bean生命周期相关的接口。</p>
</li>
</ol>
<ul>
<li>InitializingBean，其声明的接口为afterPropertiesSet方法，顾名思义，就是在bean初始化所有属性之后调用。</li>
<li>DisposableBean：其声明的接口为destroy()方法，在Spring BeanFactory销毁一个单例实例之前调用。</li>
<li>ApplicationContextAware：其声明的接口为void setApplicationContext(ApplicationContext applicationContext)，实现了该接口，Spring容器在初始化Bean时会调用该方法，注入ApplicationContext，已方便该实例可以直接调用applicationContext获取其他Bean。</li>
<li>ApplicationListener&lt; ContextRefreshedEvent&gt;：容器重新刷新时执行事件函数。</li>
<li>BeanNameAware：其声明的接口为：void setBeanName(String name)，实现该接口的Bean，其实例可以获取该实例在BeanFactory的id或name。</li>
<li>FactoryBean：Spring初始化Bean的另外一种方式，例如dubbo:reference，需要返回的对象并不是ReferenceBean,而是要返回ref指定的代理类来执行业务操作，故这里使用FactoryBean非常合适，FactoryBean定义了如下三个方法：<ul>
<li>T getObject() throws Exception：获取需要返回的结果对象。</li>
<li>Class&lt;?&gt; getObjectType()：获取返回对象的类型。</li>
<li>boolean isSingleton()：返回是否是单例。</li>
</ul>
</li>
</ul>
<p>看到这里，不免有一点小激动，似乎已经摸到Dubbo服务注册与发现机制（Dubbo服务提供者、Dubbo服务消费者、注册中心的启动流程入口点了，下一步就是分析ServiceBean、ReferenceBean的实现原理，试图揭开Dubbo服务注册与发现机制，该部分内容将在下一篇中详细分析。</p>
<h3 id="3-2-注解配置方式解析"><a href="#3-2-注解配置方式解析" class="headerlink" title="3.2 注解配置方式解析"></a>3.2 注解配置方式解析</h3><p>注解配置方式的解析入口类：AnnotationBeanDefinitionParser，也是基于Spring注解解析逻辑，这部分在将在未来《Spring系列进阶篇-源码分析注解解析实现原理》中详细分析，目前暂未深究，读者朋友们，如果有兴趣，可以以AnnotationBeanDefinitionParser为入口，进行进一步的分析。</p>
<p>本节就讲解到这里了，下一篇将重点分析ServiceBean(服务提供者启动流程)。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo序列化-源码分析kryo序列化实现原理</title>
    <url>/posts/c1c80d83.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文主要梳理Kryo序列化基本实现。重点剖析Kryo#writeClassAndObject、Kryo#readClassAndObject方法。</p>
<h2 id="1、源码分析Kryo-writeClassAndObject"><a href="#1、源码分析Kryo-writeClassAndObject" class="headerlink" title="1、源码分析Kryo#writeClassAndObject"></a>1、源码分析Kryo#writeClassAndObject</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void writeClassAndObject (Output output, Object object) &#123;</span><br><span class="line">	if (output &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;output cannot be null.&quot;);</span><br><span class="line">	beginObject();                                             &#x2F;&#x2F; @1</span><br><span class="line">	try &#123;</span><br><span class="line">		if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">			writeClass(output, null);              &#x2F;&#x2F; @2</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		Registration registration &#x3D; writeClass(output, object.getClass());   &#x2F;&#x2F; @3</span><br><span class="line">		if (references &amp;&amp; writeReferenceOrNull(output, object, false)) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">			registration.getSerializer().setGenerics(this, null);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		if (TRACE || (DEBUG &amp;&amp; depth &#x3D;&#x3D; 1)) log(&quot;Write&quot;, object);</span><br><span class="line">		registration.getSerializer().write(this, output, object);  &#x2F;&#x2F; @5</span><br><span class="line">	&#125; finally &#123;</span><br><span class="line">		if (--depth &#x3D;&#x3D; 0 &amp;&amp; autoReset) reset();       &#x2F;&#x2F; @6</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：开始序列化， 将dept自增，表示当前深度，因为在序列化一个对象时，该方法有可能会被递归调用，每递归调用增加1，一次调用结束后在finally字句中自减。</p>
<p>代码@2：如果对象为空，则调用writeClass(DefaultSerializers$ClassSerializer),序列化为空。</p>
<p>代码@3：如果对象不为空，首先序列化对象所属的Class实例，从这里可以看出，Kryo在序列化时，首先先序列化类型。</p>
<p>代码@4：如果references 为true(默认为true，可以序列化循环依赖)，则调用writeReferenceOrNull序列化。</p>
<p>代码@5：如果references 为false，则调用write序列化，此时如果对象存在循环依赖，则会抛出 throw new KryoException(“Max depth exceeded: “ + depth)异常,如果object为基本类型，也将通过该方法完成值的序列化。</p>
<p>代码@6：完成序列化后，恢复相关数据。也就是说Kryo实例并不是线程安全的。<br>默认references 为true，表示支持循环嵌套，我们接下来重点跟踪一下writeReferenceOrNull方法。</p>
<h3 id="1-1-源码分析writeReferenceOrNull方法"><a href="#1-1-源码分析writeReferenceOrNull方法" class="headerlink" title="1.1 源码分析writeReferenceOrNull方法"></a>1.1 源码分析writeReferenceOrNull方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** @param object May be null if mayBeNull is true.</span><br><span class="line">	 * @return true if no bytes need to be written for the object. *&#x2F;</span><br><span class="line">	boolean writeReferenceOrNull (Output output, Object object, boolean mayBeNull) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">		if (object &#x3D;&#x3D; null) &#123;                                                                                                    &#x2F;&#x2F; @2                    </span><br><span class="line">			if (TRACE || (DEBUG &amp;&amp; depth &#x3D;&#x3D; 1)) log(&quot;Write&quot;, null);</span><br><span class="line">			output.writeVarInt(Kryo.NULL, true);</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line">		if (!referenceResolver.useReferences(object.getClass())) &#123;                                  &#x2F;&#x2F; @3</span><br><span class="line">			if (mayBeNull) output.writeVarInt(Kryo.NOT_NULL, true);</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Determine if this object has already been seen in this object graph.</span><br><span class="line">		int id &#x3D; referenceResolver.getWrittenId(object);                                                 &#x2F;&#x2F; @4</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; If not the first time encountered, only write reference ID.</span><br><span class="line">		if (id !&#x3D; -1) &#123;                                                                                                        &#x2F;&#x2F; @5</span><br><span class="line">			if (DEBUG) debug(&quot;kryo&quot;, &quot;Write object reference &quot; + id + &quot;: &quot; + string(object));</span><br><span class="line">			output.writeVarInt(id + 2, true); &#x2F;&#x2F; + 2 because 0 and 1 are used for NULL and NOT_NULL.</span><br><span class="line">			return true;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; Otherwise write NOT_NULL and then the object bytes.</span><br><span class="line">		id &#x3D; referenceResolver.addWrittenObject(object);     &#x2F;&#x2F; @6</span><br><span class="line">		output.writeVarInt(NOT_NULL, true);</span><br><span class="line">		if (TRACE) trace(&quot;kryo&quot;, &quot;Write initial object reference &quot; + id + &quot;: &quot; + string(object));</span><br><span class="line">		return false;                                                              &#x2F;&#x2F; @7</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数说明：Output output：输出流；Object object：待序列化的对象；</p>
<p>代码@2：如果对象为空，写入Kryo.NULL(0)，然后返回true，表示需要设置generic，后续会讲解一下generic(泛型支持)。</p>
<p>代码@3：如果是基本类型，如果maybe(值可能为空)，但该方法不为空，则设置为Kryo.NOT_NULL,然后返回false，表示非引用类型，需要持久化值。</p>
<p>代码@4：判断该对象是否在对象图中已被序列化一次。（其实现方式ListReferenceResolver、MapReferenceResolver）。</p>
<p>ListReferenceResolver#getWrittenId </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getWrittenId (Object object) &#123;</span><br><span class="line">	for (int i &#x3D; 0, n &#x3D; seenObjects.size(); i &lt; n; i++) &#123;</span><br><span class="line">		if (seenObjects.get(i) &#x3D;&#x3D; object) &#123;</span><br><span class="line">			return i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@5：如果writtenId不等于-1，表示该对象已被序列化，直接序列化ID，直接返回true,然后结束writeClassAndObject该方法，表示该对象实例完成。</p>
<p>代码@6：为object构建一个ID，这个ID数据是在一次嵌套调用writeClassAndObject内有效，然后writeClassAndObject结束后，会调用reset方法，将其清空，然后先写入为空标识，并返回false，也就是第一次序列化对象时，返回false，会进入到writeClassAndObject的代码@5中。<br>Kryo#writeClassAndObject 代码@5</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registration.getSerializer().write(this, output, object);  &#x2F;&#x2F; @5</span><br></pre></td></tr></table></figure>
<p>其实其重点关键，还是writeClassAndObject#writeClass也就是上文说的代码@3，在序列化对象之前，首先先序列化该对象的类型，然后需要返回对应的字段序列器。例如，如果类的类型为java.util.Map，则首先先要记录类型为Map，然后返回可以序列化Map的序列器，再例如类型如果是java.lang.String，则先序列化类型，然后序列化值，序列化值的序列器则为DefaultSerializers\$StringSerializer，那如果是一个对象类型，例如cn.uce.demo.Student，自然，第一步是先序列化类型cn.uce.demo.Student，接下来就需要序列化Student的各个字段的信息，返回的序列化为DefaultSerializers$FieldSerializer,然后可以通过FieldSeriaizer返回Student的属性列表，然后单独一个字段一个字段的序列化，其顺序也就是，先类型，再序列化值。这样就递归完成了一个对象的序列化操作。</p>
<a id="more"></a>

<p><strong>Kryo序列化实现原理</strong> ：<br>1、先序列化类型(Class实例)，然后根据类型返回相应的序列化器(上一篇详细介绍了各种类型的序列化器)。</p>
<p>2、再序列化该类型的值。</p>
<p>3、如果自定义类型，例如(cn.uce.demo.Student)，则返回的值序列化器为DefaultSerializers$FieldSerializer,然后一个字段一个字段的序列化，当然其序列化类型也是，先类型再值的模式，递归进行，最终完成。</p>
<p>4、引入了对象图的概念来消除循环依懒的序列化，已序列化的对象，在循环引用时，只是用一个int类型来表示该对象值，类似一种缓存的概念。</p>
<p><strong>Kryo与java 序列化的区别</strong><br>kryo的设计目的是指对象值的序列化，关注的是数据有效数据的传输，减少需要序列化的元数据信息。</p>
<p>这一点通过Kryo对Class对象的序列化，也就是类型的序列化就能看出端倪。Kryo对Class的序列化只需要化Class的全路径名，在反序列化时根据Class通过类加载进行加载，大大减少了序列化后的文件大小，能极大提高性能。</p>
<p>Kryo的核心设计理念就是尽最大可能减少序列化后的文件大小，其举措1就是通过对long,int等数据类型，采用变长字节存储来代替java中使用固定字节(4,8)字节的模式，因为在软件开发中，对象的这些值基本上都是小值，能节省很多空间，第二个举措是使用了类似缓存的机制，在一次序列化对象中，在整个递归序列化期间，相同的对象，只会序列化一次，后续的用一个局部int值来代替。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>序列化</tag>
        <tag>kryo</tag>
        <tag>协议设计</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo异步调用与事件回调机制</title>
    <url>/posts/70022ae6.html</url>
    <content><![CDATA[<div id="vip-container"><p>谈到服务调用日志，大家恐怕第一想到就是如果开启了这个参数，会影响性能。那真实的情况是怎么样了？性能损耗到底有多大呢？在实践中我们如何使用该功能呢？本文将详细分析Dubbo accesslog实现原理。<br>AccessLogFilter概述</p>
<ul>
<li>过滤器作用<br>记录调用日志。</li>
<li>使用场景<br>记录服务提供者端调用日志。</li>
<li>阻断条件<br>非阻断过滤器。</li>
</ul>
<p>接下来源码分析accesslog参数的实现原理。<br><img src="https://img-blog.csdn.net/20180909221922266?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<a id="more"></a>

<h2 id="1、核心字段说明"><a href="#1、核心字段说明" class="headerlink" title="1、核心字段说明"></a>1、核心字段说明</h2><ul>
<li>LOG_MAX_BUFFER：积累最大的日志容量，默认为5000条，如果积压在队列中的待处理日志超过该值，则直接丢弃。</li>
<li>LOG_OUTPUT_INTERVAL：日志写出的调度频率，默认为5s。</li>
<li>ConcurrentMap&lt; String, Set&lt; String&gt;&gt; logQueue：日志容器。</li>
<li>ScheduledExecutorService logScheduled：写出日志调度器，默认为2个线程，线程名称为：Dubbo-Access-Log。</li>
</ul>
<h2 id="2、invoke方法源码分析"><a href="#2、invoke方法源码分析" class="headerlink" title="2、invoke方法源码分析"></a>2、invoke方法源码分析</h2><p>AccessLogFilter#invoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String accesslog &#x3D; invoker.getUrl().getParameter(Constants.ACCESS_LOG_KEY);    </span><br><span class="line">            if (ConfigUtils.isNotEmpty(accesslog)) &#123;    &#x2F;&#x2F; @1                                                       </span><br><span class="line">                RpcContext context &#x3D; RpcContext.getContext();</span><br><span class="line">                String serviceName &#x3D; invoker.getInterface().getName();</span><br><span class="line">                String version &#x3D; invoker.getUrl().getParameter(Constants.VERSION_KEY);</span><br><span class="line">                String group &#x3D; invoker.getUrl().getParameter(Constants.GROUP_KEY);</span><br><span class="line">                StringBuilder sn &#x3D; new StringBuilder();         &#x2F;&#x2F; @2 start</span><br><span class="line">                sn.append(&quot;[&quot;).append(new SimpleDateFormat(MESSAGE_DATE_FORMAT).format(new Date())).append(&quot;] </span><br><span class="line">                       &quot;).append(context.getRemoteHost()).append(&quot;:&quot;).append(context.getRemotePort())</span><br><span class="line">                        .append(&quot; -&gt; &quot;).append(context.getLocalHost()).append(&quot;:&quot;).append(context.getLocalPort())</span><br><span class="line">                        .append(&quot; - &quot;);</span><br><span class="line">                if (null !&#x3D; group &amp;&amp; group.length() &gt; 0) &#123;</span><br><span class="line">                    sn.append(group).append(&quot;&#x2F;&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(serviceName);</span><br><span class="line">                if (null !&#x3D; version &amp;&amp; version.length() &gt; 0) &#123;</span><br><span class="line">                    sn.append(&quot;:&quot;).append(version);</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(&quot; &quot;);</span><br><span class="line">                sn.append(inv.getMethodName());</span><br><span class="line">                sn.append(&quot;(&quot;);</span><br><span class="line">                Class&lt;?&gt;[] types &#x3D; inv.getParameterTypes();</span><br><span class="line">                if (types !&#x3D; null &amp;&amp; types.length &gt; 0) &#123;</span><br><span class="line">                    boolean first &#x3D; true;</span><br><span class="line">                    for (Class&lt;?&gt; type : types) &#123;</span><br><span class="line">                        if (first) &#123;</span><br><span class="line">                            first &#x3D; false;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            sn.append(&quot;,&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        sn.append(type.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                sn.append(&quot;) &quot;);</span><br><span class="line">                Object[] args &#x3D; inv.getArguments();</span><br><span class="line">                if (args !&#x3D; null &amp;&amp; args.length &gt; 0) &#123;</span><br><span class="line">                    sn.append(JSON.toJSONString(args));</span><br><span class="line">                &#125;</span><br><span class="line">                String msg &#x3D; sn.toString();</span><br><span class="line">                if (ConfigUtils.isDefault(accesslog)) &#123;         &#x2F;&#x2F; @2</span><br><span class="line">                    LoggerFactory.getLogger(ACCESS_LOG_KEY + &quot;.&quot; + invoker.getInterface().getName()).info(msg);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    log(accesslog, msg);                              &#x2F;&#x2F; @3</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.warn(&quot;Exception in AcessLogFilter of service(&quot; + invoker + &quot; -&gt; &quot; + inv + &quot;)&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(inv);                                 &#x2F;&#x2F; @4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先从服务提供者URL中获取accesslog参数，如果存在该参数并且不为空，则进入服务调用日志，如果未配置，则直接进入下一个过滤器。</p>
<p>代码@2：组装服务调用日志，其内容：<br>[服务调用时间，精确到时分秒] + 消费者IP:消费者PORT +  –&gt; 服务提供者IP:服务提供者端口 +  “服务提供者group/“(可选) + serviceName(interface name) + “:version”(可选) + methodName( + 参数类型列表）+  参数值(json格式的字符串) 。</p>
<p>代码@3：如果accesslog=”true”，则使用info级别的日志输出；如果是配置的是日志路径的话，则异步写入文件。<br>接下来分析一下log方法，写入日志文件的具体实现：<br>AccessLogFilter#log</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void log(String accesslog, String logmessage) &#123;</span><br><span class="line">        init();     														&#x2F;&#x2F; @1</span><br><span class="line">        Set&lt;String&gt; logSet &#x3D; logQueue.get(accesslog);                                            &#x2F;&#x2F; @2 start</span><br><span class="line">        if (logSet &#x3D;&#x3D; null) &#123;</span><br><span class="line">            logQueue.putIfAbsent(accesslog, new ConcurrentHashSet&lt;String&gt;());</span><br><span class="line">            logSet &#x3D; logQueue.get(accesslog);</span><br><span class="line">        &#125;</span><br><span class="line">        if (logSet.size() &lt; LOG_MAX_BUFFER) &#123;                                                   &#x2F;&#x2F; @2 end</span><br><span class="line">            logSet.add(logmessage);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：授权通过init方法启动定时任务，已间隔5s,延迟5s后执行第一次调度，具体的任务实现为LogTask。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void init() &#123;</span><br><span class="line">        if (logFuture &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (logScheduled) &#123;</span><br><span class="line">                if (logFuture &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    logFuture &#x3D; logScheduled.scheduleWithFixedDelay(new LogTask(), LOG_OUTPUT_INTERVAL, LOG_OUTPUT_INTERVAL, </span><br><span class="line">                           TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@2：以文件路径名accesslog为键，从logQueue中获取，如果当前处理的长度大于LOG_MAX_BUFFER固定为5000条，则丢弃。由于存储日志的容器为ConcurrentHashSet<String>，则日志记录是乱序的。<br>具体异步记录日志的任务实现为AccessLogFilter$LogTask。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private class LogTask implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                if (logQueue !&#x3D; null &amp;&amp; logQueue.size() &gt; 0) &#123;</span><br><span class="line">                    for (Map.Entry&lt;String, Set&lt;String&gt;&gt; entry : logQueue.entrySet()) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            String accesslog &#x3D; entry.getKey();</span><br><span class="line">                            Set&lt;String&gt; logSet &#x3D; entry.getValue();</span><br><span class="line">                            File file &#x3D; new File(accesslog);              </span><br><span class="line">                            File dir &#x3D; file.getParentFile();  </span><br><span class="line">                            if (null !&#x3D; dir &amp;&amp; !dir.exists()) &#123;</span><br><span class="line">                                dir.mkdirs();</span><br><span class="line">                            &#125;     &#x2F;&#x2F; @1</span><br><span class="line">                            if (logger.isDebugEnabled()) &#123;</span><br><span class="line">                                logger.debug(&quot;Append log to &quot; + accesslog);</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (file.exists()) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">                                String now &#x3D; new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date());</span><br><span class="line">                                String last &#x3D; new SimpleDateFormat(FILE_DATE_FORMAT).format(new Date(file.lastModified()));</span><br><span class="line">                                if (!now.equals(last)) &#123;</span><br><span class="line">                                    File archive &#x3D; new File(file.getAbsolutePath() + &quot;.&quot; + last);</span><br><span class="line">                                    file.renameTo(archive);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            FileWriter writer &#x3D; new FileWriter(file, true);</span><br><span class="line">                            try &#123;</span><br><span class="line">                                for (Iterator&lt;String&gt; iterator &#x3D; logSet.iterator();</span><br><span class="line">                                     iterator.hasNext();</span><br><span class="line">                                     iterator.remove()) &#123;</span><br><span class="line">                                    writer.write(iterator.next());</span><br><span class="line">                                    writer.write(&quot;\r\n&quot;);</span><br><span class="line">                                &#125;</span><br><span class="line">                                writer.flush();</span><br><span class="line">                            &#125; finally &#123;</span><br><span class="line">                                writer.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            logger.error(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：从这里可以看出accesslog配置的是具体的日志文件全路径，例如d:/logs/accesslog.log。</p>
<p>代码@2：如果文件存在，则需要判断该文件的最后修改时间与当前日期是否相同，如果不同，则首先将文件重新命名为前一天的日期，然后再创建一个新的accesslog文件，也就是accesslog文件的布局是一天一个文件。</p>
<p>accesslog 调用日志记录就分析到这里，我们思考一下开启该参数对服务提供者的性能影响。</p>
<ul>
<li>accesslog=”true”,其实现为通过log4j等日志组件，使用info级别将调用日志输出，该方法对服务调用者的影响还是比较大，不建议这样使用。</li>
<li>accesslog=”日志文件路径”，该方式，dubbo使用的是异步记录日志的方式，开启额外的信息，主要是需要组织日志内容，耗费一定的CPU资源，但对服务的响应整体性能损耗还是不会起到恶劣的影响。默认情况下，还是不建议开启，但是如果线上服务器有BUG，需要通过调用日志来拍错的话，也可以在不重启服务提供者的情况下开启，开启方法利用Dubbo的配置覆盖机制，该部分的内容详情请参考作者的另一篇博客：源码分析Dubbo配置规则机制（override协议）：<a href="https://blog.csdn.net/prestigeding/article/details/80795708">https://blog.csdn.net/prestigeding/article/details/80795708</a> 。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>异步调用</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo服务提供者、服务消费者并发度控制机制</title>
    <url>/posts/1ea63fb8.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将详细分析&lt; dubbo:service executes=””/&gt;与&lt; dubbo:reference actives = “”/&gt;的实现机制，深入探讨Dubbo自身的保护机制。</p>
<h2 id="1、源码分析ExecuteLimitFilter"><a href="#1、源码分析ExecuteLimitFilter" class="headerlink" title="1、源码分析ExecuteLimitFilter"></a>1、源码分析ExecuteLimitFilter</h2><p>@Activate(group = Constants.PROVIDER, value = Constants.EXECUTES_KEY )</p>
<ul>
<li>过滤器作用<br>服务调用方并发度控制。</li>
<li>使用场景<br>对Dubbo服务提供者实现的一种保护机制，控制每个服务的最大并发度。</li>
<li>阻断条件<br>当服务调用超过允许的并发度后，直接抛出RpcException异常。<br>接下来源码分析ExecuteLimitFilter的实现细节。</li>
</ul>
<a id="more"></a>

<p>ExecuteLimitFilter#invoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();</span><br><span class="line">        String methodName &#x3D; invocation.getMethodName();</span><br><span class="line">        Semaphore executesLimit &#x3D; null;</span><br><span class="line">        boolean acquireResult &#x3D; false;</span><br><span class="line">        int max &#x3D; url.getMethodParameter(methodName, Constants.EXECUTES_KEY, 0);      &#x2F;&#x2F; @1</span><br><span class="line">        if (max &gt; 0) &#123;</span><br><span class="line">            RpcStatus count &#x3D; RpcStatus.getStatus(url, invocation.getMethodName());             &#x2F;&#x2F; @2</span><br><span class="line">            executesLimit &#x3D; count.getSemaphore(max);                                                              &#x2F;&#x2F; @3</span><br><span class="line">            if(executesLimit !&#x3D; null &amp;&amp; !(acquireResult &#x3D; executesLimit.tryAcquire())) &#123;              &#x2F;&#x2F; @4</span><br><span class="line">                throw new RpcException(&quot;Failed to invoke method &quot; + invocation.getMethodName() + &quot; in provider &quot; + url + &quot;, cause: The service using threads </span><br><span class="line">                      greater than &lt;dubbo:service executes&#x3D;\&quot;&quot; + max + &quot;\&quot; &#x2F;&gt; limited.&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        boolean isSuccess &#x3D; true;</span><br><span class="line">        try &#123;</span><br><span class="line">            Result result &#x3D; invoker.invoke(invocation);                 &#x2F;&#x2F; @5</span><br><span class="line">            return result;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            isSuccess &#x3D; false;</span><br><span class="line">            if (t instanceof RuntimeException) &#123;</span><br><span class="line">                throw (RuntimeException) t;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                throw new RpcException(&quot;unexpected exception when ExecuteLimitFilter&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if(acquireResult) &#123;                                   &#x2F;&#x2F; @6</span><br><span class="line">                executesLimit.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：从服务提供者列表中获取参数executes的值，如果该值小于等于0，表示不启用并发度控制，直接沿着调用链进行调用。</p>
<p>代码@2：根据服务提供者url和服务调用方法名，获取RpcStatus。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static RpcStatus getStatus(URL url, String methodName) &#123;</span><br><span class="line">        String uri &#x3D; url.toIdentityString();      </span><br><span class="line">        ConcurrentMap&lt;String, RpcStatus&gt; map &#x3D; METHOD_STATISTICS.get(uri);         </span><br><span class="line">        if (map &#x3D;&#x3D; null) &#123;</span><br><span class="line">            METHOD_STATISTICS.putIfAbsent(uri, new ConcurrentHashMap&lt;String, RpcStatus&gt;());    </span><br><span class="line">            map &#x3D; METHOD_STATISTICS.get(uri);</span><br><span class="line">        &#125;</span><br><span class="line">        RpcStatus status &#x3D; map.get(methodName);          &#x2F;</span><br><span class="line">        if (status &#x3D;&#x3D; null) &#123;</span><br><span class="line">            map.putIfAbsent(methodName, new RpcStatus());</span><br><span class="line">            status &#x3D; map.get(methodName);</span><br><span class="line">        &#125;</span><br><span class="line">        return status;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里是并发容器ConcurrentHashMap的经典使用，从 这里可以看出ConcurrentMap&lt; String, ConcurrentMap&lt; String, RpcStatus&gt;&gt; METHOD_STATISTICS的存储结构为 {  服务提供者URL唯一字符串：{方法名：RpcStatus} }。</p>
<p>代码@3：根据服务提供者配置的最大并发度，创建该服务该方法对应的信号量对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Semaphore getSemaphore(int maxThreadNum) &#123;</span><br><span class="line">        if(maxThreadNum &lt;&#x3D; 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (executesLimit &#x3D;&#x3D; null || executesPermits !&#x3D; maxThreadNum) &#123;</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (executesLimit &#x3D;&#x3D; null || executesPermits !&#x3D; maxThreadNum) &#123;</span><br><span class="line">                    executesLimit &#x3D; new Semaphore(maxThreadNum);</span><br><span class="line">                    executesPermits &#x3D; maxThreadNum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return executesLimit;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>使用了双重检测来创建executesLimit 信号量。</p>
<p>代码@4：如果获取不到锁，并不会阻塞等待，而是直接抛出RpcException,服务端的策略是快速抛出异常，供服务调用方（消费者）根据集群策略进行执行，例如重试其他服务提供者。</p>
<p>代码@5：执行真实的服务调用。</p>
<p>代码@6：如果成功申请到信号量，在服务调用结束后，释放信号量。<br>总结：&lt; dubbo:service executes=””/&gt;的含义是，针对每个服务每个方法的最大并发度。如果超过该值，则直接抛出RpcException。</p>
<h2 id="2、源码分析ActiveLimitFilter"><a href="#2、源码分析ActiveLimitFilter" class="headerlink" title="2、源码分析ActiveLimitFilter"></a>2、源码分析ActiveLimitFilter</h2><p>@Activate(group = Constants.CONSUMER, value = Constants.ACTIVES_KEY )</p>
<ul>
<li>过滤器作用<br>消费端调用服务的并发控制。</li>
<li>使用场景<br>控制同一个消费端对服务端某一服务的并发调用度，通常该值应该小于&lt; dubbo:service executes=””/&gt;</li>
<li>阻断条件<br>非阻断，但如果超过允许的并发度会阻塞，超过超时时间后将不再调用服务，而是直接抛出超时。</li>
</ul>
<p>源码分析ActiveLimitFilter的实现原理：<br>ActiveLimitFilter#invoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();</span><br><span class="line">        String methodName &#x3D; invocation.getMethodName();</span><br><span class="line">        int max &#x3D; invoker.getUrl().getMethodParameter(methodName, Constants.ACTIVES_KEY, 0);    &#x2F;&#x2F; @1</span><br><span class="line">        RpcStatus count &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName());           &#x2F;&#x2F; @2</span><br><span class="line">        if (max &gt; 0) &#123;                                          </span><br><span class="line">            long timeout &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.TIMEOUT_KEY, 0);   &#x2F;&#x2F; @3</span><br><span class="line">            long start &#x3D; System.currentTimeMillis();</span><br><span class="line">            long remain &#x3D; timeout;</span><br><span class="line">            int active &#x3D; count.getActive();                                                                                                                                          &#x2F;&#x2F; @4</span><br><span class="line">            if (active &gt;&#x3D; max) &#123;                                                                                                                                                          &#x2F;&#x2F; @5</span><br><span class="line">                synchronized (count) &#123;                                                                                                                                                                      </span><br><span class="line">                    while ((active &#x3D; count.getActive()) &gt;&#x3D; max) &#123;                                                                                                     </span><br><span class="line">                        try &#123;</span><br><span class="line">                            count.wait(remain);                                                                                                                                      </span><br><span class="line">                        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        long elapsed &#x3D; System.currentTimeMillis() - start;                               </span><br><span class="line">                        remain &#x3D; timeout - elapsed;</span><br><span class="line">                        if (remain &lt;&#x3D; 0) &#123;                                                                                                                                             &#x2F;&#x2F; @6</span><br><span class="line">                            throw new RpcException(&quot;Waiting concurrent invoke timeout in client-side for service:  &quot;</span><br><span class="line">                                    + invoker.getInterface().getName() + &quot;, method: &quot;</span><br><span class="line">                                    + invocation.getMethodName() + &quot;, elapsed: &quot; + elapsed</span><br><span class="line">                                    + &quot;, timeout: &quot; + timeout + &quot;. concurrent invokes: &quot; + active</span><br><span class="line">                                    + &quot;. max concurrent invoke limit: &quot; + max);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            long begin &#x3D; System.currentTimeMillis();</span><br><span class="line">            RpcStatus.beginCount(url, methodName);        &#x2F;&#x2F; @7</span><br><span class="line">            try &#123;</span><br><span class="line">                Result result &#x3D; invoker.invoke(invocation);     &#x2F;&#x2F; @8</span><br><span class="line">                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, true);    &#x2F;&#x2F; @9</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (RuntimeException t) &#123;</span><br><span class="line">                RpcStatus.endCount(url, methodName, System.currentTimeMillis() - begin, false);</span><br><span class="line">                throw t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            if (max &gt; 0) &#123;</span><br><span class="line">                synchronized (count) &#123;</span><br><span class="line">                    count.notify();     &#x2F;&#x2F; @10</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：从Invoker中获取消息端URL中的配置的actives参数，为什么从Invoker中获取的Url是消费端的Url呢？这是因为在消费端根据服务提供者URL创建调用Invoker时，会用服务提供者URL，然后合并消费端的配置属性，其优先级 -D &gt; 消费端 &gt; 服务端。其代码位于：、<br>RegistryDirectory#toInvokers<br>URL url = mergeUrl(providerUrl);</p>
<p>代码@2：根据服务提供者URL和调用服务提供者方法，获取RpcStatus。</p>
<p>代码@3：获取接口调用的超时时间，默认为1s。</p>
<p>代码@4：获取当前消费者，针对特定服务，特定方法的并发调用度，active值。</p>
<p>代码@5：如果当前的并发 调用大于等于允许的最大值，则针对该RpcStatus申请锁，并调用其wait(timeout)进行等待，也就是在接口调用超时时间内，还是未被唤醒，则直接抛出超时异常。</p>
<p>代码@6：判断被唤醒的原因是因为等待超时，还是由于调用结束，释放了”名额“，如果是超时唤醒，则直接抛出异常。</p>
<p>代码@7：在一次服务调用前，先将 服务名+方法名对应的RpcStatus的active加一。</p>
<p>代码@8：执行RPC服务调用。</p>
<p>代码@9：记录成功调用或失败调用，并将active减一。</p>
<p>代码@10：最终成功执行，如果开启了actives机制(dubbo:referecnce actives=””)时，唤醒等待者。</p>
<blockquote>
<p>总结：&lt; dubbo:reference actives=””/&gt; 是控制消费端对 单个服务提供者单个服务允许调用的最大并发度。该值的取值不应该大于&lt; dubbo:service executes=””/&gt;的值，并且如果消费者机器的配置，如果性能不尽相同，不建议对该值进行设置。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>execute</tag>
        <tag>active</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo服务提供者启动流程-下篇</title>
    <url>/posts/380ae8bd.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文继续上文Dubbo服务提供者启动流程，在上篇文章中详细梳理了基于dubbo spring文件的配置方式，Dubbo是如何加载配置文件，服务提供者dubbo:service标签服务暴露全流程，本节重点关注RegistryProtocol#export中调用doLocalExport方法，其实主要是根据各自协议，服务提供者建立网络服务器，在特定端口建立监听，监听来自消息消费端服务的请求。</p>
<a id="more"></a>

<p>RegistryProtocol#doLocalExport:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; ExporterChangeableWrapper&lt;T&gt; doLocalExport(final Invoker&lt;T&gt; originInvoker) &#123;</span><br><span class="line">        String key &#x3D; getCacheKey(originInvoker);</span><br><span class="line">        ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">        if (exporter &#x3D;&#x3D; null) &#123;</span><br><span class="line">            synchronized (bounds) &#123;</span><br><span class="line">                exporter &#x3D; (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);</span><br><span class="line">                if (exporter &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    final Invoker&lt;?&gt; invokerDelegete &#x3D; new InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));   &#x2F;&#x2F; @1</span><br><span class="line">                    exporter &#x3D; new ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);    &#x2F;&#x2F; @2</span><br><span class="line">                    bounds.put(key, exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return exporter;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果服务提供者以dubbo协议暴露服务，getProviderUrl(originInvoker)返回的URL将以dubbo://开头。<br>代码@2：根据Dubbo内置的SPI机制，将调用DubboProtocol#export方法。</p>
<h2 id="1、源码分析DubboProtocol-export"><a href="#1、源码分析DubboProtocol-export" class="headerlink" title="1、源码分析DubboProtocol#export"></a>1、源码分析DubboProtocol#export</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">        URL url &#x3D; invoker.getUrl();     &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F; export service.</span><br><span class="line">        String key &#x3D; serviceKey(url);      &#x2F;&#x2F; @2</span><br><span class="line">        DubboExporter&lt;T&gt; exporter &#x3D; new DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line">        exporterMap.put(key, exporter);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;export an stub service for dispatching event</span><br><span class="line">        Boolean isStubSupportEvent &#x3D; url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);    &#x2F;&#x2F;@3  start</span><br><span class="line">        Boolean isCallbackservice &#x3D; url.getParameter(Constants.IS_CALLBACK_SERVICE, false);                                                  </span><br><span class="line">        if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;                                                                                                                        </span><br><span class="line">            String stubServiceMethods &#x3D; url.getParameter(Constants.STUB_EVENT_METHODS_KEY);</span><br><span class="line">            if (stubServiceMethods &#x3D;&#x3D; null || stubServiceMethods.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                if (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(new IllegalStateException(&quot;consumer [&quot; + url.getParameter(Constants.INTERFACE_KEY) +</span><br><span class="line">                            &quot;], has set stubproxy support event ,but no stub methods founded.&quot;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);                                                                      </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   &#x2F;&#x2F; @3 end</span><br><span class="line"></span><br><span class="line">        openServer(url);   &#x2F;&#x2F; @4</span><br><span class="line">        optimizeSerialization(url);  &#x2F;&#x2F; @5</span><br><span class="line">        return exporter;                </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取服务提供者URL，以协议名称，这里是dubbo://开头。<br>代码@2：从服务提供者URL中获取服务名，key: interface:port，例如：com.alibaba.dubbo.demo.DemoService:20880。<br>代码@3：是否将转发事件导出成stub。<br>代码@4：根据url打开服务，下面将详细分析其实现。<br>代码@5：根据url优化器序列化方式。</p>
<h2 id="2、源码分析DubboProtocol-openServer"><a href="#2、源码分析DubboProtocol-openServer" class="headerlink" title="2、源码分析DubboProtocol#openServer"></a>2、源码分析DubboProtocol#openServer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void openServer(URL url) &#123;</span><br><span class="line">        &#x2F;&#x2F; find server.</span><br><span class="line">        String key &#x3D; url.getAddress();    &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F;client can export a service which&#39;s only for server to invoke</span><br><span class="line">        boolean isServer &#x3D; url.getParameter(Constants.IS_SERVER_KEY, true);</span><br><span class="line">        if (isServer) &#123;</span><br><span class="line">            ExchangeServer server &#x3D; serverMap.get(key);           &#x2F;&#x2F; @2</span><br><span class="line">            if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">                serverMap.put(key, createServer(url));                    &#x2F;&#x2F;@3</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; server supports reset, use together with override</span><br><span class="line">                server.reset(url);                                                       &#x2F;&#x2F;@4</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据url获取网络地址：ip:port，例如：192.168.56.1:20880，服务提供者IP与暴露服务端口号。<br>代码@2：根据key从服务器缓存中获取，如果存在，则执行代码@4，如果不存在，则执行代码@3.<br>代码@3：根据URL创建一服务器，Dubbo服务提供者服务器实现类为ExchangeServer。<br>代码@4：如果服务器已经存在，用当前URL重置服务器，这个不难理解，因为一个Dubbo服务中，会存在多个dubbo:service标签，这些标签都会在服务台提供者的同一个IP地址、端口号上暴露服务。</p>
<h3 id="2-1-源码分析DubboProtocol-createServer"><a href="#2-1-源码分析DubboProtocol-createServer" class="headerlink" title="2.1 源码分析DubboProtocol#createServer"></a>2.1 源码分析DubboProtocol#createServer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ExchangeServer createServer(URL url) &#123;</span><br><span class="line">        &#x2F;&#x2F; send readonly event when server closes, it&#39;s enabled by default</span><br><span class="line">        url &#x3D; url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());    &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F; enable heartbeat by default</span><br><span class="line">        url &#x3D; url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));     &#x2F;&#x2F; @2</span><br><span class="line">        String str &#x3D; url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);  &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))    &#x2F;&#x2F; @4</span><br><span class="line">            throw new RpcException(&quot;Unsupported server type: &quot; + str + &quot;, url: &quot; + url);</span><br><span class="line"></span><br><span class="line">        url &#x3D; url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);       &#x2F;&#x2F; @5</span><br><span class="line">        ExchangeServer server;</span><br><span class="line">        try &#123;</span><br><span class="line">            server &#x3D; Exchangers.bind(url, requestHandler);    &#x2F;&#x2F; @6</span><br><span class="line">        &#125; catch (RemotingException e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Fail to start server(url: &quot; + url + &quot;) &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        str &#x3D; url.getParameter(Constants.CLIENT_KEY);     &#x2F;&#x2F;@7</span><br><span class="line">        if (str !&#x3D; null &amp;&amp; str.length() &gt; 0) &#123;</span><br><span class="line">            Set&lt;String&gt; supportedTypes &#x3D; ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();</span><br><span class="line">            if (!supportedTypes.contains(str)) &#123;</span><br><span class="line">                throw new RpcException(&quot;Unsupported client type: &quot; + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return server;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：为服务提供者url增加channel.readonly.sent属性，默认为true，表示在发送请求时，是否等待将字节写入socket后再返回，默认为true。<br>代码@2：为服务提供者url增加heartbeat属性，表示心跳间隔时间，默认为60*1000，表示60s。<br>代码@3：为服务提供者url增加server属性，可选值为netty,mina等等，默认为netty。<br>代码@4：根据SPI机制，判断server属性是否支持。<br>代码@5：为服务提供者url增加codec属性，默认值为dubbo，协议编码方式。<br>代码@6：根据服务提供者URI,服务提供者命令请求处理器requestHandler构建ExchangeServer实例。requestHandler的实现具体在以后详细分析Dubbo服务调用时再详细分析。<br>代码@7：验证客户端类型是否可用。</p>
<h4 id="2-1-1-源码分析Exchangers-bind-根据URL、ExchangeHandler构建服务器"><a href="#2-1-1-源码分析Exchangers-bind-根据URL、ExchangeHandler构建服务器" class="headerlink" title="2.1.1 源码分析Exchangers.bind 根据URL、ExchangeHandler构建服务器"></a>2.1.1 源码分析Exchangers.bind 根据URL、ExchangeHandler构建服务器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (handler &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;handler &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        url &#x3D; url.addParameterIfAbsent(Constants.CODEC_KEY, &quot;exchange&quot;);</span><br><span class="line">        return getExchanger(url).bind(url, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码不难看出，首先根据url获取Exchanger实例，然后调用bind方法构建ExchangeServer，Exchanger接口如下<br><img src="https://img-blog.csdn.net/20180605225624607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li>ExchangeServer bind(URL url, ExchangeHandler handler) : 服务提供者调用。</li>
<li>ExchangeClient connect(URL url, ExchangeHandler handler):服务消费者调用。</li>
</ul>
<p>dubbo提供的实现类为：HeaderExchanger，其bind方法如下：</p>
<p>HeaderExchanger#bind</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;</span><br><span class="line">        return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里可以看出，端口的绑定由Transporters的bind方法实现。</p>
<h4 id="2-1-2-源码分析Transporters-bind方法"><a href="#2-1-2-源码分析Transporters-bind方法" class="headerlink" title="2.1.2 源码分析Transporters.bind方法"></a>2.1.2 源码分析Transporters.bind方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;</span><br><span class="line">        if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;url &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if (handlers &#x3D;&#x3D; null || handlers.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;handlers &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ChannelHandler handler;</span><br><span class="line">        if (handlers.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            handler &#x3D; handlers[0];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            handler &#x3D; new ChannelHandlerDispatcher(handlers);</span><br><span class="line">        &#125;</span><br><span class="line">        return getTransporter().bind(url, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">public static Transporter getTransporter() &#123;</span><br><span class="line">        return ExtensionLoader.getExtensionLoader(Transporter.class).getAdaptiveExtension();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里得知，Dubbo网络传输的接口有Transporter接口实现，其继承类图所示：<br><img src="https://img-blog.csdn.net/20180605225739594?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>本文以netty版本来查看一下Transporter实现。</p>
<p>NettyTransporter源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NettyTransporter implements Transporter &#123;</span><br><span class="line"></span><br><span class="line">    public static final String NAME &#x3D; &quot;netty&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyServer(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Client connect(URL url, ChannelHandler listener) throws RemotingException &#123;</span><br><span class="line">        return new NettyClient(url, listener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>NettyServer建立网络连接的实现方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        ExecutorService boss &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerBoss&quot;, true));</span><br><span class="line">        ExecutorService worker &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;NettyServerWorker&quot;, true));</span><br><span class="line">        ChannelFactory channelFactory &#x3D; new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));</span><br><span class="line">        bootstrap &#x3D; new ServerBootstrap(channelFactory);</span><br><span class="line"></span><br><span class="line">        final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);      &#x2F;&#x2F; @1</span><br><span class="line">        channels &#x3D; nettyHandler.getChannels();</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-365</span><br><span class="line">        &#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-379</span><br><span class="line">        &#x2F;&#x2F; final Timer timer &#x3D; new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">        bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public ChannelPipeline getPipeline() &#123;</span><br><span class="line">                NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">                ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">                &#x2F;*int idleTimeout &#x3D; getIdleTimeout();</span><br><span class="line">                if (idleTimeout &gt; 10000) &#123;</span><br><span class="line">                    pipeline.addLast(&quot;timer&quot;, new IdleStateHandler(timer, idleTimeout &#x2F; 1000, 0, 0));</span><br><span class="line">                &#125;*&#x2F;</span><br><span class="line">                pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());</span><br><span class="line">                pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());</span><br><span class="line">                pipeline.addLast(&quot;handler&quot;, nettyHandler);     &#x2F;&#x2F; @2</span><br><span class="line">                return pipeline;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; bind</span><br><span class="line">        channel &#x3D; bootstrap.bind(getBindAddress());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>熟悉本方法需要具备Netty的知识，有关源码：<a href="https://blog.csdn.net/prestigeding/article/details/53977445">阅读Netty系列文章</a>，这里不对每一行代码进行解读，对于与网络相关的参数，将在后续文章中详细讲解，本方法@1、@2引起了我的注意，首先创建NettyServer必须传入一个服务提供者URL，但从DubboProtocol#createServer中可以看出，Server是基于网络套接字（ip:port）缓存的，一个JVM应用中，必然会存在多个dubbo:server标签，就会有多个URL，这里为什么可以这样做呢？从DubboProtocol#createServer中可以看出，在解析第二个dubbo:service标签时并不会调用createServer,而是会调用Server#reset方法，是不是这个方法有什么魔法，在reset方法时能将URL也注册到Server上，那接下来分析NettyServer#reset方法是如何实现的。</p>
<h3 id="2-2源码分析DdubboProtocol-reset"><a href="#2-2源码分析DdubboProtocol-reset" class="headerlink" title="2.2源码分析DdubboProtocol#reset"></a>2.2源码分析DdubboProtocol#reset</h3><p>reset方法最终将用Server的reset方法，同样还是以netty版本的NettyServer为例，查看reset方法的实现原理。NettyServer#reset—&gt;父类(AbstractServer)</p>
<p>AbstractServer#reset</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void reset(URL url) &#123;</span><br><span class="line">        if (url &#x3D;&#x3D; null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;                                                                                                       &#x2F;&#x2F; @1 start</span><br><span class="line">            if (url.hasParameter(Constants.ACCEPTS_KEY)) &#123;</span><br><span class="line">                int a &#x3D; url.getParameter(Constants.ACCEPTS_KEY, 0);</span><br><span class="line">                if (a &gt; 0) &#123;</span><br><span class="line">                    this.accepts &#x3D; a;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (url.hasParameter(Constants.IDLE_TIMEOUT_KEY)) &#123;</span><br><span class="line">                int t &#x3D; url.getParameter(Constants.IDLE_TIMEOUT_KEY, 0);</span><br><span class="line">                if (t &gt; 0) &#123;</span><br><span class="line">                    this.idleTimeout &#x3D; t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (url.hasParameter(Constants.THREADS_KEY)</span><br><span class="line">                    &amp;&amp; executor instanceof ThreadPoolExecutor &amp;&amp; !executor.isShutdown()) &#123;</span><br><span class="line">                ThreadPoolExecutor threadPoolExecutor &#x3D; (ThreadPoolExecutor) executor;</span><br><span class="line">                int threads &#x3D; url.getParameter(Constants.THREADS_KEY, 0);</span><br><span class="line">                int max &#x3D; threadPoolExecutor.getMaximumPoolSize();</span><br><span class="line">                int core &#x3D; threadPoolExecutor.getCorePoolSize();</span><br><span class="line">                if (threads &gt; 0 &amp;&amp; (threads !&#x3D; max || threads !&#x3D; core)) &#123;</span><br><span class="line">                    if (threads &lt; core) &#123;</span><br><span class="line">                        threadPoolExecutor.setCorePoolSize(threads);</span><br><span class="line">                        if (core &#x3D;&#x3D; max) &#123;</span><br><span class="line">                            threadPoolExecutor.setMaximumPoolSize(threads);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        threadPoolExecutor.setMaximumPoolSize(threads);</span><br><span class="line">                        if (core &#x3D;&#x3D; max) &#123;</span><br><span class="line">                            threadPoolExecutor.setCorePoolSize(threads);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(t.getMessage(), t);</span><br><span class="line">        &#125;              &#x2F;&#x2F; @1 end</span><br><span class="line">        super.setUrl(getUrl().addParameters(url.getParameters()));    &#x2F;&#x2F; @2</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先是调整线程池的相关线程数量，这个好理解。、<br>代码@2：然后设置调用setUrl覆盖原先NettyServer的private volatile URL url的属性，那为什么不会影响原先注册的dubbo:server呢？<br>原来NettyHandler上加了注解：@Sharable，由该注解去实现线程安全。</p>
<p>Dubbo服务提供者启动流程将分析到这里了，本文并未对网络细节进行详细分析，旨在梳理出启动流程，有关Dubbo服务网络实现原理将在后续章节中详细分析，敬请期待。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>服务提供者</tag>
        <tag>启动</tag>
        <tag>网络监听</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo网络通信篇NettyServer、HeaderExchangeServer</title>
    <url>/posts/5b5952d6.html</url>
    <content><![CDATA[<div id="vip-container"><p> 本文主要分析一下NettyServer，HeaderExchangeServer实现细节。</p>
<h2 id="1、NettyServer"><a href="#1、NettyServer" class="headerlink" title="1、NettyServer"></a>1、NettyServer</h2><p> NettyServer整个类图如下：<br><img src="https://img-blog.csdn.net/20180723120806159?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 首先从全貌上大概看一下NettyServer对象所持有的属性：</p>
<a id="more"></a>

<ul>
<li>AbstractPeer<br>1、private final ChannelHandler handler ： 事件处理Handler。<br>2、private volatile URL url ：该协议的第一个服务提供者的URL，<br>Server只需要用到URL中的参数，与具体某一个服务没什么关系。</li>
<li>AbstractEndpoint<br>这些属性都是以第一个加载到的服务提供者的配置，不科学？超时机制需要后续关注】<br>1、private Codec2 codec ：编码解码器。<br>2、private int timeout ：      超时时间<br>3、private int connectTimeout ：连接超时时间<br>注，如果通过dubbo:provider改变codec,不同的服务提供者引用的默<br>认服务提供者参数不同，那这个只能是以第一个为主了，应该不科学？</li>
<li>AbstractServer<br>1、private InetSocketAddress localAddress ：url host:port地址。<br>2、private InetSocketAddress bindAddress：如果是多网卡，并且指定了 bind.ip、bind.port，如果为空，与localAddress相同。<br>3、private int accepts ： AbstractServer#accepts未使用到。<br>4、private int idleTimeout = 600;  AbstractServer#accepts未使用到。</li>
<li>NettyServer<br>1、private Map&lt; String, Channel&gt; channels：&lt; ip:port, channel&gt; 所有通道。<br>2、private ServerBootstrap bootstrap ： netty 服务端启动器。<br>3、private io.netty.channel.Channel channel：服务端监听通道。<br>4、private EventLoopGroup bossGroup;Netty boss线程组（负责连接事件）<br>5、private EventLoopGroup workerGroup ： nety work线程组（负责IO事件）<br>上述只是简单介绍一下Server端的属性，有如下几个疑问需要关注。<br>AbstractEndpoint中定义的属性，为什么可以取第一个服务提供者的配置。<br>AbstractServer中的accepts、idleTimeout为什么是取最后一服务提供者的配置【从代码中看，这两个属性，未使用】。</li>
</ul>
<h3 id="1-1-NettyServer-构造方法"><a href="#1-1-NettyServer-构造方法" class="headerlink" title="1.1 NettyServer 构造方法"></a>1.1 NettyServer 构造方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用父类的public AbstractServer(URL url, ChannelHandler handler)方法，从前面的文章中得知， ChannelHandlers.wrap方法会对ChannelHandler handler进行封装，主要是加入事件分发模式(Dispatch)。</p>
<h4 id="1-1-1-AbstractServer构造方法"><a href="#1-1-1-AbstractServer构造方法" class="headerlink" title="1.1.1 AbstractServer构造方法"></a>1.1.1 AbstractServer构造方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123;</span><br><span class="line">        super(url, handler);       &#x2F;&#x2F; @1</span><br><span class="line">        localAddress &#x3D; getUrl().toInetSocketAddress();   &#x2F;&#x2F; @2</span><br><span class="line"></span><br><span class="line">        String bindIp &#x3D; getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());</span><br><span class="line">        int bindPort &#x3D; getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());</span><br><span class="line">        if (url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) &#123;</span><br><span class="line">            bindIp &#x3D; NetUtils.ANYHOST;</span><br><span class="line">        &#125;</span><br><span class="line">        bindAddress &#x3D; new InetSocketAddress(bindIp, bindPort);   &#x2F;&#x2F; @3</span><br><span class="line">        this.accepts &#x3D; url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);  </span><br><span class="line">        this.idleTimeout &#x3D; url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT); &#x2F;&#x2F; @4</span><br><span class="line">        try &#123;</span><br><span class="line">            doOpen();   &#x2F;&#x2F; @5</span><br><span class="line">            if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(&quot;Start &quot; + getClass().getSimpleName() + &quot; bind &quot; + getBindAddress() + &quot;, export &quot; + getLocalAddress());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new RemotingException(url.toInetSocketAddress(), null, &quot;Failed to bind &quot; + getClass().getSimpleName()</span><br><span class="line">                    + &quot; on &quot; + getLocalAddress() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;fixme replace this with better method</span><br><span class="line">        DataStore dataStore &#x3D; ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class="line">        executor &#x3D; (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：调用父类的构造方法，主要初始化AbstractPeer（channelHandler、url）和AbstractEndpoint（codec2、timeout、idleTimeout ）<br>代码@2：根据URL中的host与端口，创建localAddress。<br>代码@3：如果配置了&lt; dubbo:parameter key = “bind.ip” value = “”/&gt; 与 &lt; dubbo:parameter key = “bind.port” /&gt;，则用该IP与端口创建bindAddress，通常用于多网卡，如果未配置，bindAddress与 localAddress绑定的IP与端口一样。<br>代码@4：初始化accepts与idleTimeout ,这两个参数未被其他地方使用。<br>代码@5，调用doOpen方法，正式在相应端口建立网络监听。</p>
<h3 id="1-2、源码分析NettyServer-doOpen"><a href="#1-2、源码分析NettyServer-doOpen" class="headerlink" title="1.2、源码分析NettyServer#doOpen"></a>1.2、源码分析NettyServer#doOpen</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void doOpen() throws Throwable &#123;</span><br><span class="line">        NettyHelper.setNettyLoggerFactory();</span><br><span class="line">        bootstrap &#x3D; new ServerBootstrap();       &#x2F;&#x2F; @1</span><br><span class="line">        bossGroup &#x3D; new NioEventLoopGroup(1, new DefaultThreadFactory(&quot;NettyServerBoss&quot;, true));    &#x2F;&#x2F; @2</span><br><span class="line">        workerGroup &#x3D; new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</span><br><span class="line">                new DefaultThreadFactory(&quot;NettyServerWorker&quot;, true));    &#x2F;&#x2F; @3</span><br><span class="line">        final NettyServerHandler nettyServerHandler &#x3D; new NettyServerHandler(getUrl(), this);   &#x2F;&#x2F; @4</span><br><span class="line">        channels &#x3D; nettyServerHandler.getChannels();</span><br><span class="line">        bootstrap.group(bossGroup, workerGroup)                                                                        &#x2F;&#x2F; @5</span><br><span class="line">                .channel(NioServerSocketChannel.class)</span><br><span class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</span><br><span class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</span><br><span class="line">                .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    protected void initChannel(NioSocketChannel ch) throws Exception &#123;</span><br><span class="line">                        NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">                        ch.pipeline()&#x2F;&#x2F;.addLast(&quot;logging&quot;,new LoggingHandler(LogLevel.INFO))&#x2F;&#x2F;for debug                       </span><br><span class="line">                                .addLast(&quot;decoder&quot;, adapter.getDecoder())   </span><br><span class="line">                                .addLast(&quot;encoder&quot;, adapter.getEncoder())</span><br><span class="line">                                .addLast(&quot;handler&quot;, nettyServerHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        &#x2F;&#x2F; bind</span><br><span class="line">        ChannelFuture channelFuture &#x3D; bootstrap.bind(getBindAddress());     &#x2F;&#x2F; @6</span><br><span class="line">        channelFuture.syncUninterruptibly();</span><br><span class="line">        channel &#x3D; channelFuture.channel();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：创建Netty服务端启动帮助类ServerBootstrap.<br>代码@2：创建服务端Boss线程，线程名：.NettyServerBoss，主要负责客户端的连接事件，主从多Reactor线程模型中的主线程（连接事件）。<br>代码@3：创建服务端Work线程组，线程名：NettyServerWorker-序号，线程个数取自参数：iothreads，默认为(CPU核数+1)与32取小值，顾名思义，IO线程数，主要处理读写事件，编码、解码都在IO线程中完成。<br>代码@4：创建用户Handler,这里是NettyServerHandler。<br>代码@5：Netty启动的常规写法，关注如下内容：<br>addLast(“decoder”, adapter.getDecoder())  : 添加解码器<br>addLast(“encoder”, adapter.getEncoder()) ：添加编码器<br>addLast(“handler”, nettyServerHandler) ：添加业务Handler。</p>
<p>这里简单介绍一下流程：<br>1、客户端建立与服务端连接，此时Boss线程的连接事件触发，建立TCP连接，并向IO线程注册该通道(Channel0)的读事件。<br>2、当客户端向服务端发送请求消息后，IO线程中的读事件触发，会首先调用adapter.getDecoder() 根据对应的请求协议（例如dubbo）从二进制流中解码出一个完整的请求对象，然后传入到业务handler,例如nettyServerHandler，执行相应的事件方法，例如recive方法。<br>3、当服务端向Channel写入响应结果时，首先编码器会按照协议编码成二进制流，供客户端解码。、<br>如果对Netty想深入学习的话，请移步到作者的《源码分析Netty系列》<a href="https://blog.csdn.net/prestigeding/article/details/53977445">https://blog.csdn.net/prestigeding/article/details/53977445</a></p>
<h2 id="2、HeaderExchangeServer"><a href="#2、HeaderExchangeServer" class="headerlink" title="2、HeaderExchangeServer"></a>2、HeaderExchangeServer</h2><p>根据Dubbo服务端初始化流程，我们可知，Dubbo为了封装各种不同的网络实现客户端（netty、mina）等，映入了Exchangers层，通用存在ExchangeServer，其实现Server并内部持有具体的Server实现端，例如NettyServer。<br><img src="https://img-blog.csdn.net/20180723122046649?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>接下来，我们重点来关注一下HeaderExchangeServer.<br>核心属性如下：</p>
<ul>
<li>ScheduledExecutorService scheduled：心跳线程数，线程名称前缀，dubbo-remoting-server-heartbeat-thread-序号</li>
<li>private final Server server：具体的Server实现类，例如NettyServer。</li>
<li>private ScheduledFuture&lt; ?&gt; heartbeatTimer：心跳调度Future，可以通过future取消心跳等动作。</li>
<li>private int heartbeat：心跳间隔时间</li>
<li>private int heartbeatTimeout：心跳超时时间，至少为heartbeat的两倍</li>
</ul>
<h3 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public HeaderExchangeServer(Server server) &#123;</span><br><span class="line">        if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;server &#x3D;&#x3D; null&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        this.server &#x3D; server;</span><br><span class="line">        this.heartbeat &#x3D; server.getUrl().getParameter(Constants.HEARTBEAT_KEY, 0);</span><br><span class="line">        this.heartbeatTimeout &#x3D; server.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);</span><br><span class="line">        if (heartbeatTimeout &lt; heartbeat * 2) &#123;</span><br><span class="line">            throw new IllegalStateException(&quot;heartbeatTimeout &lt; heartbeatInterval * 2&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        startHeartbeatTimer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>说明，主要是通过heartbeat参数设置心跳间隔，如果不配置，则不启动心跳检测。从上面看来HeaderExchangeServer内部持有Server,并封装了心跳的功能，在这里就不细细分析了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>NettyServer</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo网络通讯篇之NettyServer网络事件之线程池</title>
    <url>/posts/25a8fc09.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文主要分析Dubbo线程池的构建过程，主要介绍官方文档中有关于ThreadPool的种类：</p>
<ul>
<li>fixed<br>固定大小线程池，启动时建立线程，不关闭，一致持有。（缺省)</li>
<li>cached<br>缓存线程池，空闲一分钟，线程会消费，需要时重新创建新线程。</li>
<li>limited<br>可伸缩线程池，但池中的线程数只会增长不会收缩。</li>
<li>eager<br>优先使用线程来执行新提交任务。（渴望立即执行，而不是进入队列排队执行）。</li>
</ul>
<p>在介绍这各种线程策略之前，先简单回顾一下线程池的基本知识。</p>
<a id="more"></a>

<p><strong>线程池的核心属性如下</strong>：</p>
<ul>
<li><p>int corePoolSize<br>线程池核心线程数、常驻线程数。</p>
</li>
<li><p>int maximumPoolSize<br>线程池中最大线程数量</p>
</li>
<li><p>long keepAliveTime<br>线程保持活跃时间,（如果线程创建，并空闲指定值后，线程会被回收，0表示不开启该特性,其范围针对    corePoolSize的线程）</p>
</li>
<li><p>TimeUnit unit<br>keepAliveTime的时间单位。</p>
</li>
<li><p>BlockingQueue&lt; Runnable&gt; workQueue<br>任务队列</p>
</li>
<li><p>ThreadFactory threadFactory<br>线程工厂类，一般通过该线程工厂，为线程命名，以便区分线程。</p>
</li>
<li><p>RejectedExecutionHandler handler)<br>拒绝策略。</p>
</li>
</ul>
<p><strong>提交任务流程（线程创建流程）</strong></p>
<ol>
<li>如果线程池中线程数量小于corePoolSize，则创建一个线程来执行该任务。</li>
<li>如果线程池中的线程大于等于corePoolSize，则尝试将任务放入队列中。</li>
<li>如果成功将任务放入队列，则本次提交任务正常结束，如果放入任务队列失败则继续下一步。<ol start="4">
<li>如果线程池中的线程数量小于最大线程数，则创建先的线程，否则执行拒绝策略。<h2 id="1、fixed-固定大小线程池"><a href="#1、fixed-固定大小线程池" class="headerlink" title="1、fixed 固定大小线程池"></a>1、fixed 固定大小线程池</h2></li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FixedThreadPool implements ThreadPool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Executor getExecutor(URL url) &#123;</span><br><span class="line">        String name &#x3D; url.getParameter(Constants.THREAD_NAME_KEY, </span><br><span class="line">              Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        int threads &#x3D; url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br><span class="line">        int queues &#x3D; url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        return new ThreadPoolExecutor(threads, threads, 0, TimeUnit.MILLISECONDS,</span><br><span class="line">                queues &#x3D;&#x3D; 0 ? new SynchronousQueue&lt;Runnable&gt;() :</span><br><span class="line">                        (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;()</span><br><span class="line">                                : new LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                new NamedThreadFactory(name, true), new AbortPolicyWithReport(name,       </span><br><span class="line">                   url));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现要点：<br>  1、首先获取可配置参数threadname、threads、queues三个参数，分别代表线程池中线程名前缀、线程中最大线程数量、任务队列长度。<br>  2、要实现fixed固定大小线程池，故名思议，就是线程池自创建以来，线程数量始终保持一致。其实现要点是，corePoolSize、maximumPoolSize相等，并且其值等于threads(默认200)，并且keepAliveTime=0，表示线程始终活跃。<br>  3、任务队列，如果queues 为0，则使用SynchronousQueue，如果小于0，则使用无界队列，如果大于0，则创建容量为LinkedBlockingQueue的队列，超过容量，则拒绝入队。<br>  4、线程工厂，NamedThreadFactory，主要设置线程名称，默认为Dubbo-thread-序号。<br>  5、拒绝策略AbortPolicyWithReport，其主要是如果拒绝任务，首先会打印出详细日志，包含线程池的核心参数，并且会dump jstack日志，日志文件默认存储在user.home/Dubbo_JStack.log.timestamp，可以通过dump.directory 属性配置，可通过&lt;  dubbo:protocol&gt; &lt; dubbo:parameter key =“” value = “”/&gt; &lt; /dubbo:protocol&gt;。</p>
<p>这里再简单介绍如果队列长度为0（默认），为什么是选用SynchronousQueue队列。<br><strong>SynchronousQueue的一个简单理解：调用offer、put之前，必须先调用take，也就是先调用take方法的线程阻塞，然后当别的线程调用offer之后，调用take的线程被唤醒，如果没有线程调用take方法，一个线程调用offer方法，则会返回false，并不会将元素添加到SynchronousQueue队列中，因为SynchronousQueue内部的队列长度为0。</strong></p>
<p>与该线程池相关的配置属性：threadname、theadpool、threads、queues。</p>
<h2 id="2、cached-缓存线程池，线程空闲后会被回收"><a href="#2、cached-缓存线程池，线程空闲后会被回收" class="headerlink" title="2、cached   缓存线程池，线程空闲后会被回收"></a>2、cached   缓存线程池，线程空闲后会被回收</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CachedThreadPool implements ThreadPool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Executor getExecutor(URL url) &#123;</span><br><span class="line">        String name &#x3D; url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        int cores &#x3D; url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br><span class="line">        int threads &#x3D; url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE);</span><br><span class="line">        int queues &#x3D; url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        int alive &#x3D; url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE);</span><br><span class="line">        return new ThreadPoolExecutor(cores, threads, alive, TimeUnit.MILLISECONDS,</span><br><span class="line">                queues &#x3D;&#x3D; 0 ? new SynchronousQueue&lt;Runnable&gt;() :</span><br><span class="line">                        (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;()</span><br><span class="line">                                : new LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                new NamedThreadFactory(name, true), new AbortPolicyWithReport(name, url));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  实现要点：既然要实现线程可以被回收，则必然要设置keepAliveTime。<br>  故对应线程池核心参数设置，对应如下：<br>   ● corePoolSize：通过参数corethreads设置，默认为0<br>   ● maximumPoolSize：通过参数threads设置，默认200<br>   ● keepAliveTime：通过参数alive设置，默认为60 * 1000<br>   ● workQueue  ：通过queues参数设置，默认为0<br>   ● 其他与fixed相同，则不重复介绍</p>
<h2 id="3、limited-可伸缩线程池，其特征：线程数只增不减"><a href="#3、limited-可伸缩线程池，其特征：线程数只增不减" class="headerlink" title="3、limited 可伸缩线程池，其特征：线程数只增不减"></a>3、limited 可伸缩线程池，其特征：线程数只增不减</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LimitedThreadPool implements ThreadPool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Executor getExecutor(URL url) &#123;</span><br><span class="line">        String name &#x3D; url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        int cores &#x3D; url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br><span class="line">        int threads &#x3D; url.getParameter(Constants.THREADS_KEY, Constants.DEFAULT_THREADS);</span><br><span class="line">        int queues &#x3D; url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        return new ThreadPoolExecutor(cores, threads, Long.MAX_VALUE, TimeUnit.MILLISECONDS,</span><br><span class="line">                queues &#x3D;&#x3D; 0 ? new SynchronousQueue&lt;Runnable&gt;() :</span><br><span class="line">                        (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;()</span><br><span class="line">                                : new LinkedBlockingQueue&lt;Runnable&gt;(queues)),</span><br><span class="line">                new NamedThreadFactory(name, true), new AbortPolicyWithReport(name, url));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 与cached不同的是，limited线程池中线程一旦创建，就不回收，与cached不同的就是keepAliveTime的取值不同，limited取值为：Long.MAX_VALUE,其他与cached相同。</p>
<h2 id="4、eager"><a href="#4、eager" class="headerlink" title="4、eager"></a>4、eager</h2><p>其核心实现主要由TaskQueue、EagerThreadPoolExecutor共同完成。<br>首先，我们关注一下TaskQueued的offer方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public boolean offer(Runnable runnable) &#123;</span><br><span class="line">        if (executor &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new RejectedExecutionException(&quot;The task queue does not have executor!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int currentPoolThreadSize &#x3D; executor.getPoolSize();     &#x2F;&#x2F; @1</span><br><span class="line">        &#x2F;&#x2F; have free worker. put task into queue to let the worker deal with task.</span><br><span class="line">        if (executor.getSubmittedTaskCount() &lt; currentPoolThreadSize) &#123;   &#x2F;&#x2F; @2</span><br><span class="line">            return super.offer(runnable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; return false to let executor create new worker.</span><br><span class="line">        if (currentPoolThreadSize &lt; executor.getMaximumPoolSize()) &#123;    &#x2F;&#x2F; @3</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; currentPoolThreadSize &gt;&#x3D; max     &#x2F;&#x2F; @4</span><br><span class="line">        return super.offer(runnable); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取当前线程池中线程的数量。<br>代码@2：如果当前已提交到线程池中的任务数量小于当前存在在的线程数，则走默认的提交流程。<br>代码@3：如果当前已提交到线程中的数量大于当前的线程池，并线程池中数量并未达到线程池允许创建的最大线程数时，则返回false，并不入队，其效果是会创建新的线程来执行。<br>代码@4：如果当前线程池中的线程已达到允许创建的最大线程数后，走默认的提交任务逻辑。<br>其次看一下EagerThreadPoolExecutor#execute</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">        if (command &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; do not increment in method beforeExecute!</span><br><span class="line">        submittedTaskCount.incrementAndGet();       &#x2F;&#x2F; @1 </span><br><span class="line">        try &#123;</span><br><span class="line">            super.execute(command);</span><br><span class="line">        &#125; catch (RejectedExecutionException rx) &#123;</span><br><span class="line">            &#x2F;&#x2F; retry to offer the task into queue.</span><br><span class="line">            final TaskQueue queue &#x3D; (TaskQueue) super.getQueue();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!queue.retryOffer(command, 0, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                    submittedTaskCount.decrementAndGet();</span><br><span class="line">                    throw new RejectedExecutionException(&quot;Queue capacity is full.&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (InterruptedException x) &#123;</span><br><span class="line">                submittedTaskCount.decrementAndGet();</span><br><span class="line">                throw new RejectedExecutionException(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            &#x2F;&#x2F; decrease any way</span><br><span class="line">            submittedTaskCount.decrementAndGet();   &#x2F;&#x2F; @2</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其核心实现逻辑：如果提交任务失败，则再走一次默认的任务提交流程。<br>最总后结一下Eager的核心特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EagerThreadPool implements ThreadPool &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Executor getExecutor(URL url) &#123;</span><br><span class="line">        String name &#x3D; url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        int cores &#x3D; url.getParameter(Constants.CORE_THREADS_KEY, Constants.DEFAULT_CORE_THREADS);</span><br><span class="line">        int threads &#x3D; url.getParameter(Constants.THREADS_KEY, Integer.MAX_VALUE);</span><br><span class="line">        int queues &#x3D; url.getParameter(Constants.QUEUES_KEY, Constants.DEFAULT_QUEUES);</span><br><span class="line">        int alive &#x3D; url.getParameter(Constants.ALIVE_KEY, Constants.DEFAULT_ALIVE);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; init queue and executor</span><br><span class="line">        TaskQueue&lt;Runnable&gt; taskQueue &#x3D; new TaskQueue&lt;Runnable&gt;(queues &lt;&#x3D; 0 ? 1 : queues);</span><br><span class="line">        EagerThreadPoolExecutor executor &#x3D; new EagerThreadPoolExecutor(cores,</span><br><span class="line">                threads,</span><br><span class="line">                alive,</span><br><span class="line">                TimeUnit.MILLISECONDS,</span><br><span class="line">                taskQueue,</span><br><span class="line">                new NamedThreadFactory(name, true),</span><br><span class="line">                new AbortPolicyWithReport(name, url));</span><br><span class="line">        taskQueue.setExecutor(executor);</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其核心特性如下：<br>1、首先，其配置参数与cached类型的线程池相同，说明eager也是基于缓存的。<br>2、eager与cached类型线程池不同的一点是，提交任务后，线程优先于队列，默认的提交流程是如果线程数达到核心线程数后，新提交的任务是首先进入队列，但eager是优先创建线程来执行，这有点与公平锁，非公平锁一样的概念了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>cached</tag>
        <tag>limited</tag>
        <tag>eager</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo网络通讯篇概要总结(类图一览、服务端、客户端网络构造流程一览)</title>
    <url>/posts/531bec0b.html</url>
    <content><![CDATA[<div id="vip-container"><p>从本节开始将开始深入学习Dubbo网络通讯的底层实现细节，在深入学习Dubbo网络模型时，首先应从整体上了解Dubbo的网络通讯模型、线程模型是怎样的？下图是Dubbo官方给出的线程模型：<br><img src="https://img-blog.csdn.net/20180712121146997?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<a id="more"></a>

<p>涉及如下方面：</p>
<ul>
<li>网络调用客户端。</li>
<li>网络调用服务端。</li>
<li>网络传输，编解码、序列化。</li>
<li>网络服务端转发模型、线程池。</li>
<li>下面给出与上述网络模型对应的详细类图：<br><img src="https://img-blog.csdn.net/2018071212121998?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>上述类做一个简单的结束，后续篇章将会一一详细分析。</li>
</ul>
<ol>
<li>基础接口</li>
</ol>
<ul>
<li>Resetable   可重置。</li>
<li>Endpoint   端（服务端、客户端基接口）</li>
</ul>
<ol start="2">
<li> 服务端</li>
</ol>
<ul>
<li>Server 服务端根接口</li>
<li>ExchangeServer 服务端交换机，默认实现Server，内部持有具体Server的实现。</li>
<li>HeaderExchangeServer 基于协议头的服务端交互机。</li>
</ul>
<ol start="3">
<li>客户端</li>
</ol>
<ul>
<li>Channel 客户端通道描述接口。</li>
<li>Client 客户端基础接口，继承自Endpoint,Channel，主要定义重连接口。</li>
</ul>
<ol start="4">
<li>传输层</li>
</ol>
<ul>
<li>Transporter 定义根据URL创建服务端或客户端，内部实现就是构建Server,Client对象。</li>
</ul>
<ol start="5">
<li>编解码</li>
</ol>
<ul>
<li>Codec2 定义编解码对应的接口。<br>下面以Dubbo协议为例，底层网络通信组建基于Netty，Dubbo协议创建服务端的流程如下所示：<br><img src="https://img-blog.csdn.net/20180712121540371?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>下面还是以Dubbo协议为例，底层网络通信组件基于Netty，Dubbo协议消费端（客户端）建立网络流程图如下：<br><img src="https://img-blog.csdn.net/20180712121622395?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>网络通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo配置规则机制(override协议)</title>
    <url>/posts/a0fe1016.html</url>
    <content><![CDATA[<div id="vip-container"><p>在上篇在讲解RegistryDirectory的时候，dubbo管理员可以通过dubbo-admin管理系统在线上修改dubbo服务提供者的参数，最终将存储在注册中心的configurators catalog，然后通知RegistryDirectory更新服务提供者的URL中相关属性，按照最新的配置，重新创建Invoker并销毁原来的Invoker。<br>有关官方文档关于动态改变配置(override协议）的详细描述如下：<br><img src="https://img-blog.csdn.net/20180624225822489?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/2018062422584447?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>dubbo-admin 管理后台，界面如下：<br><img src="https://img-blog.csdn.net/20180624225915334?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><img src="https://img-blog.csdn.net/20180624225933538?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<a id="more"></a>

<p>当Dubbo管理人员在上述界面，选择配置后点击保存，会构建override:// url存入到注册中心(configurators) catalog下，此时基于注册中心发现服务提供者的监听器(RegistryDirectory)会收到回调(notify)方法，接下来我们再来看一下RegistryDirectory#notify方法。</p>
<p>RegistryDirectory#notify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void notify(List&lt;URL&gt; urls) &#123;        &#x2F;&#x2F; @1</span><br><span class="line">        List&lt;URL&gt; invokerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; routerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">        List&lt;URL&gt; configuratorUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">        for (URL url : urls) &#123;</span><br><span class="line">            String protocol &#x3D; url.getProtocol();</span><br><span class="line">            String category &#x3D; url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">            if (Constants.ROUTERS_CATEGORY.equals(category) </span><br><span class="line">                    || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                routerUrls.add(url);</span><br><span class="line">            &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) </span><br><span class="line">                    || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;</span><br><span class="line">                configuratorUrls.add(url);</span><br><span class="line">            &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;</span><br><span class="line">                invokerUrls.add(url);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                logger.warn(&quot;Unsupported category &quot; + category + &quot; in notified url: &quot; + url + &quot; from registry &quot; + getUrl().getAddress() + &quot; to consumer &quot; + </span><br><span class="line">                     NetUtils.getLocalHost());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; configurators </span><br><span class="line">        if (configuratorUrls !&#x3D; null &amp;&amp; configuratorUrls.size() &gt;0 )&#123;       &#x2F;&#x2F; @2</span><br><span class="line">            this.configurators &#x3D; toConfigurators(configuratorUrls);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; routers</span><br><span class="line">        if (routerUrls !&#x3D; null &amp;&amp; routerUrls.size() &gt;0 )&#123;</span><br><span class="line">            List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);</span><br><span class="line">            if(routers !&#x3D; null)&#123; &#x2F;&#x2F; null - do nothing</span><br><span class="line">                setRouters(routers);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Configurator&gt; localConfigurators &#x3D; this.configurators; &#x2F;&#x2F; local reference</span><br><span class="line">        &#x2F;&#x2F; 合并override参数</span><br><span class="line">        this.overrideDirectoryUrl &#x3D; directoryUrl;</span><br><span class="line">        if (localConfigurators !&#x3D; null &amp;&amp; localConfigurators.size() &gt; 0) &#123;</span><br><span class="line">            for (Configurator configurator : localConfigurators) &#123;</span><br><span class="line">                this.overrideDirectoryUrl &#x3D; configurator.configure(overrideDirectoryUrl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; providers</span><br><span class="line">        refreshInvoker(invokerUrls);    &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个方法的实现在上一篇文章<a href="https://blog.csdn.net/prestigeding/article/details/80727275">《源码分析Dubbo服务发现机制(RegistryDirectory)》</a>中详细分析，故这里只列出与本文章相关的关注点：<br>代码@1：参数为当前configurators目录下所有的URL,例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">urls: [override:&#x2F;&#x2F;0.0.0.0&#x2F;com.wuys.frame.api.service.IUserService?category&#x3D;configurators&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;timeout&#x3D;10000, override:&#x2F;&#x2F;0.0.0.0&#x2F;com.wuys.frame.api.service.IUserService?category&#x3D;configurators&amp;dynamic&#x3D;false&amp;enabled&#x3D;true&amp;weight&#x3D;200]。</span><br></pre></td></tr></table></figure>
<p>代码@2:将override url转换为List&lt; Configurator&gt;，是本节重点要讨论的内容。<br>代码@3：调用refreshInvoker方法，由于这里的invokerUrls为空，此时会对原先的invoker马上应用新的配置参数吗？带着这个疑问，我们先看一下refreshInvoker是如何处理的，然后回头重点分析代码@2的实现细节。<br>关于refreshInvoker的实现，在上一篇<a href="https://blog.csdn.net/prestigeding/article/details/80727275">源码分析Dubbo服务注册与发现机制RegistryDirectory)</a>中也详细分析过，这里只是为了求证一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (invokerUrls.size() &#x3D;&#x3D; 0 &amp;&amp; this.cachedInvokerUrls !&#x3D; null)&#123;</span><br><span class="line">       invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">      this.cachedInvokerUrls &#x3D; new HashSet&lt;URL&gt;();</span><br><span class="line">            this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;缓存invokerUrls列表，便于交叉对比</span><br><span class="line">      &#125;</span><br><span class="line">     if (invokerUrls.size() &#x3D;&#x3D;0 )&#123;</span><br><span class="line">          return;</span><br><span class="line">     &#125;</span><br><span class="line">   &#x2F;&#x2F; 省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这里看出，如果invokerUrls为空，如果已缓存的服务提供者不为空，则将已缓存的服务提供者加入到invokerUrls中，此时invokerUrls不为空，则会重新用新的配置生成新的invoker，然后销毁原先的invoker。</p>
<p>接下来重点分析Dubbo关于override协议的解析实现细节。</p>
<h2 id="1、dubbo关于override类图"><a href="#1、dubbo关于override类图" class="headerlink" title="1、dubbo关于override类图"></a>1、dubbo关于override类图</h2><p><img src="https://img-blog.csdn.net/20180624230247836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ol>
<li>Configurator：协议配置接口，主要抽象出两个接口方法：</li>
</ol>
<ul>
<li>URL getUrl()：获取配置URL。</li>
<li>URL configure(URL url)：根据configureUrl来配置 URL url。</li>
</ul>
<ol start="2">
<li>AbstractConfigurator：协议配置抽象实现类（模板类）。</li>
<li>AbsentConfigurator：absent配置器，其策略是，如果configureUrl存在的属性，则不覆盖。</li>
<li>OverrideConfigurator：override配置器，其策略是，直接覆盖属性。</li>
</ol>
<h2 id="2、源码分析OverrideConfigurator实现原理"><a href="#2、源码分析OverrideConfigurator实现原理" class="headerlink" title="2、源码分析OverrideConfigurator实现原理"></a>2、源码分析OverrideConfigurator实现原理</h2><h3 id="2-1-源码分析AbstractConfigurator-configure"><a href="#2-1-源码分析AbstractConfigurator-configure" class="headerlink" title="2.1 源码分析AbstractConfigurator#configure"></a>2.1 源码分析AbstractConfigurator#configure</h3><p>AbstractConfigurator#configure</p>
<ol>
<li>Configurator：协议配置接口，主要抽象出两个接口方法：</li>
</ol>
<ul>
<li>URL getUrl()：获取配置URL。</li>
<li>URL configure(URL url)：根据configureUrl来配置 URL url。</li>
</ul>
<ol start="2">
<li>AbstractConfigurator：协议配置抽象实现类（模板类）。</li>
<li>AbsentConfigurator：absent配置器，其策略是，如果configureUrl存在的属性，则不覆盖。</li>
<li>OverrideConfigurator：override配置器，其策略是，直接覆盖属性。</li>
</ol>
<h3 id="2-2-源码分析AbstractConfigurator-configure"><a href="#2-2-源码分析AbstractConfigurator-configure" class="headerlink" title="2.2 源码分析AbstractConfigurator#configure"></a>2.2 源码分析AbstractConfigurator#configure</h3><p>AbstractConfigurator#configure</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public URL configure(URL url) &#123;</span><br><span class="line">        if (configuratorUrl &#x3D;&#x3D; null || configuratorUrl.getHost() &#x3D;&#x3D; null</span><br><span class="line">                || url &#x3D;&#x3D; null || url.getHost() &#x3D;&#x3D; null) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">            return url;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (configuratorUrl.getPort() !&#x3D; 0) &#123;          &#x2F;&#x2F;  @2</span><br><span class="line">            if (url.getPort() &#x3D;&#x3D; configuratorUrl.getPort()) &#123;</span><br><span class="line">                return configureIfMatch(url.getHost(), url);      &#x2F;&#x2F; @3</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (url.getParameter(Constants.SIDE_KEY, Constants.PROVIDER).equals(Constants.CONSUMER)) &#123;   &#x2F;&#x2F; @4</span><br><span class="line">                return configureIfMatch(NetUtils.getLocalHost(), url);&#x2F;&#x2F; NetUtils.getLocalHost is the ip address consumer registered to registry.</span><br><span class="line">            &#125; else if (url.getParameter(Constants.SIDE_KEY, Constants.CONSUMER).equals(Constants.PROVIDER)) &#123;   &#x2F;&#x2F; @5</span><br><span class="line">                return configureIfMatch(Constants.ANYHOST_VALUE, url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果configuratorUrl (配置URL)为空host为空，或url为空或host为空，则返回url。这里参数的覆盖方向  configuratorUrl —-&gt; url。<br>代码@2：如果configuratorUrl如果端口不为空，则需要判断url的端口，端口必须相同，才执行configuratorUrl配置url。<br>代码@3，执行具体的配置操作，下文待分析。<br>代码@4、@5：如果端口为空，该配置URL(configuratorUrl)的类型要么是针对消费者，要么地址是0.0.0.0(任意)。</p>
<p>如果url属于服务消费者，host为消费者的注册IP地址，如果是服务提供者，则host为0.0.0.0来配置。</p>
<h3 id="2-3-源码分析AbstractConfigurator-configureIfMatch"><a href="#2-3-源码分析AbstractConfigurator-configureIfMatch" class="headerlink" title="2.3 源码分析AbstractConfigurator#configureIfMatch"></a>2.3 源码分析AbstractConfigurator#configureIfMatch</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private URL configureIfMatch(String host, URL url) &#123;</span><br><span class="line">        if (Constants.ANYHOST_VALUE.equals(configuratorUrl.getHost()) || host.equals(configuratorUrl.getHost())) &#123;</span><br><span class="line">            String configApplication &#x3D; configuratorUrl.getParameter(Constants.APPLICATION_KEY,</span><br><span class="line">                    configuratorUrl.getUsername());</span><br><span class="line">            String currentApplication &#x3D; url.getParameter(Constants.APPLICATION_KEY, url.getUsername());</span><br><span class="line">            if (configApplication &#x3D;&#x3D; null || Constants.ANY_VALUE.equals(configApplication)</span><br><span class="line">                    || configApplication.equals(currentApplication)) &#123;</span><br><span class="line">                Set&lt;String&gt; condtionKeys &#x3D; new HashSet&lt;String&gt;();</span><br><span class="line">                condtionKeys.add(Constants.CATEGORY_KEY);</span><br><span class="line">                condtionKeys.add(Constants.CHECK_KEY);</span><br><span class="line">                condtionKeys.add(Constants.DYNAMIC_KEY);</span><br><span class="line">                condtionKeys.add(Constants.ENABLED_KEY);</span><br><span class="line">                for (Map.Entry&lt;String, String&gt; entry : configuratorUrl.getParameters().entrySet()) &#123;</span><br><span class="line">                    String key &#x3D; entry.getKey();</span><br><span class="line">                    String value &#x3D; entry.getValue();</span><br><span class="line">                    if (key.startsWith(&quot;~&quot;) || Constants.APPLICATION_KEY.equals(key) || Constants.SIDE_KEY.equals(key)) &#123;</span><br><span class="line">                        condtionKeys.add(key);</span><br><span class="line">                        if (value !&#x3D; null &amp;&amp; !Constants.ANY_VALUE.equals(value)</span><br><span class="line">                                &amp;&amp; !value.equals(url.getParameter(key.startsWith(&quot;~&quot;) ? key.substring(1) : key))) &#123;</span><br><span class="line">                            return url;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                return doConfigure(url, configuratorUrl.removeParameters(condtionKeys));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return url;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要实现的功能就是排除不能动态修改的属性，不支持属性主要包括：category、check、dynamic、enabled、还有以<del>开头的属性，并且如果</del>开头的属性，配置URL与原URL的值不相同，则不使用该配置URL重写原URL。将配置URL(configuratorUrl)移除不支持属性后，调用其子类的doConfigure方法覆盖属性，Dubbo默认支持如下覆盖策略</p>
<ul>
<li>override 直接覆盖。</li>
<li>absent，如果原先存在该属性的配置，则以原先配置的属性值优先，如果原先没有配置该属性，则添加新的配置属性。</li>
</ul>
<p>总结一下：当在dubbo-admin(管理后台)中创建一条override规则后，会首先存储在注册中心（zookeeper的指定目录下${service}/configurators目录下，此时基于注册中心的事件机制，会通知相关监听者（服务消费者），服务消费者收到最新的配置时，会根据最新的配置重新构建Invoker对象，然后销毁原先的Invoker对象。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>override</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Mybatis MappedStatement的创建流程</title>
    <url>/posts/18c7756d.html</url>
    <content><![CDATA[<div id="vip-container"><p>上文<a href="https://blog.csdn.net/prestigeding/article/details/90415680">源码分析Mybatis MapperProxy创建流程</a>重点阐述MapperProxy的创建流程，但并没有介绍*.Mapper.java(UserMapper.java)是如何与*Mapper.xml文件中的SQL语句是如何建立关联的。本文将重点接开这个谜团。</p>
<p>接下来重点从源码的角度分析Mybatis MappedStatement的创建流程。</p>
<h2 id="1、上节回顾"><a href="#1、上节回顾" class="headerlink" title="1、上节回顾"></a>1、上节回顾</h2><p>我们注意到这里有两三个与Mapper相关的配置：</p>
<ol>
<li>SqlSessionFactory#mapperLocations，指定xml文件的配置路径。</li>
<li>SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。</li>
<li>MapperScannerConfigurer，扫描Mapper的java类(DAO)。</li>
</ol>
<p>我们已经详细介绍了Mybatis Mapper对象的扫描与构建，那接下来我们将重点介绍MaperProxy与mapper.xml文件是如何建立关联关系的。</p>
<p>根据上面的罗列以及上文的讲述，Mapper.xml与Mapper建立联系主要的入口有三：<br>1）MapperScannerConfigurer扫描Bean流程中，在调用MapperReigistry#addMapper时如果Mapper对应的映射文件(Mapper.xml)未加载到内存，会触发加载。<br>2）实例化SqlSessionFactory时，如果配置了mapperLocations。<br>3）示例化SqlSessionFactory时，如果配置了configLocation。</p>
<p>本节的行文思路：从SqlSessionFacotry的初始化开始讲起，因为mapperLocations、configLocation都是是SqlSessionFactory的属性。</p>
<blockquote>
<p>温馨提示：下面开始从源码的角度对其进行介绍，大家可以先跳到文末看看其调用序列图。</p>
</blockquote>
<a id="more"></a>

<h2 id="2、SqlSessionFacotry"><a href="#2、SqlSessionFacotry" class="headerlink" title="2、SqlSessionFacotry"></a>2、SqlSessionFacotry</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (xmlConfigBuilder != <span class="keyword">null</span>) &#123;  <span class="comment">// XMLConfigBuilder   // @1</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        xmlConfigBuilder.parse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Parsed configuration file: &#x27;&quot;</span> + <span class="keyword">this</span>.configLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse config resource: &quot;</span> + <span class="keyword">this</span>.configLocation, ex);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!isEmpty(<span class="keyword">this</span>.mapperLocations)) &#123;   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">for</span> (Resource mapperLocation : <span class="keyword">this</span>.mapperLocations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapperLocation == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          XMLMapperBuilder xmlMapperBuilder = <span class="keyword">new</span> XMLMapperBuilder(mapperLocation.getInputStream(),</span><br><span class="line">              configuration, mapperLocation.toString(), configuration.getSqlFragments());</span><br><span class="line">          xmlMapperBuilder.parse();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NestedIOException(<span class="string">&quot;Failed to parse mapping resource: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          ErrorContext.instance().reset();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Parsed mapper file: &#x27;&quot;</span> + mapperLocation + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Property &#x27;mapperLocations&#x27; was not specified or no matching resources found&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上文有两个入口：<br>代码@1：处理configLocation属性。<br>代码@2：处理mapperLocations属性。</p>
<p>我们先从XMLConfigBuilder#parse开始进行追踪。该方法主要是解析configLocation指定的配置路径，对其进行解析，具体调用parseConfiguration方法。</p>
<h3 id="2-1-XMLConfigBuilder"><a href="#2-1-XMLConfigBuilder" class="headerlink" title="2.1 XMLConfigBuilder"></a>2.1 XMLConfigBuilder</h3><p>我们直接查看其parseConfiguration方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>)); <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">      settingsElement(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>)); <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));   <span class="comment">// @1</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>重点关注mapperElement，从名称与参数即可以看出，该方法主要是处理中mappers的定义，即mapper sql语句的解析与处理。如果使用过Mapper的人应该不难知道，我们使用mapper节点，通过resource标签定义具体xml文件的位置。</p>
<h4 id="2-1-1XMLConfigBuilder-mapperElement"><a href="#2-1-1XMLConfigBuilder-mapperElement" class="headerlink" title="2.1.1XMLConfigBuilder#mapperElement"></a>2.1.1XMLConfigBuilder#mapperElement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">          String mapperPackage = child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          configuration.addMappers(mapperPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          String resource = child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">          String url = child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">          String mapperClass = child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(resource);</span><br><span class="line">            InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());    <span class="comment">// @1</span></span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorContext.instance().resource(url);</span><br><span class="line">            InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">            XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">            mapperParser.parse();</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">            configuration.addMapper(mapperInterface);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码比较简单，不难看出，解析出Mapper标签，解析出resource标签的属性，创建对应的文件流，通过构建XMLMapperBuilder来解析对应的mapper.xml文件。此时大家会惊讶的发现，在SqlSessionFacotry的初始化代码中，处理mapperLocations时就是通过构建XMLMapperBuilder来解析mapper文件，其实也不难理解，因为这是mybatis支持的两个地方可以使用mapper标签来定义mapper映射文件，具体解析代码当然是一样的逻辑。那我们解析来重点把目光投向XMLMapperBuilder。</p>
<h3 id="2-2-XMLMapperBuilder"><a href="#2-2-XMLMapperBuilder" class="headerlink" title="2.2 XMLMapperBuilder"></a>2.2 XMLMapperBuilder</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XMLMapperBuilder#parse</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;     <span class="comment">// @1</span></span><br><span class="line">      configurationElement(parser.evalNode(<span class="string">&quot;/mapper&quot;</span>));</span><br><span class="line">      configuration.addLoadedResource(resource);</span><br><span class="line">      bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parsePendingResultMaps();                                    <span class="comment">// @2</span></span><br><span class="line">    parsePendingChacheRefs();                                   <span class="comment">// @3</span></span><br><span class="line">    parsePendingStatements();                                     <span class="comment">// @4</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果该映射文件(*.Mapper.xml)文件未加载，则首先先加载，完成xml文件的解析，提取xml中与mybatis相关的数据，例如sql、resultMap等等。<br>代码@2：处理mybatis xml中ResultMap。<br>代码@3：处理mybatis缓存相关的配置。<br>代码@4：处理mybatis statment相关配置，这里就是本篇关注的，Sql语句如何与Mapper进行关联的核心实现。</p>
<p>接下来我们重点探讨parsePendingStatements()方法，解析statement(对应SQL语句)。</p>
<h4 id="2-2-1-XMLMapperBuilder-parsePendingStatements"><a href="#2-2-1-XMLMapperBuilder-parsePendingStatements" class="headerlink" title="2.2.1 XMLMapperBuilder#parsePendingStatements"></a>2.2.1 XMLMapperBuilder#parsePendingStatements</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parsePendingStatements</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	  Collection&lt;XMLStatementBuilder&gt; incompleteStatements = configuration.getIncompleteStatements();</span><br><span class="line">	  <span class="keyword">synchronized</span> (incompleteStatements) &#123;</span><br><span class="line">		  Iterator&lt;XMLStatementBuilder&gt; iter = incompleteStatements.iterator();    <span class="comment">// @1</span></span><br><span class="line">		  <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">			  <span class="keyword">try</span> &#123;</span><br><span class="line">				  iter.next().parseStatementNode();   <span class="comment">// @2</span></span><br><span class="line">				  iter.remove();</span><br><span class="line">			  &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">				  <span class="comment">// Statement is still missing a resource...</span></span><br><span class="line">			  &#125;</span><br><span class="line">		  &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：遍历解析出来的所有SQL语句，用的是XMLStatementBuilder对象封装的，故接下来重点看一下代码@2，如果解析statmentNode。</p>
<h4 id="2-2-2-XMLStatementBuilder-parseStatementNode"><a href="#2-2-2-XMLStatementBuilder-parseStatementNode" class="headerlink" title="2.2.2 XMLStatementBuilder#parseStatementNode"></a>2.2.2 XMLStatementBuilder#parseStatementNode</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String id = context.getStringAttribute(<span class="string">&quot;id&quot;</span>);                                                                  <span class="comment">// @1 start</span></span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">&quot;databaseId&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">&quot;fetchSize&quot;</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">&quot;parameterMap&quot;</span>);</span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">&quot;parameterType&quot;</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">&quot;resultMap&quot;</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">&quot;resultType&quot;</span>);</span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">&quot;lang&quot;</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">&quot;resultSetType&quot;</span>);</span><br><span class="line">    StatementType statementType = StatementType.valueOf(context.getStringAttribute(<span class="string">&quot;statementType&quot;</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line"></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    SqlCommandType sqlCommandType = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">&quot;flushCache&quot;</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">&quot;useCache&quot;</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">&quot;resultOrdered&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);             <span class="comment">// @1 end</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);                <span class="comment">// @2</span></span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">&quot;resultSets&quot;</span>);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">&quot;keyProperty&quot;</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">&quot;keyColumn&quot;</span>);</span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = context.getBooleanAttribute(<span class="string">&quot;useGeneratedKeys&quot;</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp; SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? <span class="keyword">new</span> Jdbc3KeyGenerator() : <span class="keyword">new</span> NoKeyGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    builderAssistant.addMappedStatement(id, sqlSource, statementType, sqlCommandType,                             <span class="comment">// @3</span></span><br><span class="line">        fetchSize, timeout, parameterMap, parameterTypeClass, resultMap, resultTypeClass,</span><br><span class="line">        resultSetTypeEnum, flushCache, useCache, resultOrdered, </span><br><span class="line">        keyGenerator, keyProperty, keyColumn, databaseId, langDriver, resultSets);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法有点长，其关注点主要有3个：<br>代码@1：构建基本属性，其实就是构建MappedStatement的属性，因为MappedStatement对象就是用来描述Mapper-SQL映射的对象。</p>
<p>代码@2：根据xml配置的内容，解析出实际的SQL语句，使用SqlSource对象来表示。</p>
<p>代码@3：使用MapperBuilderAssistant对象，根据准备好的属性，构建MappedStatement对象，最终将其存储在Configuration中。</p>
<h4 id="2-2-3-Configuration-addMappedStatement"><a href="#2-2-3-Configuration-addMappedStatement" class="headerlink" title="2.2.3 Configuration#addMappedStatement"></a>2.2.3 Configuration#addMappedStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappedStatement</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">   mappedStatements.put(ms.getId(), ms);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MappedStatement的id为：mapperInterface + methodName，例如com.demo.dao.UserMapper.findUser。</p>
<p>即上述流程完成了xml的解析与初始化，对终极目标是创建MappedStatement对象，上一篇文章介绍了mapperInterface的初始化，最终会初始化为MapperProxy对象，那这两个对象如何关联起来呢？</p>
<p>从下文可知，MapperProxy与MappedStatement是在调用具Mapper方法时，可以根据mapperInterface.getName + methodName构建出MappedStatement的id，然后就可以从Configuration的mappedStatements容器中根据id获取到对应的MappedStatement对象，这样就建立起联系了。</p>
<p>其对应的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MapperMethod 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SqlCommand 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> <span class="keyword">throws</span> BindingException </span>&#123;</span><br><span class="line">      String statementName = mapperInterface.getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">      MappedStatement ms = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (configuration.hasStatement(statementName)) &#123;</span><br><span class="line">        ms = configuration.getMappedStatement(statementName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mapperInterface.equals(method.getDeclaringClass().getName())) &#123; <span class="comment">// issue #35</span></span><br><span class="line">        String parentStatementName = method.getDeclaringClass().getName() + <span class="string">&quot;.&quot;</span> + method.getName();</span><br><span class="line">        <span class="keyword">if</span> (configuration.hasStatement(parentStatementName)) &#123;</span><br><span class="line">          ms = configuration.getMappedStatement(parentStatementName);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Invalid bound statement (not found): &quot;</span> + statementName);</span><br><span class="line">      &#125;</span><br><span class="line">      name = ms.getId();</span><br><span class="line">      type = ms.getSqlCommandType();</span><br><span class="line">      <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>怎么样，从上面的源码分析中，大家是否已经了解MapperProxy与Xml中的SQL语句是怎样建立的关系了吗？为了让大家更清晰的了解上述过程，现给出其调用时序图：<br><img src="https://img-blog.csdnimg.cn/2019052321283257.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>MappedStatement</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Mybatis MapperProxy初始化之Mapper对象的扫描与构建</title>
    <url>/posts/47c4bb93.html</url>
    <content><![CDATA[<div id="vip-container"><p>MapperScannerConfigurer，Spring整合Mybatis的核心类，其作用是扫描项目中Dao类，将其创建为Mybatis的Maper对象即MapperProxy对象。</p>
<p>首先进入源码学习之前，我们先看一下在项目中的配置文件信息。<br><img src="https://img-blog.csdnimg.cn/20190521205718910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们注意到这里有两三个与Mapper相关的配置：</p>
<ol>
<li>SqlSessionFactory#mapperLocations，指定xml文件的配置路径。</li>
<li>SqlSessionFactory#configLocation，指定mybaits的配置文件，该配置文件也可以配置mapper.xml的配置路径信息。</li>
<li>MapperScannerConfigurer，扫描Mapper的java类(DAO)。</li>
</ol>
<p>本文的行文思路如下：</p>
<ol>
<li>Mybatis MapperProxy对象的扫描与构建</li>
<li>Mapper类与SQL语句如何建立关联<br>这部分主要阐述Java类的运行实例Mapper对象（例如UserMapper、BookMapper)是如何与mapper.xml(UserMapper.xml、BookMapper.xml文件建立联系的)。</li>
</ol>
<h2 id="Mybatis-MapperProxy对象创建流程"><a href="#Mybatis-MapperProxy对象创建流程" class="headerlink" title="Mybatis MapperProxy对象创建流程"></a>Mybatis MapperProxy对象创建流程</h2><p>下面的源码分析或许会比较枯燥，进入源码分析之前，先给出MapperProxy的创建序列图。</p>
<h3 id="1-1-MapperProxy创建序列图"><a href="#1-1-MapperProxy创建序列图" class="headerlink" title="1.1 MapperProxy创建序列图"></a>1.1 MapperProxy创建序列图</h3><p><img src="https://img-blog.csdnimg.cn/20190521215333400.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-2-MapperScannerConfigurer详解"><a href="#1-2-MapperScannerConfigurer详解" class="headerlink" title="1.2 MapperScannerConfigurer详解"></a>1.2 MapperScannerConfigurer详解</h3><p>MapperScannerConfigurer的类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190521210119671.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>MapperScannerConfigurer实现Spring Bean生命周期相关的类：BeanNameAware、ApplicationContextAware、BeanFactoryPostProcessor、InitializingBean、BeanDefinitionRegistryPostProcessor，我们先来看一下这些接口对应的方法的调用时机：</p>
<a id="more"></a>

<ul>
<li>BeanNameAware<br>是Bean对自己的名称感知，也就是在Bean创建的时候，自动将Bean的名称设置在Bean中，外部应用程序不需要调用setBeanName，就可以通过getBeanName()方法获取其bean名称。</li>
<li>ApplicationContextAware<br>自动感知ApplicationContext对象，即在Bean创建的时候，Spring工厂会自动将当前的ApplicationContext注入该Bean中。</li>
<li>InitializingBean<br>实现该接口，Spring在初始化Bean后会自动调用InitializingBean#afterPropertiesSet方法。</li>
<li>BeanFactoryPostProcessor<br>BeanFactory后置处理器，这个时候只是创建好了Bean的定义信息(BeanDefinition)，在BeanFactoryPostProcessor接口的postProcessBeanFactory方法中，我们可以修改bean的定义信息，例如修改属性的值，修改bean的scope为单例或者多例。与其相似的是BeanPostProcessor，这个是在bean初始化前后对Bean执行，即bean的构造方法调用后，init-method前执行。</li>
<li>BeanDefinitionRegistryPostProcessor<br>主要用来增加Bean的定义，增加BeanDefinition。由于MapperScannerConfigurer主要的目的就是扫描特定的包，并创建对应的Mapper对象，估这里是MapperScannerConfigurer重点实现的接口。</li>
</ul>
<p>那我们接下来从BeanDefinitionRegistryPostProcessor的实现接口开始跟踪。</p>
<h4 id="BeanDefinitionRegistryPostProcessor-postProcessBeanDefinitionRegistry"><a href="#BeanDefinitionRegistryPostProcessor-postProcessBeanDefinitionRegistry" class="headerlink" title="BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry"></a>BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;</span><br><span class="line">    if (this.processPropertyPlaceHolders) &#123;</span><br><span class="line">      processPropertyPlaceHolders();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ClassPathMapperScanner scanner &#x3D; new ClassPathMapperScanner(registry);</span><br><span class="line">    scanner.setAddToConfig(this.addToConfig);</span><br><span class="line">    scanner.setAnnotationClass(this.annotationClass);</span><br><span class="line">    scanner.setMarkerInterface(this.markerInterface);</span><br><span class="line">    scanner.setSqlSessionFactory(this.sqlSessionFactory);     &#x2F;&#x2F; @1</span><br><span class="line">    scanner.setSqlSessionTemplate(this.sqlSessionTemplate);</span><br><span class="line">    scanner.setSqlSessionFactoryBeanName(this.sqlSessionFactoryBeanName);   </span><br><span class="line">    scanner.setSqlSessionTemplateBeanName(this.sqlSessionTemplateBeanName);</span><br><span class="line">    scanner.setResourceLoader(this.applicationContext);</span><br><span class="line">    scanner.setBeanNameGenerator(this.nameGenerator);</span><br><span class="line">    scanner.registerFilters();</span><br><span class="line">    scanner.scan(StringUtils.tokenizeToStringArray(this.basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS));    &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先设置SqlSessionFactory，从该Scan器生成的Mapper最终都是受该SqlSessionFactory的管辖。<br>代码@2：调用ClassPathMapperScanner的scan方法进行扫描动作，接下来详细介绍。</p>
<h4 id="ClassPathMapperScanner-doScan"><a href="#ClassPathMapperScanner-doScan" class="headerlink" title="ClassPathMapperScanner#doScan"></a>ClassPathMapperScanner#doScan</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123;</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions &#x3D; super.doScan(basePackages);   &#x2F;&#x2F;@1</span><br><span class="line">    if (beanDefinitions.isEmpty()) &#123;</span><br><span class="line">      logger.warn(&quot;No MyBatis mapper was found in &#39;&quot; + Arrays.toString(basePackages) + &quot;&#39; package. Please check your configuration.&quot;);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      processBeanDefinitions(beanDefinitions);   &#x2F;&#x2F; @2</span><br><span class="line">    &#125;</span><br><span class="line">    return beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先调用父类(org.springframework.context.annotation.ClassPathBeanDefinitionScanner)方法，根据扫描的文件，构建对应的BeanDefinitionHolder对象。<br>代码@2：对这些BeanDefinitions进行处理，对Bean进行加工，加入Mybatis特性。</p>
<h4 id="ClassPathMapperScanner-processBeanDefinitions"><a href="#ClassPathMapperScanner-processBeanDefinitions" class="headerlink" title="ClassPathMapperScanner#processBeanDefinitions"></a>ClassPathMapperScanner#processBeanDefinitions</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void processBeanDefinitions(Set&lt;BeanDefinitionHolder&gt; beanDefinitions) &#123;</span><br><span class="line">    GenericBeanDefinition definition;</span><br><span class="line">    for (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">      definition &#x3D; (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">      if (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(&quot;Creating MapperFactoryBean with name &#39;&quot; + holder.getBeanName() </span><br><span class="line">          + &quot;&#39; and &#39;&quot; + definition.getBeanClassName() + &quot;&#39; mapperInterface&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; the mapper interface is the original class of the bean</span><br><span class="line">      &#x2F;&#x2F; but, the actual class of the bean is MapperFactoryBean</span><br><span class="line">      definition.getPropertyValues().add(&quot;mapperInterface&quot;, definition.getBeanClassName());</span><br><span class="line">      definition.setBeanClass(this.mapperFactoryBean.getClass());   &#x2F;&#x2F; @1</span><br><span class="line">      definition.getPropertyValues().add(&quot;addToConfig&quot;, this.addToConfig);</span><br><span class="line">      boolean explicitFactoryUsed &#x3D; false;</span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionFactoryBeanName)) &#123;    &#x2F;&#x2F; @2 start</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, new RuntimeBeanReference(this.sqlSessionFactoryBeanName));</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125; else if (this.sqlSessionFactory !&#x3D; null) &#123;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionFactory&quot;, this.sqlSessionFactory);</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125;    &#x2F;&#x2F; @2 end</span><br><span class="line"></span><br><span class="line">      if (StringUtils.hasText(this.sqlSessionTemplateBeanName)) &#123;  &#x2F;&#x2F; @3</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, new RuntimeBeanReference(this.sqlSessionTemplateBeanName));</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125; else if (this.sqlSessionTemplate !&#x3D; null) &#123;</span><br><span class="line">        if (explicitFactoryUsed) &#123;</span><br><span class="line">          logger.warn(&quot;Cannot use both: sqlSessionTemplate and sqlSessionFactory together. sqlSessionFactory is ignored.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.getPropertyValues().add(&quot;sqlSessionTemplate&quot;, this.sqlSessionTemplate);</span><br><span class="line">        explicitFactoryUsed &#x3D; true;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!explicitFactoryUsed) &#123;</span><br><span class="line">        if (logger.isDebugEnabled()) &#123;</span><br><span class="line">          logger.debug(&quot;Enabling autowire by type for MapperFactoryBean with name &#39;&quot; + holder.getBeanName() + &quot;&#39;.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法有3个关键点：<br>代码@1：BeanDefinition中的beanClass设置的类为MapperFactoryBean，即该BeanDefinition初始化的实例为MapperFactoryBean，其名字可以看出，这是一个FactoryBean对象，会通过其getObject方法进行构建具体实例。</p>
<p>代码@2：将为MapperFactoryBean设置属性，将SqlSessionFactory放入其属性中，在实例化时可以自动获取到该SqlSessionFactory。</p>
<p>代码@3：如果sqlSessionTemplate不为空，则放入到属性中，以便Spring在实例化MapperFactoryBean时可以得到对应的SqlSessionTemplate。</p>
<p>分析到这里，MapperScannerConfigurer的doScan方法就结束了，但并没有初始化Mapper，只是创建了很多的BeanDefinition,并且其beanClass为MapperFactoryBean，那我们将目光转向MapperFactoryBean。</p>
<h3 id="1-3-MapperFactoryBean"><a href="#1-3-MapperFactoryBean" class="headerlink" title="1.3 MapperFactoryBean"></a>1.3 MapperFactoryBean</h3><p>MapperFactoryBean的类图如下：<br><img src="https://img-blog.csdnimg.cn/20190521210725838.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>先对上述核心类做一个简述：</p>
<h4 id="DaoSupport"><a href="#DaoSupport" class="headerlink" title="DaoSupport"></a>DaoSupport</h4><p>Dao层的基类，定义一个模板方法，供其子类实现具体的逻辑，DaoSupport的模板方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final void afterPropertiesSet() throws IllegalArgumentException, BeanInitializationException &#123;</span><br><span class="line">	&#x2F;&#x2F; Let abstract subclasses check their configuration.</span><br><span class="line">	checkDaoConfig(); &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F; Let concrete implementations initialize themselves.</span><br><span class="line">	try &#123;</span><br><span class="line">		initDao();           &#x2F;&#x2F; @2</span><br><span class="line">	&#125; catch (Exception ex) &#123;</span><br><span class="line">		throw new BeanInitializationException(&quot;Initialization of DAO failed&quot;, ex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检查或构建dao的配置信息，该方法为抽象类，供子类实现，等下我们本节的主角MapperFactoryBean主要实现该方法，从而实现与Mybatis相关的整合信息。<br>代码@2：初始化Dao相关的方法，该方法为一个空实现。</p>
<h4 id="SqlSessionDaoSupport"><a href="#SqlSessionDaoSupport" class="headerlink" title="SqlSessionDaoSupport"></a>SqlSessionDaoSupport</h4><p>SqlSession支持父类，通过使用SqlSessionFactory或SqlSessionTemplate创建SqlSession，那下面两个方法会在什么时候被调用呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory)</span><br><span class="line">public void setSqlSessionTemplate(SqlSessionTemplate sqlSessionTemplate)</span><br></pre></td></tr></table></figure>
<p>不知道大家还记不记得，在创建MapperFactoryBean的时候，其属性里会设置SqlSessionFacotry或SqlSessionTemplate，见上文代码(processBeanDefinitions)，这样的话在示例化Bean时，Spring会自动注入实例，即在实例化Bean时，上述方法中的一个或多个会被调用。</p>
<h4 id="MapperFactoryBean"><a href="#MapperFactoryBean" class="headerlink" title="MapperFactoryBean"></a>MapperFactoryBean</h4><p>主要看它是如何实现checkDaoConfig的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MapperFactoryBean#checkDaoConfig</span><br><span class="line">protected void checkDaoConfig() &#123;</span><br><span class="line">    super.checkDaoConfig();   &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">    notNull(this.mapperInterface, &quot;Property &#39;mapperInterface&#39; is required&quot;);</span><br><span class="line"></span><br><span class="line">    Configuration configuration &#x3D; getSqlSession().getConfiguration();</span><br><span class="line">    if (this.addToConfig &amp;&amp; !configuration.hasMapper(this.mapperInterface)) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">      try &#123;</span><br><span class="line">        configuration.addMapper(this.mapperInterface);                                        </span><br><span class="line">      &#125; catch (Throwable t) &#123;</span><br><span class="line">        logger.error(&quot;Error while adding the mapper &#39;&quot; + this.mapperInterface + &quot;&#39; to configuration.&quot;, t);</span><br><span class="line">        throw new IllegalArgumentException(t);</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        ErrorContext.instance().reset();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先先调用父类的checkDaoConfig方法。<br>代码@2：mapperInterface，就是具体的Mapper的接口类，例如com.demo.dao.UserMapper，如果以注册，则抛出异常，否则调用configuration增加Mapper。</p>
<p>接下来进入到org.apache.ibatis.session.Configuration中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    mapperRegistry.addMapper(type);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    return mapperRegistry.getMapper(type, sqlSession);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean hasMapper(Class&lt;?&gt; type) &#123;</span><br><span class="line">   return mapperRegistry.hasMapper(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，正在注册(添加)、查询、获取Mapper的核心类为MapperRegistry。</p>
<h3 id="1-4-MapperRegistry"><a href="#1-4-MapperRegistry" class="headerlink" title="1.4 MapperRegistry"></a>1.4 MapperRegistry</h3><p>其核心类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190521211339211.png" alt="在这里插入图片描述"><br>对其属性做个简单的介绍：</p>
<ul>
<li>Configuration config<br>Mybatis全局配置对象。</li>
<li>Map&lt;Class<?>, MapperProxyFactory<?>&gt; knownMappers<br>已注册Map，这里的键值为mapper接口，例如com.demo.dao.UserMapper，值为MapperProxyFactory，创建MapperProxy的工厂。</li>
</ul>
<p>下面简单介绍MapperRegistry的几个方法，其实现都比较简单。</p>
<h4 id="MapperRegistry-addMapper"><a href="#MapperRegistry-addMapper" class="headerlink" title="MapperRegistry#addMapper"></a>MapperRegistry#addMapper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; void addMapper(Class&lt;T&gt; type) &#123;</span><br><span class="line">    if (type.isInterface()) &#123;</span><br><span class="line">      if (hasMapper(type)) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">        throw new BindingException(&quot;Type &quot; + type + &quot; is already known to the MapperRegistry.&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      boolean loadCompleted &#x3D; false;</span><br><span class="line">      try &#123;</span><br><span class="line">        knownMappers.put(type, new MapperProxyFactory&lt;T&gt;(type));    &#x2F;&#x2F; @2</span><br><span class="line">        MapperAnnotationBuilder parser &#x3D; new MapperAnnotationBuilder(config, type);    &#x2F;&#x2F; @3</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted &#x3D; true;</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">        if (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果该接口已经注册，则抛出已经绑定的异常。<br>代码@2：为该接口注册MapperProxyFactory，但这里只是注册其创建MapperProxy的工厂，并不是创建MapperProxy。<br>代码@3：如果Mapper对应的xml资源未加载，触发xml的绑定操作，将xml中的sql语句与Mapper建立关系。本文将不详细介绍，在下一篇中详细介绍。</p>
<p>注意：addMapper方法，只是为*Mapper创建对应对应的MapperProxyFactory。</p>
<h4 id="MapperRegistry-getMapper"><a href="#MapperRegistry-getMapper" class="headerlink" title="MapperRegistry#getMapper"></a>MapperRegistry#getMapper</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T getMapper(Class&lt;T&gt; type, SqlSession sqlSession) &#123;</span><br><span class="line">    final MapperProxyFactory&lt;T&gt; mapperProxyFactory &#x3D; (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);   &#x2F;&#x2F; @1</span><br><span class="line">    if (mapperProxyFactory &#x3D;&#x3D; null)</span><br><span class="line">      throw new BindingException(&quot;Type &quot; + type + &quot; is not known to the MapperRegistry.&quot;);</span><br><span class="line">    try &#123;</span><br><span class="line">      return mapperProxyFactory.newInstance(sqlSession);                                                                                 &#x2F;&#x2F; @2</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">      throw new BindingException(&quot;Error getting mapper instance. Cause: &quot; + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>根据Mapper接口与SqlSession创建MapperProxy对象。<br>代码@1：根据接口获取MapperProxyFactory。<br>代码@2：调用MapperProxyFactory的newInstance创建MapperProxy对象。</p>
<p>到目前为止Mybatis Mapper的初始化构造过程就完成一半了，即MapperScannerConfigurer通过包扫描，然后构建MapperProxy，但此时MapperProxy还未与mapper.xml文件中的sql语句建立关联，由于篇幅的原因，将在下一节重点介绍其关联关系建立的流程。接下来我们先一睹MapperProxy对象，毕竟这是本文最终要创建的对象，也为后续SQL的执行流程做个简单准备。</p>
<h3 id="1-5-MapperProxy"><a href="#1-5-MapperProxy" class="headerlink" title="1.5 MapperProxy"></a>1.5 MapperProxy</h3><p>类图如下：<br><img src="https://img-blog.csdnimg.cn/2019052121164389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的类都比较简单，MapperMethod，代表一个一个的Mapper方法，从SqlCommand可以看出，每一个MapperMethod都会对应一条SQL语句。</p>
<p>下面以一张以SqlSessionFacotry为视角的各核心类的关系图：<br><img src="https://img-blog.csdnimg.cn/20190521211724837.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>温馨提示：本文只阐述了Mybatis MapperProxy的创建流程，MapperProxy与*.Mapper.xml即SQL是如何关联的本文未涉及到，这部分的内容请看下文，即将发布。</p>
</blockquote>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>mybatis</tag>
        <tag>MapperProxy</tag>
        <tag>MapperScannerConfigurer</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Mybatis插件(Plugin)机制与实战</title>
    <url>/posts/3e30e205.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>温馨提示：本文也是以提问式阅读与探究源码的技巧展示。</p>
</blockquote>
<h2 id="1、回顾"><a href="#1、回顾" class="headerlink" title="1、回顾"></a>1、回顾</h2><p>从前面的文章我们已经知道，Mybatis在执行SQL语句的扩展点为Executor、StatementHandler、ParameterHandler与ResultSetHandler，我们本节将以Executor为入口，向大家展示Mybatis插件的扩展机制。</p>
<p>我们先来看回顾一下Mybatis Executor的创建入口。</p>
<h3 id="1-1-Configuration-newExecutor"><a href="#1-1-Configuration-newExecutor" class="headerlink" title="1.1 Configuration#newExecutor"></a>1.1 Configuration#newExecutor</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">  executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">  Executor executor;</span><br><span class="line">  <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">  &#125;</span><br><span class="line">  executor = (Executor) interceptorChain.pluginAll(executor);   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1,：使用InterceptorChain.pluginAll(executor)进行拆件化处理。</p>
<p>思考：使用该方法调用后，会返回一个什么对象呢？如何自定义拆件，自定义插件如何执行呢？</p>
<p>那接下来我们带着上述疑问，从InterceptorChain类开始进行深入学习。</p>
<h2 id="2、InterceptorChain"><a href="#2、InterceptorChain" class="headerlink" title="2、InterceptorChain"></a>2、InterceptorChain</h2><p>从名字上看其大意为拦截器链。</p>
<h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190530205753805.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>InterceptorChain<br>拦截器链，其内部维护一个interceptors,表示拦截器链中所有的拦截器，并提供增加或获取拦截器链的方法，下面会重点分析pluginAll方法。</li>
<li>Interceptor<br>拦截器接口，用户自定义的拦截器需要实现该接口。</li>
<li>Invocation<br>拦截器执行时的上下文环境，其实就是目标方法的调用信息，包含目标对象、调用的方法信息、参数信息。其中包含一个非常重要的方法：proceed。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">proceed</span><span class="params">()</span> <span class="keyword">throws</span> InvocationTargetException, IllegalAccessException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
该方法的主要目的就是进行处理链的传播，执行完拦截器的方法后，最终需要调用目标方法的invoke方法。</li>
</ul>
<p>记下来中先重点分析一下InterceptorChain方法的pluginAll方法，因为从开头也知道,Mybatis在创建对象时，是调用该方法，完成目标对象的包装。</p>
<a id="more"></a>

<h3 id="2-2-核心方法一览"><a href="#2-2-核心方法一览" class="headerlink" title="2.2 核心方法一览"></a>2.2 核心方法一览</h3><h4 id="2-2-1-pluginAll"><a href="#2-2-1-pluginAll" class="headerlink" title="2.2.1 pluginAll"></a>2.2.1 pluginAll</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;   <span class="comment">// @2</span></span><br><span class="line">    target = interceptor.plugin(target);         </span><br><span class="line">  <span class="comment">// @3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：目标对象，需要被代理的对象。</p>
<p>代码@2：遍历InterceptorChain的拦截器链，分别调用Intercpetor对象的Plugin进行拦截(@3)。</p>
<p>那接下来有三个疑问？<br>问题1：InterceptorChain中的interceptors是从什么时候初始化的呢，即拦截链中的拦截器从何而来。<br>问题2：从前面也得知，无论是创建Executor，还是创建StatementHandler等，都是调用InterceptorChain#pluginAll方法，那是不是拦截器中的拦截器都会作用与目标对象，这应该是有问题的，该如何处理？<br>问题3：代理对象是如何创建的。</p>
<h4 id="2-2-1-addInterceptor"><a href="#2-2-1-addInterceptor" class="headerlink" title="2.2.1 addInterceptor"></a>2.2.1 addInterceptor</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  interceptors.add(interceptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要想知道interceptors是如何初始化的，我们只需要查看该方法的调用链即可。</p>
<p>一路跟踪到源头，我们会发现在初始化SqlSessionFactory时，会解析一个标签plugin，就可以得知，会在SqlSessionFacotry的一个属性中配置所有的拦截器。<br>具体配置示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;shardingDataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperLocations&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath*:META-INF/mybatis/mappers/OrderMapper.xml&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;plugins&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span> = <span class="string">&quot;teneantInteceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.demo.inteceptor.TenaInteceptor&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>问题1已经解决。但后面两个问题似乎没有什么突破口。由于目前所涉及的三个类，显然不足以给我们提供答案，我们先将目光移到InterceptorChain所在包中的其他类，看看其他类的职责如何。</p>
<h2 id="3、Intercepts与Signature"><a href="#3、Intercepts与Signature" class="headerlink" title="3、Intercepts与Signature"></a>3、Intercepts与Signature</h2><p>在org.apache.ibatis.plugin中存在如下两个注解类：Intercepts与Signature，从字面意思就是用来配置拦截的方法信息。<br><img src="https://img-blog.csdnimg.cn/2019053021040719.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>Siganature注解的属性说明如下：<ul>
<li>Class&lt;?&gt; type ：需要拦截目标对象的类。</li>
<li>String method：需要拦截目标类的方法名。</li>
<li>Class&lt;?&gt;[] args：需要拦截目标类的方法名的参数类型签名。</li>
</ul>
</li>
</ul>
<p>备注：至于如何得知上述字段的含义，请看下文的Plugin#getSignatureMap方法。</p>
<p>但另外一个类型Plugin类确引起了我的注意。接下来我们将重点分析Plugin方法。</p>
<h2 id="4、Plugin详解"><a href="#4、Plugin详解" class="headerlink" title="4、Plugin详解"></a>4、Plugin详解</h2><h3 id="4-1-Plugin类图"><a href="#4-1-Plugin类图" class="headerlink" title="4.1 Plugin类图"></a>4.1 Plugin类图</h3><p><img src="https://img-blog.csdnimg.cn/20190530210628459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中InvocationHandler为JDK的动态代理机制中的事件执行器，我们可以隐约阈值代理对象的生成将基于JDK内置的动态代理机制。</p>
<p>Plugin的核心属性如下：</p>
<ul>
<li>Object target<br>目标对象。</li>
<li>Interceptor interceptor<br>拦截器对象。</li>
<li>Map&lt;Class&lt;?&gt;, Set&lt; Method&gt;&gt; signatureMap<br>拦截器中的签名映射。</li>
</ul>
<h2 id="4-2-构造函数"><a href="#4-2-构造函数" class="headerlink" title="4.2  构造函数"></a>4.2  构造函数</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Plugin</span><span class="params">(Object target, Interceptor interceptor, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    <span class="keyword">this</span>.interceptor = interceptor;</span><br><span class="line">    <span class="keyword">this</span>.signatureMap = signatureMap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意：其构造函数为私有的，那如何构建Plugin呢，其构造方法为Plugin的镜头方法wrap中被调用。</p>
<h3 id="4-3-核心方法详解"><a href="#4-3-核心方法详解" class="headerlink" title="4.3 核心方法详解"></a>4.3 核心方法详解</h3><h4 id="4-3-1-wrap"><a href="#4-3-1-wrap" class="headerlink" title="4.3.1 wrap"></a>4.3.1 wrap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);  <span class="comment">// @1</span></span><br><span class="line">  Class&lt;?&gt; type = target.getClass();   </span><br><span class="line">  Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);   <span class="comment">// @2</span></span><br><span class="line">  <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(    <span class="comment">// @3</span></span><br><span class="line">        type.getClassLoader(),</span><br><span class="line">        interfaces,</span><br><span class="line">        <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取待包装的Interceptor的方法签名映射表，稍后详细分析。</p>
<p>代码@2：获取需要代理的对象的Class上声明的所有接口。</p>
<p>代码@3：使用JDK内置的Proxy创建代理对象。Proxy创建代理对象的方法声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</span>，</span></span><br></pre></td></tr></table></figure>
<p>注意其事件处理器为Plugin，故在动态运行过程中会执行Plugin的invoker方法。</p>
<p>在进入Plugin#invoker方法学习之前，我们先重点查看一下getSignatureMap、getAllInterfaces的实现。</p>
<h4 id="4-3-2-getSignatureMap"><a href="#4-3-2-getSignatureMap" class="headerlink" title="4.3.2 getSignatureMap"></a>4.3.2 getSignatureMap</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; getSignatureMap(Interceptor interceptor) &#123;</span><br><span class="line">  Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);  <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">if</span> (interceptsAnnotation == <span class="keyword">null</span>) &#123; <span class="comment">// issue #251                                          // @2</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;No @Intercepts annotation was found in interceptor &quot;</span> + interceptor.getClass().getName());      </span><br><span class="line">  &#125;</span><br><span class="line">  Signature[] sigs = interceptsAnnotation.value();   <span class="comment">// @3</span></span><br><span class="line">  Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt;(); </span><br><span class="line">  <span class="keyword">for</span> (Signature sig : sigs) &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(sig.type());</span><br><span class="line">    <span class="keyword">if</span> (methods == <span class="keyword">null</span>) &#123;</span><br><span class="line">      methods = <span class="keyword">new</span> HashSet&lt;Method&gt;();</span><br><span class="line">      signatureMap.put(sig.type(), methods);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Method method = sig.type().getMethod(sig.method(), sig.args());    </span><br><span class="line">      methods.add(method);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> PluginException(<span class="string">&quot;Could not find method on &quot;</span> + sig.type() + <span class="string">&quot; named &quot;</span> + sig.method() + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> signatureMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先从Interceptor的类上获取Intercepts注解。</p>
<p>代码@2：如果Interceptor的类上没有定义Intercepts注解，则抛出异常，说明我们在自定义插件时，必须要有Intercepts注解。</p>
<p>代码@3：解析Interceptor的values属性（Signature[]）数组，然后存入HashMap&lt;Class&lt;?&gt;, Set&lt; Method&gt;&gt;容器内。</p>
<blockquote>
<p>温馨提示：从这里可以得知：自定义的插件必须定义Intercepts注解，其注解的value值为Signature。</p>
</blockquote>
<h4 id="4-3-3-getAllInterfaces"><a href="#4-3-3-getAllInterfaces" class="headerlink" title="4.3.3 getAllInterfaces"></a>4.3.3 getAllInterfaces</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt;[] getAllInterfaces(Class&lt;?&gt; type, Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap) &#123;</span><br><span class="line">  Set&lt;Class&lt;?&gt;&gt; interfaces = <span class="keyword">new</span> HashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  <span class="keyword">while</span> (type != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; c : type.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (signatureMap.containsKey(c)) &#123;</span><br><span class="line">        interfaces.add(c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    type = type.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> interfaces.toArray(<span class="keyword">new</span> Class&lt;?&gt;[interfaces.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的实现比较简单，并不是获取目标对象所实现的所有接口，而是返回需要拦截的方法所包括的接口。</p>
<h4 id="4-3-4-invoke"><a href="#4-3-4-invoke" class="headerlink" title="4.3.4 invoke"></a>4.3.4 invoke</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123; <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">    <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));   <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> method.invoke(target, args);                           <span class="comment">// @4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先对其参数列表做一个简单的说明：</p>
<ul>
<li>Object proxy 当前的代理对象</li>
<li>Method method 当前执行的方法</li>
<li>Object[] args 当前执行方法的参数</li>
</ul>
<p>代码@2：获取当前执行方法所属的类，并获取需要被拦截的方法集合。</p>
<p>代码@3：如果需被拦截的方法集合包含当前执行的方法，则执行拦截器的interceptor方法。</p>
<p>代码@4：如果不是，则直接调用目标方法的Invoke方法。</p>
<p>从该方法可以看出Interceptor接口的intercept方法就是拦截器自身需要实现的逻辑，其参数为Invocation，在该方法的结束，需要调用invocation#proceed()方法，进行拦截器链的传播。</p>
<p>从目前的学习中，我们已经了解了Plugin.wrap方法就是生成带来带来类的唯一入口，那该方法在什么地方调用呢？从代码类库中没有找到该方法的调用链，说明该方法是供用户调用的。</p>
<p>再看InterceptorChain方法的pluginAll方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">  <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;   <span class="comment">// @2</span></span><br><span class="line">    target = interceptor.plugin(target);           <span class="comment">// @3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会遍历用户定义的插件实现类（Interceptor），并调用Interceptor的plugin方法，对target进行拆件化处理，即我们在实现自定义的Interceptor方法时，在plugin中需要根据自己的逻辑，对目标对象进行包装（代理），创建代理对象，那我们就可以在该方法中使用Plugin#wrap来创建代理类。</p>
<p>接下来我们再来用序列图来对上述源码分析做一个总结：<br><img src="https://img-blog.csdnimg.cn/2019053021182314.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>看到这里，大家是否对上面提出的3个问题都已经有了自己的答案了。</p>
<p>问题1：InterceptorChain中的interceptors是从什么时候初始化的呢，即拦截链中的拦截器从何而来。<br>答：在初始化SqlSesstionFactory的时候，会解析属性plugins属性，会加载所有的拦截器到InterceptorChain中。</p>
<p>问题2：从前面也得知，无论是创建Executor，还是创建StatementHandler等，都是调用InterceptorChain#pluginAll方法，那是不是拦截器中的拦截器都会作用与目标对象，这应该是有问题的，该如何处理？</p>
<p>答案是在各自订阅的Interceptor#plugin方法中，我们可以根据传入的目标对象，是否是该拦截器关注的，如果不关注，则直接返回目标对象，如果关注，则使用Plugin#wrap方法创建代理对象。</p>
<p>问题3：代理对象是如何创建的？<br>代理对象是使用JDK的动态代理机制创建，使用Plugin#wrap方法创建。</p>
<h2 id="5、实践"><a href="#5、实践" class="headerlink" title="5、实践"></a>5、实践</h2><p>实践是检验真理的唯一标准，那到底如何使用Mybatis的插件机制呢？<br>创建自定义的拦截器Interceptor,实现Interceptor接口。<br>1）实现plugin方法，在该方法中决定是否需要创建代理对象，如果创建，使用Plugin#wrap方法创建。<br>2）实现interceptor方法，该方法中定义拦截器的逻辑，并且在最后请调用invocation.proceed()方法传递拦截器链。<br>3）使用Intercepts注解，定义需要拦截目标对象的方法签名，支持多个。<br>将实现的Interceptor在定义SqlSessionFactory的配置中，放入plugins属性。</p>
<p>最后给出一个Mybatis Plugin插件机制使用案例：基于Mycat+Mybatis的多租户方案：<a href="https://blog.csdn.net/prestigeding/article/details/52662426">基于Mybatis与Mycat的多租户方式，通过Mybatis的插件机制，动态改写SQL语句来实现多租户</a></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>实战</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析RateLimiter SmoothWarmingUp 实现原理(文末附流程图)</title>
    <url>/posts/6c0cb4a9.html</url>
    <content><![CDATA[<div id="vip-container"><p>上一篇详细介绍了 <a href="https://blog.csdn.net/prestigeding/article/details/105027563">SmoothBursty</a> 的实现原理，本文将介绍带有预热机制的限速器实现原理。</p>
<h2 id="1、类图"><a href="#1、类图" class="headerlink" title="1、类图"></a>1、类图</h2><p><img src="https://img-blog.csdnimg.cn/20200329155128855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>从上文也详细介绍了 RateLimiter 相关的类图，本文就不详细介绍。</p>
<h2 id="2、SmoothWarmingUp-创建流程"><a href="#2、SmoothWarmingUp-创建流程" class="headerlink" title="2、SmoothWarmingUp 创建流程"></a>2、SmoothWarmingUp 创建流程</h2><p>创建 SmoothWarmingUp 限速器的入口为 RateLimiter 的 create 方法，其代码如下：<br>RateLimiter#create</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    checkArgument(warmupPeriod &gt;= <span class="number">0</span>, <span class="string">&quot;warmupPeriod must not be negative: %s&quot;</span>, warmupPeriod);</span><br><span class="line">    <span class="keyword">return</span> create(</span><br><span class="line">        SleepingStopwatch.createFromSystemTimer(), permitsPerSecond, warmupPeriod, unit, <span class="number">3.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先先来看一下参数列表：</p>
<ul>
<li>double permitsPerSecond<br>每秒发放许可数量，即所谓的QPS。</li>
<li>long warmupPeriod<br>设置预热时间。</li>
<li>TimeUnit unit<br>warmupPeriod 的时间单位。</li>
</ul>
<p>代码@2：调用内部的重载方法创建 SmoothWarmingUp 。</p>
<a id="more"></a>

<p>RateLimiter#create</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">( SleepingStopwatch stopwatch, <span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> warmupPeriod, TimeUnit unit, <span class="keyword">double</span> coldFactor)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothWarmingUp(stopwatch, warmupPeriod, unit, coldFactor);  <span class="comment">// @1</span></span><br><span class="line">    rateLimiter.setRate(permitsPerSecond); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 SmoothWarmingUp 两个主要步骤分别是调用其构造方法首先创建 SmoothWarmingUp 实例，然后调用其 setRate 方法进行初始化速率。这里先突出 coldFactor，默认为 3.0，该属性的作用将在下文详细介绍。</p>
<p>我们先来重点探讨一下 setRate 方法的实现。最终会调用其父类 SmoothRateLimiter 的doSetRate 方法。</p>
<p>SmoothRateLimiter#doSetRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1 </span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;   </span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;   <span class="comment">// @2</span></span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);  <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：基于当前时间重置 SmoothRateLimiter 内部的 storedPermits(已存储的许可数量) 与 nextFreeTicketMicros(下一次可以免费获取许可的时间) 值，所谓的免费指的是无需等待就可以获取设定速率的许可，该方法对理解限流许可的产生非常关键，稍后详细介绍。</p>
<p>代码@2：根据QPS算出一个稳定的获取1个许可的时间。以一秒发放5个许可，即限速为5QPS，那发放一个许可的世界间隔为 200ms，stableIntervalMicros 变量是以微妙为单位。</p>
<p>代码@4：调用 SmoothRateLimiter 的抽象方法 doSetRate 设置速率，这里会调用 SmoothWarmingUp 的 doSetRate 方法。</p>
<p>在介绍 SmoothWarmingUp 的 doSetRate 方法之前，我们先来看一下 resync 方法的实现。</p>
<p>SmoothRateLimiter#resync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;  <span class="comment">// @1 </span></span><br><span class="line">      <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();  <span class="comment">// @2</span></span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);    <span class="comment">// @3</span></span><br><span class="line">      nextFreeTicketMicros = nowMicros;   <span class="comment">// @4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果当前已启动时间大于nextFreeTicketMicros（下一次可以免费获取许可的时间），则需要重新计算许可，即又可以向许可池中添加许可。</p>
<p>代码@2：根据当前时间可增加的许可数量，由于 SmoothWarmingUp 实现了预热机制，平均生成一个许可的时间并不是固定不变的。具体由 coolDownIntervalMicros 方法实现，稍候详细介绍。</p>
<p>代码@3：计算当前可用的许可，将新增的这些许可添加到许可池，但不会超过其最大值。</p>
<p>代码@4：更新下一次可增加计算许可的时间。 </p>
<p>SmoothWarmingUp#coolDownIntervalMicros</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">coolDownIntervalMicros</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> warmupPeriodMicros / maxPermits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的实现其实简单，用生成这些许可的总时间除以现在已经生成的许可数，即可得到当前时间点平均一个许可的生成时间。</p>
<ol>
<li><p>接下来重点探讨 SmoothWarmingUp 的 doSetRate 方法。<br>为了方便理解 SmoothWarmingUp doSetRate 方法，我根据 SmoothWarmingUp 类的注释，结合代码，给出如下示例图：<br><img src="https://img-blog.csdnimg.cn/20200329155338150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>首先我们先来根据 SmoothWarmingUp 的相关注释来理解一下上述这张图的几个要点。</p>
<ul>
<li>图中有两个阴影面积，一个用 stable，另外一个warm up period。在预热算法中，这两个阴影面积的关系与冷却因子相关。</li>
<li>冷却因子 coldFactor 表示的含义为 coldIntervalMicros 与  stableIntervalMicros 的比值。</li>
<li>warm up period 阴影面积 与 stable 阴影面积的比值等于 (coldIntervalMicros -  stableIntervalMicros ) / stableIntervalMicros ，例如 SmoothWarmingUp 固定的冷却因子为3，那么 coldIntervalMicros 与 stableIntervalMicros 的比值为 3，那  (coldIntervalMicros -  stableIntervalMicros ) / stableIntervalMicros 则为 2。</li>
<li>在预热算法中与数学中的积分相关（笔者对这方面的数学知识一窍不通），故这里只展示结论，而不做推导，阴影 WARM UP PERIOD 的面积等于 warmupPeriod,那阴影stable的面积等于 warmupPeriod/2。</li>
<li>存在如下等式 warmupPeriod/2 = thresholdPermits * stableIntervalMicros (长方形的面积)</li>
<li>同样存在如下等式 warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits) （梯形面积，(上底 + 下底 * 高 / 2) ）</li>
</ul>
<p>有了上述基本知识，我们再来看一下代码。</p>
<p>SmoothWarmingUp#doSetRate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = maxPermits;</span><br><span class="line">    <span class="keyword">double</span> coldIntervalMicros = stableIntervalMicros * coldFactor;                <span class="comment">// @1</span></span><br><span class="line">    thresholdPermits = <span class="number">0.5</span> * warmupPeriodMicros / stableIntervalMicros;    <span class="comment">// @2</span></span><br><span class="line">    maxPermits =</span><br><span class="line">          thresholdPermits + <span class="number">2.0</span> * warmupPeriodMicros / (stableIntervalMicros + coldIntervalMicros);   <span class="comment">// @3</span></span><br><span class="line">    slope = (coldIntervalMicros - stableIntervalMicros) / (maxPermits - thresholdPermits);  <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">        storedPermits = <span class="number">0.0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        storedPermits =</span><br><span class="line">            (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">                ? maxPermits <span class="comment">// initial state is cold</span></span><br><span class="line">                : storedPermits * maxPermits / oldMaxPermits;    <span class="comment">// @5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据冷却因子(coldFactor)来计算冷却间隔(单位为微秒)，等于冷却因子与 stableIntervalMicros 的乘积。从这里我们可以得出如下几个基本的概念。冷却因子 coldFactor 为 冷却间隔与稳定间隔的比例。</p>
<p>代码@2：通过  warmupPeriod/2 = thresholdPermits * stableIntervalMicros 等式，求出 thresholdPermits 的值。</p>
<p>代码@3：根据  warmupPeriod = 0.5 * (stableInterval + coldInterval) * (maxPermits - thresholdPermits)  表示可求出 maxPermits 的数量。</p>
<p>代码@4：斜率，表示的是从 stableIntervalMicros 到 coldIntervalMicros 这段时间，许可数量从 thresholdPermits 变为 maxPermits 的增长速率。</p>
<p>代码@5：根据 maxPermits 更新当前存储的许可，即当前剩余可消耗的许可数量。</p>
<h2 id="3、SmoothWarmingUp-acquire-流程"><a href="#3、SmoothWarmingUp-acquire-流程" class="headerlink" title="3、SmoothWarmingUp acquire 流程"></a>3、SmoothWarmingUp acquire 流程</h2><p>首先 acquire 的定义在其父类，这里是典型的模板模式，由其父类定义基本流程，由具体的子类实现其特定功能。RateLimiter 中的 acquire 方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> microsToWait = reserve(permits);    <span class="comment">// @1</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);   <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据当前剩余的许可与本次申请的许可来判断本次申请需要等待的时长，如果返回0则表示无需等待。</p>
<p>代码@2：如果需要等待的时间不为0，表示触发限速，睡眠指定时间后唤醒。</p>
<p>代码@3：返回本次申请等待的时长。</p>
<p>接下来重点介绍 reserve 方法的实现原理。</p>
<p>RateLimiter#reserve</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">inal <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;  <span class="comment">// @1</span></span><br><span class="line">      <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros()); <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：限速器主要维护的重要数据字段(storedPermits)，对其进行维护时都需要先获取锁。</p>
<p>代码@2：调用内部方法 reserveAndGetWaitLength 来计算需要等待时间。</p>
<p>继续跟踪 reserveAndGetWaitLength 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据当前拥有的许可数量、当前时间判断待申请许可最早能得到满足的最早时间，用momentAvailable 表示。</p>
<p>代码@2：然后计算 momentAvailable 与 nowMicros 的差值与0做比较，得出需要等待的时间。</p>
<p>继续跟踪 reserveEarliestAvailable方法，该方法在 RateLimiter 中一个抽象方法，具体实现在其子类 SmoothRateLimiter 中。</p>
<p>SmoothRateLimiter#reserveEarliestAvailable</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    resync(nowMicros);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">    <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits); <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend; <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">long</span> waitMicros =</span><br><span class="line">        storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);  <span class="comment">// @4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);  <span class="comment">// @5</span></span><br><span class="line">    <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;    <span class="comment">// @6</span></span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：在尝试申请许可之前，先根据当前时间即发放许可速率更新 storedPermits 与 nextFreeTicketMicros（下一次可以免费获取许可的时间）。</p>
<p>代码@2：计算本次能从 storedPermits 中消耗的许可数量，取需要申请的许可数量与当前可用的许可数量的最小值，用 storedPermitsToSpend 表示。</p>
<p>代码@3：如果需要申请的许可数量(requiredPermits)大于当前剩余许可数量(storedPermits)，则还需要等待新的许可生成，用freshPermits 表示，即如果该值大于0，则表示本次申请需要阻塞一定时间。</p>
<p>代码@4：计算本次申请需要等待的时间，等待的时间由两部分组成，一部分是由 storedPermitsToWaitTime 方法返回的，另外一部分以稳定速率生成需要的许可，其需要时间为 freshPermits * stableIntervalMicros,稍后我们详细分析一下 storedPermitsToWaitTime 方法的实现。</p>
<p>代码@5：更新 nextFreeTicketMicros 为当前时间加上需要等待的时间。</p>
<p>代码@6：更新 storedPermits 的值，即减少本次已消耗的许可数量。</p>
<p>代码@7：请注意这里返回的 returnValue 的值，并没有包含由于剩余许可需要等待创建新许可的时间，即允许一定的突发流量，故本次计算需要的等待时间将对下一次请求生效。</p>
<p>接下来重点探讨一下 SmoothWarmingUp 的 storedPermitsToWaitTime 方法。</p>
<p>SmoothWarmingUp#SmoothWarmingUp </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">storedPermitsToWaitTime</span><span class="params">(<span class="keyword">double</span> storedPermits, <span class="keyword">double</span> permitsToTake)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">	<span class="keyword">double</span> availablePermitsAboveThreshold = storedPermits - thresholdPermits;   <span class="comment">// @2</span></span><br><span class="line">	<span class="keyword">long</span> micros = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (availablePermitsAboveThreshold &gt; <span class="number">0.0</span>) &#123;  <span class="comment">// @3</span></span><br><span class="line">		<span class="keyword">double</span> permitsAboveThresholdToTake = min(availablePermitsAboveThreshold, permitsToTake);  <span class="comment">// @31 </span></span><br><span class="line">                <span class="comment">// TODO(cpovirk): Figure out a good name for this variable.</span></span><br><span class="line">                <span class="keyword">double</span> length = permitsToTime(availablePermitsAboveThreshold)</span><br><span class="line">                     + permitsToTime(availablePermitsAboveThreshold - permitsAboveThresholdToTake);             <span class="comment">// @32</span></span><br><span class="line">                micros = (<span class="keyword">long</span>) (permitsAboveThresholdToTake * length / <span class="number">2.0</span>);                                                      <span class="comment">// @33</span></span><br><span class="line">                permitsToTake -= permitsAboveThresholdToTake;                                                                          <span class="comment">// @34</span></span><br><span class="line">         &#125;</span><br><span class="line">        <span class="comment">// measuring the integral on the left part of the function (the horizontal line)</span></span><br><span class="line">        micros += (stableIntervalMicros * permitsToTake);   <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">return</span> micros;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍其两个参数的含义：</p>
<ul>
<li>double storedPermits<br>当前存储的许可数量。</li>
<li>double permitsToTake<br>本次申请需要的许可数量。</li>
</ul>
<p>代码@2：availablePermitsAboveThreshold ，当前超出 thresholdPermits 的许可个数，如果超过 thresholdPermits ，申请许可将来源于超过的部分，只有其不足后，才会从 thresholdPermits 中申请，这部分的详细逻辑见代码@3。</p>
<p>代码@3：如果当前存储的许可数量超过了稳定许可 thresholdPermits，即存在预热的许可数量的申请逻辑，其实现关键点如下：</p>
<ul>
<li>获取本次从预热区间申请的许可数量。</li>
<li>从预热区间获取一个许可的时间其算法有点晦涩难懂，具体实现为@32~@34。</li>
</ul>
<p>代码@4：从稳定区间获取一个许可的时间，就容易理解，为固定的 stableIntervalMicros 。</p>
<blockquote>
<p>温馨提示：从预热区间计算获取多个许可的算法，与 slope 有关，笔者并未完成感悟，但至少我们需要明白的是，从 剩余许可(storedPermits)中申请许可时，优先消耗(大于thresholdPermits 的许可，即消耗 (thresholdPermits ~ maxPermit ) 之间的许可)。</p>
</blockquote>
<p>SmoothWarmingUp 的 acquire 流程就介绍到这里了。</p>
<h2 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a>4、总结</h2><p>SmoothWarmingUp 的 acquire 的流程与 SmoothBursty 类似，故其流程图与下图通用，主要的区别生成一个许可的时间有变化，主要是提供了预热机制。<br><img src="https://img-blog.csdnimg.cn/20200329155751536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
</ol>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>SmoothWarmingUp</tag>
        <tag>coldFactor</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读技巧篇：RocketMQ DLedger 多副本即主从切换专栏回顾</title>
    <url>/posts/12736650.html</url>
    <content><![CDATA[<div id="vip-container"><p>RocketMQ DLedger 多副本即主从切换专栏总共包含9篇文章，时间跨度大概为2个月的时间，笔者觉得授人以鱼不如授人以渔，借以这个系列来展示该系列的创作始末，展示笔者阅读源码的技巧。</p>
<p>首先在下决心研读  RocketMQ DLedger 多副本(主从切换)的源码之前，首先还是要通过官方的分享、百度等途径对该功能进行一些基本的了解。</p>
<p>我们了解到 RocketMQ 在 4.5.0 之前提供了主从同步功能，即当主节点宕机后，消费端可以继续从从节点上消费消息，但无法继续向该复制组发送消息。RocketMQ 4.5.0版本引入了多副本机制，即 DLedger，支持主从切换，即当一个复制组内的主节点宕机后，会在该复制组内触发重新选主，选主完成后即可继续提供消息写功能。同时还了解到 rocketmq 主从切换是基于 raft 协议的。</p>
<p>raft 协议是何许人也，我猜想大部分读者对这个名词并不陌生，但像笔者一样只是听过其大体作用但并未详细学习的应该也不在少数，故我觉得看 RocketMQ DLedger 多副本即主从切换之前应该重点了解 raft 协议。</p>
<p>1、<a href="https://blog.csdn.net/prestigeding/article/details/99101912">RocketMQ 多副本前置篇：初探raft协议</a></p>
<p>本文主要根据 raft 官方提供的动画来学习了解 raft 协议，从本文基本得知了 raft 协议主要包含两个重要部分：选主 以及 日志复制。在了解了 raft 协议的选主、日志复制的基本实现后，然后就可以步入到 RocketMQ DLedger 多副本即主从切换的源码研究了，以探究大神是如何实现 raft 协议的。同时在了解到了 raft 协议的选主部分内容后，自己也可以简单的思考，如果自己去实现 raft 协议，应该要实现哪些关键点，当时我的思考如下：<br><img src="https://img-blog.csdnimg.cn/20191020212502611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这样在看源码时更加有针对性，不至于在阅读源码过程中“迷失”。</p>
<p>2、<a href="https://blog.csdn.net/prestigeding/article/details/99697323">源码分析 RocketMQ DLedger 多副本之 Leader 选主</a></p>
<p>本文按照上一篇的思路，重点对 DLedgerLeaderElector 的实现进行了详细分析，特别是其内部的状态机流转，最后也给出一张流程图对选主过程进行一个简单的梳理与总结。</p>
<a id="more"></a>

<blockquote>
<p>温馨提示：如果在阅读源码的过程中一时无法理解，可以允许其提供的单元测试，DEBUG一下，可以起到拨云见雾之效。</p>
</blockquote>
<p>3、<a href="https://blog.csdn.net/prestigeding/article/details/100177780">源码分析 RocketMQ DLedger 多副本存储实现</a></p>
<p>在学习完 DLedger 选主实现后，接下来将重点突破 raft 协议的另外一个部分：日志复制。因为日志复制将涉及到存储，故在学习日志复制之前，先来看一下 DLedger 与存储相关的设计，例如 DLedger 日志条目的存储协议、日志在服务器的组织等关系，这部分类比 RocketMQ commitlog 等的存储。</p>
<p>4、<a href="https://blog.csdn.net/prestigeding/article/details/100835869">源码分析 RocketMQ DLedger(多副本) 之日志追加流程</a></p>
<p>在学习完DLedger 多副本即主从切换 日志存储后，我们将正式进入到日志复制部分，从上图我们可以简单了解，日志复制其实包含两个比较大的阶段，第一阶段是指主节点(Leader)接受客户端请求后，将数据先存储到主服务器中，然后再将数据转发到它的所有从节点。故本篇文章中的关注第一阶段：日志追加。</p>
<p>5、<a href="https://blog.csdn.net/prestigeding/article/details/100836389">源码分析 RocketMQ DLedger(多副本) 之日志复制(传播)</a><br>本文继续关注日志复制的第二个阶段，包含主节点日志转发、从节点接收日志、主节点对日志转发进行仲裁，即需要实现只有超过集群半数节点都存储成功才认为该消息已成功提交，才会对客户端承偌消息发送成功。</p>
<p>6、<a href="https://blog.csdn.net/prestigeding/article/details/101629440">基于 raft 协议的 RocketMQ DLedger 多副本日志复制设计原理</a></p>
<p>源码解读 raft 协议的日志复制部分毕竟比较枯燥，故本文梳理了3张流程图，并对日志的实现要点做一个总结，以此来介绍 rocketmq Dledger 多副本即主从切换部分的 raft 协议的解读。</p>
<p>7、<a href="https://blog.csdn.net/prestigeding/article/details/101984216">RocketMQ 整合 DLedger(多副本)即主从切换实现平滑升级的设计技巧</a></p>
<p>前面6篇文章都聚焦在 raft 协议的选主与日志复制。从本节开始将介绍 rocketmq 主从切换的实现细节，基于 raft 协议已经可以实现主节点的选主与日志复制，主从切换的另外一个核心就是主从切换后元数据的同步，例如topic、消费组订阅信息、消息消费进度等。另外主从切换是rocketmq 4.5.0 版本才引入的，如果从老版本升级到 4.5.0，直接兼容原先的消息是重中之中，故本文将详细剖析其设计要点。</p>
<p>8、<a href="https://blog.csdn.net/prestigeding/article/details/102239892">源码分析 RocketMQ DLedger 多副本即主从切换实现原理</a></p>
<p>从设计上理解了平滑升级的技巧，本篇就从源码角度剖析主从切换的实现要点，即重点关注元数据的同步（特别是消息消费进度的同步）。</p>
<p>9、<a href="https://blog.csdn.net/prestigeding/article/details/102532485">RocketMQ DLedger 多副本即主从切换实战</a></p>
<p>经过前面8篇文章的铺垫，我相信大家对 DLedger 的实现原理有了一个全新的认识，本篇作为该系列的收官之作，介绍如何从主从同步集群平滑升级到DLedger，即主从切换版本，并对功能进行验证。</p>
<p>整体总结一下就是首先从整体上认识其核心要点，然后逐步展开，逐步分解形成一篇一篇的文章，在遇到看不懂的时候，可以 debug  官方提供的单元测试用例。</p>
<p>如果本文对大家有所帮助的话，麻烦帮忙点个【在看】，谢谢。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
        <tag>DLedger</tag>
      </tags>
  </entry>
  <entry>
    <title>源码阅读方法、误区与三种境界</title>
    <url>/posts/5cfc78e.html</url>
    <content><![CDATA[<div id="vip-container"><p>在技术职场中普遍存在如下几种现象：</p>
<ul>
<li>对待工作中所使用的技术<strong>不需要阅读源码</strong>，只需在开发过程中能够熟练运用就行</li>
<li>看源码太费时间，而且容易忘记，如果从实际使用过程中出现的问题出发，针对性的阅读源码，其学习效率会更高效，所以平时无需看源码。</li>
</ul>
<p>对此我有着不同的理解，容我慢慢道来。</p>
<p>本文将从如下4个角度进行剖析：</p>
<ol>
<li>源码阅读的必要性</li>
<li>源码阅读技巧</li>
<li>源码阅读的三种境界</li>
<li>源码阅读的误区</li>
</ol>
<a id="more"></a>

<h2 id="1、源码阅读必要性"><a href="#1、源码阅读必要性" class="headerlink" title="1、源码阅读必要性"></a>1、源码阅读必要性</h2><h4 id="1-1-通用型基础技术应该深入源码研究"><a href="#1-1-通用型基础技术应该深入源码研究" class="headerlink" title="1.1 通用型基础技术应该深入源码研究"></a>1.1 通用型基础技术应该深入源码研究</h4><p>在 JAVA 领域中笔者认为通用型基础技术包含 JAVA 集合、Java并发(JUC)。这类技术是项目中使用的高频技术，在合适的场景中选用合适的数据结构、选用合适的线程并发模型、合理控制锁粒度等都能显著提高应用程序的可用性、健壮性。</p>
<p>通用型技术正因为其具有普遍性，横向对比更具代表性，职场面试时的可辨别性非常高，<strong>如何在高样本中突出自己就显得极为必要，通过阅读源码，深刻理解其内部原理成为我们的不二法宝。</strong></p>
<p>当然通过阅读源码并不是知晓原理的唯一方法，但作为一个名程序员、直面代码，亲自感受代码的魅力或许来的更加直接。</p>
<h4 id="1-2-重点领域应深入源码研究"><a href="#1-2-重点领域应深入源码研究" class="headerlink" title="1.2 重点领域应深入源码研究"></a>1.2 重点领域应深入源码研究</h4><p>为了提高辨识度作为职场的我们应该打造自己的专属标签，即<strong>“亮点”</strong>。通常情况我们应该选择在日常工作中使用的技术，在积累了丰富的使用经验、线上故障排查经验的前提下，应该深入研究其源码，成体系掌握该技术，从而对其更具掌控性，做到提前预判线上问题，规避大量线上故障，提升稳定性，助力业务降本增效。</p>
<p>例如笔者所在公司在微服务、消息中间件领域分别采用了 Dubbo、RocketMQ，并且笔者有幸参与到这项技术栈的运用与运维，积累了丰富的使用经验，为此笔者为了突出在这两个领域的优势，详细阅读其源码，并作成专栏发布在『中间件兴趣圈』公众号与CSDN等知识分享平台，由于是成体系剖析的原因被出版社相中，邀请出书，《RocketMQ技术内幕》一书就在这样的背景中应运而生，<strong>从而成为笔者职业技能中非常亮眼的标签，助力职场</strong>。</p>
<p><strong>源码阅读确实很重要，但一定需要成体系研究</strong>，大部分人认为<strong>在处理问题时再根据具体问题去看源码，会更有针对性，觉得没必要成体系看</strong>。</p>
<p>不可否认这有其正确性的一面，从问题本身出发，看源码效率更快，“投入产出比”更高，随着遇到的问题越来越多，对该技术理解也会越来越深，这个其实就是我们通常讲的<strong>“经验”</strong>。我觉得大部分情况下是可取的，<strong>这个过程其实是一个被动的过程</strong>，并且如果生产环节由于并发不高等因素，可能一年、两年也不会出现一两次故障，这样就会造成经验的积累会非常慢，从而使得工作了4、5年的朋友其竞争力还不如工作2,3年的重要原因，<strong>所以我的观点是如果是想打造成自己的专属亮点的话，我们还是需要主动通过阅读其源码，成体系掌握其设计理念、实现原理，更好的打造自己的专属亮点。</strong></p>
<h2 id="2、如何阅读源码"><a href="#2、如何阅读源码" class="headerlink" title="2、如何阅读源码"></a>2、如何阅读源码</h2><p>既然阅读源码非常有必要，那如何阅读源码呢？笔者根据多年的源码阅读经验整理了如下方法论：</p>
<ol>
<li>了解这款中间件的使用场景、以及架构设计中将承担的责任。</li>
<li>寻找官方文档，从整体上把握这款中间件的设计理念。</li>
<li>搭建自己的开发调试环境，运行官方提供Demo示例，为后续深入研究打下基础。</li>
<li>先主干流程再分支流程，注意切割，逐个击破。</li>
<li>阅读源码过程中带着思考与质疑思维。</li>
</ol>
<p>理解了其使用场景后，结合官方文档，尝试理解该中间件需要解决的问题、并思考如何解决，思考过程中并不一定要求我们想出一个具体的答案，只是在真正步入源码阅读时能更快感悟其代码含义。</p>
<p>当然在阅读源码的<strong>过程中可能会到难题</strong>，遇到无法理解作者的实现意图，特别是遇到一些自己不太熟悉的编程方式(例如位运算)，此时通常有<strong>两种解决方案</strong>：</p>
<ol>
<li>通过DEBUG，结合运行时数据，方便对代码的理解。</li>
<li>从易到难，可以先尝试阅读一下JAVA集合框架的源码，提炼出一套自己的源码研究方法论。</li>
</ol>
<p><strong>源码阅读其实最难的不是代码本身</strong>，也不是无法理解其设计理念，<strong>最难的是坚持</strong>，故在这里借用笔者的座右铭与大家共勉：越努力越幸运，唯有坚持不懈。</p>
<h2 id="3、源码阅读的三层境界"><a href="#3、源码阅读的三层境界" class="headerlink" title="3、源码阅读的三层境界"></a>3、源码阅读的三层境界</h2><p>接下来我想再结合笔者4年源码阅读的历程，谈谈我对源码阅读的一些更深层次的理解，介绍一下笔者在各个阶段阅读源码所处的状态。</p>
<ol>
<li>源码阅读的初级阶段<br>笔者的老粉丝们应该能感觉到笔者初期的源码阅读文章，基本上是<strong>记流水账</strong>,其最直观的表现现象是对源码一样一行加注释，只关注底层实现细节，但并未形成更高层次认知，对其设计理念并未提炼与深度领悟。 </li>
<li>能提问、思考、并提炼<br>随着技术类文章的持续分享，笔者认识了很多大牛、发现与大牛交流的时候，一开始并不会说细节，而是讲设计理念，这就要求我们在<strong>阅读源码的时候多思考</strong>，并反问自己如果需要自己实现的话我们该如何着手，如何设计，带着疑问去研究源码，通过对比，思考，会对其背后的理念有了更深刻的理解。</li>
<li>思考、质疑、验证<br>其实无论是哪个开源框架都会存在BUG或者实现并不合理的地方，如果大家在阅读源码的时候能够思考并开始质疑其不合理性，并能通过验证证明自己的观点，然后与官方取得联系，交流，建Isuue，共同促进社区的发展，说明我们的能力、思考得到了极大的提升。</li>
</ol>
<p>关于这一点，可以参考笔者对 Sentinel 对应熔断实现机制进行的质疑与思考过程。</p>
<p><a href="https://mp.weixin.qq.com/s/4HrfIfwszrW-q2BUcVwlhw">从Sentinel Dubbo 适配器看限流与熔断（实战思考篇）</a></p>
<h2 id="4、源码阅读误区"><a href="#4、源码阅读误区" class="headerlink" title="4、源码阅读误区"></a>4、源码阅读误区</h2><p><strong>源码阅读是手段，但一定不是目的。</strong></p>
<p>我在面试过程中发现好多候选者在谈到某一项技术时，首先不是介绍其原理，而是一下子具体到某个类啥的，这些类是如何如何工作等等，其实这是不太妥当的，源码阅读的目的是主要是深入理解其设计理念、工作机制，方便我们在实际使用过程中对其成体系的认识，加强对它的驾驭能力，做到提前规避风险。</p>
<p>其次源码阅读<strong>非常不建议</strong>一上来就直接DEBUG。如果一开始就使用DEBUG，很容易会迷失在代码的各个分支中，<strong>缺乏全局视角</strong>，从而变得没有头绪，极大的增加了源码理解的难度，很容易让我们半途而废。</p>
<p><strong>最后学习一门技术并一定要深入源码</strong>，特别是非主流，非重点打造的领域。对于此类我们通常只需根据阅读官方文档，了解其使用场景、能解决什么问题，理解其设计理念、工作机制，灵活运用解决具体问题即可。</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>源码阅读并不是目的，只是手段。对于通用型基础技术诸如JAVA集合、并发、需重点打造为亮点的领域建议大家阅读其源码，成体系深入细节掌握其工作机制，增强其驾驭能力，拥有提前规避风险的能力。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>源码</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>阅读</tag>
        <tag>源码分享</tag>
        <tag>源码阅读</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>生产环境JVM内存溢出案例分析</title>
    <url>/posts/81f19d85.html</url>
    <content><![CDATA[<div id="vip-container"><p>如果我们所在公司的业务量比较大，在生产环境经常会出现JVM内存溢出的现象，那我们该如何快速响应，快速定位，快速恢复问题呢？</p>
<p>本文将通过一个线上环境JVM内存溢出的案例向大家介绍一下处理思路与分析方法。</p>
<p>案例：架构组接到某项目组反馈，Zabbix监控上显示JMX不可用，请求协助处理。</p>
<p>分析思路：</p>
<ul>
<li><p>JMX不可用，往往是由于垃圾回收时间停顿时间过长、内存溢出等问题引起的。</p>
</li>
<li><p>线上故障分析的原则是首先要采取措施快速恢复故障对业务的影响，然后才是采集信息、分析定位问题，并最终给出解决办法。</p>
</li>
</ul>
<p>具体分析过程如下。</p>
<h2 id="1、如何快速恢复业务"><a href="#1、如何快速恢复业务" class="headerlink" title="1、如何快速恢复业务"></a>1、如何快速恢复业务</h2><p>通常线上的故障会对业务造成重大影响，影响用户体验，故如果线上服务器出现故障，应规避对业务造成影响，但不能简单的重启服务器，因为需要尽可能保留现场，为后续的问题分析打下基础。</p>
<p>那我们如何快速规避对业务的影响，并能保留现场呢？</p>
<p>通常的做法是隔离故障服务器。</p>
<p>通常线上服务器是集群部署，一个好的分布式负载方案会自动剔除故障的机器，从而实现高可用架构，但如果未被剔除，则需要运维人员将故障服务器进行剔除，保留现场进行分析。</p>
<p>发生内存泄露，通常情况下是由于代码的原因造成的，一般无法立即对代码进行修复，很容易会发送连锁反应造成应用服务器一台一台接连宕机，故障面积会慢慢扩大，针对此种情况，应快速定位发生内存泄露的原因，将该服务进行降级，避免对其他服务造成影响。最简单的降级方法是根据F5(Nginx)转发策略，对该功能定向到一个单独的集群，与其他流量进行隔离，确保其他业务不受牵连，给故障排查、解决提供宝贵的缓冲时间。</p>
<h3 id="1-1-分析解决问题"><a href="#1-1-分析解决问题" class="headerlink" title="1.1 分析解决问题"></a>1.1 分析解决问题</h3><p>首先可以通过查看日志，确定是哪种内存溢出，堆内存溢出可发生的地方：Java heap space(堆空间)、perm space(持久代)。<br><img src="https://img-blog.csdnimg.cn/20190407211939699.png" alt="在这里插入图片描述"></p>
<h4 id="1-1-1-收集内存溢出Dump文件"><a href="#1-1-1-收集内存溢出Dump文件" class="headerlink" title="1.1.1 收集内存溢出Dump文件"></a>1.1.1 收集内存溢出Dump文件</h4><p>收集Dump文件有两种方式：</p>
<ul>
<li>设置JVM启动参数<br>  -XX:+HeapDumpOnOutOfMemoryError<br>  -XX:HeapDumpPath=/opt/jvmdump</li>
</ul>
<p>在每次发生内存溢出时，JVM会自动将堆转储，dump文件存放在-XX:HeapDumpPath指定的路径下。</p>
<ul>
<li>使用jmap命令收集<br> 通过jmap -dump:live,format=b,file=/opt/jvm/dump.hprof pid。</li>
</ul>
<h4 id="1-1-2-分析Dump文件"><a href="#1-1-2-分析Dump文件" class="headerlink" title="1.1.2 分析Dump文件"></a>1.1.2 分析Dump文件</h4><p>在获取Dump文件后，可以使用工具MAT(MemoryAnalyzer)进行分析，该工具大家可以通过百度自行下载。</p>
<p>使用MAT打开Dump文件后，首页截图如下：<br><img src="https://img-blog.csdnimg.cn/2019040721211771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>工具按钮介绍：</p>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20190407212228666.png">：直方图视图，将堆中所有的内存消耗情况统计出来，其如图所示：<br><img src="https://img-blog.csdnimg.cn/20190407212451707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190407212424828.png" alt="在这里插入图片描述">：内存使用树状结构，以线程为维度，树状形式展开，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190407212509381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190407212438288.png" alt="在这里插入图片描述">线程栈，其截图如下：<br><img src="https://img-blog.csdnimg.cn/20190407212535591.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20190407212606556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据该图，可以明确，堆的总大小为1.9G，被4个线程全部占据，导致其他线程无法再申请资源，抛出堆内存溢出错误。</p>
<p>接下来，我通常的做法是直接去看【内存使用树状结构，见上文描述】(以线程为基本维度，查找线程中占用内存的对象)，为后续定位排查提供必要的依据。<br><img src="https://img-blog.csdnimg.cn/20190407212709798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190407212721605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面的截图中可以得出如下关键信息点：</p>
<ul>
<li><p>org.apache.ibatis.executor.result.DefaultResultHandler内部持有一个List，其原始为java.util.HashMap，从这个类基本可以看出是与数据库的查询相关，对数据库返回结果的解码并组织成HashMap。</p>
</li>
<li><p>这个List中的元素总共有146033个，初步可以判断出是在一次查询中从数据库中一次查询出了太多数据，造成了内存溢出。</p>
</li>
</ul>
<p>由于SQL查询代码中，是用HashMap来接收数据库中的返回字段，无法一时间看出是那个查询，那我们能不能精确找到是哪一个查询，哪一行代码，甚至与哪一条SQL语句呢？</p>
<p>答案是可以的，我们可以从视图一探究竟。</p>
<pre><code>温馨提示：
视图使用技巧：展开技巧：沿着使用率最高的项一层一层进行展开，直至发现具体占用内存的对象。</code></pre>
<p>接下来我们从 视图去寻找是哪个方法，哪条SQL语句触发的。</p>
<p>具体方法：首先完全展开一个线程，从展开图的底部向上寻找：<br>其线程的入口(控制层代码)<br><img src="https://img-blog.csdnimg.cn/20190407212846134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>继续往上查找，要找到SQL语句，应该找到Mybatis处理结果集相关的类，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190407212857266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="加粗样式"><br>然后展开boundSql即能找到SQL语句：<br><img src="https://img-blog.csdnimg.cn/20190407212915357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后鼠标可以放在SQL属性中，右键，可以将SQL语句复制出来。<br><img src="https://img-blog.csdnimg.cn/20190407212928341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于这里涉及到公司的代码机密，故在这里不贴出具体的SQL语句。</p>
<p>这里根据后面的分析，原来是在做导出功能的时候，没有使用分页对数据进行分页查询，分页写入Excel文件，而是一次将全部数据查询，导致导出功能如果并发数超过4个时，就会将所有内存耗尽。</p>
<p>解决方案：</p>
<ul>
<li><p>首先在运维层面将该请求导入到指定的一台服务器上，是导出任务与其他任务进行隔离，避免对其他重要服务造成影响。</p>
</li>
<li><p>项目组对其代码进行修复，可以使用分页查数据，然后分配写入Excel。</p>
</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>实战</tag>
        <tag>内存溢出</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>结合 Sentinel 专栏谈谈我的源码阅读技巧</title>
    <url>/posts/b9d8cad7.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>本文行文思路：先抛出源码阅读方法，然后结合Sentinel创作过程谈谈具体是如何运用这些技巧，最后解答几个源码阅读的误区。</p>
</blockquote>
<p>Sentinel 系列共包含15篇文章，主要以源码分析为手段，图文并茂的方式对 Sentinel 的架构设计理念、核心实现要点进行了一一剖析，并加以实战分析与思考。</p>
<p><strong>很多朋友都在询我是如何阅读源码的。对此可归纳为如下几个要点，然后结合 Sentienl 源码分析专栏对各个要点进行拆解，对源码阅读方法进行一次“实战”。</strong></p>
<ul>
<li>阅读官方文档，从全局了解待学习框架能解决什么样的问题，整体架构设计与思想是什么，主要包含哪些要点。</li>
<li>从官方提供的 Demo 程序开始，学习基本的使用方法，进一步加深其理解，并伺机寻找入口（突破口）。</li>
<li>寻找突破口，逐一突破，先主干再旁支，适度分解，各个击破。</li>
</ul>
<p>接下来将展示我是如何使用这套方法论来学习 Sentinel 的。</p>
<p>在准备深入学习 Sentinel 之前，首先认真看了一遍 Sentinel 的官方文档，从而形成了对 Sentinel 的基本认识，我们可以从官方文档了解到 Sentinel 主要涉及的核心内容，正如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020053015083815.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这些内容可以简单的当成一个学习的提纲，可以从里面挑选自己感兴趣的进行重点学习。</p>
<p>在看完官方文档后，我就踏上创作 Sentinel 系列的征途。</p>
<blockquote>
<p>本文不会再详细介绍每一个知识点的细节，有关各个知识点的具体讲解，大家可以点击感兴趣的链接中进行深入研究，本文主要是点到为止，重在介绍笔者是如何学习源码的。</p>
</blockquote>
<p>1、<a href="https://blog.csdn.net/prestigeding/article/details/103544443">Alibaba Sentinel 限流与熔断初探</a><br>该文章主要从如下几个点进行展开：</p>
<ul>
<li>Sentinel 是什么 ？主要能解决什么问题？</li>
<li>限流与熔断的使用场景</li>
<li>Sentinel 源码结构</li>
<li>在 IntelliJ IDEA 中运行 Sentine Demo</li>
</ul>
<p>其实第三点并不是特别必须，不过要得出这些结论也并不难，因为对 Sentinel 有了全局的认识后并根据各个模块的命名很容易能得出该模块的作用。这里第四点非常关键，通常一个优秀的开源框架都会提供完备的演示 Demo，大家可以看到 Sentinel 的演示 demo 非常丰富，在本文中我特意选择了 Dubbo 来做示例，主要是我们公司大量使用 dubbo 来实现公司的微服务，这样会更加贴近实战，更有利于寻找突破口。</p>
<p>通过跑通 Demo 的主要目的有三个：</p>
<ul>
<li>通过运行 Demo，了解框架的基本使用方法。</li>
<li>搭建一个可 Debug 的环境，为后续看不懂代码的情况下进行调试，根据运行时数据，可加快代码的理解速度，但千万不要一开始就 debug。</li>
<li>寻找源码阅读的入口。</li>
</ul>
<p>2、<a href="https://blog.csdn.net/prestigeding/article/details/103654590">源码分析 Sentinel 之 Dubbo 适配原理</a><br>紧跟第一篇文章，既然使用的是 Dubbo 作为其示例代码，自然而然的思考 Sentinel 是如何做到对 Dubbo 的适配并对业务无侵入性。</p>
<p>通过该篇文章的学习我们了解到可以通过 Dubbo 的扩展机制实现对 Dubbo 的适配，在 Dubbo Filter 中我们能看到了与 Sentinel 相关的核心 API SphU.entry，从而找到深入学习 Sentinel 的核心入口，也就是后续文章会通过对该方法的研究，从而打开进入 Sentinel 内核世界的大门。</p>
<blockquote>
<p>备注：在阅读这篇文章的时候，我觉得 Dubbo 的适配感觉非常简单，但随着我对这个系列的深入学习，发现了该方法没有那么简单，当时很多点都没有理解到位，这个在后续会有重点阐述，这也是不断学习、不断思考带来的好处。</p>
</blockquote>
<a id="more"></a>

<p>3、<a href="https://blog.csdn.net/prestigeding/article/details/103842382">寻找一把进入 Alibaba Sentinel 的钥匙</a><br>本文主要是详细跟踪 SphU.entry 方法的执行流程，从而揭晓其实现的关键点，果不其然，通过跟踪该方法的流程，找到了 Sentinel 的核心运作机制：Slot 处理链。<br><img src="https://img-blog.csdnimg.cn/20200530151308395.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>就问大家激不激动，开不开心，从这些 Slot 的名字基本就能得出其含义，后续的研究重点就是逐一解开这些 Slot 的实现原理即可。</p>
<p>4、<a href="https://blog.csdn.net/prestigeding/article/details/103943070">Sentinel 调用上下文环境实现原理</a><br>按照上述 Slot 的链，开始了 NodeSelectorSlot 的研究，通过学习了解到该 NodeSelectorSlot 主要是构建 Sentinel 的调用链，即调用上下文环境管理,准确的说是构建调用链的入口节点。在 Sentinel 中每进入一个资源都会有对应的节点实时存储该资源的调用信息。</p>
<p>5、Sentinel 实时数据采集原理<br>这个议题共两篇文章，其相关链接如下：</p>
<ul>
<li><a href="https://blog.csdn.net/prestigeding/article/details/104045216">实时采集数据详解</a></li>
<li><a href="https://blog.csdn.net/prestigeding/article/details/103753595">Sentinel 滑动窗口实现原理</a></li>
</ul>
<p>如果按照 Slot 链的执行顺序，下一个执行的 ClusterBuilderSlot，从名字就可以看出与集群限流相关的，但秉承着先简后难的学习策略，在当前先跳过该类的学习，先重点突破单机版限流，后续再回过头来学习集群限流相关的知识。</p>
<p>要实现限流、熔断等功能，首先要解决的问题是如何实时采集服务(资源)调用信息。例如将某一个接口设置的限流阔值 1W/tps，那首先如何判断当前的 TPS 是多少？Alibaba Sentinel 采用滑动窗口来实现实时数据的统计，实现类：StatisticSlot。</p>
<p>6、Sentinel 限流实现原理<br>在弄懂了 Sentinel 的实时数据采集原理后，限流实现就非常简单了，就是基于采集的调用信息，然后与限流规则进行比较，判断是否需要限流，Sentinel 在触发限流后还提供了多种处理策略，例如快速失败、匀速排队、预热等机制。</p>
<p>但我在学习限流的时候，我将限流核心逻辑与触发限流后的处理策略进行了分解，在学习限流的时候挑选了最简单处理策略(匀速排队)，将比较难的预热机制分解，再单起一篇文章进行学习，这样的拆解有利于保证学习单篇文章的用时，并提高自己的“产量”，提高自己的成就感。</p>
<p>这块主要包含如下4篇文章：</p>
<ul>
<li><a href="https://blog.csdn.net/prestigeding/article/details/104884255">Sentinel FlowSlot 限流实现原理</a></li>
<li><a href="https://blog.csdn.net/prestigeding/article/details/105027563"> RateLimiter SmoothBursty 实现原理</a></li>
<li><a href="https://blog.csdn.net/prestigeding/article/details/105180419">RateLimiter SmoothWarmingUp 实现原理</a></li>
<li><a href="https://blog.csdn.net/prestigeding/article/details/105341098">Sentinel 匀速排队与预热实现原理与实战建议</a></li>
</ul>
<p>这里还要重点阐述一下限流领域最核心的算法：漏桶算法、漏斗算法等，并且 Sentinel 的预热机制主要是参考 Guava 的实现，故这里花了点精力认真学习了 Guava 的 RateLimite 的实现原理。</p>
<p>7、<a href="https://blog.csdn.net/prestigeding/article/details/105470516">Sentinel DegradeSlot 熔断实现原理</a><br>限流部分学习完后，我就迫不及待的去探究熔断的实现，其实熔断本身并不复杂，和限流一样，无非就是根据当前的实时调用信息与熔断规则进行对比即可，如果满足熔断规则就抛出异常。如果只是熔断自身的实现本质确实简单，但要结合实际，其实有更多的问题需要思考，这个在后面的实战篇又是反复思考，从而发现 Sentinel 在熔断的实现上其实比较粗糙。</p>
<p>8、<a href="https://blog.csdn.net/prestigeding/article/details/105756877">Sentienl 动态数据源架构设计理念与改造实践</a><br>经过前面的文章，Sentinel 的单机限流与熔断已经基本学习了，这个时候就要开始思考如何使用 Sentinel 了，但 Sentinel 官方提供的后台运维管理系统的熔断、限流规则只能存储在内存，显然不能直接用于生产环境，故需要提出解决方案，本篇文章详细介绍了笔者是如何根据官方资料进行动态数据源配置的方法调研的，完成是按照工作中架构设计方案的标准来思考的，强烈推荐。</p>
<p>9、<a href="https://blog.csdn.net/prestigeding/article/details/106041456">Sentinel Dubbo 适配器看限流与熔断(实战思考篇)</a><br>支持了动态数据源，就继续进行思考，在微服务领域是如何思考引入熔断机制的，进行一番思考后发现官方提供的 Dubbo 适配器的粒度是服务级别的，无法控制机器级别，例如下图所示：<br><img src="https://img-blog.csdnimg.cn/2020053015244341.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>例如当前的 Sentinel Dubbo 适配器目前不支持一个服务其中一台服务提供者变慢，发往这台机器上的请求被熔断，当前的实现版本会调用该服务的所有请求都会被熔断，故官方的 Dubbo 适配器还需要更加完善，有了自己的思考才会对知识理解更多，故通过学习源码，一定不能“尽信书”，要有自己的思考与怀疑能力，这样才能对开源社区做出一定的贡献，共同进步与成长。</p>
<p>以上就是我学习源码的方法，希望对大家真正有所帮助与感触。</p>
<p><strong>最后我再来谈一下回答关于源码阅读方面误区的几个问题。</strong></p>
<p><strong>1、看源码会忘记吗？为什么我们看源码的时候感觉看懂了，但很容易就忘记？</strong></p>
<p>我们要始终明白看<strong>源码只是手段</strong>，目的是要思考框架的设计原理、并通过源码了解实现细节并指导实践。重在思考。当然实现细节看过后容易忘记，但只要理解了思想，在需要使用时可以看自己写过的文章，一下子就能拾起来。</p>
<p><strong>2、看源码的时候是不是可以直接使用 Debug 进行调试学习</strong></p>
<p>我是<strong>强烈不建议</strong>这样做，这样会迷失在细节中无可自拔。正确的姿势是寻找入口，带上自己的思考去梳理，当遇到看不懂源码或是无法理解其思想时，这个时候可以借助 Debug，可以通过运行时可视化的数据，帮助我们更快的了解。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码阅读技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>KafkaProducer Sender 线程详解（含详细的执行流程图）</title>
    <url>/posts/80780dfa.html</url>
    <content><![CDATA[<div id="vip-container"><p>上文 <a href="https://blog.csdn.net/prestigeding/article/details/102994716">《源码分析 Kafka 消息发送流程》</a> 已经详细介绍了 KafkaProducer send 方法的流程，该方法只是将消息追加到 KafKaProducer 的缓存中，并未真正的向 broker 发送消息，本文将来探讨 Kafka 的 Sender 线程。</p>
<p>在 KafkaProducer 中会启动一个单独的线程，其名称为 “kafka-producer-network-thread | clientID”，其中 clientID 为生产者的 id 。</p>
<h2 id="1、Sender-线程详解"><a href="#1、Sender-线程详解" class="headerlink" title="1、Sender 线程详解"></a>1、Sender 线程详解</h2><h4 id="1-1-类图"><a href="#1-1-类图" class="headerlink" title="1.1 类图"></a>1.1 类图</h4><p><img src="https://img-blog.csdnimg.cn/20191117174420482.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们先来看一下其各个属性的含义：</p>
<ul>
<li>KafkaClient client<br>kafka 网络通信客户端，主要封装与 broker 的网络通信。</li>
<li>RecordAccumulator accumulator<br>消息记录累积器，消息追加的入口(RecordAccumulator 的 append 方法)。</li>
<li>Metadata metadata<br>元数据管理器，即 topic 的路由分区信息。</li>
<li>boolean guaranteeMessageOrder<br>是否需要保证消息的顺序性。</li>
<li>int maxRequestSize<br>调用 send 方法发送的最大请求大小，包括 key、消息体序列化后的消息总大小不能超过该值。通过参数 max.request.size 来设置。</li>
<li>short acks<br>用来定义消息“已提交”的条件(标准)，就是 Broker 端向客户端承偌已提交的条件，可选值如下0、-1、1.</li>
<li>int retries<br>重试次数。</li>
<li>Time time<br>时间工具类。</li>
<li>boolean running<br>该线程状态，为 true 表示运行中。</li>
<li>boolean forceClose<br>是否强制关闭，此时会忽略正在发送中的消息。</li>
<li>SenderMetrics sensors<br>消息发送相关的统计指标收集器。</li>
<li>int requestTimeoutMs<br>请求的超时时间。</li>
<li>long retryBackoffMs<br>请求失败之在重试之前等待的时间。</li>
<li>ApiVersions apiVersions<br>API版本信息。</li>
<li>TransactionManager transactionManager<br>事务处理器。</li>
<li>Map&lt; TopicPartition, List&lt; ProducerBatch&gt;&gt; inFlightBatches<br>正在执行发送相关的消息批次。</li>
</ul>
<a id="more"></a>

<h4 id="1-2-run-方法详解"><a href="#1-2-run-方法详解" class="headerlink" title="1.2 run 方法详解"></a>1.2 run 方法详解</h4><p>Sender#run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;Starting Kafka producer I/O thread.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (running) &#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runOnce();    <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;Beginning shutdown of Kafka producer I/O thread, sending remaining records.&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span> (!forceClose &amp;&amp; (<span class="keyword">this</span>.accumulator.hasUndrained() || <span class="keyword">this</span>.client.inFlightRequestCount() &gt; <span class="number">0</span>)) &#123;    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runOnce();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;Uncaught error in kafka producer I/O thread: &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (forceClose) &#123;                                                                                                                                     <span class="comment">// @3</span></span><br><span class="line">        log.debug(<span class="string">&quot;Aborting incomplete batches due to forced shutdown&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.accumulator.abortIncompleteBatches();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.client.close();                                                                                                                               <span class="comment">// @4</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Failed to close network client&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;Shutdown of Kafka producer I/O thread has completed.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：Sender 线程在运行状态下主要的业务处理方法，将消息缓存区中的消息向 broker 发送。<br>代码@2：如果主动关闭 Sender 线程，如果不是强制关闭，则如果缓存区还有消息待发送，再次调用 runOnce 方法将剩余的消息发送完毕后再退出。<br>代码@3：如果强制关闭 Sender 线程，则拒绝未完成提交的消息。<br>代码@4：关闭 Kafka Client 即网络通信对象。</p>
<p>接下来将分别探讨其上述方法的实现细节。</p>
<h5 id="1-2-1-runOnce-详解"><a href="#1-2-1-runOnce-详解" class="headerlink" title="1.2.1 runOnce 详解"></a>1.2.1 runOnce 详解</h5><p>Sender#runOnce</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 此处省略与事务消息相关的逻辑</span></span><br><span class="line">    <span class="keyword">long</span> currentTimeMs = time.milliseconds();</span><br><span class="line">    <span class="keyword">long</span> pollTimeout = sendProducerData(currentTimeMs);   <span class="comment">// @1</span></span><br><span class="line">    client.poll(pollTimeout, currentTimeMs);                            <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文不关注事务消息的实现原理，故省略了该部分的代码。<br>代码@1：调用 sendProducerData 方法发送消息。<br>代码@2：调用这个方法的作用？</p>
<p>接下来分别对上述两个方法进行深入探究。</p>
<h6 id="1-1-2-1-sendProducerData"><a href="#1-1-2-1-sendProducerData" class="headerlink" title="1.1.2.1 sendProducerData"></a>1.1.2.1 sendProducerData</h6><p>接下来将详细分析其实现步骤。<br>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cluster cluster = metadata.fetch();</span><br><span class="line"><span class="comment">// get the list of partitions with data ready to send</span></span><br><span class="line">RecordAccumulator.ReadyCheckResult result = <span class="keyword">this</span>.accumulator.ready(cluster, now);</span><br></pre></td></tr></table></figure>
<p>Step1：首先根据当前时间，根据缓存队列中的数据判断哪些 topic 的 哪些分区已经达到发送条件。达到可发送的条件将在 2.1.1.1 节详细分析。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!result.unknownLeaderTopics.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (String topic : result.unknownLeaderTopics)</span><br><span class="line">        <span class="keyword">this</span>.metadata.add(topic);</span><br><span class="line">    </span><br><span class="line">    log.debug(<span class="string">&quot;Requesting metadata update due to unknown leader topics from the batched records: &#123;&#125;&quot;</span>,</span><br><span class="line">                result.unknownLeaderTopics);</span><br><span class="line">    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果在待发送的消息未找到其路由信息，则需要首先去 broker 服务器拉取对应的路由信息(分区的 leader 节点信息)。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> notReadyTimeout = Long.MAX_VALUE;</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">    Node node = iter.next();</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.client.ready(node, now)) &#123;</span><br><span class="line">        iter.remove();</span><br><span class="line">        notReadyTimeout = Math.min(notReadyTimeout, <span class="keyword">this</span>.client.pollDelayMs(node, now));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：移除在网络层面没有准备好的分区，并且计算在接下来多久的时间间隔内，该分区都将处于未准备状态。<br>1、在网络环节没有准备好的标准如下：</p>
<ul>
<li>分区没有未完成的更新元素数据请求(metadata)。</li>
<li>当前生产者与对端 broker 已建立连接并完成了 TCP 的三次握手。</li>
<li>如果启用 SSL、ACL 等机制，相关状态都已就绪。</li>
<li>该分区对应的连接正在处理中的请求数时是否超过设定值，默认为 5，可通过属性 max.in.flight.requests.per.connection 来设置。</li>
</ul>
<p>2、client pollDelayMs 预估分区在接下来多久的时间间隔内都将处于未转变好状态(not ready)，其标准如下：</p>
<ul>
<li>如果已与对端的 TCP 连接已创建好，并处于已连接状态，此时如果没有触发限流，则返回0，如果有触发限流，则返回限流等待时间。</li>
<li>如果还位于对端建立 TCP 连接，则返回 Long.MAX_VALUE，因为连接建立好后，会唤醒发送线程的。</li>
</ul>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// create produce requests</span></span><br><span class="line">Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">this</span>.accumulator.drain(cluster, result.readyNodes, <span class="keyword">this</span>.maxRequestSize, now);</span><br></pre></td></tr></table></figure>
<p>Step4：根据已准备的分区，从缓存区中抽取待发送的消息批次(ProducerBatch)，并且按照 nodeId:List<ProducerBatch> 组织，注意，抽取后的 ProducerBatch 将不能再追加消息了，就算还有剩余空间可用，具体抽取将在下文在详细介绍。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">addToInflightBatches(batches);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToInflightBatches</span><span class="params">(Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;ProducerBatch&gt; batchList : batches.values()) &#123;</span><br><span class="line">        addToInflightBatches(batchList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToInflightBatches</span><span class="params">(List&lt;ProducerBatch&gt; batches)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ProducerBatch batch : batches) &#123;</span><br><span class="line">        List&lt;ProducerBatch&gt; inflightBatchList = inFlightBatches.get(batch.topicPartition);</span><br><span class="line">        <span class="keyword">if</span> (inflightBatchList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            inflightBatchList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            inFlightBatches.put(batch.topicPartition, inflightBatchList);</span><br><span class="line">        &#125;</span><br><span class="line">        inflightBatchList.add(batch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5：将抽取的 ProducerBatch 加入到 inFlightBatches 数据结构，该属性的声明如下：Map&lt;TopicPartition, List&lt; ProducerBatch &gt;&gt; inFlightBatches，即按照 topic-分区 为键，存放已抽取的 ProducerBatch，这个属性的含义就是存储待发送的消息批次。可以根据该数据结构得知在消息发送时以分区为维度反馈 Sender 线程的“积压情况”，max.in.flight.requests.per.connection 就是来控制积压的最大数量，如果积压达到这个数值，针对该队列的消息发送会限流。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">accumulator.resetNextBatchExpiryTime();</span><br><span class="line">List&lt;ProducerBatch&gt; expiredInflightBatches = getExpiredInflightBatches(now);</span><br><span class="line">List&lt;ProducerBatch&gt; expiredBatches = <span class="keyword">this</span>.accumulator.expiredBatches(now);</span><br><span class="line">expiredBatches.addAll(expiredInflightBatches);</span><br></pre></td></tr></table></figure>
<p>Step6：从 inflightBatches 与 batches 中查找已过期的消息批次(ProducerBatch)，判断是否过期的标准是系统当前时间与 ProducerBatch 创建时间之差是否超过120s，过期时间可以通过参数 delivery.timeout.ms 设置。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!expiredBatches.isEmpty())</span><br><span class="line">    log.trace(<span class="string">&quot;Expired &#123;&#125; batches in accumulator&quot;</span>, expiredBatches.size());</span><br><span class="line"><span class="keyword">for</span> (ProducerBatch expiredBatch : expiredBatches) &#123;</span><br><span class="line">    String errorMessage = <span class="string">&quot;Expiring &quot;</span> + expiredBatch.recordCount + <span class="string">&quot; record(s) for &quot;</span> + expiredBatch.topicPartition</span><br><span class="line">                + <span class="string">&quot;:&quot;</span> + (now - expiredBatch.createdMs) + <span class="string">&quot; ms has passed since batch creation&quot;</span>;</span><br><span class="line">    failBatch(expiredBatch, -<span class="number">1</span>, NO_TIMESTAMP, <span class="keyword">new</span> TimeoutException(errorMessage), <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; expiredBatch.inRetry()) &#123;</span><br><span class="line">        <span class="comment">// This ensures that no new batches are drained until the current in flight batches are fully resolved.</span></span><br><span class="line">        transactionManager.markSequenceUnresolved(expiredBatch.topicPartition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step7：处理已超时的消息批次，通知该批消息发送失败，即通过设置  KafkaProducer#send 方法返回的凭证中的 FutureRecordMetadata 中的 ProduceRequestResult result，使之调用其 get 方法不会阻塞。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sensors.updateProduceRequestMetrics(batches);</span><br></pre></td></tr></table></figure>
<p>Step8：收集统计指标，本文不打算详细分析，但后续会专门对 Kafka 的 Metrics 设计进行一个深入的探讨与学习。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> pollTimeout = Math.min(result.nextReadyCheckDelayMs, notReadyTimeout);</span><br><span class="line">pollTimeout = Math.min(pollTimeout, <span class="keyword">this</span>.accumulator.nextExpiryTimeMs() - now);</span><br><span class="line">pollTimeout = Math.max(pollTimeout, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!result.readyNodes.isEmpty()) &#123;</span><br><span class="line">    log.trace(<span class="string">&quot;Nodes with data ready to send: &#123;&#125;&quot;</span>, result.readyNodes);</span><br><span class="line">    pollTimeout = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step9：设置下一次的发送延时，待补充详细分析。</p>
<p>Sender#sendProducerData</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sendProduceRequests(batches, now);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendProduceRequests</span><span class="params">(Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; collated, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, List&lt;ProducerBatch&gt;&gt; entry : collated.entrySet())</span><br><span class="line">        sendProduceRequest(now, entry.getKey(), acks, requestTimeoutMs, entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step10：该步骤按照 brokerId 分别构建发送请求，即每一个 broker 会将多个  ProducerBatch 一起封装成一个请求进行发送，同一时间，每一个 与 broker 连接只会只能发送一个请求，注意，这里只是构建请求，并最终会通过 NetworkClient#send 方法，将该批数据设置到 NetworkClient 的待发送数据中，此时并没有触发真正的网络调用。</p>
<p>sendProducerData 方法就介绍到这里了，既然这里还没有进行真正的网络请求，那在什么时候触发呢？</p>
<p>我们继续回到 runOnce 方法。</p>
<h6 id="1-2-1-2-NetworkClient-的-poll-方法"><a href="#1-2-1-2-NetworkClient-的-poll-方法" class="headerlink" title="1.2.1.2 NetworkClient 的 poll 方法"></a>1.2.1.2 NetworkClient 的 poll 方法</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> List&lt;ClientResponse&gt; <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    ensureActive();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!abortedSends.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// If there are aborted sends because of unsupported version exceptions or disconnects,</span></span><br><span class="line">        <span class="comment">// handle them immediately without waiting for Selector#poll.</span></span><br><span class="line">        List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        handleAbortedSends(responses);</span><br><span class="line">        completeResponses(responses);</span><br><span class="line">        <span class="keyword">return</span> responses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> metadataTimeout = metadataUpdater.maybeUpdate(now);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.selector.poll(Utils.min(timeout, metadataTimeout, defaultRequestTimeoutMs));    <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Unexpected error during I/O&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process completed actions</span></span><br><span class="line">    <span class="keyword">long</span> updatedNow = <span class="keyword">this</span>.time.milliseconds();</span><br><span class="line">    List&lt;ClientResponse&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();            <span class="comment">// @3</span></span><br><span class="line">    handleCompletedSends(responses, updatedNow);</span><br><span class="line">    handleCompletedReceives(responses, updatedNow);</span><br><span class="line">    handleDisconnections(responses, updatedNow);</span><br><span class="line">    handleConnections();</span><br><span class="line">    handleInitiateApiVersionRequests(updatedNow);</span><br><span class="line">    handleTimedOutRequests(responses, updatedNow);</span><br><span class="line">    completeResponses(responses);                                               <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本文并不会详细深入探讨其网络实现部分，Kafka 的 网络通讯后续我会专门详细的介绍，在这里先点出其关键点。<br>代码@1：尝试更新云数据。<br>代码@2：触发真正的网络通讯，该方法中会通过收到调用 NIO 中的 Selector#select() 方法，对通道的读写就绪事件进行处理，当写事件就绪后，就会将通道中的消息发送到远端的 broker。<br>代码@3：然后会消息发送，消息接收、断开连接、API版本，超时等结果进行收集。<br>代码@4：并依次对结果进行唤醒，此时会将响应结果设置到  KafkaProducer#send 方法返回的凭证中，从而唤醒发送客户端，完成一次完整的消息发送流程。</p>
<p>Sender 发送线程的流程就介绍到这里了，接下来首先给出一张流程图，然后对上述流程中一些关键的方法再补充深入探讨一下。</p>
<h5 id="1-2-2-run-方法流程图"><a href="#1-2-2-run-方法流程图" class="headerlink" title="1.2.2 run 方法流程图"></a>1.2.2 run 方法流程图</h5><p><img src="https://img-blog.csdnimg.cn/20191117182748452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据上面的源码分析得出上述流程图，图中对重点步骤也详细标注了其关键点。下面我们对上述流程图中 Sender 线程依赖的相关类的核心方法进行解读，以便加深 Sender 线程的理解。</p>
<p>由于在讲解 Sender 发送流程中，大部分都是调用 RecordAccumulator 方法来实现其特定逻辑，故接下来重点对上述涉及到RecordAccumulator 的方法进行一个详细剖析，加强对 Sender 流程的理解。</p>
<h2 id="2、RecordAccumulator-核心方法详解"><a href="#2、RecordAccumulator-核心方法详解" class="headerlink" title="2、RecordAccumulator 核心方法详解"></a>2、RecordAccumulator 核心方法详解</h2><h4 id="2-1-RecordAccumulator-的-ready-方法详解"><a href="#2-1-RecordAccumulator-的-ready-方法详解" class="headerlink" title="2.1 RecordAccumulator 的 ready 方法详解"></a>2.1 RecordAccumulator 的 ready 方法详解</h4><p>该方法主要就是根据缓存区中的消息，判断哪些分区已经达到发送条件。</p>
<p>RecordAccumulator#ready</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReadyCheckResult <span class="title">ready</span><span class="params">(Cluster cluster, <span class="keyword">long</span> nowMs)</span> </span>&#123;</span><br><span class="line">    Set&lt;Node&gt; readyNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">long</span> nextReadyCheckDelayMs = Long.MAX_VALUE;</span><br><span class="line">    Set&lt;String&gt; unknownLeaderTopics = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> exhausted = <span class="keyword">this</span>.free.queued() &gt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, Deque&lt;ProducerBatch&gt;&gt; entry : <span class="keyword">this</span>.batches.entrySet()) &#123;   <span class="comment">// @1</span></span><br><span class="line">        TopicPartition part = entry.getKey();</span><br><span class="line">        Deque&lt;ProducerBatch&gt; deque = entry.getValue();</span><br><span class="line"></span><br><span class="line">        Node leader = cluster.leaderFor(part);   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">            <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; !deque.isEmpty()) &#123;   <span class="comment">// @3</span></span><br><span class="line">                <span class="comment">// This is a partition for which leader is not known, but messages are available to send.</span></span><br><span class="line">                <span class="comment">// Note that entries are currently not removed from batches when deque is empty.</span></span><br><span class="line">                unknownLeaderTopics.add(part.topic());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!readyNodes.contains(leader) &amp;&amp; !isMuted(part, nowMs)) &#123;    <span class="comment">// @4</span></span><br><span class="line">                ProducerBatch batch = deque.peekFirst();</span><br><span class="line">                <span class="keyword">if</span> (batch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> waitedTimeMs = batch.waitedTimeMs(nowMs);</span><br><span class="line">                    <span class="keyword">boolean</span> backingOff = batch.attempts() &gt; <span class="number">0</span> &amp;&amp; waitedTimeMs &lt; retryBackoffMs;</span><br><span class="line">                    <span class="keyword">long</span> timeToWaitMs = backingOff ? retryBackoffMs : lingerMs;</span><br><span class="line">                    <span class="keyword">boolean</span> full = deque.size() &gt; <span class="number">1</span> || batch.isFull();</span><br><span class="line">                    <span class="keyword">boolean</span> expired = waitedTimeMs &gt;= timeToWaitMs;</span><br><span class="line">                    <span class="keyword">boolean</span> sendable = full || expired || exhausted || closed || flushInProgress();</span><br><span class="line">                    <span class="keyword">if</span> (sendable &amp;&amp; !backingOff) &#123;   <span class="comment">// @5</span></span><br><span class="line">                        readyNodes.add(leader);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">long</span> timeLeftMs = Math.max(timeToWaitMs - waitedTimeMs, <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// Note that this results in a conservative estimate since an un-sendable partition may have</span></span><br><span class="line">                        <span class="comment">// a leader that will later be found to have sendable data. However, this is good enough</span></span><br><span class="line">                        <span class="comment">// since we&#x27;ll just wake up and then sleep again for the remaining time.</span></span><br><span class="line">                        nextReadyCheckDelayMs = Math.min(timeLeftMs, nextReadyCheckDelayMs);   </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadyCheckResult(readyNodes, nextReadyCheckDelayMs, unknownLeaderTopics);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：对生产者缓存区 ConcurrentHashMap&lt;TopicPartition, Deque&lt; ProducerBatch&gt;&gt; batches 遍历，从中挑选已准备好的消息批次。<br>代码@2：从生产者元数据缓存中尝试查找分区(TopicPartition) 的 leader 信息，如果不存在，当将该 topic 添加到 unknownLeaderTopics (代码@3)，稍后会发送元数据更新请求去 broker 端查找分区的路由信息。<br>代码@4：如果不在 readyNodes 中就需要判断是否满足条件，isMuted 与顺序消息有关，本文暂时不关注，在后面的顺序消息部分会重点探讨。<br>代码@5：这里就是判断是否准备好的条件，先一个一个来解读局部变量的含义。</p>
<ul>
<li>long waitedTimeMs<br>该 ProducerBatch 已等待的时长，等于当前时间戳 与 ProducerBatch 的 lastAttemptMs 之差，在 ProducerBatch 创建时或需要重试时会将当前的时间赋值给lastAttemptMs。</li>
<li>retryBackoffMs<br>当发生异常时发起重试之前的等待时间，默认为 100ms，可通过属性 retry.backoff.ms 配置。</li>
<li>batch.attempts()<br>该批次当前已重试的次数。</li>
<li>backingOff<br>后台发送是否关闭，即如果需要重试并且等待时间小于 retryBackoffMs ，则 backingOff = true，也意味着该批次未准备好。</li>
<li>timeToWaitMs<br>send 线程发送消息需要的等待时间，如果 backingOff  为 true，表示该批次是在重试，并且等待时间小于系统设置的需要等待时间，这种情况下 timeToWaitMs = retryBackoffMs 。否则需要等待的时间为 lingerMs。</li>
<li>boolean full<br>该批次是否已满，如果两个条件中的任意一个满足即为 true。<ul>
<li>Deque&lt; ProducerBatch&gt; 该队列的个数大于1，表示肯定有一个 ProducerBatch 已写满。 </li>
<li>ProducerBatch 已写满。</li>
</ul>
</li>
<li>boolean expired<br>是否过期，等于已经等待的时间是否大于需要等待的时间，如果把发送看成定时发送的话，expired 为 true 表示定时器已到达触发点，即需要执行。</li>
<li>boolean exhausted<br>当前生产者缓存已不够，创建新的 ProducerBatch 时阻塞在申请缓存空间的线程大于0，此时应立即将缓存区中的消息立即发送到服务器。</li>
<li>boolean sendable<br>是否可发送。其满足下面的任意一个条件即可：<ul>
<li>   该批次已写满。(full = true)。</li>
<li>   已等待系统规定的时长。（expired = true）</li>
<li>   发送者内部缓存区已耗尽并且有新的线程需要申请(exhausted = true)。</li>
<li>   该发送者的 close 方法被调用(close = true)。</li>
<li>   该发送者的 flush 方法被调用。</li>
</ul>
</li>
</ul>
<h4 id="2-2-RecordAccumulator-的-drain方法详解"><a href="#2-2-RecordAccumulator-的-drain方法详解" class="headerlink" title="2.2 RecordAccumulator 的 drain方法详解"></a>2.2 RecordAccumulator 的 drain方法详解</h4><p>RecordAccumulator#drain</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; drain(Cluster cluster, Set&lt;Node&gt; nodes, <span class="keyword">int</span> maxSize, <span class="keyword">long</span> now) &#123; <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (nodes.isEmpty())</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    Map&lt;Integer, List&lt;ProducerBatch&gt;&gt; batches = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Node node : nodes) &#123;                                                                                                                              </span><br><span class="line">        List&lt;ProducerBatch&gt; ready = drainBatchesForOneNode(cluster, node, maxSize, now);                      <span class="comment">// @2</span></span><br><span class="line">        batches.put(node.id(), ready);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> batches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：我们首先来介绍该方法的参数：</p>
<ul>
<li>Cluster cluster<br>集群信息。</li>
<li>Set&lt; Node&gt; nodes<br>已准备好的节点集合。</li>
<li>int maxSize<br>一次请求最大的字节数。</li>
<li>long now<br>当前时间。</li>
</ul>
<p>代码@2：遍历所有节点，调用 drainBatchesForOneNode 方法抽取数据，组装成 Map&lt;Integer /** brokerId */, List&lt; ProducerBatch&gt;&gt; batches。</p>
<p>接下来重点来看一下 drainBatchesForOneNode。<br>RecordAccumulator#drainBatchesForOneNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ProducerBatch&gt; <span class="title">drainBatchesForOneNode</span><span class="params">(Cluster cluster, Node node, <span class="keyword">int</span> maxSize, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    List&lt;PartitionInfo&gt; parts = cluster.partitionsForNode(node.id());   <span class="comment">// @1</span></span><br><span class="line">    List&lt;ProducerBatch&gt; ready = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> start = drainIndex = drainIndex % parts.size();                        <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">do</span> &#123;                                                                                                <span class="comment">// @3 </span></span><br><span class="line">        PartitionInfo part = parts.get(drainIndex);</span><br><span class="line">        TopicPartition tp = <span class="keyword">new</span> TopicPartition(part.topic(), part.partition()); </span><br><span class="line">        <span class="keyword">this</span>.drainIndex = (<span class="keyword">this</span>.drainIndex + <span class="number">1</span>) % parts.size();                     </span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (isMuted(tp, now))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        Deque&lt;ProducerBatch&gt; deque = getDeque(tp);                              <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (deque == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (deque) &#123;</span><br><span class="line">            <span class="comment">// invariant: !isMuted(tp,now) &amp;&amp; deque != null</span></span><br><span class="line">            ProducerBatch first = deque.peekFirst();                                         <span class="comment">// @5</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// first != null</span></span><br><span class="line">            <span class="keyword">boolean</span> backoff = first.attempts() &gt; <span class="number">0</span> &amp;&amp; first.waitedTimeMs(now) &lt; retryBackoffMs;   <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">// Only drain the batch if it is not during backoff period.</span></span><br><span class="line">            <span class="keyword">if</span> (backoff)                                                                                     </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (size + first.estimatedSizeInBytes() &gt; maxSize &amp;&amp; !ready.isEmpty()) &#123;     <span class="comment">// @7</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (shouldStopDrainBatchesForPartition(first, tp))                                  </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里省略与事务消息相关的代码，后续会重点学习。</span></span><br><span class="line">                batch.close();                                                                                            <span class="comment">// @8</span></span><br><span class="line">                size += batch.records().sizeInBytes();</span><br><span class="line">                ready.add(batch);                                                                            </span><br><span class="line"></span><br><span class="line">                batch.drained(now);                                                                             </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != drainIndex);</span><br><span class="line">    <span class="keyword">return</span> ready;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据 brokerId 获取该 broker 上的所有主分区。<br>代码@2：初始化 start。这里首先来阐述一下 start 与 drainIndex 。</p>
<ul>
<li>start 当前开始遍历的分区序号。</li>
<li>drainIndex 上次抽取的队列索引后，这里主要是为了每个队列都是从零号分区开始抽取。</li>
</ul>
<p>代码@3：循环从缓存区抽取对应分区中累积的数据。<br>代码@4：根据 topic + 分区号从生产者发送缓存区中获取已累积的双端Queue。<br>代码@5：从双端队列的头部获取一个元素。（消息追加时是追加到队列尾部）。<br>代码@6：如果当前批次是重试，并且还未到阻塞时间，则跳过该分区。<br>代码@7：如果当前已抽取的消息总大小 加上新的消息已超过 maxRequestSize，则结束抽取。<br>代码@8：将当前批次加入到已准备集合中，并关闭该批次，即不在允许向该批次中追加消息。</p>
<p>关于消息发送就介绍到这里，NetworkClient 的 poll 方法内部会调用 Selector 执行就绪事件的选择，并将抽取的消息通过网络发送到 Broker 服务器，关于网络后面的具体实现，将在后续文章中单独介绍。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>kafka</tag>
        <tag>Sender</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda表达式语法与函数式编程接口</title>
    <url>/posts/26a08b7d.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、lambda语法初探"><a href="#1、lambda语法初探" class="headerlink" title="1、lambda语法初探"></a>1、lambda语法初探</h2><p>java8 lambda表达式语法的两种格式：</p>
<ul>
<li>(parameters)  -&gt;  expression</li>
<li>(parameters) -&gt; {statements;}</li>
</ul>
<p>语法解读：</p>
<ol>
<li>(parameters)，lambda表达式的参数列表，其定义方法为JAVA普通的方法相同，例如(Object a, Object b)。</li>
<li>-&gt; 箭头，是参数列表与lambda表达式主题部分的分隔符号。</li>
<li>expression 单表达式</li>
<li>{statements; } 语句。</li>
</ol>
<p>测试：如下语句是否是正确的lambda表达式。<br>(1)  () -&gt; {}<br>(2)  () -&gt; “Raoul”<br>(3)  () -&gt; {return “Mario”;}<br>(4)  (Integer i) -&gt; return “Alan” + i;<br>(5)  (String s) -&gt; {“IronMan”;}</p>
<p>正解：<br>(1) 正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public void test() &#123;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(2)正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test() &#123;</span><br><span class="line">           return &quot;Raoul&quot;;  &#x2F;&#x2F; 如果直接接一个值，表示返回该值</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(3)正确。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test() &#123;</span><br><span class="line">          return &quot;Mario&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(4)错误。因为return是流程控制语句，表示返回，不是一个表达式，故不符合lambda语法，正确的表示方法应该是 (Integer i) -&gt;{ return “Alan” + i;}。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test(Integer i) &#123;</span><br><span class="line">          return &quot;Alan&quot; + i;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>(5)错误。因为”IronMan”是一个表达式，并不是一个语句，故不能使用{}修饰，应修改为 (String s) -&gt; “IronMan”。如果使用匿名类(接口名统一使用IDemoLambda)表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> new IDemoLambda() &#123;</span><br><span class="line">     public String test(String s) &#123;</span><br><span class="line">          return &quot;IronMan&quot;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、初步接触函数式接口"><a href="#2、初步接触函数式接口" class="headerlink" title="2、初步接触函数式接口"></a>2、初步接触函数式接口</h2><p>在java8中，一个接口如果只定义了一个抽象方法，那这个接口就可以称为函数式接口，就可以使用lambda表达式来简化程序代码。Lambda表达式可以直接赋值给变量，也可以直接作为参数传递给函数，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void startThread(Runnable a) &#123;</span><br><span class="line">    (new Thread(a)).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; lambda表达式可以直接赋值给变量，也可以直接以参数的形式传递给方法、</span><br><span class="line">    Runnable a &#x3D; () -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Hello World,Lambda...&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    &#x2F;&#x2F; JDK8之前使用匿名类来实现</span><br><span class="line">    Runnable b &#x3D; new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(&quot;Hello World,Lambda...&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    startThread(a);</span><br><span class="line">    startThread(() -&gt; &#123;</span><br><span class="line">        System.out.println(&quot;Hello World,Lambda...&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那能将(int a) -&gt; {System.out.println(“Hello World, Lambda…”);}表达式赋值给Runnable a变量吗？答案是不能，因为该表达式不符合函数式编程接口(Runnable)唯一抽象方法的函数签名列表。<br>Runnable的函数式签名列表为public abstract void run();</p>
<blockquote>
<p>温馨提示：如果我们有留意JDK8的Runnable接口的定义，你会发现给接口相对JDK8之前的版本多了一个注解：@FunctionalInterface，该注解是一个标识注解，用来标识这个接口是一个函数式接口。如果我们人为在一个不满足函数式定义的接口上增加@FunctionalInterface，则会在编译时提示错误。</p>
</blockquote>
<a id="more"></a>

<h2 id="3、-Lambda表达式实战思考"><a href="#3、-Lambda表达式实战思考" class="headerlink" title="3、 Lambda表达式实战思考"></a>3、 Lambda表达式实战思考</h2><p>例如有如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 处理文件：当前需求是处理文件的第一行数据</span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String processFile() throws IOException &#123;</span><br><span class="line">    try(BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123;</span><br><span class="line">        return  br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前需求为处理文件的第一行数据，那问题来了，如果需求变化需要返回文件的第一行和第二行数据，那该如何进行改造呢？<br>在理想的情况下，需要重用执行设置和关闭流的代码，并告诉processFile()方法对文件执行不同的操作，换句话说就是要实现对processFile的行为进行参数化。</p>
<p>Step·1：行为参数化<br>要读取文件的头两行，用Lambda语法如何实现呢？思考一下，下面这条语句是否可以实现？</p>
<p>(BufferedReader bf) -&gt; br.readLine() + br.readLine()<br>答案是当然可以，接下来就要思考，定义一个什么样的方法，能接收上面这个参数。</p>
<p>Step2：使用函数式接口来传递行为<br>要使用(bufferedReader bf) -&gt; br.readLine() + br.readLine()，则需要定义一个接受参数为BufferedReader，并返回String类型的函数式接口。<br>定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface BufferedReaderProcessor &#123;</span><br><span class="line">     public String process(BufferedReader b) throws IoException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那把processFile方法改造成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 处理文件：当前需求是处理文件的第一行数据</span><br><span class="line"> * @return</span><br><span class="line"> * @throws IOException</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static String processFile(BufferedReaderProcess brp) throws IOException &#123;</span><br><span class="line">    try(BufferedReader br &#x3D; new BufferedReader(new FileReader(&quot;data.txt&quot;))) &#123;</span><br><span class="line">        return  brp.process(br);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：使用lambda表达式作为参数进行传递<br>将行为参数化后，并对方法进行改造，使方法接受一个函数式编程接口后，就可以将Lambda表达式直接传递给方法，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">processFile(  (BufferedReader br)  -&gt; br.readLine()  );</span><br><span class="line">processFile( (BufferedReader bf) -&gt; br.readLine() + br.readLine()); </span><br></pre></td></tr></table></figure>

<h2 id="4、Java8中自定义函数式接口"><a href="#4、Java8中自定义函数式接口" class="headerlink" title="4、Java8中自定义函数式接口"></a>4、Java8中自定义函数式接口</h2><p>从上面的讲解中我们已然能够得知，要能够将Lambda表达式当成方法参数进行参数行为化的一个前提条件是首先要在方法列表中使用一个函数式接口，例如上例中的BufferReaderProcess，那如果每次使用Labmbda表达式之前都要定义各自的函数式编程接口，那也够麻烦的，那有没有一种方式，或定义一种通用的函数式编程接口呢？答案是肯定的，Java8的设计者，利用泛型，定义了一整套函数式编程接口，下面将介绍java8中常用的函数式编程接口。</p>
<h4 id="4-1-Predicate"><a href="#4-1-Predicate" class="headerlink" title="4.1 Predicate"></a>4.1 Predicate</h4><p><img src="https://img-blog.csdnimg.cn/20190512222228610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>所谓函数式编程接口就是只能定义一个抽象方法，Predicate 函数接口中定义的抽象方法为 boolean test(T t)，对应的函数式行为为接收一类对象 t，返回 boolean 类型，其可用的 lambda 表达式为 (T t) -&gt; boolean 类型的表达式，例如(Sample a) -&gt; a.isEmpty() 。</p>
<p>该接口通常的应用场景为过滤。例如，要定义一个方法，从集合中进行刷选，具体的刷选逻辑（行为）由参数进行指定，那我们可以定义这样一个刷选的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</span><br><span class="line">List&lt;T&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for(T s: list)&#123;</span><br><span class="line">if(p.test(s))&#123;</span><br><span class="line">results.add(s);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述函数，我们可以这样进行调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Predicate&lt;String&gt; behaviorFilter &#x3D; (String s) -&gt; !s.isEmpty();  &#x2F;&#x2F; lambda表达式赋值给一个变量</span><br><span class="line">filter(behaviorFilter);  </span><br></pre></td></tr></table></figure>
<p>其它add等方法，将在下文介绍（复合lambda表达式）。</p>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntPredicate、LongPredicate、DoublePredicate。我们选择LongPredicate看一下其函数接口的声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean test(long value);</span><br></pre></td></tr></table></figure>

<h4 id="4-2-Consumer"><a href="#4-2-Consumer" class="headerlink" title="4.2 Consumer"></a>4.2 Consumer</h4><p><img src="https://img-blog.csdnimg.cn/20190512222420653.png" alt="在这里插入图片描述"><br>该函数式编程接口适合对对象进行处理，但没有返回值,对应的函数描述符：T -&gt; void</p>
<p>举例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; void forEach(List&lt;T&gt; list, Consumer&lt;T&gt; c) &#123;</span><br><span class="line">    for(T t : list) &#123;</span><br><span class="line">        c.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其调用示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">forEach(  Arrays.asList(1,2,3,4,5),   (Integer i) -&gt; System.out.println(i) ); </span><br></pre></td></tr></table></figure>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntConsumer、LongConsumer、DoubleConsumer。</p>
<h4 id="4-3-Function-lt-T-R-gt"><a href="#4-3-Function-lt-T-R-gt" class="headerlink" title="4.3 Function&lt;T,R&gt;"></a>4.3 Function&lt;T,R&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222646904.png" alt="在这里插入图片描述"><br>其适合的场景是，接收一个泛型T的对象，返回一个泛型为R的对象，其对应的函数描述符:  T -&gt; R。</p>
<p>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T,R&gt; List&lt;R&gt; map(List&lt;T&gt; list, Function&lt;T,R&gt; f) &#123;</span><br><span class="line">          List&lt;R&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">          for(T t : list) &#123;</span><br><span class="line">                result.add(  f.apply(t) );</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; l &#x3D; map(Arrays.asList(&quot;lambdas&quot;, &quot;in&quot;, &quot;action&quot;),  (String s)  -&gt; s.length  );</span><br></pre></td></tr></table></figure>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntFunction&lt; R&gt;、LongFunction&lt; R&gt;、DoubleFunction&lt; R&gt;、IntToDoubleFunction、IntToLongFunction、LongToIntFunction、LongToDoubleFunction、ToIntFunction&lt; T&gt;、ToDoubleFunction&lt; T&gt;、ToLongFunction&lt; T&gt;。</p>
<h4 id="4-4-Supplier-lt-T-gt"><a href="#4-4-Supplier-lt-T-gt" class="headerlink" title="4.4 Supplier&lt; T&gt;"></a>4.4 Supplier&lt; T&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222740390.png" alt="在这里插入图片描述"><br>函数描述符：() -&gt; T。适合创建对象的场景，例如  () -&gt; new Object();</p>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：BooleanSupplier、IntSupplier、LongSupplier、DoubleSupplier。</p>
<h4 id="4-5-UnaryOperator-lt-T-gt"><a href="#4-5-UnaryOperator-lt-T-gt" class="headerlink" title="4.5 UnaryOperator&lt; T &gt;"></a>4.5 UnaryOperator&lt; T &gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222814465.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>一元运算符函数式接口，接收一个泛型T的对象，同样返回一个泛型T的对象。<br>示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; map(List&lt;T&gt; list, UnaryOperator&lt;T&gt; f) &#123;</span><br><span class="line">          List&lt;R&gt; result &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">          for(T t : list) &#123;</span><br><span class="line">                result.add(  f.apply(t) );</span><br><span class="line">          &#125;</span><br><span class="line">          return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">map(  list, (int i) -&gt; i ++ );</span><br></pre></td></tr></table></figure>

<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntUnaryOperator、LongUnaryOperator、DoubleUnaryOperator。</p>
<h4 id="4-6-BiPredicate-lt-T-U-gt"><a href="#4-6-BiPredicate-lt-T-U-gt" class="headerlink" title="4.6 BiPredicate&lt;T,U&gt;"></a>4.6 BiPredicate&lt;T,U&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222852671.png" alt="在这里插入图片描述"><br>接收两个参数，返回boolean类型。其对应的函数描述符：(T,U) -&gt; boolean。</p>
<h4 id="4-7-BiConsumer-lt-T-U-gt"><a href="#4-7-BiConsumer-lt-T-U-gt" class="headerlink" title="4.7 BiConsumer&lt;T,U&gt;"></a>4.7 BiConsumer&lt;T,U&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222914785.png" alt="在这里插入图片描述"><br>与Consume函数式接口类似，只是该接口接收两个参数，对应的函数描述符(T,U)  -&gt; void。</p>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：ObjIntConsumer、ObjLongConsumer、ObjDoubleConsumer。</p>
<h4 id="4-8-BiFunction-lt-T-U-R-gt"><a href="#4-8-BiFunction-lt-T-U-R-gt" class="headerlink" title="4.8 BiFunction&lt;T,U,R&gt;"></a>4.8 BiFunction&lt;T,U,R&gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512222939113.png" alt="在这里插入图片描述"><br>与Function函数式接口类似，其对应的函数描述符：(T,U) -&gt; R。</p>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：ToIntBiFunction(T,U)、ToLongBiFunction(T,U)、ToDoubleBiFunction(T,U)。</p>
<h4 id="4-9-BinaryOperator-lt-T-gt"><a href="#4-9-BinaryOperator-lt-T-gt" class="headerlink" title="4.9 BinaryOperator&lt; T &gt;"></a>4.9 BinaryOperator&lt; T &gt;</h4><p><img src="https://img-blog.csdnimg.cn/20190512223009303.png" alt="在这里插入图片描述"><br>二维运算符，接收两个T类型的对象，返回一个T类型的对象。</p>
<p>另外，为了避免java基本类型与包装类型的装箱与拆箱带来的性能损耗，JDK8的设计者们提供了如下函数式编程接口：IntBinaryOperator、LongBinaryOperator、DoubleBinaryOperator。</p>
<p>上述就是JDK8定义在java.util.function中的函数式编程接口。重点关注的是其定义的函数式编程接口，其复合操作相关的API将在下文中详细介绍。</p>
<h2 id="5、类型检查、类型推断以及限制"><a href="#5、类型检查、类型推断以及限制" class="headerlink" title="5、类型检查、类型推断以及限制"></a>5、类型检查、类型推断以及限制</h2><h4 id="5-1-类型检查"><a href="#5-1-类型检查" class="headerlink" title="5.1 类型检查"></a>5.1 类型检查</h4><p>java8是如何检查传入的Lambda表示式是否符合约定的类型呢？<br>例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; list, Predicate&lt;T&gt; p) &#123;</span><br><span class="line">    List&lt;T&gt; results &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    for(T s: list)&#123;</span><br><span class="line">        if(p.test(s))&#123;</span><br><span class="line">            results.add(s);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return results;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Apple&gt; heavierThan150g &#x3D; filter(inventory, (Apple a) -&gt; a.getWeight() &gt; 150);</span><br></pre></td></tr></table></figure>
<p>其类型检测的步骤：<br>1）首先查看filter函数的参数列表，得出Lambda对应的参数类型为Predicate&lt; T &gt;。<br>2）函数式接口Predicate中定义的抽象接口为  boolean test(T t),对应的函数描述符(  T  -&gt;  boolean)。<br>3）验证Lambda表达式是否符合函数描述符。</p>
<p>注意：如果一个Lambda的主体式一个语句表达式，它就和一个返回void的函数描述符兼容（当然参数列表也必须兼容）。例如，以下两行都是合法的，尽管List的add方法返回一个boolean，而不式Consumer上下文(T -&gt; void)所要求的void：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Predicate返回了一个boolean</span><br><span class="line">Predicate&lt;String&gt; p &#x3D; s -&gt; list.add(s);</span><br><span class="line">&#x2F;&#x2F; Consumer返回了一个void</span><br><span class="line">Consumer&lt;String&gt; b &#x3D; s -&gt; list.add(s);</span><br></pre></td></tr></table></figure>
<p>思考题：如下表达式是否正确？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object o &#x3D; () -&gt; &#123;System.out.println(&quot;Tricky example&quot;); &#125;;</span><br></pre></td></tr></table></figure>
<p>答案是错误的，该语句的含义就是把lambda表达式复制给目标对象(Object o)，lambda对应的函数描述符为() -&gt; void，期望目标对象拥有一个唯一的抽象方法，参数列表为空，返回值为void的方法，显然目标对象Object不满足该条件，如果换成如下示例，则能编译通过：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Runnable r &#x3D; () &#123;System.out.println(&quot;Tricky example&quot;); &#125;;</span><br></pre></td></tr></table></figure>
<p>因为Runnable的定义如下：<br><img src="https://img-blog.csdnimg.cn/20190512223153712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="5-2-类型推断"><a href="#5-2-类型推断" class="headerlink" title="5.2 类型推断"></a>5.2 类型推断</h4><p>所谓的类型推断，指的式java编译器能根据目标类型来推断出用什么函数式接口来配合Lambda表达式，这也意味着它也可以推断出适合Lambda的签名，因为函数描述符可以通过目标类型得到。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Apple&gt; greenApples &#x3D;  filter(inventory, （Apple a） -&gt; &quot;green&quot;.equals(a.getColor()));</span><br><span class="line">也可以写成</span><br><span class="line">List&lt;Apple&gt; greenApples &#x3D;  filter(inventory, a  -&gt; &quot;green&quot;.equals(a.getColor()));</span><br><span class="line"></span><br><span class="line">Lambda表达式有多个参数，代码可读性的好处就更为明显。例如，你可以这样来创建一个Comparator 对象：</span><br><span class="line">Comparator&lt;Apple&gt; c &#x3D;  (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br><span class="line">Comparator&lt;Apple&gt; c &#x3D; (a1, a2) -&gt; a1.getWeight().compareTo(a2.getWeight());</span><br></pre></td></tr></table></figure>
<p>由于java编译器能根据目标类型来推导出Lambda的函数签名，故lambda的函数签名列表时，可以去掉参数的类型。</p>
<h4 id="5-3-局部变量"><a href="#5-3-局部变量" class="headerlink" title="5.3 局部变量"></a>5.3 局部变量</h4><p>Lambda表达式主体部分也能引入外部的变量，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int portNumber &#x3D; 1337;</span><br><span class="line">Runnable r &#x3D; () -&gt; System.out.println(portNumber);</span><br></pre></td></tr></table></figure>
<p>其中portNumber参数并不是方法签名参数，但这样有一个限制条件，引入的局部变量必须是常量（实际意义上的常量，可以不用final来定义，但不能改变其值。例如如下示例是错误的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int portNumber &#x3D; 1337;</span><br><span class="line">Runnable r &#x3D; () -&gt; System.out.println(portNumber);</span><br><span class="line">portNumber &#x3D; 1228;  &#x2F;&#x2F; 因为portNumber的值已改变，不符合局部变量的捕获条件，上述代码无法编译通过。</span><br></pre></td></tr></table></figure>
<h4 id="5-4-方法引用"><a href="#5-4-方法引用" class="headerlink" title="5.4 方法引用"></a>5.4 方法引用</h4><h5 id="5-4-1-方法引用常用的构造方法"><a href="#5-4-1-方法引用常用的构造方法" class="headerlink" title="5.4.1 方法引用常用的构造方法"></a>5.4.1 方法引用常用的构造方法</h5><p>JDK8中有3中方法引用：</p>
<ol>
<li>指向静态方法的方法引用<br>Integer.parseInt  对应的方法引用可以写成： Integer::parseInt。</li>
<li>指向任意类型的实例方法的引用<br>  (Strng str ) -&gt; str.length  对应的方法引用：String::length。(注意这里的属性为方法列表)</li>
<li>lambda捕获外部的实例对象<br>例如如下代码：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Apple a &#x3D; new Apple();</span><br><span class="line">process(  () -&gt; a.getColor()  );  &#x2F;&#x2F; 则可以写成  process ( a::getColor ); </span><br></pre></td></tr></table></figure>
<h5 id="5-4-2-构造函数引用"><a href="#5-4-2-构造函数引用" class="headerlink" title="5.4.2 构造函数引用"></a>5.4.2 构造函数引用</h5><p>大家可以回想一下，jdk8中定义了一个创建对象的函数式编程接口Supplier,函数描述符：() -&gt; T。适合创建对象的场景，例如  () -&gt; new Object();<br>对于没有构造函数的，我们可以这样来创建对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Supplier&lt;Apple&gt; c1 &#x3D; Apple:new;</span><br><span class="line">Apple a1 &#x3D; c1.get();</span><br></pre></td></tr></table></figure>
<p>如果有1个参数的构造方法呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Function&lt;Integer, Apple&gt; c2 &#x3D; Apple::new;</span><br><span class="line">Apple a2 &#x3D; c2.apply(weight);</span><br></pre></td></tr></table></figure>
<p>Lambda语法的基础知识就介绍到这里，本文详细介绍了Lambda表达式的语法格式、函数式编程接口、lambda与函数式编程接口的关系、方法引用。</p>
<p>下一节主要介绍复合Lambda表达式使用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Lambda</tag>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis一二级缓存实现原理与使用指南</title>
    <url>/posts/36b32da.html</url>
    <content><![CDATA[<div id="vip-container"><p>Mybatis 与 Hibernate 一样，支持一二级缓存。一级缓存指的是 Session 级别的缓存，即在一个会话中多次执行同一条 SQL 语句并且参数相同，则后面的查询将不会发送到数据库，直接从 Session 缓存中获取。二级缓存，指的是 SessionFactory 级别的缓存，即不同的会话可以共享。</p>
<p>缓存，通常涉及到缓存的写、读、过期(更新缓存)等几个方面，请带着这些问题一起来探究Mybatis关于缓存的实现原理吧。</p>
<blockquote>
<p>提出问题：缓存的查询顺序，是先查一级缓存还是二级缓存？</p>
</blockquote>
<p>本文以SQL查询与更新两个流程来揭开Mybatis缓存实现的细节。</p>
<h2 id="1、从-SQL-查询流程看一二级缓存"><a href="#1、从-SQL-查询流程看一二级缓存" class="headerlink" title="1、从 SQL 查询流程看一二级缓存"></a>1、从 SQL 查询流程看一二级缓存</h2><blockquote>
<p>温馨提示，本文不会详细介绍详细的 SQL 执行流程，如果对其感兴趣，可以查阅笔者的另外一篇文章：<a href="https://blog.csdn.net/prestigeding/article/details/90647674">源码分析Mybatis SQL执行流程</a></p>
</blockquote>
<h3 id="1-1-创建Executor"><a href="#1-1-创建Executor" class="headerlink" title="1.1 创建Executor"></a>1.1 创建Executor</h3><p>Configuration#newExecutor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">	executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;                                                           <span class="comment">// @1</span></span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);                 <span class="comment">// @2</span></span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果 cacheEnabled 为 true，表示开启缓存机制，缓存的实现类为 CachingExecutor，这里使用了经典的装饰模式，处理了缓存的相关逻辑后，委托给的具体的 Executor 执行。</p>
<p>cacheEnable 在实际的使用中通过在 mybatis-config.xml 文件中指定，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>该值默认为true。</p>
<h3 id="1-2-CachingExecutor-query"><a href="#1-2-CachingExecutor-query" class="headerlink" title="1.2 CachingExecutor#query"></a>1.2 CachingExecutor#query</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    BoundSql boundSql = ms.getBoundSql(parameterObject);  <span class="comment">// @1</span></span><br><span class="line">    CacheKey key = createCacheKey(ms, parameterObject, rowBounds, boundSql);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">return</span> query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);       <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据参数生成SQL语句。</p>
<p>代码@2：根据 MappedStatement、参数、分页参数、SQL 生成缓存 Key。</p>
<p>代码@3：调用6个参数的 query 方法。</p>
<p>缓存 Key 的创建比较简单，本文就只贴出代码，大家一目了然,大家重点关注组成缓存Key的要素。<br>BaseExecute#createCacheKey</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CacheKey <span class="title">createCacheKey</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, BoundSql boundSql)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CacheKey cacheKey = <span class="keyword">new</span> CacheKey();</span><br><span class="line">  cacheKey.update(ms.getId());</span><br><span class="line">  cacheKey.update(rowBounds.getOffset());</span><br><span class="line">  cacheKey.update(rowBounds.getLimit());</span><br><span class="line">  cacheKey.update(boundSql.getSql());</span><br><span class="line">  List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">  TypeHandlerRegistry typeHandlerRegistry = ms.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">  <span class="comment">// mimic DefaultParameterHandler logic</span></span><br><span class="line">  <span class="keyword">for</span> (ParameterMapping parameterMapping : parameterMappings) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">      Object value;</span><br><span class="line">      String propertyName = parameterMapping.getProperty();</span><br><span class="line">      <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">        value = parameterObject;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">        value = metaObject.getValue(propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">      cacheKey.update(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (configuration.getEnvironment() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// issue #176</span></span><br><span class="line">    cacheKey.update(configuration.getEnvironment().getId());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cacheKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来重点看CachingExecutor的另外一个query方法。</p>
<p>CachingExecutor#query</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);        <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;                                                              <span class="comment">// @4</span></span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    <span class="comment">//@5</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116                                                               // @6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  <span class="comment">//@7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取 MappedStatement 中的 Cache cache 属性。<br>代码@2：如果不为空，则尝试从缓存中获取，否则直接委托给具体的执行器执行，例如 SimpleExecutor (@7)。<br>代码@3：尝试从缓存中根据缓存 Key 查找。<br>代码@4：如果从缓存中获取的值不为空，则直接返回缓存中的值，否则先从数据库查询@5，将查询结果更新到缓存中。</p>
<p>这里的缓存即 MappedStatement 中的 Cache 对象是一级缓存还是二级缓存？通常在 ORM 类框架中，Session 级别的缓存为一级缓存，即会话结束后就会失效，显然这里不会随着 Session 的失效而失效，因为 Cache 对象是存储在于 MappedStatement 对象中的，每一个 MappedStatement 对象代表一个 Dao(Mapper) 中的一个方法，即代表一条对应的 SQL 语句，是一个全局的概念。</p>
<p>相信大家也会觉得，想继续深入了解 CachingExecutor 中使用的 Cache 是一级缓存还是二级缓存，了解 Cache 对象的创建至关重要。关于 MappedStatement 的创建流程，建议查阅笔者的另外一篇博文：<a href="https://blog.csdn.net/prestigeding/article/details/90488395">源码分析Mybatis MappedStatement的创建流程</a>。</p>
<p>本文只会关注 MappedStatement 对象流程中关于于缓存相关的部分。</p>
<p>接下来将按照先二级缓存，再一级缓存的思路进行讲解。</p>
<h4 id="1-2-1-二级缓存"><a href="#1-2-1-二级缓存" class="headerlink" title="1.2.1 二级缓存"></a>1.2.1 二级缓存</h4><h5 id="1-2-1-1-MappedStatement-cache属性创建机制"><a href="#1-2-1-1-MappedStatement-cache属性创建机制" class="headerlink" title="1.2.1.1 MappedStatement#cache属性创建机制"></a>1.2.1.1 MappedStatement#cache属性创建机制</h5><p>从上面看，如果 cacheEnable 为 true 并且 MappedStatement 对象的 cache 属性不为空，则能使用二级缓存。</p>
<p>我们可以看到 MappedStatement 对象的 cache 属性赋值的地方为：MapperBuilderAssistant#addMappedStatement，从该方法的调用链可以得知是在解析 Mapper 定义的时候就会创建。<br><img src="https://img-blog.csdnimg.cn/20190826205429651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用的 cache 属性为 MapperBuilderAssistant 的 currentCache,我们跟踪一下该属性的赋值方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useCacheRef</span><span class="params">(String namespace)</span></span></span><br></pre></td></tr></table></figure>
<p>其调用链如下：<br><img src="https://img-blog.csdnimg.cn/2019082620552683.png" alt="在这里插入图片描述"><br>可以看出是在解析 cacheRef 标签，即在解析 Mapper.xml 文件中的 cacheRef 标签时，即二级缓存的使用和 cacheRef 标签离不开关系，并且特别注意一点，其参数为 namespace，即每一个 namespace 对应一个 Cache 对象，在 Mybatis 的方法中，通常namespace 对一个 Mapper.java 对象，对应对数据库一张表的更新、新增操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Cache useNewCache</span><br></pre></td></tr></table></figure>
<p>其调用链如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190826205659301.png" alt="在这里插入图片描述">在解析 Mapper.xml 文件中的 cache 标签时被调用。</p>
<h5 id="1-2-1-2-cache标签解析"><a href="#1-2-1-2-cache标签解析" class="headerlink" title="1.2.1.2 cache标签解析"></a>1.2.1.2 cache标签解析</h5><p>接下来我们根据 cache 标签简单看一下 cache 标签的解析，下面以 xml 配置方式为例展开，基于注解的解析，其原理类似，其代码 XMLMapperBuilder 的 cacheElement 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">      String type = context.getStringAttribute(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;PERPETUAL&quot;</span>);                                                      </span><br><span class="line">      Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">      String eviction = context.getStringAttribute(<span class="string">&quot;eviction&quot;</span>, <span class="string">&quot;LRU&quot;</span>);</span><br><span class="line">      Class&lt;? extends Cache&gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">      Long flushInterval = context.getLongAttribute(<span class="string">&quot;flushInterval&quot;</span>);</span><br><span class="line">      Integer size = context.getIntAttribute(<span class="string">&quot;size&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">&quot;readOnly&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">&quot;blocking&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">      Properties props = context.getChildrenAsProperties();</span><br><span class="line">      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上面 cache 标签的核心属性如下：</p>
<ul>
<li>type<br>缓存实现类，可选择值：PERPETUAL、LRU 等，Mybatis 中所有的缓存实现类如下：<br><img src="https://img-blog.csdnimg.cn/2019082620593518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li>eviction<br>移除算法，默认为 LRU。</li>
<li>flushInterval<br>缓存过期时间。</li>
<li>size<br>缓存在内存中的缓存个数。</li>
<li>readOnly<br>是否是只读。</li>
<li>blocking<br>是否阻塞，具体实现请看 BlockingCache。</li>
</ul>
<h5 id="1-2-1-3-cacheRef"><a href="#1-2-1-3-cacheRef" class="headerlink" title="1.2.1.3 cacheRef"></a>1.2.1.3 cacheRef</h5><p><img src="https://img-blog.csdnimg.cn/20190826210042752.png" alt="在这里插入图片描述"><br>cacheRef 只有一个属性，就是 namespace，就是引用其他 namespace 中的 cache。</p>
<p>Cache 的创建流程就讲解到这里，同一个 Namespace 只会定义一个 Cache。二级缓存的创建是在 *Mapper.xml 文件中使用了&lt; cache/&gt;、&lt; cacheRef/&gt;标签时创建，并且会按 NameSpace 为维度，为各个 MapperStatement 传入它所属的 Namespace 的二级缓存对象。</p>
<p>二级缓存的查询逻辑就介绍到这里了，我们再次回成 CacheingExecutor 的查询方法：<br>CachingExecutor#query</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">      flushCacheIfRequired(ms);        <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ensureNoOutParams(ms, boundSql);</span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);      <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;                                                              <span class="comment">// @4</span></span><br><span class="line">          list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);    <span class="comment">//@5</span></span><br><span class="line">          tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116                                                               // @6</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);  <span class="comment">//@7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 MappedStatement 的 cache 属性为空，则直接调用内部的 Executor 的查询方法。也就时如果在 *.Mapper.xm l文件中未定义&lt; cache/&gt;或&lt; cacheRef/&gt;，则 cache 属性会为空。</p>
<h4 id="1-2-2-一级缓存"><a href="#1-2-2-一级缓存" class="headerlink" title="1.2.2 一级缓存"></a>1.2.2 一级缓存</h4><p>Mybatis 根据 SQL 的类型共有如下3种 Executor类型，分别是 SIMPLE,  REUSE, BATCH，本文将以 SimpleExecutor为 例来对一级缓存的介绍。</p>
<p>BaseExecutor#query</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;   <span class="comment">// @1</span></span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;                                                              </span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;     <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);   <span class="comment">// @3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #601</span></span><br><span class="line">      deferredLoads.clear();</span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;</span><br><span class="line">        <span class="comment">// issue #482</span></span><br><span class="line">        clearLocalCache();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：queryStack：查询栈，每次查询之前，加一，查询返回结果后减一，如果为1，表示整个会会话中没有执行的查询语句，并根据 MappedStatement 是否需要执行清除缓存，如果是查询类的请求，无需清除缓存，如果是更新类操作的MappedStatemt，每次执行之前都需要清除缓存。<br>代码@2：如果缓存中存在，直接返回缓存中的数据。<br>代码@3：如果缓存未命中，则调用 queryFromDatabase 从数据中查询。</p>
<p>我们顺便看一下 queryFromDatabase 方法，再来看一下一级缓存的实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">queryFromDatabase</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">   List&lt;E&gt; list;</span><br><span class="line">   localCache.putObject(key, EXECUTION_PLACEHOLDER);   <span class="comment">//@!</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);   <span class="comment">// @2</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     localCache.removeObject(key);                                                            <span class="comment">// @3</span></span><br><span class="line">   &#125;</span><br><span class="line">   localCache.putObject(key, list);                                                              <span class="comment">// @4</span></span><br><span class="line">   <span class="keyword">if</span> (ms.getStatementType() == StatementType.CALLABLE) &#123;</span><br><span class="line">     localOutputParameterCache.putObject(key, parameter);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> list;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先往本地遍历存储一个厂里，表示正在执行中。<br>代码@2：从数据中查询数据。<br>代码@3：先移除正在执行中的标记。<br>代码@4：将数据库中的值存储到一级缓存中。</p>
<p>可以看出一级缓存的属性为 localCache，为 Executor 的属性。如果大家看过笔者发布的这个 Mybatis 系列就能轻易得出一个结论，每一个 SQL 会话对应一个 SqlSession 对象，每一个 SqlSession 会对应一个 Executor 对象，故 Executor 级别的缓存即为Session 级别的缓存，即为 Mybatis 的一级缓存。</p>
<p>上面已经介绍了一二级缓存的查找与添加，在查询的时候，首先查询缓存，如果缓存未命中，则查询数据库，然后将查询到的结果存入缓存中。</p>
<p>下面我们来简单看看缓存的更新。</p>
<h2 id="2、从SQL更新流程看一二级缓存"><a href="#2、从SQL更新流程看一二级缓存" class="headerlink" title="2、从SQL更新流程看一二级缓存"></a>2、从SQL更新流程看一二级缓存</h2><p>从更新的角度，更加的是关注缓存的更新，即当数据发生变化后，如果清除对应的缓存。</p>
<a id="more"></a>

<h3 id="2-1-二级缓存"><a href="#2-1-二级缓存" class="headerlink" title="2.1 二级缓存"></a>2.1 二级缓存</h3><p>CachingExecutor#update</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameterObject)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    flushCacheIfRequired(ms);    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> delegate.update(ms, parameterObject);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果有必要则刷新缓存。<br>代码@2：调用内部的 Executor，例如 SimpleExecutor。</p>
<p>接下来重点看一下 flushCacheIfRequired 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushCacheIfRequired</span><span class="params">(MappedStatement ms)</span> </span>&#123;</span><br><span class="line">    Cache cache = ms.getCache();</span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;      </span><br><span class="line">      tcm.clear(cache);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TransactionalCacheManager#clear</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    getTransactionalCache(cache).clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionalCacheManager 事务缓存管理器，其实就是对 MappedStatement 的 cache 属性进行装饰，最终调用的还是MappedStatement 的 getCache 方法得到其缓存对象然后调用 clear 方法，清空所有的缓存，即缓存的更新策略是只要namespace 的任何一条插入或更新语句执行，整个 namespace 的缓存数据将全部清空。</p>
<h3 id="2-2-一级缓存的更新"><a href="#2-2-一级缓存的更新" class="headerlink" title="2.2 一级缓存的更新"></a>2.2 一级缓存的更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(MappedStatement ms, Object parameter)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing an update&quot;</span>).object(ms.getId());</span><br><span class="line">  <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  clearLocalCache();</span><br><span class="line">  <span class="keyword">return</span> doUpdate(ms, parameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其更新策略与二级缓存维护的一样。</p>
<p>一二级缓存的的新增、查询、更新就介绍到这里了，接下来对其进行一个总结。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><h3 id="3-1-一二级缓存作用序列图"><a href="#3-1-一二级缓存作用序列图" class="headerlink" title="3.1 一二级缓存作用序列图"></a>3.1 一二级缓存作用序列图</h3><p>Mybatis 一二级缓存时序图如下：<br><img src="https://img-blog.csdnimg.cn/20190826210834511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="3-2-如何使用二级缓存"><a href="#3-2-如何使用二级缓存" class="headerlink" title="3.2 如何使用二级缓存"></a>3.2 如何使用二级缓存</h3><p>1、在mybatis-config.xml中将cacheEnable设置为true。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不过该值默认为true。</p>
<p>2、在需要缓存的表操作，对应的 Dao 的配置文件中，例如 *Mapper.xml 文件中使用 cache、或 cacheRef 标签来定义缓存。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.winterchen.dao.UserDao&quot;</span> &gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;insert&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.winterchen.model.UserDomain&quot;</span>&gt;</span></span><br><span class="line">    //省略</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;selectUsers&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.winterchen.model.UserDomain&quot;</span>&gt;</span></span><br><span class="line">      //省略</span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">&quot;lru&quot;</span> <span class="attr">readOnly</span>=<span class="string">&quot;true&quot;</span> <span class="attr">flushInterval</span>=<span class="string">&quot;3600000&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样就定义了一个 Cache，其 namespace 为 com.winterchen.dao.UserDao。其中 flushInterval 定义该 cache 定时清除的时间间隔，单位为 ms。</p>
<p>如果一个表的更新操作、新增操作位于不同的 Mapper.xml 文件中，如果对一个表的操作的 Cache 定义在不同的文件，则缓存数据则会出现不一致的情况，因为 Cache 的更新逻辑是，在一个 Namespace 中，如果有更新、插入语句的执行，则会清除该 namespace 对应的 cache 里面的所有缓存。那怎么来处理这种场景呢？cacheRef 闪亮登场。</p>
<p>如果一个 Mapper.xml 文件需要引入定义在别的 Mapper.xml 文件中定义的 cache,则使用 cacheRef，示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cacheRef</span> &quot;<span class="attr">namespace</span>&quot; = <span class="string">&quot;com.winterchen.dao.UserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>一级缓存默认是开启的，也无法关闭。</p>
<p>缓存的介绍就介绍到这里。如果本文对您有所帮助，麻烦点一下赞，谢谢。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>一级缓存</tag>
        <tag>二级缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty4 事件处理传播机制</title>
    <url>/posts/be152999.html</url>
    <content><![CDATA[<div id="vip-container"><p>本节将详细分析Netty事件传播机制，即事件链的实现机制。</p>
<p>本文重点的行文思路：</p>
<ul>
<li>详解事件的触发事件</li>
<li>事件传播机制</li>
<li>思考题：在NIO中是通道是一定需要注册写事件才能通过该通道写数据吗？</li>
</ul>
<a id="more"></a>

<p>Netty4的事件链核心类如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215532749.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>接下先详细介绍上述核心类的核心方法。<br>1、ChannelPipeline<br>“Channel流水线”，即Channel管道（事件处理链），其主要核心方法包括如下三类。<br><strong>添加类操作</strong></p>
<ul>
<li>ChannelPipeline addFirst(String name, ChannelHandler handler)</li>
<li>ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler)</li>
<li>ChannelPipeline addFirst(ChannelHandler… handlers)</li>
<li>ChannelPipeline addFirst(EventExecutorGroup group, ChannelHandler… handlers)</li>
<li>ChannelPipeline addLast(String name, ChannelHandler handler)</li>
<li>ChannelPipeline addBefore(String baseName, String name, ChannelHandler handler)</li>
<li>ChannelPipeline addAfter(String baseName, String name, ChannelHandler handler)</li>
</ul>
<p>其中省略了addLast、addBefore、addAfter的其他重载方法，模式为addFirst类似。在这里着重讲解一下各个参数的含义。</p>
<ul>
<li>EventExecutorGroup group<br>ChannelHandler执行的线程组EventLoop，如果为空，则ChannelHandler在Channel所注册的EventLoop。</li>
<li>String name<br>ChannelHandler的名称，DefaultChannelPipeline会避免因重名而修改ChannelHandler的名称。</li>
</ul>
<p><strong>ChannelHandler的增删改查</strong></p>
<ul>
<li>ChannelPipeline remove(ChannelHandler handler)<br>ChannelHandler removeFirst()<br>省略其他API，此类API其实能反映出ChannelPipeline内部是一个双链表结构。</li>
</ul>
<p><strong>入端(inbound)事件传播</strong></p>
<ul>
<li>ChannelPipeline fireChannelRegistered()</li>
<li>ChannelPipeline fireChannelUnregistered()</li>
<li>ChannelPipeline fireChannelActive()</li>
<li>ChannelPipeline fireChannelInactive()</li>
<li>ChannelPipeline fireExceptionCaught(Throwable cause)</li>
<li>ChannelPipeline fireUserEventTriggered(Object event)</li>
<li>ChannelPipeline fireChannelRead(Object msg)</li>
<li>ChannelPipeline fireChannelReadComplete()</li>
<li>ChannelPipeline fireChannelWritabilityChanged()<br>不难看出，此类API方法名 fire + ChannelInboundHandler 中的方法。特别注意的是fireChannelRead(Object msg)的参数为通过网络SocketChannel#read一次读取的字节数组（ByteBuf），跟随着事件处理器一步一步的处理。</li>
</ul>
<p><strong>出端(outbound)事件传播</strong></p>
<ul>
<li>ChannelFuture bind(SocketAddress localAddress)</li>
<li>ChannelFuture connect(SocketAddress remoteAddress)</li>
<li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress)</li>
<li>ChannelFuture disconnect()</li>
<li>ChannelFuture close()</li>
<li>ChannelFuture deregister()</li>
<li>ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise)</li>
<li>ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise)</li>
<li>ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise)</li>
<li>ChannelFuture disconnect(ChannelPromise promise)</li>
<li>ChannelFuture close(ChannelPromise promise)</li>
<li>ChannelFuture deregister(ChannelPromise promise)</li>
<li>ChannelPipeline read()</li>
<li>ChannelFuture write(Object msg)</li>
<li>ChannelFuture write(Object msg, ChannelPromise promise)</li>
<li>ChannelPipeline flush()</li>
<li>ChannelFuture writeAndFlush(Object msg, ChannelPromise promise)</li>
<li>ChannelFuture writeAndFlush(Object msg)<br>不难看出，上述方法为ChannelOutboundHandler的方法。</li>
</ul>
<h2 id="2、DefaultChannelPipeline"><a href="#2、DefaultChannelPipeline" class="headerlink" title="2、DefaultChannelPipeline"></a>2、DefaultChannelPipeline</h2><p>ChannelPipeline的简单类图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215634424.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>结合head、taill与下面的构造函数可知DefaultChannelPipeline的结构是其双链表，其中head、tail为双链表的首尾节点，并且其引用不能更改，其中节点（Node）实现为AbstractChannelHandlerContext，其内部必然定义两个属性prev与next，分别代表前一个节点与下一个节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext head</span><br><span class="line"><span class="keyword">final</span> AbstractChannelHandlerContext tail</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Channel channel </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.channel = ObjectUtil.checkNotNull(channel, <span class="string">&quot;channel&quot;</span>);</span><br><span class="line">        tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">        head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从这里看一个Channel对应一个ChannelPipeline。</p>
<h3 id="2-1-事件链构建"><a href="#2-1-事件链构建" class="headerlink" title="2.1 事件链构建"></a>2.1 事件链构建</h3><p>本节将以addFirst方法为例展示ChannelPipeline事件链的维护实现。<br>DefaultChannelPipeline#addFirst</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addFirst(<span class="keyword">null</span>, name, handler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>内部调用其重载方法。接下来重点分析该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addFirst</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;     <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            checkMultiplicity(handler);                                                                                                                        <span class="comment">// @2</span></span><br><span class="line">            name = filterName(name, handler);</span><br><span class="line">            newCtx = newContext(group, name, handler);                                                                                         <span class="comment">// @3</span></span><br><span class="line">            addFirst0(newCtx);                                                                                                                                   <span class="comment">// @4                                   </span></span><br><span class="line">            <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">            <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">            <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">            <span class="keyword">if</span> (!registered) &#123;                                                                                                                                        <span class="comment">// @5</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            EventExecutor executor = newCtx.executor();</span><br><span class="line">            <span class="keyword">if</span> (!executor.inEventLoop()) &#123;                                                                                                                  <span class="comment">// @6</span></span><br><span class="line">                newCtx.setAddPending();</span><br><span class="line">                executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        callHandlerAdded0(newCtx);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        callHandlerAdded0(newCtx);                                                                                                                    <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先对参数简单说明一下：</p>
<ul>
<li>EventExecutorGroup group：指定ChannelHandler在哪个事件选择器中执行(EventLoopGroup)，如果为空，表示在Channel注册的事件轮询器中执行。</li>
<li>String name：ChannelHandler名称。</li>
<li>ChannelHandler channelHandler：待添加的事件处理器。</li>
</ul>
<p>代码@2：检查是否重复添加，声明为Shareable的ChannelHandler允许重复添加。</p>
<p>代码@3：使用AbstractChannelHandlerContext类包装ChannelHandler，即双链表结构的Node类为AbstractChannelHandlerContext。</p>
<p>代码@4：将AbstractChannelHandlerContext调用addFirst0添加到双链表的“第一条”，其实是添加到双链表头结点(HeaderContext)的next值执行该节点。</p>
<p>代码@5-代码@7都是处理handerAdd事件，如果通道还未注册，handerAdd事件会“挂起”，也就是需要等待通道被注册后才执行，其实现思路也是构建PendingHandlerCallback链，DefaultChannelPipeline内部持有该链的头节点，待通道注册后，顺序触发handlerAdd事件的传播。</p>
<p>接下来看一下addFirst0的执行：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFirst0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext nextCtx = head.next;    </span><br><span class="line">        newCtx.prev = head;                                                        </span><br><span class="line">        newCtx.next = nextCtx;                                                  </span><br><span class="line">        head.next = newCtx;                                                       </span><br><span class="line">        nextCtx.prev = newCtx;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里就是典型的链表操作过程。<br>如果使用如下代码构建事件链，那事件是如何传播的呢？<br>p.addLast(“1”, new InboundHandlerA());<br>p.addLast(“2”, new InboundHandlerB());<br>p.addLast(“3”, new OutboundHandlerA());<br>p.addLast(“4”, new OutboundHandlerB());<br>p.addLast(“5”, new InboundOutboundHandlerX());<br>其构建的事件链最终如图所示：<br><img src="https://img-blog.csdnimg.cn/20201213215730318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>但ChannelInboundHandler中的事件是如何传播的呢？ChannelOutboundHandler的事件又是如何传播的呢？</p>
<p>事件链中的节点对象为AbstractChannelHandlerContext，其类图如下：</p>
<p><img src="https://img-blog.csdnimg.cn/2020121321581174.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>HeadContext：事件链的头节点。</li>
<li>TailContext：事件链的尾节点。</li>
<li>DefaultChannelHandlerContext：用户定义的Handler所在的节点。</li>
</ul>
<h3 id="2-2-事件传播"><a href="#2-2-事件传播" class="headerlink" title="2.2 事件传播"></a>2.2 事件传播</h3><p>inbound事件与outbound事件传播机制实现原理相同，只是方向不同，inbound事件的传播从HeadContext开始，沿着next指针进行传播，而outbound事件传播从TailContext开始，沿着prev指针向前传播，故下文重点分析inbound事件传播机制。</p>
<p>DefaultChannelPipeline有关于ChannelInboundHandler的方法实现如下：<br><img src="https://img-blog.csdnimg.cn/20201213215906969.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>所有的入端事件的传播入口都是从head开始传播</strong>。接下来我们以channelRead事件的传播为例，展示inbound的事件的流转。注意：以下观点都是针对NIO的读取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DefaultChannelPipeline#fireChannelRead(Object msg) &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">     AbstractChannelHandlerContext.invokeChannelRead(head, msg);  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>首先在NIO事件选择器在网络读事件就绪后，会调用底层SocketChanel#read 方法从读缓存中读取字节，在Netty中使用ByteBuf来存储，然后调用DefaultChannelPipeline # fireChannelRead 方法进行事件传播，每个ChannelHandler针对输入进行加工处理，ChannelPipeline因此而得名，有关Netty基于NIO的事件就绪选择实现将在Netty线程模型、IO读写流程部分详细讲解。</p>
<p>从代码@1处可得知，通过AbstractChannelHandlerContext的静态方法invokerChanelRead，从HeadContext处开始执行，</p>
<p>AbstractChannelHandlerContext#invokerChanelRead</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, <span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>);</span><br><span class="line">        EventExecutor executor = next.executor();         <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;                                <span class="comment">// @2</span></span><br><span class="line">            next.invokeChannelRead(msg);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;              <span class="comment">// @3</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种写法是Netty处理事件执行的“模板”方法，都是先获取需要执行的线程组(EventLoop),如果当前线程不属于Eventloop，则将任务提交到EventLoop中异步执行，如果在，则直接调用。第一次调用，该next指针为HeadContext，那接下来重点关注一下HeadContext的invokeChannelRead方法。<br>AbstractChannelHandlerContext#invokeChannelRead</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;                                                                            <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);   <span class="comment">// @2</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);                                                                     <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果该通道已经成功添加@1，则执行对应的事件@2，否则只是传播事件@3。</p>
<p>传播事件在AbstractChannelHandlerContext的实现思路如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractChannelHandlerContext#fireChannelRead</span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上述就从事件链中按顺序提取inbound类型的处理器，上述代码要最终能结束，那么TailContext必须是Inbound类型的事件处理器。</p>
<p>从代码@2中执行完对应的事件处理逻辑后，事件如何向下传播呢？如果需要继续将事件传播的话，请调用ChannelInboundHandlerAdapter 对应的传播事件方法，如上例中的 ChannelInboundHandlerAdapter#fireChannelRead，该方法会将事件链继续往下传播，如果在对应的事件处理中继续调用fireChannelRead，则事件传播则停止传播，也就是并不是事件一定会顺着整个调用链到达事件链的尾部TailContext，在实践中请特别重视。</p>
<p>Netty inbound 事件传播流程图如下：<br><img src="https://img-blog.csdnimg.cn/20201213215946585.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述主要分析了inboud事件的传播机制，为了加深理解，我们接下来浏览一下HeadContext、TailContext是如何实现各个事件方法的，这些事件，后续在梳理Netty读写流程时会再详细介绍。</p>
<h3 id="2-3-源码分析DefaultChannelPipeline-HeadContex"><a href="#2-3-源码分析DefaultChannelPipeline-HeadContex" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$HeadContex"></a>2.3 源码分析DefaultChannelPipeline$HeadContex</h3><h4 id="2-3-1-HeadContext声明与构造方法"><a href="#2-3-1-HeadContext声明与构造方法" class="headerlink" title="2.3.1 HeadContext声明与构造方法"></a>2.3.1 HeadContext声明与构造方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeadContext</span> <span class="keyword">extends</span> <span class="title">AbstractChannelHandlerContext</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ChannelOutboundHandler</span>, <span class="title">ChannelInboundHandler</span> </span>&#123;    <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Unsafe unsafe;                                                                     <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">        HeadContext(DefaultChannelPipeline pipeline) &#123;                        </span><br><span class="line">            <span class="keyword">super</span>(pipeline, <span class="keyword">null</span>, HEAD_NAME, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            unsafe = pipeline.channel().unsafe();</span><br><span class="line">            setAddComplete();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：HeadContext实现ChannelInboundHandler与ChannelOutboundHandler，故它的inbound与outbound都返回true。<br>代码@2：Unsafe，Netty操作类。</p>
<h4 id="2-3-2-handlerAdded、handlerRemoved"><a href="#2-3-2-handlerAdded、handlerRemoved" class="headerlink" title="2.3.2 handlerAdded、handlerRemoved"></a>2.3.2 handlerAdded、handlerRemoved</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerRemoved</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ChanelHandler增加与移除事件处理逻辑：不做任何处理。为什么可以不传播呢？其实上文在讲解addFirst方法时已提到，在添加一个ChannelHandler到事件链时，会根据通道是否被注册，如果未注册，会先阻塞执行，DefaultChannelPipeline会保存一条执行链，等通道被注册后处触发执行，HeadContext作为一个非业务类型的事件处理器，对通道的增加与否无需关注。</p>
<h4 id="2-3-3-exceptionCaught"><a href="#2-3-3-exceptionCaught" class="headerlink" title="2.3.3 exceptionCaught"></a>2.3.3 exceptionCaught</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireExceptionCaught(cause);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道异常处理事件的处理逻辑：HeadContext的选择是自己不关注，直接将异常事件往下传播。</p>
<h4 id="2-3-4-channelRegistered"><a href="#2-3-4-channelRegistered" class="headerlink" title="2.3.4 channelRegistered"></a>2.3.4 channelRegistered</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            invokeHandlerAddedIfNeeded();</span><br><span class="line">            ctx.fireChannelRegistered();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">            firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// We are now registered to the EventLoop. It&#x27;s time to call the callbacks for the ChannelHandlers,</span></span><br><span class="line">            <span class="comment">// that were added before the registration was done.</span></span><br><span class="line">            callHandlerAddedForAllHandlers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通道注册事件处理逻辑：当通道成功注册后，判断是否是第一次注册，如果是第一次注册的话，调用所有的ChannelHandler#handlerAdd事件，因为当通道增加到事件链后，如果该通道还未注册，channelAdd事件不会马上执行，需要等通道注册后才执行，故在这里首先需要执行完挂起（延迟等待的任务）。然后调用fireChannelRegistered沿着事件链传播通道注册成功事件。</p>
<h4 id="2-3-5-channelUnregistered"><a href="#2-3-5-channelUnregistered" class="headerlink" title="2.3.5 channelUnregistered"></a>2.3.5 channelUnregistered</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelUnregistered</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelUnregistered();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remove all handlers sequentially if channel is closed and unregistered.</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isOpen()) &#123;</span><br><span class="line">                destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>通道取消注册事件处理逻辑：首先传播事件，然后判断通道的状态，如果是处于关闭状态（通道调用了close方法），则需要移除所有的ChannelHandler。</p>
<h4 id="2-3-6-channelActive"><a href="#2-3-6-channelActive" class="headerlink" title="2.3.6 channelActive"></a>2.3.6 channelActive</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"> 	ctx.fireChannelActive();</span><br><span class="line">        readIfIsAutoRead();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通道激活事件的处理逻辑（TCP连接建立成功后触发）：首先传播该事件，如果开启自动读机制(autoRead为true)，则调用Channel#read方法，向NIO Selector注册读事件。</p>
<h4 id="2-3-7-channelInactive"><a href="#2-3-7-channelInactive" class="headerlink" title="2.3.7 channelInactive"></a>2.3.7 channelInactive</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelInactive();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>通道非激活事件处理逻辑：只传播事件。</p>
<h4 id="2-3-8-channelRead"><a href="#2-3-8-channelRead" class="headerlink" title="2.3.8 channelRead"></a>2.3.8 channelRead</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelRead(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道读事件处理逻辑：向下传播事件，各个编码器、业务处理器将各自处理业务逻辑。</p>
<h4 id="2-3-9-channelReadComplete"><a href="#2-3-9-channelReadComplete" class="headerlink" title="2.3.9 channelReadComplete"></a>2.3.9 channelReadComplete</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ctx.fireChannelReadComplete();</span><br><span class="line">readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道读完成事件，首先先传播事件，然后如果开启了自动读取的话，继续注册读事件。</p>
<h4 id="2-3-10-userEventTriggered"><a href="#2-3-10-userEventTriggered" class="headerlink" title="2.3.10 userEventTriggered"></a>2.3.10 userEventTriggered</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireUserEventTriggered(evt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户自定义事件的处理逻辑：传播事件。</p>
<h4 id="2-3-11-channelWritabilityChanged"><a href="#2-3-11-channelWritabilityChanged" class="headerlink" title="2.3.11 channelWritabilityChanged"></a>2.3.11 channelWritabilityChanged</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelWritabilityChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通道可写状态变更事件的处理逻辑：传播事件。</p>
<p>接下来介绍HeadContext对于ChannelOutboundHander事件的处理逻辑：</p>
<h4 id="2-3-12-bind"><a href="#2-3-12-bind" class="headerlink" title="2.3.12 bind"></a>2.3.12 bind</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">( ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">unsafe.bind(localAddress, promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过Unsafe实例完成具体的绑定操作，后续会重点分析该方法的实现原理。</p>
<p>由于HeadContex是outbound事件的尾部事件处理器，而且outbound是用户发送的API调用，其最终目的是希望通过Netty完成具体的网络操作，故HeadContex是离Netty底层机制最近的，到了这里，就意味者“应用程序”层面的定制化介绍，最终需要通过HeadContex直接调用Netty的API来完成具体的动作，故HeadContex关于outbound事件的实现，都是通过调用unsafe去完成具体的动作。故后面的方面就不在一一罗列。</p>
<h3 id="2-3-源码分析DefaultChannelPipeline-TailContext"><a href="#2-3-源码分析DefaultChannelPipeline-TailContext" class="headerlink" title="2.3 源码分析DefaultChannelPipeline$TailContext"></a>2.3 源码分析DefaultChannelPipeline$TailContext</h3><p>TailContext由于是 inbound事件链的最后一站，故该节点大部分事件都是空实现，其他实现的方法，基本上就是释放一下资源，我们看一下TailContex关于channelRead事件的处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            onUnhandledInboundMessage(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.debug(</span><br><span class="line">                    <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ReferenceCountUtil.release(msg);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是主动调用ReferenceCountUtil.release(msg)释放资源。</p>
<p>Netty事件传播机制就讲解到这里了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>netty4</category>
      </categories>
      <tags>
        <tag>netty4</tag>
        <tag>事件传播</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 消息发送system busy、broker busy原因分析与解决方案</title>
    <url>/posts/be0ab616.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、现象"><a href="#1、现象" class="headerlink" title="1、现象"></a>1、现象</h2><p>最近收到很多RocketMQ使用者，反馈生产环境中在消息发送过程中偶尔会出现如下4个错误信息之一：<br>1）[REJECTREQUEST]system busy, start flow control for a while<br>2）too many requests and system thread pool busy, RejectedExecutionException<br>3）[PC_SYNCHRONIZED]broker busy, start flow control for a while<br>4）[PCBUSY_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: %sms, size of queue: %d</p>
<h2 id="2、原理解读"><a href="#2、原理解读" class="headerlink" title="2、原理解读"></a>2、原理解读</h2><p>在进行消息中间件的选型时，如果待选中间件在功能上、性能上都能满足业务的情况下，建议把中间件的实现语言这个因素也考虑进去，毕竟选择一门用自己擅长的语言实现的中间件会更具掌控性。在出现异常的情况下，我们可以根据自己的经验提取错误信息关键字system busy，在RocketMQ源码中直接搜索，得到抛出上述错误信息的代码如下：<br><img src="https://img-blog.csdnimg.cn/20190618213541816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其代码入口为：org.apache.rocketmq.remoting.netty.NettyRemotingAbstract#processRequestCommand。从图中可以看出，抛出上述错误的关键原因是：pair.getObject1().rejectRequest()和抛出RejectedExecutionException异常。</p>
<blockquote>
<p>备注：本文偏实战，源码只是作为分析的重点证据，故本文只会点出关键源码，并不会详细跟踪其整个实现流程，如果想详细了解其实现，可以查阅笔者编著的《RocketMQ技术内幕》。</p>
</blockquote>
<h3 id="2-1-RocketMQ-网络处理机制概述"><a href="#2-1-RocketMQ-网络处理机制概述" class="headerlink" title="2.1 RocketMQ 网络处理机制概述"></a>2.1 RocketMQ 网络处理机制概述</h3><p>RocketMQ的网络设计非常值得我们学习与借鉴，首先在客户端端将不同的请求定义不同的请求命令CODE，服务端会将客户端请求进行分类，每个命令或每类请求命令定义一个处理器(NettyRequestProcessor)，然后每一个NettyRequestProcessor绑定到一个单独的线程池，进行命令处理，不同类型的请求将使用不同的线程池进行处理，实现线程隔离。</p>
<a id="more"></a>

<p>为了方便下文的描述，我们先简单的认识一下NettyRequestProcessor、Pair、RequestCode。其核心关键点如下：<br><img src="https://img-blog.csdnimg.cn/20190618213801293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>NettyRequestProcessor<br>RocketMQ 服务端请求处理器，例如SendMessageProcessor是消息发送处理器、PullMessageProcessor是消息拉取命令处理器。</li>
<li>RequestCode<br>请求CODE，用来区分请求的类型，例如SEND_MESSAGE：表示该请求为消息发送，PULL_MESSAGE:消息拉取请求。</li>
<li>Pair<br>用来封装NettyRequestProcessor与ExecuteService的绑定关系。在RocketMQ的网络处理模型中，会为每一个NettyRequestProcessor与特定的线程池绑定，所有该NettyRequestProcessor的处理逻辑都在该线程池中运行。</li>
</ol>
<h3 id="2-2-pair-getObject1-rejectRequest"><a href="#2-2-pair-getObject1-rejectRequest" class="headerlink" title="2.2 pair.getObject1().rejectRequest()"></a>2.2 pair.getObject1().rejectRequest()</h3><p>由于读者朋友提出的问题，都是发生在消息发送过程中，故本文重点关注SendMessageProcessor#rejectRequest方法。<br>SendMessageProcessor#rejectRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rejectRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.brokerController.getMessageStore().isOSPageCacheBusy() ||               <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">this</span>.brokerController.getMessageStore().isTransientStorePoolDeficient();        <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拒绝请求的条件有两个，只要其中任意一个满足，则返回true。</p>
<p>代码@1：Os PageCache busy，判断操作系统PageCache是否繁忙，如果忙，则返回true。想必看到这里大家肯定与我一样好奇，RocketMQ是如何判断pageCache是否繁忙呢？下面会重点分析。</p>
<p>代码@2：transientStorePool是否不足。</p>
<h4 id="2-2-1-isOSPageCacheBusy"><a href="#2-2-1-isOSPageCacheBusy" class="headerlink" title="2.2.1 isOSPageCacheBusy()"></a>2.2.1 isOSPageCacheBusy()</h4><p>DefaultMessageStore#isOSPageCacheBusy()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOSPageCacheBusy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> begin = <span class="keyword">this</span>.getCommitLog().getBeginTimeInLock();  <span class="comment">// @1 start</span></span><br><span class="line">    <span class="keyword">long</span> diff = <span class="keyword">this</span>.systemClock.now() - begin;                         <span class="comment">// @1  end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> diff &lt; <span class="number">10000000</span></span><br><span class="line">                &amp;&amp; diff &gt; <span class="keyword">this</span>.messageStoreConfig.getOsPageCacheBusyTimeOutMills();     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先重点解释begin、diff两个局部变量的含义：</p>
<ul>
<li>begin<br>通俗的一点讲，就是将消息写入Commitlog文件所持有锁的时间，精确说是将消息体追加到内存映射文件(DirectByteBuffer)或pageCache(FileChannel#map)该过程中开始持有锁的时间戳，具体的代码请参考：CommitLog#putMessage。</li>
<li>diff<br>一次消息追加过程中持有锁的总时长，即往内存映射文件或pageCache追加一条消息所耗时间。</li>
</ul>
<p>代码@2：如果一次消息追加过程的时间超过了Broker配置文件osPageCacheBusyTimeOutMills，则认为pageCache繁忙，osPageCacheBusyTimeOutMills默认值为1000，表示1s。</p>
<h4 id="2-2-2-isTransientStorePoolDeficient"><a href="#2-2-2-isTransientStorePoolDeficient" class="headerlink" title="2.2.2 isTransientStorePoolDeficient()"></a>2.2.2 isTransientStorePoolDeficient()</h4><p>DefaultMessageStore#isTransientStorePoolDeficient</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTransientStorePoolDeficient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> remainTransientStoreBufferNumbs() == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainTransientStoreBufferNumbs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.transientStorePool.remainBufferNumbs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用TransientStorePool#remainBufferNumbs方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">remainBufferNumbs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (storeConfig.isTransientStorePoolEnable()) &#123;</span><br><span class="line">            <span class="keyword">return</span> availableBuffers.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果启用transientStorePoolEnable机制，返回当前可用的ByteBuffer个数，即整个isTransientStorePoolDeficient方法的用意是是否还存在可用的ByteBuffer，如果不存在，即表示pageCache繁忙。那什么是transientStorePoolEnable机制呢？</p>
<h3 id="2-3-漫谈transientStorePoolEnable机制"><a href="#2-3-漫谈transientStorePoolEnable机制" class="headerlink" title="2.3 漫谈transientStorePoolEnable机制"></a>2.3 漫谈transientStorePoolEnable机制</h3><p>Java NIO的内存映射机制，提供了将文件系统中的文件映射到内存机制，实现对文件的操作转换对内存地址的操作，极大的提高了IO特性，但这部分内存并不是常驻内存，可以被置换到交换内存(虚拟内存)，RocketMQ为了提高消息发送的性能，引入了内存锁定机制，即将最近需要操作的commitlog文件映射到内存，并提供内存锁定功能，确保这些文件始终存在内存中，该机制的控制参数就是transientStorePoolEnable。</p>
<h3 id="2-3-1-MappedFile"><a href="#2-3-1-MappedFile" class="headerlink" title="2.3.1 MappedFile"></a>2.3.1 MappedFile</h3><p>重点关注MappedFile的ByteBuffer writeBuffer、MappedByteBuffer mappedByteBuffer这两个属性的初始化，因为这两个方法是写消息与查消息操作的直接数据结构。<br><img src="https://img-blog.csdnimg.cn/20190618214230830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>两个关键点如下：</p>
<ul>
<li>ByteBuffer writeBuffer<br>如果开启了transientStorePoolEnable,则使用ByteBuffer.allocateDirect(fileSize),创建(java.nio的内存映射机制)。如果未开启，则为空。</li>
<li>MappedByteBuffer mappedByteBuffer<br>使用FileChannel#map方法创建，即真正意义上的PageCache。</li>
</ul>
<p>消息写入时：<br>MappedFile#appendMessagesInner<br><img src="https://img-blog.csdnimg.cn/20190618214320459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从中可见，在消息写入时，如果writerBuffer不为空，说明开启了transientStorePoolEnable机制，则消息首先写入writerBuffer中，如果其为空，则写入mappedByteBuffer中。</p>
<p>消息拉取(读消息)：<br>MappedFile#selectMappedBuffer<br><img src="https://img-blog.csdnimg.cn/2019061821440272.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>消息读取时，是从mappedByteBuffer中读(pageCache)。</p>
<p>大家是不是发现了一个有趣的点，如果开启transientStorePoolEnable机制，是不是有了读写分离的效果，先写入writerBuffer中，读却是从mappedByteBuffer中读取。</p>
<p>为了对transientStorePoolEnable引入意图阐述的更加明白，这里我引入Rocketmq社区贡献者胡宗棠关于此问题的见解。</p>
<p>通常有如下两种方式进行读写：</p>
<ol>
<li>第一种，Mmap+PageCache的方式，读写消息都走的是pageCache，这样子读写都在pagecache里面不可避免会有锁的问题，在并发的读写操作情况下，会出现缺页中断降低，内存加锁，污染页的回写。</li>
<li>第二种，DirectByteBuffer(堆外内存)+PageCache的两层架构方式，这样子可以实现读写消息分离，写入消息时候写到的是DirectByteBuffer——堆外内存中,读消息走的是PageCache(对于,DirectByteBuffer是两步刷盘，一步是刷到PageCache，还有一步是刷到磁盘文件中)，带来的好处就是，避免了内存操作的很多容易堵的地方，降低了时延，比如说缺页中断降低，内存加锁，污染页的回写。</li>
</ol>
<blockquote>
<p>温馨提示：如果想与胡宗棠大神进一步沟通交流，可以关注他的github账号：<a href="https://github.com/zongtanghu">https://github.com/zongtanghu</a></p>
</blockquote>
<p>不知道大家会不会有另外一个担忧，如果开启了transientStorePoolEnable，内存锁定机制，那是不是随着commitlog文件的不断增加，最终导致内存溢出？</p>
<h3 id="2-3-2-TransientStorePool初始化"><a href="#2-3-2-TransientStorePool初始化" class="headerlink" title="2.3.2 TransientStorePool初始化"></a>2.3.2 TransientStorePool初始化</h3><p><img src="https://img-blog.csdnimg.cn/20190618214632249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从这里可以看出，TransientStorePool默认会初始化5个DirectByteBuffer(对外内存)，并提供内存锁定功能，即这部分内存不会被置换，可以通过transientStorePoolSize参数控制。</p>
<p>在消息写入消息时，首先从池子中获取一个DirectByteBuffer进行消息的追加。当5个DirectByteBuffer全部写满消息后，该如何处理呢？从RocketMQ的设计中来看，同一时间，只会对一个commitlog文件进行顺序写，写完一个后，继续创建一个新的commitlog文件。故TransientStorePool的设计思想是循环利用这5个DirectByteBuffer，只需要写入到DirectByteBuffer的内容被提交到PageCache后，即可重复利用。对应的代码如下：<br>TransientStorePool#returnBuffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnBuffer</span><span class="params">(ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">    byteBuffer.position(<span class="number">0</span>);</span><br><span class="line">    byteBuffer.limit(fileSize);</span><br><span class="line">    <span class="keyword">this</span>.availableBuffers.offerFirst(byteBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其调用栈如下：<br><img src="https://img-blog.csdnimg.cn/20190618214837186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上面的分析看来，并不会随着消息的不断写入而导致内存溢出。</p>
<h2 id="3、现象解答"><a href="#3、现象解答" class="headerlink" title="3、现象解答"></a>3、现象解答</h2><h3 id="3-1-REJECTREQUEST-system-busy"><a href="#3-1-REJECTREQUEST-system-busy" class="headerlink" title="3.1 [REJECTREQUEST]system busy"></a>3.1 [REJECTREQUEST]system busy</h3><p><img src="https://img-blog.csdnimg.cn/20190618214915789.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其抛出的源码入口点：NettyRemotingAbstract#processRequestCommand，上面的原理分析部分已经详细介绍其实现原理，总结如下。</p>
<p>在不开启transientStorePoolEnable机制时，如果Broker PageCache繁忙时则抛出上述错误，判断PageCache繁忙的依据就是向PageCache追加消息时，如果持有锁的时间超过1s，则会抛出该错误；在开启transientStorePoolEnable机制时，其判断依据是如果TransientStorePool中不存在可用的堆外内存时抛出该错误。</p>
<h3 id="3-2-too-many-requests-and-system-thread-pool-busy-RejectedExecutionException"><a href="#3-2-too-many-requests-and-system-thread-pool-busy-RejectedExecutionException" class="headerlink" title="3.2 too many requests and system thread pool busy, RejectedExecutionException"></a>3.2 too many requests and system thread pool busy, RejectedExecutionException</h3><p><img src="https://img-blog.csdnimg.cn/20190618215005406.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其抛出的源码入口点：NettyRemotingAbstract#processRequestCommand，其调用地方紧跟3.1,是在向线程池执行任务时，被线程池拒绝执行时抛出的，我们可以顺便看看Broker消息处理发送的线程信息：<br>BrokerController#registerProcessor<br><img src="https://img-blog.csdnimg.cn/20190618215027611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>该线程池的队列长度默认为10000，我们可以通过sendThreadPoolQueueCapacity来改变默认值。</p>
<h3 id="3-3-PC-SYNCHRONIZED-broker-busy"><a href="#3-3-PC-SYNCHRONIZED-broker-busy" class="headerlink" title="3.3 [PC_SYNCHRONIZED]broker busy"></a>3.3 [PC_SYNCHRONIZED]broker busy</h3><p><img src="https://img-blog.csdnimg.cn/20190618215119506.png" alt="在这里插入图片描述"><br>其抛出的源码入口点：DefaultMessageStore#putMessage，在进行消息追加时，再一次判断PageCache是否繁忙，如果繁忙，则抛出上述错误。</p>
<h3 id="3-4-broker-busy-period-in-queue-sms-size-of-queue-d"><a href="#3-4-broker-busy-period-in-queue-sms-size-of-queue-d" class="headerlink" title="3.4 broker busy,  period in queue: %sms, size of queue: %d"></a>3.4 broker busy,  period in queue: %sms, size of queue: %d</h3><p><img src="https://img-blog.csdnimg.cn/2019061821520312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其抛出源码的入口点：BrokerFastFailure#cleanExpiredRequest。该方法的调用频率为每隔10s中执行一次，不过有一个执行前提条件就是Broker端要开启快速失败，默认为开启，可以通过参数brokerFastFailureEnable来设置。该方法的实现要点是每隔10s，检测一次，如果检测到PageCache繁忙，并且发送队列中还有排队的任务，则直接不再等待，直接抛出系统繁忙错误，使正在排队的线程快速失败，结束等待。</p>
<h2 id="4、实践建议"><a href="#4、实践建议" class="headerlink" title="4、实践建议"></a>4、实践建议</h2><p>经过上面的原理讲解与现象分析，消息发送时抛出system busy、broker busy的原因都是PageCache繁忙，那是不是可以通过调整上述提到的某些参数来避免抛出错误呢？.例如如下参数：</p>
<ul>
<li>osPageCacheBusyTimeOutMills<br>设置PageCache系统超时的时间，默认为1000，表示1s，那是不是可以把增加这个值，例如设置为2000或3000。作者观点：非常不可取。</li>
<li>sendThreadPoolQueueCapacity<br>Broker服务器处理的排队队列，默认为10000，如果队列中积压了10000个请求，则会抛出RejectExecutionException。作者观点：不可取。</li>
<li>brokerFastFailureEnable<br>是否启用快速失败，默认为true，表示当如果发现Broker服务器的PageCache繁忙，如果发现sendThreadPoolQueue队列中不为空，表示还有排队的发送请求在排队等待执行，则直接结束等待，返回broker busy。那如果不开启快速失败，则同样可以避免抛出这个错误。作者观点：非常不可取。</li>
</ul>
<p>修改上述参数，都不可取，原因是出现system busy、broker busy这个错误，其本质是系统的PageCache繁忙，通俗一点讲就是向PageCache追加消息时，单个消息发送占用的时间超过1s了，如果继续往该Broker服务器发送消息并等待，其TPS根本无法满足，哪还是高性能的消息中间了呀。故才会采用快速失败机制，直接给消息发送者返回错误，消息发送者默认情况会重试2次，将消息发往其他Broker，保证其高可用。</p>
<p>下面根据个人的见解，提出如下解决办法：</p>
<h3 id="4-1-开启transientStorePoolEnable"><a href="#4-1-开启transientStorePoolEnable" class="headerlink" title="4.1 开启transientStorePoolEnable"></a>4.1 开启transientStorePoolEnable</h3><p>在broker.config中将transientStorePoolEnable=true。</p>
<ul>
<li><p>方案依据：<br>启用“读写”分离，消息发送时消息先追加到DirectByteBuffer(堆外内存)中，然后在异步刷盘机制下，会将DirectByteBuffer中的内容提交到PageCache，然后刷写到磁盘。消息拉取时，直接从PageCache中拉取，实现了读写分离，减轻了PageCaceh的压力，能从根本上解决该问题。</p>
</li>
<li><p>方案缺点：<br>会增加数据丢失的可能性，如果Broker JVM进程异常退出，提交到PageCache中的消息是不会丢失的，但存在堆外内存(DirectByteBuffer)中但还未提交到PageCache中的这部分消息，将会丢失。但通常情况下，RocketMQ进程退出的可能性不大。</p>
</li>
</ul>
<h3 id="4-2-扩容Broker服务器"><a href="#4-2-扩容Broker服务器" class="headerlink" title="4.2 扩容Broker服务器"></a>4.2 扩容Broker服务器</h3><p>方案依据：</p>
<p>当Broker服务器自身比较忙的时候，快速失败，并且在接下来的一段时间内会规避该Broker，这样该Broker恢复提供了时间保证，Broker本身的架构是支持分布式水平扩容的，增加Topic的队列数，降低单台Broker服务器的负载，从而避免出现PageCache。</p>
<blockquote>
<p>温馨提示：在Broker扩容时候，可以复制集群中任意一台Broker服务下${ROCKETMQ_HOME}/store/config/topics.json到新Broker服务器指定目录，避免在新Broker服务器上为Broker创建队列，然后消息发送者、消息消费者都能动态获取Topic的路由信息。</p>
</blockquote>
<p>与之扩容对应的，也可以通过对原有Broker进行升配，例如增加内存、把机械盘换成SSD，但这种情况，通常需要重启Broekr服务器，没有扩容来的方便。</p>
<p>本文就介绍到这里了，如果大家觉得文章对自己有用的话，麻烦帮忙点赞、转发，谢谢。亲爱的读者朋友，还有更好的方案没？欢迎留言与作者互动，共同探讨。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>broker busy</tag>
        <tag>system busy</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 整合 DLedger(多副本)即主从切换实现平滑升级的设计技巧</title>
    <url>/posts/ab1a7b9b.html</url>
    <content><![CDATA[<div id="vip-container"><p>源码分析 RocketMQ DLedger 多副本系列已经进行到第 8 篇了，前面的章节主要是介绍了基于 raft  协议的选主与日志复制，从本篇开始将开始关注如何将 DLedger 应用到 RocketMQ中。</p>
<p>摘要：详细分析了RocketMQ DLedger 多副本(主从切换) 是如何整合到 RocketMQ中，本文的行文思路首先结合已掌握的DLedger 多副本相关的知识初步思考其实现思路，然后从 Broker启动流程、DLedgerCommitlog 核心类的讲解，再从消息发送(追加)与消息查找来进一步探讨 DLedger 是如何支持平滑升级的。</p>
<h2 id="1、阅读源码之前的思考"><a href="#1、阅读源码之前的思考" class="headerlink" title="1、阅读源码之前的思考"></a>1、阅读源码之前的思考</h2><p>RocketMQ 的消息存储文件主要包括 commitlog 文件、consumequeue 文件与 Index 文件。commitlog 文件存储全量的消息，consumequeue、index 文件都是基于 commitlog 文件构建的。要使用 DLedger 来实现消息存储的一致性，应该关键是要实现 commitlog 文件的一致性，即  DLedger 要整合的对象应该是 commitlog 文件，即只需保证 raft 协议的复制组内各个节点的 commitlog 文件一致即可。</p>
<p>我们知道使用文件存储消息都会基于一定的存储格式，rocketmq 的 commitlog 一个条目就包含魔数、消息长度，消息属性、消息体等，而我们再来回顾一下 DLedger 日志的存储格式：<br><img src="https://img-blog.csdnimg.cn/20191003120527109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>DLedger 要整合 commitlog 文件，是不是可以把 rocketmq  消息，即一个个  commitlog 条目整体当成 DLedger 的 body 字段即可。</p>
<p>还等什么，跟我一起来看源码吧！！！别急，再抛一个问题，DLedger 整合 RocketMQ commitlog，能不能做到平滑升级？</p>
<p>带着这些思考和问题，一起来探究 DLedger 是如何整合 RocketMQ 的。 </p>
<a id="more"></a>

<h2 id="2、从-Broker-启动流程看-DLedger"><a href="#2、从-Broker-启动流程看-DLedger" class="headerlink" title="2、从 Broker 启动流程看 DLedger"></a>2、从 Broker 启动流程看 DLedger</h2><blockquote>
<p>温馨提示：本文不会详细介绍 Broker 端的启动流程，只会点出在启动过程中与 DLedger 相关的代码，如想详细了解 Broker 的启动流程，建议关注笔者的《RocketMQ技术内幕》一书。</p>
</blockquote>
<p>Broker 涉及到 DLedger 相关关键点如下：<br><img src="https://img-blog.csdnimg.cn/20191003120628182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2-1-构建-DefaultMessageStore"><a href="#2-1-构建-DefaultMessageStore" class="headerlink" title="2.1 构建 DefaultMessageStore"></a>2.1 构建 DefaultMessageStore</h3><p>DefaultMessageStore 构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(messageStoreConfig.isEnableDLegerCommitLog()) &#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.commitLog = <span class="keyword">new</span> DLedgerCommitLog(<span class="keyword">this</span>);</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.commitLog = <span class="keyword">new</span> CommitLog(<span class="keyword">this</span>);                    <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果开启 DLedger ，commitlog 的实现类为 DLedgerCommitLog，也是本文需要关注的关键所在。</p>
<p>代码@2：如果未开启 DLedger，则使用旧版的 Commitlog实现类。</p>
<h3 id="2-2-增加节点状态变更事件监听器"><a href="#2-2-增加节点状态变更事件监听器" class="headerlink" title="2.2 增加节点状态变更事件监听器"></a>2.2 增加节点状态变更事件监听器</h3><p>BrokerController#initialize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class="line">    DLedgerRoleChangeHandler roleChangeHandler = <span class="keyword">new</span> DLedgerRoleChangeHandler(<span class="keyword">this</span>, (DefaultMessageStore) messageStore);</span><br><span class="line">    ((DLedgerCommitLog)((DefaultMessageStore) messageStore).getCommitLog()).getdLedgerServer().getdLedgerLeaderElector().addRoleChangeHandler(roleChangeHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要调用 LedgerLeaderElector 的 addRoleChanneHandler 方法增加 节点角色变更事件监听器，DLedgerRoleChangeHandler 是实现主从切换的另外一个关键点。</p>
<h3 id="2-3-调用-DefaultMessageStore-的-load-方法"><a href="#2-3-调用-DefaultMessageStore-的-load-方法" class="headerlink" title="2.3 调用 DefaultMessageStore 的 load 方法"></a>2.3 调用 DefaultMessageStore 的 load 方法</h3><p>DefaultMessageStore#load</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load Commit Log</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.commitLog.load();   <span class="comment">// @1</span></span><br><span class="line"><span class="comment">// load Consume Queue</span></span><br><span class="line">result = result &amp;&amp; <span class="keyword">this</span>.loadConsumeQueue();  </span><br><span class="line"><span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.storeCheckpoint =  <span class="keyword">new</span> StoreCheckpoint(StorePathConfigHelper.getStoreCheckpoint(<span class="keyword">this</span>.messageStoreConfig.getStorePathRootDir()));</span><br><span class="line">    <span class="keyword">this</span>.indexService.load(lastExitOK);</span><br><span class="line">    <span class="keyword">this</span>.recover(lastExitOK);                         <span class="comment">// @2</span></span><br><span class="line">    log.info(<span class="string">&quot;load over, and the max phy offset = &#123;&#125;&quot;</span>, <span class="keyword">this</span>.getMaxPhyOffset());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1、@2 最终都是委托 commitlog 对象来执行，这里的关键又是如果开启了 DLedger，则最终调用的是 DLedgerCommitLog。</p>
<p>经过上面的铺垫，主角 DLedgerCommitLog “闪亮登场“了。</p>
<h2 id="3、DLedgerCommitLog-详解"><a href="#3、DLedgerCommitLog-详解" class="headerlink" title="3、DLedgerCommitLog 详解"></a>3、DLedgerCommitLog 详解</h2><p>温馨提示：由于 Commitlog 的绝大部分方法都已经在《RocketMQ技术内幕》一书中详细介绍了，并且 DLedgerCommitLog  的实现原理与 Commitlog 文件的实现原理类同，本文会一笔带过关于存储部分的实现细节。</p>
<h3 id="3-1-核心类图"><a href="#3-1-核心类图" class="headerlink" title="3.1 核心类图"></a>3.1 核心类图</h3><p><img src="https://img-blog.csdnimg.cn/20191003120747775.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>DLedgerCommitlog 继承自 Commitlog。让我们一一来看一下它的核心属性。</p>
<ul>
<li>DLedgerServer dLedgerServer<br>基于 raft 协议实现的集群内的一个节点，用 DLedgerServer 实例表示。</li>
<li>DLedgerConfig dLedgerConfig<br>DLedger 的配置信息。</li>
<li>DLedgerMmapFileStore dLedgerFileStore<br>DLedger 基于文件映射的存储实现。</li>
<li>MmapFileList dLedgerFileList<br>DLedger 所管理的存储文件集合，对比 RocketMQ 中的 MappedFileQueue。</li>
<li>int id<br>节点ID，0 表示主节点，非0表示从节点</li>
<li>MessageSerializer messageSerializer<br>消息序列器。</li>
<li>long beginTimeInDledgerLock = 0<br>用于记录 消息追加的时耗(日志追加所持有锁时间)。</li>
<li>long dividedCommitlogOffset = -1<br>记录的旧 commitlog 文件中的最大偏移量，如果访问的偏移量大于它，则访问 dledger 管理的文件。</li>
<li>boolean isInrecoveringOldCommitlog = false<br>是否正在恢复旧的 commitlog 文件。</li>
</ul>
<p>接下来我们将详细介绍 DLedgerCommitlog 各个核心方法及其实现要点。</p>
<h3 id="3-2-构造方法"><a href="#3-2-构造方法" class="headerlink" title="3.2 构造方法"></a>3.2 构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DLedgerCommitLog</span><span class="params">(<span class="keyword">final</span> DefaultMessageStore defaultMessageStore)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(defaultMessageStore);                   <span class="comment">// @1</span></span><br><span class="line">    dLedgerConfig =  <span class="keyword">new</span> DLedgerConfig();</span><br><span class="line">    dLedgerConfig.setEnableDiskForceClean(defaultMessageStore.getMessageStoreConfig().isCleanFileForciblyEnable());</span><br><span class="line">    dLedgerConfig.setStoreType(DLedgerConfig.FILE);</span><br><span class="line">    dLedgerConfig.setSelfId(defaultMessageStore.getMessageStoreConfig().getdLegerSelfId());</span><br><span class="line">    dLedgerConfig.setGroup(defaultMessageStore.getMessageStoreConfig().getdLegerGroup());</span><br><span class="line">    dLedgerConfig.setPeers(defaultMessageStore.getMessageStoreConfig().getdLegerPeers());</span><br><span class="line">    dLedgerConfig.setStoreBaseDir(defaultMessageStore.getMessageStoreConfig().getStorePathRootDir());</span><br><span class="line">    dLedgerConfig.setMappedFileSizeForEntryData(defaultMessageStore.getMessageStoreConfig().getMapedFileSizeCommitLog());</span><br><span class="line">    dLedgerConfig.setDeleteWhen(defaultMessageStore.getMessageStoreConfig().getDeleteWhen());</span><br><span class="line">    dLedgerConfig.setFileReservedHours(defaultMessageStore.getMessageStoreConfig().getFileReservedTime() + <span class="number">1</span>);  </span><br><span class="line">    id = Integer.valueOf(dLedgerConfig.getSelfId().substring(<span class="number">1</span>)) + <span class="number">1</span>;            <span class="comment">// @2</span></span><br><span class="line">    dLedgerServer = <span class="keyword">new</span> DLedgerServer(dLedgerConfig);                           <span class="comment">// @3</span></span><br><span class="line">    dLedgerFileStore = (DLedgerMmapFileStore) dLedgerServer.getdLedgerStore();</span><br><span class="line">    DLedgerMmapFileStore.AppendHook appendHook = (entry, buffer, bodyOffset) -&gt; &#123;</span><br><span class="line">            <span class="keyword">assert</span> bodyOffset == DLedgerEntry.BODY_OFFSET;</span><br><span class="line">            buffer.position(buffer.position() + bodyOffset + MessageDecoder.PHY_POS_POSITION);</span><br><span class="line">            buffer.putLong(entry.getPos() + bodyOffset);</span><br><span class="line">    &#125;;</span><br><span class="line">    dLedgerFileStore.addAppendHook(appendHook);   <span class="comment">// @4</span></span><br><span class="line">    dLedgerFileList = dLedgerFileStore.getDataFileList();</span><br><span class="line">    <span class="keyword">this</span>.messageSerializer = <span class="keyword">new</span> MessageSerializer(defaultMessageStore.getMessageStoreConfig().getMaxMessageSize());   <span class="comment">// @5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：调用父类 即 CommitLog 的构造函数，加载 ${ROCKETMQ_HOME}/store/ comitlog 下的 commitlog 文件，以便兼容升级 DLedger 的消息。我们稍微看一下 CommitLog 的构造函数：<br><img src="https://img-blog.csdnimg.cn/20191003120936564.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码@2：构建 DLedgerConfig 相关配置属性，其主要属性如下：</p>
<ul>
<li>enableDiskForceClean<br>是否强制删除文件，取自 broker 配置属性 cleanFileForciblyEnable，默认为 true 。</li>
<li>storeType<br>DLedger 存储类型，固定为 基于文件的存储模式。</li>
<li>dLegerSelfId<br>leader 节点的 id 名称，示例配置：n0，其配置要求第二个字符后必须是数字。</li>
<li>dLegerGroup<br>DLeger group 的名称，建议与 broker 配置属性 brokerName 保持一致。</li>
<li>dLegerPeers<br>DLeger Group 中所有的节点信息，其配置示例 n0-127.0.0.1:40911;n1-127.0.0.1:40912;n2-127.0.0.1:40913。多个节点使用分号隔开。</li>
<li>storeBaseDir<br>设置 DLedger 的日志文件的根目录，取自 borker 配件文件中的 storePathRootDir ，即 RocketMQ 的数据存储根路径。</li>
<li>mappedFileSizeForEntryData<br>设置 DLedger 的单个日志文件的大小，取自 broker 配置文件中的 - mapedFileSizeCommitLog，即与 commitlog 文件的单个文件大小一致。</li>
<li>deleteWhen<br>DLedger 日志文件的删除时间，取自 broker 配置文件中的 deleteWhen，默认为凌晨 4点。</li>
<li>fileReservedHours<br>DLedger 日志文件保留时长，取自 broker 配置文件中的 fileReservedHours，默认为 72h。</li>
</ul>
<p>代码@3：根据 DLedger 配置信息创建 DLedgerServer，即创建 DLedger 集群节点，集群内各个节点启动后，就会触发选主。</p>
<p>代码@4：构建 appendHook 追加钩子函数，这是兼容 Commitlog 文件很关键的一步，后面会详细介绍其作用。</p>
<p>代码@5：构建消息序列化。</p>
<p>根据上述的流程图，构建好 DefaultMessageStore 实现后，就是调用其 load 方法，在启用 DLedger 机制后，会依次调用 DLedgerCommitlog 的 load、recover 方法。</p>
<h3 id="3-3-load"><a href="#3-3-load" class="headerlink" title="3.3 load"></a>3.3 load</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">load</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">super</span>.load();</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DLedgerCommitLog 的 laod 方法实现比较简单，就是调用 其父类 Commitlog 的 load 方法，即这里也是为了启用 DLedger 时能够兼容以前的消息。</p>
<h3 id="3-4-recover"><a href="#3-4-recover" class="headerlink" title="3.4 recover"></a>3.4 recover</h3><p>在 Broker 启动时会加载 commitlog、consumequeue等文件，需要恢复其相关是数据结构，特别是与写入、刷盘、提交等指针，其具体调用 recover 方法。<br>DLedgerCommitLog#recover</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverNormally</span><span class="params">(<span class="keyword">long</span> maxPhyOffsetOfConsumeQueue)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    recover(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会先恢复 consumequeue，得出 consumequeue 中记录的最大有效物理偏移量，然后根据该物理偏移量进行恢复。<br>接下来看一下该方法的处理流程与关键点。</p>
<p>DLedgerCommitLog#recover</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">dLedgerFileStore.load();</span><br></pre></td></tr></table></figure>
<p>Step1：加载 DLedger  相关的存储文件，并一一构建对应的 MmapFile，其初始化三个重要的指针 wrotePosition、flushedPosition、committedPosition 三个指针为文件的大小。</p>
<p>DLedgerCommitLog#recover</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (dLedgerFileList.getMappedFiles().size() &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">    dLedgerFileStore.recover();   <span class="comment">// @1</span></span><br><span class="line">    dividedCommitlogOffset = dLedgerFileList.getFirstMappedFile().getFileFromOffset();     <span class="comment">// @2</span></span><br><span class="line">    MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;                                                                                                       <span class="comment">// @3</span></span><br><span class="line">        disableDeleteDledger();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> maxPhyOffset = dLedgerFileList.getMaxWrotePosition();</span><br><span class="line">    <span class="comment">// Clear ConsumeQueue redundant data</span></span><br><span class="line">    <span class="keyword">if</span> (maxPhyOffsetOfConsumeQueue &gt;= maxPhyOffset) &#123;      <span class="comment">// @4</span></span><br><span class="line">        log.warn(<span class="string">&quot;[TruncateCQ]maxPhyOffsetOfConsumeQueue(&#123;&#125;) &gt;= processOffset(&#123;&#125;), truncate dirty logic files&quot;</span>, maxPhyOffsetOfConsumeQueue, maxPhyOffset);</span><br><span class="line">        <span class="keyword">this</span>.defaultMessageStore.truncateDirtyLogicFiles(maxPhyOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果已存在  DLedger 的数据文件，则只需要恢复 DLedger 相关数据文建，因为在加载旧的 commitlog 文件时已经将其重要的数据指针设置为最大值。其关键实现点如下：</p>
<ul>
<li>首先调用 DLedger 文件存储实现类 DLedgerFileStore 的 recover 方法，恢复管辖的 MMapFile 对象(一个文件对应一个MMapFile实例)的相关指针，其实现方法与 RocketMQ 的 DefaultMessageStore 的恢复过程类似。</li>
<li>设置 dividedCommitlogOffset 的值为  DLedger 中所有物理文件的最小偏移量。操作消息的物理偏移量小于该值，则从 commitlog 文件中查找；物理偏移量大于等于该值的话则从 DLedger 相关的文件中查找消息。</li>
<li>如果存在旧的 commitlog 文件，则禁止删除 DLedger 文件，其具体做法就是禁止强制删除文件，并将文件的有效存储时间设置为 10 年。</li>
<li>如果 consumequeue 中存储的最大物理偏移量大于 DLedger 中最大的物理偏移量，则删除多余的 consumequeue 文件。</li>
</ul>
<blockquote>
<p>温馨提示：为什么当存在 commitlog 文件的情况下，不能删除 DLedger 相关的日志文件呢？</p>
<p>因为在此种情况下，如果 DLedger 中的物理文件有删除，则物理偏移量会断层。<br><img src="https://img-blog.csdnimg.cn/20191003143959204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正常情况下， maxCommitlogPhyOffset 与 dividedCommitlogOffset 是连续的，这样非常方便是访问 commitlog 还是 访问 DLedger ，但如果DLedger 部分文件删除后，这两个值就变的不连续，就会造成中间的文件空洞，无法被连续访问。</p>
</blockquote>
<p>DLedgerCommitLog#recover</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isInrecoveringOldCommitlog = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">super</span>.recoverNormally(maxPhyOffsetOfConsumeQueue);</span><br><span class="line">isInrecoveringOldCommitlog = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>Step3：如果启用了 DLedger 并且是初次启动(还未生成 DLedger 相关的日志文件)，则需要恢复 旧的 commitlog 文件。</p>
<p>DLedgerCommitLog#recover</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line"><span class="keyword">if</span> (mappedFile == <span class="keyword">null</span>) &#123;           <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">ByteBuffer byteBuffer =  mappedFile.sliceByteBuffer();</span><br><span class="line">byteBuffer.position(mappedFile.getWrotePosition());</span><br><span class="line"><span class="keyword">boolean</span> needWriteMagicCode = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 1 TOTAL SIZE</span></span><br><span class="line">byteBuffer.getInt(); <span class="comment">//size</span></span><br><span class="line"><span class="keyword">int</span> magicCode = byteBuffer.getInt();</span><br><span class="line"><span class="keyword">if</span> (magicCode == CommitLog.BLANK_MAGIC_CODE) &#123;   <span class="comment">// @2</span></span><br><span class="line">    needWriteMagicCode = <span class="keyword">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">&quot;Recover old commitlog found a illegal magic code=&#123;&#125;&quot;</span>, magicCode);</span><br><span class="line">&#125;</span><br><span class="line">dLedgerConfig.setEnableDiskForceClean(<span class="keyword">false</span>);</span><br><span class="line">dividedCommitlogOffset = mappedFile.getFileFromOffset() + mappedFile.getFileSize();   <span class="comment">// @3</span></span><br><span class="line">log.info(<span class="string">&quot;Recover old commitlog needWriteMagicCode=&#123;&#125; pos=&#123;&#125; file=&#123;&#125; dividedCommitlogOffset=&#123;&#125;&quot;</span>, needWriteMagicCode, mappedFile.getFileFromOffset() + mappedFile.getWrotePosition(), mappedFile.getFileName(), dividedCommitlogOffset);</span><br><span class="line"><span class="keyword">if</span> (needWriteMagicCode) &#123;  <span class="comment">// @4</span></span><br><span class="line">    byteBuffer.position(mappedFile.getWrotePosition());</span><br><span class="line">    byteBuffer.putInt(mappedFile.getFileSize() - mappedFile.getWrotePosition());</span><br><span class="line">    byteBuffer.putInt(BLANK_MAGIC_CODE);</span><br><span class="line">    mappedFile.flush(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">mappedFile.setWrotePosition(mappedFile.getFileSize());   <span class="comment">// @5</span></span><br><span class="line">mappedFile.setCommittedPosition(mappedFile.getFileSize());</span><br><span class="line">mappedFile.setFlushedPosition(mappedFile.getFileSize());</span><br><span class="line">dLedgerFileList.getLastMappedFile(dividedCommitlogOffset);</span><br><span class="line">log.info(<span class="string">&quot;Will set the initial commitlog offset=&#123;&#125; for dledger&quot;</span>, dividedCommitlogOffset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：如果存在旧的 commitlog 文件，需要将最后的文件剩余部分全部填充，即不再接受新的数据写入，新的数据全部写入到 DLedger 的数据文件中。其关键实现点如下：</p>
<ul>
<li>尝试查找最后一个 commitlog 文件，如果未找到，则结束。</li>
<li>从最后一个文件的最后写入点(原 commitlog 文件的 待写入位点)尝试去查找写入的魔数，如果存在魔数并等于 CommitLog.BLANK_MAGIC_CODE，则无需再写入魔数，在升级 DLedger 第一次启动时，魔数为空，故需要写入魔数。</li>
<li>初始化 dividedCommitlogOffset ，等于最后一个文件的起始偏移量加上文件的大小，即该指针指向最后一个文件的结束位置。</li>
<li>将最后一个 commitlog 未写满的数据全部写入，其方法为 设置消息体的 size 与 魔数即可。</li>
<li>设置最后一个文件的 wrotePosition、flushedPosition、committedPosition  为文件的大小，同样有意味者最后一个文件已经写满，下一条消息将写入 DLedger 中。</li>
</ul>
<p>在启用 DLedger 机制时 Broker 的启动流程就介绍到这里了，相信大家已经了解 DLedger 在整合 RocketMQ 上做的努力，接下来我们从消息追加、消息读取两个方面再来探讨  DLedger 是如何无缝整合 RocketMQ 的，实现平滑升级的。</p>
<h2 id="4、从消息追加看-DLedger-整合-RocketMQ-如何实现无缝兼容"><a href="#4、从消息追加看-DLedger-整合-RocketMQ-如何实现无缝兼容" class="headerlink" title="4、从消息追加看 DLedger 整合 RocketMQ 如何实现无缝兼容"></a>4、从消息追加看 DLedger 整合 RocketMQ 如何实现无缝兼容</h2><blockquote>
<p>温馨提示：本节同样也不会详细介绍整个消息追加(存储流程)，只是要点出与 DLedger(多副本、主从切换)相关的核心关键点。如果想详细了解消息追加的流程，可以阅读笔者所著的《RocketMQ技术内幕》一书。</p>
</blockquote>
<p>DLedgerCommitLog#putMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AppendEntryRequest request = <span class="keyword">new</span> AppendEntryRequest();</span><br><span class="line">request.setGroup(dLedgerConfig.getGroup());</span><br><span class="line">request.setRemoteId(dLedgerServer.getMemberState().getSelfId());</span><br><span class="line">request.setBody(encodeResult.data);</span><br><span class="line">dledgerFuture = (AppendFuture&lt;AppendEntryResponse&gt;) dLedgerServer.handleAppend(request);</span><br><span class="line"><span class="keyword">if</span> (dledgerFuture.getPos() == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PutMessageResult(PutMessageStatus.OS_PAGECACHE_BUSY, <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.UNKNOWN_ERROR));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键点一：消息追加时，则不再写入到原先的 commitlog 文件中，而是调用 DLedgerServer 的 handleAppend 进行消息追加，该方法会有集群内的 Leader 节点负责消息追加以及在消息复制，只有超过集群内的半数节点成功写入消息后，才会返回写入成功。如果追加成功，将会返回本次追加成功后的起始偏移量，即 pos 属性，即类似于 rocketmq 中 commitlog 的偏移量，即物理偏移量。</p>
<p>DLedgerCommitLog#putMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> wroteOffset =  dledgerFuture.getPos() + DLedgerEntry.BODY_OFFSET;</span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(MessageDecoder.MSG_ID_LENGTH);</span><br><span class="line">String msgId = MessageDecoder.createMessageId(buffer, msg.getStoreHostBytes(), wroteOffset);</span><br><span class="line">eclipseTimeInLock = <span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - beginTimeInDledgerLock;</span><br><span class="line">appendResult = <span class="keyword">new</span> AppendMessageResult(AppendMessageStatus.PUT_OK, wroteOffset, encodeResult.data.length, msgId, System.currentTimeMillis(), queueOffset, eclipseTimeInLock);</span><br></pre></td></tr></table></figure>
<p>关键点二：根据 DLedger 的起始偏移量计算真正的消息的物理偏移量，从开头部分得知，DLedger 自身有其存储协议，其 body 字段存储真实的消息，即 commitlog 条目的存储结构，返回给客户端的消息偏移量为  body  字段的开始偏移量，即通过 putMessage 返回的物理偏移量与不使用Dledger 方式返回的物理偏移量的含义是一样的，即从开偏移量开始，可以正确读取消息，这样 DLedger 完美的兼容了 RocketMQ Commitlog。关于 pos 以及 wroteOffset 的图解如下：<br><img src="https://img-blog.csdnimg.cn/20191003152522946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="5、从消息读取看-DLedger-整合-RocketMQ-如何实现无缝兼容"><a href="#5、从消息读取看-DLedger-整合-RocketMQ-如何实现无缝兼容" class="headerlink" title="5、从消息读取看 DLedger 整合 RocketMQ 如何实现无缝兼容"></a>5、从消息读取看 DLedger 整合 RocketMQ 如何实现无缝兼容</h2><p>DLedgerCommitLog#getMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SelectMappedBufferResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; dividedCommitlogOffset) &#123;   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getMessage(offset, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mappedFileSize = <span class="keyword">this</span>.dLedgerServer.getdLedgerConfig().getMappedFileSizeForEntryData();</span><br><span class="line">    MmapFile mappedFile = <span class="keyword">this</span>.dLedgerFileList.findMappedFileByOffset(offset, offset == <span class="number">0</span>);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = (<span class="keyword">int</span>) (offset % mappedFileSize);</span><br><span class="line">        <span class="keyword">return</span>  convertSbr(mappedFile.selectMappedBuffer(pos, size));                                       <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息查找比较简单，因为返回给客户端消息，转发给 consumequeue 的消息物理偏移量并不是  DLedger 条目的偏移量，而是真实消息的起始偏移量。其实现关键点如下：</p>
<ul>
<li>如果查找的物理偏移量小于 dividedCommitlogOffset，则从原先的 commitlog 文件中查找。</li>
<li>然后根据物理偏移量按照二分方找到具体的物理文件。</li>
<li>对物理偏移量取模，得出在该物理文件中中的绝对偏移量，进行消息查找即可，因为只有知道其物理偏移量，从该处先将消息的长度读取出来，然后即可读出一条完整的消息。</li>
</ul>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>根据上面详细的介绍，我想读者朋友们应该不难得出如下结论：</p>
<ul>
<li>DLedger 在整合时，使用 DLedger 条目包裹 RocketMQ 中的 commitlog 条目，即在  DLedger 条目的 body 字段来存储整条 commitlog 条目。</li>
<li>引入 dividedCommitlogOffset 变量，表示物理偏移量小于该值的消息存在于旧的 commitlog 文件中，实现 升级 DLedger 集群后能访问到旧的数据。</li>
<li>新 DLedger 集群启动后，会将最后一个 commitlog 填充，即新的数据不会再写入到 原先的 commitlog 文件。</li>
<li>消息追加到 DLedger 数据日志文件中，返回的偏移量不是 DLedger 条目的起始偏移量，而是DLedger 条目中 body 字段的起始偏移量，即真实消息的起始偏移量，保证消息物理偏移量的语义与 RocketMQ Commitlog一样。</li>
</ul>
<p>RocketMQ 整合 DLedger(多副本)实现平滑升级的设计技巧就介绍到这里了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>主从同步</tag>
        <tag>多副本</tag>
        <tag>raft</tag>
        <tag>源码阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ一个新的消费组初次启动时从何处开始消费呢？</title>
    <url>/posts/9502f6ef.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、抛出问题"><a href="#1、抛出问题" class="headerlink" title="1、抛出问题"></a>1、抛出问题</h2><p>一个新的消费组订阅一个已存在的Topic主题时，消费组是从该Topic的哪条消息开始消费呢？</p>
<p>首先翻阅DefaultMQPushConsumer的API时，setConsumeFromWhere(ConsumeFromWhere consumeFromWhere)API映入眼帘，从字面意思来看是设置消费者从哪里开始消费，正是解开该问题的”钥匙“。ConsumeFromWhere枚举类图如下：<br><img src="https://img-blog.csdnimg.cn/20190720120834686.png" alt="在这里插入图片描述"></p>
<ul>
<li>CONSUME_FROM_MAX_OFFSET<br>从消费队列最大的偏移量开始消费。</li>
<li>CONSUME_FROM_FIRST_OFFSET<br>从消费队列最小偏移量开始消费。</li>
<li>CONSUME_FROM_TIMESTAMP<br>从指定的时间戳开始消费，默认为消费者启动之前的30分钟处开始消费。可以通过DefaultMQPushConsumer#setConsumeTimestamp。</li>
</ul>
<p>是不是点小激动，还不快试试。</p>
<p>需求：新的消费组启动时，从队列最后开始消费，即只消费启动后发送到消息服务器后的最新消息。</p>
<h3 id="1-1-环境准备"><a href="#1-1-环境准备" class="headerlink" title="1.1 环境准备"></a>1.1 环境准备</h3><p>本示例所用到的Topic路由信息如下：<br><img src="https://img-blog.csdnimg.cn/20190720120920850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>Broker的配置如下(broker.conf)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brokerClusterName &#x3D; DefaultCluster</span><br><span class="line">brokerName &#x3D; broker-a</span><br><span class="line">brokerId &#x3D; 0</span><br><span class="line">deleteWhen &#x3D; 04</span><br><span class="line">fileReservedTime &#x3D; 48</span><br><span class="line">brokerRole &#x3D; ASYNC_MASTER</span><br><span class="line">flushDiskType &#x3D; ASYNC_FLUSH</span><br><span class="line"></span><br><span class="line">storePathRootDir&#x3D;E:&#x2F;SH2019&#x2F;tmp&#x2F;rocketmq_home&#x2F;rocketmq4.5_simple&#x2F;store</span><br><span class="line">storePathCommitLog&#x3D;E:&#x2F;SH2019&#x2F;tmp&#x2F;rocketmq_home&#x2F;rocketmq4.5_simple&#x2F;store&#x2F;commitlog</span><br><span class="line">namesrvAddr&#x3D;127.0.0.1:9876</span><br><span class="line">autoCreateTopicEnable&#x3D;false</span><br><span class="line">mapedFileSizeCommitLog&#x3D;10240</span><br><span class="line">mapedFileSizeConsumeQueue&#x3D;2000</span><br></pre></td></tr></table></figure>
<p>其中重点修改了如下两个参数：</p>
<ul>
<li>mapedFileSizeCommitLog<br>单个commitlog文件的大小，这里使用10M，方便测试用。</li>
<li>mapedFileSizeConsumeQueue<br>单个consumequeue队列长度，这里使用1000，表示一个consumequeue文件中包含1000个条目。</li>
</ul>
<h3 id="1-2-消息发送者代码"><a href="#1-2-消息发送者代码" class="headerlink" title="1.2 消息发送者代码"></a>1.2 消息发送者代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">    DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;please_rename_unique_group_name&quot;</span>);</span><br><span class="line">    producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">    producer.start();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span> ,<span class="string">&quot;TagA&quot;</span> , (<span class="string">&quot;Hello RocketMQ &quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">            SendResult sendResult = producer.send(msg);</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    producer.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上述，往TopicTest发送300条消息，发送完毕后，RocketMQ Broker存储结构如下：<br><img src="https://img-blog.csdnimg.cn/20190720121132299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-3-消费端验证代码"><a href="#1-3-消费端验证代码" class="headerlink" title="1.3 消费端验证代码"></a>1.3 消费端验证代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;my_consumer_01&quot;</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行上述代码后，按照期望，应该是不会消费任何消息，只有等生产者再发送消息后，才会对消息进行消费，事实是这样吗？执行效果如图所示：<br><img src="https://img-blog.csdnimg.cn/20190720121225978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><strong>令人意外的是，竟然从队列的最小偏移量开始消费了</strong>，这就“尴尬”了。难不成是RocketMQ的Bug。带着这个疑问，从源码的角度尝试来解读该问题，并指导我们实践。</p>
<a id="more"></a>

<h2 id="2、探究CONSUME-FROM-MAX-OFFSET实现原理"><a href="#2、探究CONSUME-FROM-MAX-OFFSET实现原理" class="headerlink" title="2、探究CONSUME_FROM_MAX_OFFSET实现原理"></a>2、探究CONSUME_FROM_MAX_OFFSET实现原理</h2><p>对于一个新的消费组，无论是集群模式还是广播模式都不会存储该消费组的消费进度，可以理解为-1,此时就需要根据DefaultMQPushConsumer#consumeFromWhere属性来决定其从何处开始消费，首先我们需要找到其对应的处理入口。我们知道，消息消费者从Broker服务器拉取消息时，需要进行消费队列的负载，即RebalanceImpl。</p>
<blockquote>
<p>温馨提示：本文不会详细介绍RocketMQ消息队列负载、消息拉取、消息消费逻辑，只会展示出通往该问题的简短流程，如想详细了解消息消费具体细节，建议购买笔者出版的《RocketMQ技术内幕》书籍。</p>
</blockquote>
<p>RebalancePushImpl#computePullFromWhere</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">computePullFromWhere</span><span class="params">(MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = -<span class="number">1</span>;                                                                                                                                                                                                                  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">final</span> ConsumeFromWhere consumeFromWhere = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();    </span><br><span class="line">        <span class="keyword">final</span> OffsetStore offsetStore = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore();</span><br><span class="line">        <span class="keyword">switch</span> (consumeFromWhere) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_MIN_OFFSET:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_MAX_OFFSET:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET: &#123;                                                                                                                                                                <span class="comment">// @2</span></span><br><span class="line">               <span class="comment">// 省略部分代码</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;                                                                                                                                                              <span class="comment">// @3</span></span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_TIMESTAMP: &#123;                                                                                                                                                                  <span class="comment">//@4</span></span><br><span class="line">                <span class="comment">// 省略部分代码</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;                                                                                                                                                                                                                  <span class="comment">// @5</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先解释几个局部变量。</p>
<ul>
<li>result<br>最终的返回结果，默认为-1。</li>
<li>consumeFromWhere<br>消息消费者开始消费的策略，即CONSUME_FROM_LAST_OFFSET等。</li>
<li>offsetStore<br>offset存储器，消费组消息偏移量存储实现器。</li>
</ul>
<p>代码@2：CONSUME_FROM_LAST_OFFSET(从队列的最大偏移量开始消费)的处理逻辑，下文会详细介绍。</p>
<p>代码@3：CONSUME_FROM_FIRST_OFFSET(从队列最小偏移量开始消费)的处理逻辑，下文会详细介绍。</p>
<p>代码@4：CONSUME_FROM_TIMESTAMP(从指定时间戳开始消费)的处理逻辑，下文会详细介绍。</p>
<p>代码@5：返回最后计算的偏移量，从该偏移量出开始消费。</p>
<h3 id="2-1-CONSUME-FROM-LAST-OFFSET计算逻辑"><a href="#2-1-CONSUME-FROM-LAST-OFFSET计算逻辑" class="headerlink" title="2.1 CONSUME_FROM_LAST_OFFSET计算逻辑"></a>2.1 CONSUME_FROM_LAST_OFFSET计算逻辑</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET: &#123;</span><br><span class="line">    <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;                                                                                                             <span class="comment">// @2</span></span><br><span class="line">        result = lastOffset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// First start,no offset</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;                                                                                                  <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;               </span><br><span class="line">            result = <span class="number">0L</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);                     </span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException e) &#123;                                                                              <span class="comment">// @4</span></span><br><span class="line">                result = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = -<span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：使用offsetStore从消息消费进度文件中读取消费消费进度，本文将以集群模式为例展开。稍后详细分析。</p>
<p>代码@2：如果返回的偏移量大于等于0，则直接使用该offset，这个也能理解，大于等于0，表示查询到有效的消息消费进度，从该有效进度开始消费，但我们要特别留意lastOffset为0是什么场景，因为返回0，并不会执行CONSUME_FROM_LAST_OFFSET(语义)。</p>
<p>代码@3：如果lastOffset为-1,表示当前并未存储其有效偏移量，可以理解为第一次消费，如果是消费组重试主题，从重试队列偏移量为0开始消费；如果是普通主题，则从队列当前的最大的有效偏移量开始消费，即CONSUME_FROM_LAST_OFFSET语义的实现。</p>
<p>代码@4：如果从远程服务拉取最大偏移量拉取异常或其他情况，则使用-1作为第一次拉取偏移量。</p>
<p><strong>分析，上述执行的现象，虽然设置的是CONSUME_FROM_LAST_OFFSET，但现象是从队列的第一条消息开始消费，根据上述源码的分析，只有从消费组消费进度存储文件中取到的消息偏移量为0时，才会从第一条消息开始消费，故接下来重点分析消息消费进度存储器(OffsetStore)在什么情况下会返回0。</strong></p>
<p>接下来我们将以集群模式来查看一下消息消费进度的查询逻辑，集群模式的消息进度存储管理器实现为：<br>RemoteBrokerOffsetStore,最终Broker端的命令处理类为：ConsumerManageProcessor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsumerManageProcessor#queryConsumerOffset</span><br><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">queryConsumerOffset</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> RemotingCommand response =</span><br><span class="line">        RemotingCommand.createResponseCommand(QueryConsumerOffsetResponseHeader.class);</span><br><span class="line">    <span class="keyword">final</span> QueryConsumerOffsetResponseHeader responseHeader =</span><br><span class="line">        (QueryConsumerOffsetResponseHeader) response.readCustomHeader();</span><br><span class="line">    <span class="keyword">final</span> QueryConsumerOffsetRequestHeader requestHeader =</span><br><span class="line">        (QueryConsumerOffsetRequestHeader) request</span><br><span class="line">            .decodeCommandCustomHeader(QueryConsumerOffsetRequestHeader.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> offset =</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().queryOffset(</span><br><span class="line">            requestHeader.getConsumerGroup(), requestHeader.getTopic(), requestHeader.getQueueId());    <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offset &gt;= <span class="number">0</span>) &#123;                                                                                                                                          <span class="comment">// @2</span></span><br><span class="line">        responseHeader.setOffset(offset);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                                                                                                                       <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">long</span> minOffset =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getMessageStore().getMinOffsetInQueue(requestHeader.getTopic(),</span><br><span class="line">                requestHeader.getQueueId());                                                                                                     <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (minOffset &lt;= <span class="number">0</span></span><br><span class="line">            &amp;&amp; !<span class="keyword">this</span>.brokerController.getMessageStore().checkInDiskByConsumeOffset(                                <span class="comment">// @5</span></span><br><span class="line">            requestHeader.getTopic(), requestHeader.getQueueId(), <span class="number">0</span>)) &#123;</span><br><span class="line">            responseHeader.setOffset(<span class="number">0L</span>);</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                                                                                                                                 <span class="comment">// @6</span></span><br><span class="line">            response.setCode(ResponseCode.QUERY_NOT_FOUND);</span><br><span class="line">            response.setRemark(<span class="string">&quot;Not found, V3_0_6_SNAPSHOT maybe this group consumer boot first&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：从消费消息进度文件中查询消息消费进度。</p>
<p>代码@2：如果消息消费进度文件中存储该队列的消息进度，其返回的offset必然会大于等于0，则直接返回该偏移量该客户端，客户端从该偏移量开始消费。</p>
<p>代码@3：如果未从消息消费进度文件中查询到其进度，offset为-1。则首先获取该主题、消息队列当前在Broker服务器中的最小偏移量(@4)。如果小于等于0(返回0则表示该队列的文件还未曾删除过)并且其最小偏移量对应的消息存储在内存中而不是存在磁盘中，则返回偏移量0，这就意味着ConsumeFromWhere中定义的三种枚举类型都不会生效，直接从0开始消费，到这里就能解开其谜团了(@5)。</p>
<p>代码@6：如果偏移量小于等于0，但其消息已经存储在磁盘中，此时返回未找到，最终RebalancePushImpl#computePullFromWhere中得到的偏移量为-1。</p>
<p>看到这里，大家应该能回答文章开头处提到的问题了吧？</p>
<p><strong>看到这里，大家应该明白了，为什么设置的CONSUME_FROM_LAST_OFFSET，但消费组是从消息队列的开始处消费了吧，原因就是消息消费进度文件中并没有找到其消息消费进度，并且该队列在Broker端的最小偏移量为0，说的更直白点，consumequeue/topicName/queueNum的第一个消息消费队列文件为00000000000000000000,并且消息其对应的消息缓存在Broker端的内存中(pageCache)，其返回给消费端的偏移量为0，故会从0开始消费，而不是从队列的最大偏移量处开始消费。</strong></p>
<p>为了知识体系的完备性，我们顺便来看一下其他两种策略的计算逻辑。</p>
<h3 id="2-2-CONSUME-FROM-FIRST-OFFSET"><a href="#2-2-CONSUME-FROM-FIRST-OFFSET" class="headerlink" title="2.2 CONSUME_FROM_FIRST_OFFSET"></a>2.2 CONSUME_FROM_FIRST_OFFSET</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;</span><br><span class="line">    <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;    <span class="comment">// @2</span></span><br><span class="line">        result = lastOffset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;  <span class="comment">// @3</span></span><br><span class="line">        result = <span class="number">0L</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                  </span><br><span class="line">        result = -<span class="number">1</span>;                    <span class="comment">// @4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从队列的开始偏移量开始消费，其计算逻辑如下：<br>代码@1：首先通过偏移量存储器查询消费队列的消费进度。</p>
<p>代码@2：如果大于等于0，则从当前该偏移量开始消费。</p>
<p>代码@3：如果远程返回-1，表示并没有存储该队列的消息消费进度，从0开始。</p>
<p>代码@4：否则从-1开始消费。</p>
<h3 id="2-4-CONSUME-FROM-TIMESTAMP"><a href="#2-4-CONSUME-FROM-TIMESTAMP" class="headerlink" title="2.4 CONSUME_FROM_TIMESTAMP"></a>2.4 CONSUME_FROM_TIMESTAMP</h3><p>从指定时戳后的消息开始消费。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> CONSUME_FROM_TIMESTAMP: &#123;</span><br><span class="line">    ong lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;                                                                                                            <span class="comment">// @2</span></span><br><span class="line">        result = lastOffset;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;                                                                                                 <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                result = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> timestamp = UtilAll.parseDate(<span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),</span><br><span class="line">                    UtilAll.YYYYMMDDHHMMSS).getTime();</span><br><span class="line">                result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                result = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其基本套路与CONSUME_FROM_LAST_OFFSET一样：<br>代码@1：首先通过偏移量存储器查询消费队列的消费进度。</p>
<p>代码@2：如果大于等于0，则从当前该偏移量开始消费。</p>
<p>代码@3：如果远程返回-1，表示并没有存储该队列的消息消费进度，如果是重试主题，则从当前队列的最大偏移量开始消费，如果是普通主题，则根据时间戳去Broker端查询，根据查询到的偏移量开始消费。</p>
<p>原理就介绍到这里，下面根据上述理论对其进行验证。</p>
<h2 id="3、猜想与验证"><a href="#3、猜想与验证" class="headerlink" title="3、猜想与验证"></a>3、猜想与验证</h2><p>根据上述理论分析我们得知设置CONSUME_FROM_LAST_OFFSET但并不是从消息队列的最大偏移量开始消费的“罪魁祸首”是因为消息消费队列的最小偏移量为0，如果不为0，则就会符合预期，我们来验证一下这个猜想。<br>首先我们删除commitlog目录下的文件，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190720121720399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其消费队列截图如下：<br><img src="https://img-blog.csdnimg.cn/20190720121738795.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>消费端的验证代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, MQClientException </span>&#123;</span><br><span class="line">    DefaultMQPushConsumer consumer = <span class="keyword">new</span> DefaultMQPushConsumer(<span class="string">&quot;my_consumer_02&quot;</span>);</span><br><span class="line">    consumer.setConsumeFromWhere(ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET);</span><br><span class="line">    consumer.subscribe(<span class="string">&quot;TopicTest&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    consumer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">    consumer.registerMessageListener(<span class="keyword">new</span> MessageListenerConcurrently() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ConsumeConcurrentlyStatus <span class="title">consumeMessage</span><span class="params">(List&lt;MessageExt&gt; msgs,</span></span></span><br><span class="line"><span class="function"><span class="params">            ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s Receive New Messages: %s %n&quot;</span>, Thread.currentThread().getName(), msgs);</span><br><span class="line">            <span class="keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    consumer.start();</span><br><span class="line">    System.out.printf(<span class="string">&quot;Consumer Started.%n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720121811440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>并没有消息存在的消息，符合预期。</p>
<h2 id="4、解决方案"><a href="#4、解决方案" class="headerlink" title="4、解决方案"></a>4、解决方案</h2><p>如果在生产环境下，一个新的消费组订阅一个已经存在比较久的topic，设置CONSUME_FROM_MAX_OFFSET是符合预期的，即该主题的consumequeue/{queueNum}/fileName，fileName通常不会是00000000000000000000，如是是上面文件名，想要实现从队列的最后开始消费，该如何做呢？那就走自动创建消费组的路子，执行如下命令：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./mqadmin updateSubGroup -n 127.0.0.1:9876 -c DefaultCluster -g my_consumer_05</span><br><span class="line"></span><br><span class="line">//克隆一个订阅了该topic的消费组消费进度</span><br><span class="line">./mqadmin cloneGroupOffset -n 127.0.0.1:9876 -s my_consumer_01 -d my_consumer_05 -t TopicTest</span><br><span class="line"></span><br><span class="line">//重置消费进度到当前队列的最大值</span><br><span class="line">./mqadmin resetOffsetByTime -n 127.0.0.1:9876 -g my_consumer_05 -t TopicTest -s -1</span><br></pre></td></tr></table></figure>
<p>按照上上述命令后，即可实现其目的。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>CONSUME_FROM_TIMESTAMP</tag>
        <tag>ConsumeFromWhere</tag>
        <tag>CONSUME_FROM_MAX_OFFSET</tag>
        <tag>CONSUME_FROM_FIRST_OFFSET</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel FlowSlot 限流实现原理(文末附流程图与总结)</title>
    <url>/posts/d83864c8.html</url>
    <content><![CDATA[<div id="vip-container"><p>Sentinel 触发限流的实现类为 FlowSlot。我们再来简单思考一下，要实现触发限流，至少需要完成如下几件事情：</p>
<ul>
<li>收集实时调用信息。</li>
<li>设置触发限流规则</li>
<li>根据限流规则与调用信息来决定是否对请求进行限流等。</li>
</ul>
<p>如何收集实时调用信息在前面的文章中已详细介绍，请带着上述问题开始本节的探讨。</p>
<h2 id="1、初始-FlowSlot"><a href="#1、初始-FlowSlot" class="headerlink" title="1、初始 FlowSlot"></a>1、初始 FlowSlot</h2><p>我们先从 FlotSlot 类的注释来简单认识一下流量控制相关的内容。</p>
<ul>
<li>根据已（NodeSelectorSlot、ClusterNodeBuilderSlot 和 StatisticSlot）收集的运行时统计信息，FlowSlot将使用预先设置的规则来决定是否应阻止传入请求。</li>
<li>SphU.entry(resourceName)调用时，如果有任意一条规则被触发则会抛出 FlowException 异常，应用程序可捕捉该异常对业务进行定制化处理。</li>
<li>每一条流控规则(FlowRule)都包含三个要素：流控类别、基于调用链的流控制策略、限流后的处理行为(参考FlowRule相关的注释)。<ul>
<li><pre><code>grade 流量控制的阈值类型</code></pre>
可选值：QPS(基于QPS限流策略)、并发线程数。</li>
<li>strategy 基于调用链的流控制策略<br>可选值：STRATEGY_DIRECT(根据调用方限流策略)、STRATEGY_RELATE(关联流量限<br>流策略)、STRATEGY_CHAIN(根据调用链入口限流策略)</li>
<li>controlBehavior 流量控制后的采取的行为<br>CONTROL_BEHAVIOR_DEFAULT(直接拒绝)、CONTROL_BEHAVIOR_WARM_UP(预热)、CONTROL_BEHAVIOR_RATE_LIMITER(匀速排队)、<br>CONTROL_BEHAVIOR_WARM_UP_RATE_LIMITER(预热与匀速排队)。</li>
</ul>
</li>
</ul>
<h2 id="2、FlowSlot-详解"><a href="#2、FlowSlot-详解" class="headerlink" title="2、FlowSlot 详解"></a>2、FlowSlot 详解</h2><h4 id="2-1-FlowSlot-类图"><a href="#2-1-FlowSlot-类图" class="headerlink" title="2.1 FlowSlot 类图"></a>2.1 FlowSlot 类图</h4><p><img src="https://img-blog.csdnimg.cn/20200315193331252.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>FlowSlot 的类图非常简单，内部持有一个成员变量，FlowRuleChecker，用来判断是否满足流控触发条件。</p>
<p>在继续探讨 Sentinel 限流之前，我们先来了解一下 FlowRule，即认识一下 Sentienl 流控规则主要包含哪些配置项，为后续的流程做一个消息的准备。</p>
<h4 id="2-2-FlowRule-配置项"><a href="#2-2-FlowRule-配置项" class="headerlink" title="2.2 FlowRule 配置项"></a>2.2 FlowRule 配置项</h4><p>FlowRule 的类体系如图所示：<br><img src="https://img-blog.csdnimg.cn/20200315193402645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其属性的含义如下：</p>
<ul>
<li>String resource<br>资源的名称。</li>
<li>String limitApp<br>需要限制的调用来源，对应【新增流控规则界面】的针对来源。</li>
<li>int grade<br>流量控制的阈值类型，目前支持 QPS 与 并发线程数，对应 【新增流控规则界面】的阔值类型。</li>
<li>int strategy<br>基于调用链的流量控制策略，对应【新增流控规则界面】的流控模式，其可选取值在本文开头部分有详细介绍。</li>
<li>String refResource<br>关联资源或入口资源，当流控模式为关联或链路时配置的关联资源或入口资源，对应【新增流控规则界面】的【入口资源】</li>
<li>int controlBehavior<br>流量控制后的采取的行为，其可选取值在本文开头部分有详细介绍，对应【新增流控规则界面】的流控效果。</li>
<li>int warmUpPeriodSec<br>预热时间，如果 controlBehavior 设置为预热(warm up)时，可以配置其预热时间，在【新增流控规则界面】中选择 warm up 类型后，会增加一行，供用户配置，默认值 10s。</li>
<li>int maxQueueingTimeMs<br>最大超时时间，如果 controlBehavior 设置为排队等待时，等待的最大超时时间，默认为500ms。</li>
<li>boolean clusterMode<br>是否是集群限流模式，对应【新增流控规则界面】的是否集群。</li>
<li>ClusterFlowConfig clusterConfig<br>集群扩容相关配置，集群限流将在后续文章中重点介绍。</li>
</ul>
<p>在 sentinel-dashboard 的配置界面如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200315193551464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h4 id="2-3-FlowSlot-entry-流程详解"><a href="#2-3-FlowSlot-entry-流程详解" class="headerlink" title="2.3 FlowSlot#entry 流程详解"></a>2.3 FlowSlot#entry 流程详解</h4><p>FlowSlot#entry</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">entry</span><span class="params">(Context context, ResourceWrapper resourceWrapper, DefaultNode node, <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> prioritized, Object... args)</span> <span class="keyword">throws</span> Throwable </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    checkFlow(resourceWrapper, context, node, count, prioritized);       <span class="comment">// @2</span></span><br><span class="line">    fireEntry(context, resourceWrapper, node, count, prioritized, args);  <span class="comment">// @3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先来解释一下该方法的参数：</p>
<ul>
<li>Context context<br>当前 Sentinel 调用的上下文。</li>
<li>ResourceWrapper resourceWrapper<br>当前访问的资源。</li>
<li>DefaultNode node<br>当前上下文环境对应的节点。</li>
<li>int count<br>本次调用需要消耗的“令牌”个数</li>
<li>boolean prioritized<br>是否是高优先级。</li>
<li>Object… args<br>额外参数。</li>
</ul>
<p>代码@2：调用 checkFlow ，根据配置的限流规则，结合实时统计信息，判断是否满足流控条件，如果满足，则触发流控，稍后会详细探讨该方法的实现原理。</p>
<p>代码@3：调用 fireEntry 继续沿着 slot 链进行传播。</p>
<p>FlowSlot 的 checkFlow 方法在内部就是直接调用 FlowRuleChecker 的 checkFlow 方法，故我们将目光放到 FlowRuleChecker 中。</p>
<h4 id="2-4-FlowRuleChecker-checkFlow-方法详解"><a href="#2-4-FlowRuleChecker-checkFlow-方法详解" class="headerlink" title="2.4 FlowRuleChecker checkFlow 方法详解"></a>2.4 FlowRuleChecker checkFlow 方法详解</h4><p>FlowRuleChecker#checkFlow</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkFlow</span><span class="params">(Function&lt;String, Collection&lt;FlowRule&gt;&gt; ruleProvider, ResourceWrapper resource,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Context context, DefaultNode node, <span class="keyword">int</span> count, <span class="keyword">boolean</span> prioritized)</span> <span class="keyword">throws</span> BlockException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ruleProvider == <span class="keyword">null</span> || resource == <span class="keyword">null</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Collection&lt;FlowRule&gt; rules = ruleProvider.apply(resource.getName());   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (rules != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (FlowRule rule : rules) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!canPassCheck(rule, context, node, count, prioritized)) &#123;            <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FlowException(rule.getLimitApp(), rule);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：通过限流规则提供器获取与该资源相关的流控规则列表。</p>
<p>代码@2：然后遍历流控规则列表，通过调用 canPassCheck 方法来判断是否满足该规则设置的条件，如果满足流控规则，则抛出 FlowException，即只需要满足一个即结束校验。</p>
<p>接下来继续查看 canPassCheck 方法。</p>
<h5 id="2-4-1-FlowRuleChecker-canPassCheck-详解"><a href="#2-4-1-FlowRuleChecker-canPassCheck-详解" class="headerlink" title="2.4.1 FlowRuleChecker canPassCheck 详解"></a>2.4.1 FlowRuleChecker canPassCheck 详解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPassCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, </span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    String limitApp = rule.getLimitApp(); </span><br><span class="line">    <span class="keyword">if</span> (limitApp == <span class="keyword">null</span>) &#123;    <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rule.isClusterMode()) &#123;  <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">return</span> passClusterCheck(rule, context, node, acquireCount, prioritized);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passLocalCheck(rule, context, node, acquireCount, prioritized);     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果限流规则没有配置针对来源，则直接默认通过，该值在配置时，默认为 default，即对所有调用发起方都生效。</p>
<p>代码@2：如果是集群限流模式，则调用 passClusterCheck，非集群限流模式则调用 passLocalCheck 方法，本文重点讲述单节点限流，集群限流模式将在后续文章中详细探讨。</p>
<p>FlowRuleChecker#passLocalCheck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">passLocalCheck</span><span class="params">(FlowRule rule, Context context, DefaultNode node, <span class="keyword">int</span> acquireCount,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    Node selectedNode = selectNodeByRequesterAndStrategy(rule, context, node);    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (selectedNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rule.getRater().canPass(selectedNode, acquireCount, prioritized);    <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先根据流控模式(strategy)选择一个合适的 Node，看到这，大家可以思考一下，这一步骤的目的，如果为空，则直接返回 true，表示放行。</p>
<p>代码@2：调用 FlowRule 内部持有的流量控制器来判断是否符合流控规则，最终调用的是 TrafficShapingController canPass 方法。</p>
<p>那我们接下来分别对上述两个方法进行详细展开。</p>
<h6 id="2-4-1-1-selectNodeByRequesterAndStrategy"><a href="#2-4-1-1-selectNodeByRequesterAndStrategy" class="headerlink" title="2.4.1.1 selectNodeByRequesterAndStrategy"></a>2.4.1.1 selectNodeByRequesterAndStrategy</h6><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FlowRuleChecker#selectNodeByRequesterAndStrategy</span><br><span class="line"><span class="function"><span class="keyword">static</span> Node <span class="title">selectNodeByRequesterAndStrategy</span><span class="params">(FlowRule rule, Context context, DefaultNode node)</span> </span>&#123;</span><br><span class="line">    String limitApp = rule.getLimitApp();</span><br><span class="line">    <span class="keyword">int</span> strategy = rule.getStrategy();</span><br><span class="line">    String origin = context.getOrigin();   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (limitApp.equals(origin) &amp;&amp; filterOrigin(origin)) &#123;    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_DIRECT) &#123;</span><br><span class="line">            <span class="comment">// Matches limit origin, return origin statistic node.</span></span><br><span class="line">            <span class="keyword">return</span> context.getOriginNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selectReferenceNode(rule, context, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RuleConstant.LIMIT_APP_DEFAULT.equals(limitApp)) &#123;  <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_DIRECT) &#123;</span><br><span class="line">            <span class="comment">// Return the cluster node.</span></span><br><span class="line">            <span class="keyword">return</span> node.getClusterNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selectReferenceNode(rule, context, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (RuleConstant.LIMIT_APP_OTHER.equals(limitApp)</span><br><span class="line">            &amp;&amp; FlowRuleManager.isOtherOrigin(origin, rule.getResource())) &#123;    <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (strategy == RuleConstant.STRATEGY_DIRECT) &#123;</span><br><span class="line">            <span class="keyword">return</span> context.getOriginNode();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selectReferenceNode(rule, context, node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在介绍该方法之前，先回答上文提到一个问题，我们知道，要判断是否满足了限流规则所配置的条件，一个重要的点就是要拿到当前的实时统计信息，通过上面介绍限流规则时提到 Sentinel 目前支持3种流控模式（直接、关联、链路），针对模式的不同，选择的实时统计数据的逻辑就应该不同，即该方法主要是根据流控策略找到对应的实时统计信息(Node)。</p>
<p>代码@1：首先先介绍几个局部变量的含义：</p>
<ul>
<li>String limitApp<br>该条限流规则针对的调用方。</li>
<li>int strategy<br>该条限流规则的流控策略。</li>
<li>String origin<br>本次请求的调用方，从当前上下文环境中获取，例如 dubbo 服务提供者，原始调用方为 dubbo 服务提供者的 application。</li>
</ul>
<p>代码@2：如果限流规则配置的针对的调用方与当前请求实际调用来源匹配（并且不是 default、other)时的处理逻辑，其实现的要点：</p>
<ul>
<li>如果流控模式为 RuleConstant.STRATEGY_DIRECT(直接)，则从 context 中获取源调用方所代表的 Node。</li>
<li>如果流控模式为 RuleConstant.STRATEGY_RELATE(关联)，则从集群环境中获取对应关联资源所代表的 Node，通过(ClusterBuilderSlot会收集每一个资源的实时统计信息，子集群限流时详细介绍)</li>
<li>如果流控模式为 RuleConstant.STRATEGY_CHAIN(调用链)，则判断当前调用上下文的入口资源与规则配置的是否一样，如果是，则返回入口资源对应的 Node，否则返回 null，注意：返回空则该条流控规则直接通过。【这部分代码，对应代码中的 selectReferenceNode 方法】</li>
</ul>
<p>代码@3：如果流控规则针对的调用方(limitApp) 配置的为 default，表示对所有的调用源都生效，其获取实时统计节点(Node)的处理逻辑为：</p>
<ul>
<li>如果流控模式为 RuleConstant.STRATEGY_DIRECT，则直接获取本次调用上下文环境对应的节点的ClusterNode。</li>
<li>如果是其他流控模式，与代码@2的获取逻辑一样，都是调用 selectReferenceNode 进行获取。</li>
</ul>
<p>代码@4：如果流控规则针对的调用方为(other)，此时需要判断是否有针对当前的流控规则，只要存在，则这条规则对当前资源“失效”，如果针对该资源没有配置其他额外的流控规则，则获取实时统计节点(Node)的处理逻辑为：</p>
<ul>
<li>如果流控模式为 RuleConstant.STRATEGY_DIRECT(直接)，则从 context 中获取源调用方所代表的 Node。</li>
<li>如果是其他流控模式，与代码@2的获取逻辑一样，都是调用 selectReferenceNode 进行获取。</li>
</ul>
<p>从这里可以看出，流控规则针对调用方如果设置为 other，表示针对没有配置流控规则的资源。</p>
<p>根据流控策略选择合适的 Node 的逻辑就介绍到这里，如果没有选择到合适的 Node，则针对该流控规则，默认放行。</p>
<h6 id="2-4-1-2-TrafficShapingController-canPass"><a href="#2-4-1-2-TrafficShapingController-canPass" class="headerlink" title="2.4.1.2 TrafficShapingController canPass"></a>2.4.1.2 TrafficShapingController canPass</h6><p>经过上一个步骤获取到对应的实时统计数据，接下来就是根据数据与流控规则，是否匹配。Sentinel 中用于实现流控规则的匹配其类体系如图所示：<br><img src="https://img-blog.csdnimg.cn/20200315193943356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于篇幅的关系，本节只会以 DefaultController 来介绍其实现原理，对应【流控模式：快速失败】，由于篇幅的关系，其他两种流控模式将在下文详细探讨。<br>DefaultController#canPass</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curCount = avgUsedTokens(node);     <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (curCount + acquireCount &gt; count) &#123;   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (prioritized &amp;&amp; grade == RuleConstant.FLOW_GRADE_QPS) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">long</span> currentTime;</span><br><span class="line">            <span class="keyword">long</span> waitInMs;</span><br><span class="line">            currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">            waitInMs = node.tryOccupyNext(currentTime, acquireCount, count);   <span class="comment">// @4</span></span><br><span class="line">            <span class="keyword">if</span> (waitInMs &lt; OccupyTimeoutProperty.getOccupyTimeout()) &#123;             <span class="comment">// @5</span></span><br><span class="line">                node.addWaitingRequest(currentTime + waitInMs, acquireCount);</span><br><span class="line">                node.addOccupiedPass(acquireCount);</span><br><span class="line">                sleep(waitInMs);                                                                                  <span class="comment">// @6</span></span><br><span class="line">                <span class="comment">// PriorityWaitException indicates that the request will pass after waiting for &#123;@link @waitInMs&#125;.</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> PriorityWaitException(waitInMs);   <span class="comment">// @7</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;     <span class="comment">// @8</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;       <span class="comment">// @9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先先解释一下两个局部变量的含义：</p>
<ul>
<li>int curCount<br>当前已消耗的令牌数量，即当前时间窗口内已创建的线程数量(FLOW_GRADE_THREAD) 或已通过的请求个数(FLOW_GRADE_QPS)。</li>
<li>double count<br>流控规则中配置的阔值(即一个时间窗口中总的令牌个数)</li>
</ul>
<p>代码@2：如果当前请求的令牌数加上已消耗的令牌数之和小于总令牌数，则直接返回true，表示通过，见代码@9;如果当前时间窗口剩余令牌数小于需要申请的令牌数，则需要根据是否有优先级进行不同的处理。</p>
<ul>
<li>如果该请求存在优先级，即 prioritized 设置为 true，并且流控类型为基于QPS进行限流，则进入相关的处理逻辑，见代码@3~@8。</li>
<li>否则直接返回 false，最终会直接抛出 FlowException，即快速失败，应用方可以捕捉该异常，对其业务进行容错处理。</li>
</ul>
<p>代码@4：尝试抢占下一个滑动窗口的令牌，并返回该时间窗口所剩余的时间，如果获取失败，则返回 OccupyTimeoutProperty.getOccupyTimeout() 值，该返回值的作用就是当前申请资源的线程将 sleep(阻塞)的时间。</p>
<p>代码@5：如果 waitInMs 小于抢占的最大超时时间，则在下一个时间窗口中增加对应令牌数，并且线程将sleep，见代码@6。</p>
<p>代码@7：这里不是很明白为什么等待 waitMs 之后，还需要抛出 PriorityWaitException，那这个prioritized 机制、可抢占下一个时间窗口的令牌有什么意义呢？应该是一个BUG吧。</p>
<h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>整个 FlowSlot 限流规则就介绍到这里了，为了更加直观的认识其限流的流程，下面给出一张流程图来对上面的源码分析进行一个总结。<br><img src="https://img-blog.csdnimg.cn/20200315194109133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>该篇注重理论与实践相结合，在进行源码解读之前先从流控规则配置界面入手，代入感比较强，文章再提供一张流程图。</p>
<p>整个限流部分目前还有所欠缺的两个部分：<br>1、流程规则的存储与加载。<br>2、其他几种流控后行为(预热、匀速排队等实现原理)</p>
<p>该部分内容将在后续文章中详细介绍，本文疑似发现一个BUG，也请大家一起交流、探讨。<br>在分析 DefaultController canPass 方法时，prioritized 为 true 时，执行 sleep 方法唤醒后不管三七二十一，直接抛出 PriorityWaitException 这是要起到一个什么作用呢？</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>sentinel</category>
      </categories>
      <tags>
        <tag>sentinel</tag>
        <tag>源码</tag>
        <tag>FlowSlot</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发锁ReentrantLock源码分析二之Condition实现原理</title>
    <url>/posts/c82e1c77.html</url>
    <content><![CDATA[<div id="vip-container"><h1 id="1、Condition接口一览"><a href="#1、Condition接口一览" class="headerlink" title="1、Condition接口一览"></a>1、Condition接口一览</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>Condition 实现的语义为 Object.wait 与 Object.notify。</p>
<p>关于Condition 的实现类为 AbstractQueuedSynchronizer.ConditionObject 内部类。</p>
<p>首先在讲解源码之前，我重点罗列出ConditionObject的关键数据结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node fristWaiter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br></pre></td></tr></table></figure>

<p>从这里看出，每个CondtionObject,都维护着自己的条件等待等待队列，并且是一个双端链表。</p>
<a id="more"></a>

<h2 id="1-1-void-await-throws-InterruptedException"><a href="#1-1-void-await-throws-InterruptedException" class="headerlink" title="1.1 void await() throws InterruptedException"></a>1.1 void await() throws InterruptedException</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Implements interruptible condition wait.</span></span><br><span class="line"><span class="comment">         * &lt;ol&gt;</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If current thread is interrupted, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Save lock state returned by &#123;<span class="doctag">@link</span> #getState&#125;.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Invoke &#123;<span class="doctag">@link</span> #release&#125; with</span></span><br><span class="line"><span class="comment">         *      saved state as argument, throwing</span></span><br><span class="line"><span class="comment">         *      IllegalMonitorStateException if it fails.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Block until signalled or interrupted.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; Reacquire by invoking specialized version of</span></span><br><span class="line"><span class="comment">         *      &#123;<span class="doctag">@link</span> #acquire&#125; with saved state as argument.</span></span><br><span class="line"><span class="comment">         * &lt;li&gt; If interrupted while blocked in step 4, throw InterruptedException.</span></span><br><span class="line"><span class="comment">         * &lt;/ol&gt;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())    <span class="comment">// @1 </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line"></span><br><span class="line">            Node node = addConditionWaiter();    <span class="comment">//@2</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node);   <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;     <span class="comment">//@4</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)  <span class="comment">// @5</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)  <span class="comment">//@6</span></span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled                                 //@7</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)                                                                            <span class="comment">//@8</span></span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>代码@1：检测当前线程的中断标记，如果中断位为1，则抛出异常。</p>
<p>代码@2：添加等待节点。就是一个简单的链表维护节点的操作，具体参照addConditionWaiter讲解。</p>
<p>代码@3：释放占有的锁，并获取当前锁的state,因为await实现的语意为Object.wait,释放锁并并等待条件的发生。当条件满足后，线程被唤醒后，第一步是需要获取锁，然后在上次await的下一条指令处继续执行。代码3就是实现上述语义的释放锁。</p>
<p>代码@4：isOnSyncQueue 当前节点是否在同步队列中，如果在同步阻塞队列中，则申请锁，去执行；如果不在同步队列中（在条件队列中），阻塞，等待满足条件，新增的节点，默认在条件队列中(Conditon)。isOnSyncQueue 源码解读在下文中；</p>
<p>代码@5：线程从条件等待被唤醒,唤醒后，线程要从条件队列移除，进入到同步等待队列，被唤醒有有如下两种情况，一是条件满足，收到singal信号，二是线程被取消（中断），该步骤是从条件队列移除，加入到同步等待队列，返回被唤醒的原因，如果是被中断，需要根据不同模式，处理中断。处理中断，也有两种方式：1.继续设置中断位；2：直接抛出InterruptedException。请看下文关于checkInterruptWhileWaiting的源码解读。</p>
<p>代码@6：运行到代码6时，说明线程已经结束了释放锁，从条件队列移除，线程运行，在继续执行业务逻辑之前，必须先获取锁。只有成功获取锁后，才会去判断线程的中断标志，才能在中断标志为真时，抛出InterruptException。</p>
<p>代码@7，执行一些收尾工作，清理整个条件队列：</p>
<p>代码@8，处理中断，是设置中断位，还是抛出InterruptException。</p>
<p>那我们先关注一下addConditionWaiter方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Adds a new waiter to wait queue.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> its new wait node</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;     <span class="comment">//@1</span></span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);  <span class="comment">//@2</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>添加条件等待节点，根据链表的特征，直接在尾部节点的nextWaiter指向新建的节点，并将新建的节点设置为整个链表的尾部，首先要知道如下数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">object &#123;</span><br><span class="line"></span><br><span class="line">      Node firstWaiter;</span><br><span class="line"></span><br><span class="line">      Node lastWaiter;</span><br><span class="line"></span><br><span class="line">      node &#123;</span><br><span class="line"></span><br><span class="line">           node nextWaiter;</span><br><span class="line"></span><br><span class="line">          该节点承载的业务数据，比如这里的Thread t;等</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知道上述结构，其实整个链的数据维护，基本一目了然，自己都可以实现下面的逻辑。</p>
<p>代码@1,如果最后一个等待节点的状态不是Node.CONDITION,则，则先删除等待链中节点状态不为Node.CONDITION的节点。具体代码分析请参照下文unlinkCancelledWaiters的解读。</p>
<p>代码@2开始，就是普通链表的节点添加的基本方法。</p>
<p>清除等待节点方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Unlinks cancelled waiter nodes from condition queue.</span></span><br><span class="line"><span class="comment">         * Called only while holding lock. This is called when</span></span><br><span class="line"><span class="comment">         * cancellation occurred during condition wait, and upon</span></span><br><span class="line"><span class="comment">         * insertion of a new waiter when lastWaiter is seen to have</span></span><br><span class="line"><span class="comment">         * been cancelled. This method is needed to avoid garbage</span></span><br><span class="line"><span class="comment">         * retention in the absence of signals. So even though it may</span></span><br><span class="line"><span class="comment">         * require a full traversal, it comes into play only when</span></span><br><span class="line"><span class="comment">         * timeouts or cancellations occur in the absence of</span></span><br><span class="line"><span class="comment">         * signals. It traverses all nodes rather than stopping at a</span></span><br><span class="line"><span class="comment">         * particular target to unlink all pointers to garbage nodes</span></span><br><span class="line"><span class="comment">         * without requiring many re-traversals during cancellation</span></span><br><span class="line"><span class="comment">         * storms.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = firstWaiter;  <span class="comment">// </span></span><br><span class="line">            Node trail = <span class="keyword">null</span>;       <span class="comment">//@1</span></span><br><span class="line">            <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Node next = t.nextWaiter;    </span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;  <span class="comment">// @3</span></span><br><span class="line">                    t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (trail == <span class="keyword">null</span>)                      <span class="comment">// @4</span></span><br><span class="line">                        firstWaiter = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        trail.nextWaiter = next;       <span class="comment">//@5</span></span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)    <span class="comment">// @6</span></span><br><span class="line">                        lastWaiter = trail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">// @4</span></span><br><span class="line">                    trail = t;</span><br><span class="line">                t = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>该方法的思路为，从第一节点开始，将不等于Node.CONDITION的节点。</p>
<p>代码@1,设置尾部节点临时变量，用来记录最终的尾部节点。代码@1 第一次循环，是循环第一个节点，如果它的状态为Node.CONDITION, 则该链的头节点保持不变，设置临时尾节点为t,然后进行一个节点的判断，如果节点不为Node.CONDITION, 重置头节点的下一个节点，或尾部节点的下一个节点(@4,@5)。代码@6代表整个循环结束，设置 ConditionObject对象的lastWaiter为trail的值；</p>
<p>await步骤中，释放锁过程源码解析。释放锁的过程，逻辑为unlock,但该方法，返回当前锁的state,因为释放锁后，该方法在条件没有满足前提下，自身需要阻塞。被唤醒后，需要先尝试获取锁，然后才能执行接下来的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Invokes release with current state value; returns saved state.</span></span><br><span class="line"><span class="comment">     * Cancels node and throws exception on failure.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the condition node for this wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous sync state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> savedState = getState();</span><br><span class="line">            <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> savedState;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                node.waitStatus = Node.CANCELLED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>await，@4步骤中，isOnSyncQueue 源码解读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns true if a node, always one that was initially placed on</span></span><br><span class="line"><span class="comment">     * a condition queue, is now waiting to reacquire on sync queue.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if is reacquiring</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)   <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) <span class="comment">// If has successor, it must be on queue   // @2</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * node.prev can be non-null, but not yet on queue because</span></span><br><span class="line"><span class="comment">         * the CAS to place it on queue can fail. So we have to</span></span><br><span class="line"><span class="comment">         * traverse from tail to make sure it actually made it.  It</span></span><br><span class="line"><span class="comment">         * will always be near the tail in calls to this method, and</span></span><br><span class="line"><span class="comment">         * unless the CAS failed (which is unlikely), it will be</span></span><br><span class="line"><span class="comment">         * there, so we hardly ever traverse much.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码@1,如果节点的状态为Node.CONDITION 或 node.prev == null,表明该节点在条件队列中，并没有加入同步阻塞队列（同步阻塞队列为申请锁等待的队列），await方法中，新增的节点，默认满足上述条件，所以返回false,表示在条件队列中，等待条件的发生，条件满足之前，当前线程应该阻塞。这里，先预留一个疑问，那node.prev在什么时候会改变呢？</p>
<p>代码@2,如果node.next不为空，说明在同步阻塞队列中。这个我想毫无疑问。当然也说明next域肯定是在进入同步队列过程中会设置值。</p>
<p>代码@3, 上面的注释也说的比较清楚，node.prev不为空，但也不在同步队列中，这个是由于CAS可能会失败，为了不丢失信号，从同步队列中再次选择该节点，如果找到则返回true,否则返回false,在这里，我就更加对node.prev在什么时候会设置值感兴趣了，请继续await方法向下看，总有水落石出的时候。</p>
<p>await @5 checkInterruptWhileWaiting 代码解读：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * For interruptible waits, we need to track whether to throw</span></span><br><span class="line"><span class="comment">         * InterruptedException, if interrupted while blocked on</span></span><br><span class="line"><span class="comment">         * condition, versus reinterrupt current thread, if</span></span><br><span class="line"><span class="comment">         * interrupted while blocked waiting to re-acquire.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Mode meaning to reinterrupt on exit from wait */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REINTERRUPT =  <span class="number">1</span>;   <span class="comment">// 重新设置中断位，中断由上层处理</span></span><br><span class="line">        <span class="comment">/** Mode meaning to throw InterruptedException on exit from wait */</span>  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THROW_IE    = -<span class="number">1</span>;    <span class="comment">// 直接抛出 InterruptedException  0:正常</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Checks for interrupt, returning THROW_IE if interrupted</span></span><br><span class="line"><span class="comment">         * before signalled, REINTERRUPT if after signalled, or</span></span><br><span class="line"><span class="comment">         * 0 if not interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers node, if necessary, to sync queue after a cancelled</span></span><br><span class="line"><span class="comment">     * wait. Returns true if thread was cancelled before being</span></span><br><span class="line"><span class="comment">     * signalled.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> current the waiting thread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node its node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if cancelled before the node was signalled</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;   <span class="comment">//@1</span></span><br><span class="line">            enq(node);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If we lost out to a signal(), then we can&#x27;t proceed</span></span><br><span class="line"><span class="comment">         * until it finishes its enq().  Cancelling during an</span></span><br><span class="line"><span class="comment">         * incomplete transfer is both rare and transient, so just</span></span><br><span class="line"><span class="comment">         * spin.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重点关注@1,首先需要知道一点，如果收到正常的singal()信号而被唤醒的节点【这个再singal方法时重点分析】，状态为Node.SINGAL,不会是Node.CONDITION状态，所以如果代码1compareAndSetWaitStatus设置成功，说明线程是调用了t.interrupt方法而使得LockSupport.park解除阻塞的，然后将该节点加入到同步队列中，使得 while( ! isOnSyncQueue(node)) 的条件为真，结束 await的等待条件触发语义，，进入到 抢占锁阶段。【再次重申Object wait语义，释放当前锁，然后等待条件的触发【条件队列】，，条件发生后，要先重新去抢占锁，获取锁则继续执行，否则阻塞在获取锁【同步队列】】，所以当 线程阻塞在  await 方法时，调用 t.interrupt方法时只是中断条件队列的等待，并不能马上取消执行，马上抛出InterrupterException。</p>
<p><strong>await方法流程图：</strong></p>
<h2 id="1-2-signal-方法详解"><a href="#1-2-signal-方法详解" class="headerlink" title=" 1.2 signal()方法详解"></a><img src="https://img-blog.csdn.net/20161114141204119?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"> 1.2 signal()方法详解</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Moves the longest-waiting thread, if one exists, from the</span></span><br><span class="line"><span class="comment">         * wait queue for this condition to the wait queue for the</span></span><br><span class="line"><span class="comment">         * owning lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="doctag">@link</span> #isHeldExclusively&#125;</span></span><br><span class="line"><span class="comment">         *         returns &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())  <span class="comment">//如果当前线程不是锁的持有者，直接抛出异常。</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first); <span class="comment">//通知第一个等待者          //@2</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Removes and transfers nodes until hit non-cancelled one or</span></span><br><span class="line"><span class="comment">         * null. Split out from signal in part to encourage compilers</span></span><br><span class="line"><span class="comment">         * to inline the case of no waiters.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> first (non-null) the first node on condition queue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)   <span class="comment">// @3</span></span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                     (first = firstWaiter) != <span class="keyword">null</span>);                          <span class="comment">// @4</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers a node from a condition queue onto sync queue.</span></span><br><span class="line"><span class="comment">     * Returns true if successful.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true if successfully transferred (else the node was</span></span><br><span class="line"><span class="comment">     * cancelled before signal).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;  <span class="comment">// @5</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))   <span class="comment">//@6</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">         * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">         * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">         * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node p = enq(node);     <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))     <span class="comment">//@8</span></span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>signal的具体实现，是从doSignal方法开始。</p>
<p>@代码3，首先将要被通知的节点的下一个节点设置为等待队列的head节点，如果当前节点的下一个节点为空，则设在等待队列的尾节点（lastWaiter）设置为空，然后将当前被通知的节点的下一个节点设为空；该步骤核心思想就是将被通知节点移除条件等待队列，然后重新维护条件等待对的firstWaiter和lastWaiter。</p>
<p>@代码4，!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null，根据后文的解析可以知道，如果被通知节点没有进入到同步阻塞队列(transferForSignal返回false)并且条件等待队列还有不为空的节点，则继续循环通知。</p>
<p>@代码5，transferForSignal该方法，将被通知的节点放入同步等待队列。</p>
<p>@代码6，首先判断，尝试将节点状态设置为0,如果设置失败，则说明该节点的状态已经不是Node.CONDITION,进一步说明该节点在没有等到通知信号时，被取消，直接返回false,通知下一个等待者。（回到代码@3,@4）</p>
<p>@代码7，将节点放入到同步队列中。个人认为信号通知，主要是将节点从条件等待队列移入到同步等待队列，主要是防止sinal信号的丢失。</p>
<p>@代码8，如果前置节点取消，或者在设置前置节点状态为Node.SIGNAL状态失败时，唤醒被通知节点代表的线程，@8设置失败发送的情况也就是前置节点状态发送改变（被取消等），所以直接唤醒被通知节点的线程，也就是说，sinal方法，只有在入队列后，前置节点被取消时，才会执行LockSupport.unpark方法唤醒线程，通常该方法，只是将节点从条件等待队列放入同步队列，然后该方法执行完毕，释放持有的锁。</p>
<p>整个通知sinal方法的流程如下：</p>
<p><img src="https://img-blog.csdn.net/20161114141402135?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>源码</tag>
        <tag>Condition</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发锁ReentrantLock源码分析一 可重入支持中断锁的实现原理</title>
    <url>/posts/22168d83.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将详细介绍 ReentrantLock 的实现原理。</p>
<p>在进入源码分析之前，我先提出如下观点：希望大家纠正与讨论：</p>
<ul>
<li>如果一个节点的状态设置为Node.SIGNAL,则说明它有后继节点，并处于阻塞状态。</li>
<li>ReentantLock的head节点，如果不为空，在该节点代表的线程为锁的占有者。这是对CLH算法的改进之处。众所周知，CLH算法的head节点为假节点，不代表任何线程。</li>
<li>ReentantLock几个编码技巧值得借鉴：<ul>
<li>利用内部类实现功能扩展，使得java.util.concurrent.locks包类数量少，十分清晰。</li>
<li>利用了模板模式，AbstractQueuedSynchronizer就是锁机制的模板（CLH算法的一个变种）。</li>
</ul>
</li>
</ul>
<p>本文重点关注如下几个方法的实现：</p>
<ul>
<li>lock()  </li>
<li>unlock()</li>
<li>lockInterruptibly()</li>
</ul>
<p>进入源码分析之前，希望读者带着如下问题边看边想：</p>
<p>问题1：一个线程用lock方法申请锁而被阻塞后，调用线程的interput方法，会发生什么情况，能中断锁的获取吗？</p>
<p>问题2：什么是CLH算法，RenntrantLock针对CLH算法做了哪些变化。</p>
<p>问题3：Node.CANCEL状态的节点在什么时候会删除。</p>
<a id="more"></a>

<h1 id="1、ReentrantLock-lock-方法详解"><a href="#1、ReentrantLock-lock-方法详解" class="headerlink" title="1、ReentrantLock#lock 方法详解"></a>1、ReentrantLock#lock 方法详解</h1><p>如下摘录自  ReentrantLock.NonFairSync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))     <span class="comment">// @1</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>); <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码@1 首先线程请求锁时，第一步，直接通过锁的状态 state, 如果 state 为0，通过 CAS 尝试去获取锁，如果获取，直接返回，这里就是所谓的不公平，先抢占，然后再尝试排队。如果当前锁被占用，则尝试申请锁, 进入代码 @2；</p>
<p>继续查看 acquire(1)方法，该方法存在于 AbstractQueuedSynchronizer 类，该类是 java.util.concurent.locks 锁的队列机制实现类，基于CLH 算法的变体的基本思想。，附上 AbstractQueuedSynchronizer 的 acquire 方法源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, ignoring interrupts.  Implemented</span></span><br><span class="line"><span class="comment">     * by invoking at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquire&#125; until success.  This method can be used</span></span><br><span class="line"><span class="comment">     * to implement method &#123;<span class="doctag">@link</span> Lock#lock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>先进入到 tryAcquire(arg)方法，查看获取锁的逻辑，该方法不阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;   <span class="comment">// 说明，该方法在具体的子类中实现。</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一路跟踪进来，发现尝试获取锁的代码在 ReentrantLock内部类 Sync 汇总，Sync 是 NonFairSync 和 FairSync 的父类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs non-fair tryLock.  tryAcquire is</span></span><br><span class="line"><span class="comment">         * implemented in subclasses, but both need nonfair</span></span><br><span class="line"><span class="comment">         * try for trylock method.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;    <span class="comment">// @1</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>该方法，尝试获取锁，如果成功获取锁，则返回true,否则，返回false;</p>
<p>重点关注 代码@1, 再次查看 锁的 state,该字段，表示该锁被占用的次数，如果为0，表示没有线程持有该锁，如果     大于1，表示同一个线程，多次请求锁；也就是可重入锁的实现原理。</p>
<p>代码@2：进一步说明可重入锁的实现机制。再次回到上文提到的 AbstractQueuedSynchronizer的 acquire(arg)方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">          acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">          selfInterrupt();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>如果 tryAcquire(arg) 返回 true,则不会执行 acquireQueued，表示成功获取锁，如果 tryAcquire(arg) 返回 false, 说明没有成功获取锁，则加入请求队列中。接着请看 addWaiter (Node.EXCLUSIVE) 方法。</p>
<p>addWaiter 中涉及的逻辑，就是 CLH 思想的实现，故在 AbstractQueuedSynchronizer 中,源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates and enqueues node for current thread and given mode.</span></span><br><span class="line"><span class="comment">     * 创建并入队一节点，为当前线程和给定的模式, Node.EXCLUSIVE 独占模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the new node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123; <span class="comment">//@1 start</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//@1 end</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于上面的代码@1,处说，如果当前该锁的尾部节点不为空时，只需要原子性的将新增节点放入原先的尾部，然后更新锁的 tail 属性即可。如果尾部节点不为空，说明有线程已经在该锁上等待，那如果尾部为空，是什么情况呢？尾部为空，表示没有线程持有锁，为什么该获取锁没有成功呢？我们不妨设想一下，该线程在没有执行到 addWaiter 时，尾部不为空，无法获取锁，当执行到 addWaiter 时，别的线程释放了锁，导致尾部为空，可以重新获取锁了；（其实这个就是并发编程的魅力，与 synchronized 关键字不同的机制）；为了解答上述疑问，我们进入到 enq(node) 方法中一探究竟。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Inserts node into queue, initializing if necessary. See picture above.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> node the node to insert</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> node&#x27;s predecessor</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize                     @1</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               node.prev = t;</span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>使用自旋来加入,众所周知，CLH算法，需要初始化一个假的 head 节点，也就是 head 节点并不代表一个等待获取锁的对象，AbstractQueuedSynchronzier 选择初始化 head,tail 的时机为第一次产生锁争用的时候。@1处为初始化head,tail,设置成功后，初始化后，再将新添加的节点放入到队列的尾部，然后该方法会返回原先的尾节点。addWaiter方法执行后，继续回到acquire(args)方法处：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接下来，查看 acquireQueued 方法,addWaiter 方法返回的是代表当前线程的 Node 节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive uninterruptible mode for thread already in</span></span><br><span class="line"><span class="comment">     * queue. Used by condition wait methods as well as acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">//  @1</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  parkAndCheckInterrupt()  )   <span class="comment">//@3</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>首先@1,获取该节点的 node 的上一个节点。</p>
<p>@2如果node的前节点是head,因为head初始化时，都是假节点，不代表有线程拥有锁，所以，再次尝试获取锁，如果获取锁，则将锁的 head 设置为当前获取锁的线程的 Node，然后返回 false。返回 false, 则代表 if (!tryAcquire(arg) &amp;&amp;  acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) 的结果为 false,直接返回，并不需要设置中断标记。如果当前节点不是head的话，则说明该锁被别的线程占用了，那就需要等待其他线程释放该锁，具体，我们看一下shouldParkAfterFailedAcquire，为了更好的理解 shouldParkAfterFailedAcquire, 我们先看一下parkAndCheckInterrupt 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Convenience method to park and then check if interrupted</span></span><br><span class="line"><span class="comment">     * 阻塞该线程，然等待唤醒后，会返回 当前线程的中断位；</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Checks and updates status for a node that failed to acquire.</span></span><br><span class="line"><span class="comment">     * Returns true if thread should block. This is the main signal</span></span><br><span class="line"><span class="comment">     * control in all acquire loops.  Requires that pred == node.prev</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pred node&#x27;s predecessor holding status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if thread should block</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">       该方法，如果返回true,则代表该线程将被阻塞。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">//  @1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)    <span class="comment">// @2</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// @4 start</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);   <span class="comment">//@4 end</span></span><br><span class="line"></span><br><span class="line">            pred.next = node; <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               只有前置节点的状态为 0 或 PROPAGATE,,才能进入到该代码块，表明我们需要一个信号，但暂不挂起线程，调用者需要重                  试一次，确保它不能获取到锁，从而阻塞该线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>@1 首先获取前置节点的 waitStatus。</p>
<p>@2 如果前置节点的waitStatus = Node.SIGNAL,那么当前节点，直接阻塞，说明状态是一个信号，如果前置节点状态为       Node.SIGNAL,那么后续节点应该阻塞的信号量，为什么这么说，情况代码@6,一个节点，新增的时候，为 0 正常。</p>
<p> @3,ws &gt; 0 ，则代表前置节点已取消。</p>
<p>@4 处的代码，就是当前 Node 的第一个不为取消状态的前置节点，重构 CLH 队列后，返回 false, 再次进入到 acquireQueued  的无限循环中，又继续 acquireQueued 的流程，继续尝试获取锁，获取锁，或者阻塞。</p>
<p>@6，如果前置节点为0或 PROPAGATE(可传播)，如果前置节点为0，还没有其他节点通过(prev)来判断该 prev 的后继节点是否需要阻塞过，所以，通过 CAS 设置前置节点为 Node.SIGNAL, 重试获取锁过程，避免不必要的线程阻塞。</p>
<p>至此，获取锁的过程就结束了，为了直观体现上述获取锁的过程，现给出如下流程图：</p>
<p><img src="https://img-blog.csdn.net/20161108175842999?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="2、ReentrantLock-unlock"><a href="#2、ReentrantLock-unlock" class="headerlink" title="2、ReentrantLock unlock"></a>2、ReentrantLock unlock</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//代码直接进入到AbstractQueuedSynchronzier 的 relase方法。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Releases in exclusive mode.  Implemented by unblocking one or</span></span><br><span class="line"><span class="comment">     * more threads if &#123;<span class="doctag">@link</span> #tryRelease&#125; returns true.</span></span><br><span class="line"><span class="comment">     * This method can be used to implement method &#123;<span class="doctag">@link</span> Lock#unlock&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the release argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the value returned from &#123;<span class="doctag">@link</span> #tryRelease&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;  @<span class="number">1</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>直接看代码 tryRelease(arg)方法：tryRelease 方法，是由具体的子类实现的，故将目光转移到 NonFairSync 类的 tryRelease() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState() - releases;   <span class="comment">//  @1</span></span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread()) <span class="comment">//@2</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;  <span class="comment">// @3</span></span><br><span class="line">                free = <span class="keyword">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);   <span class="comment">//@4</span></span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>代码@1，首先，计算持有锁的次数=当前被持有锁的次数-减去释放的锁的数量；</p>
<p>代码@2，判断当前锁的持有线程释放与释放锁的线程是否相同，否则，直接抛出运行时异常</p>
<p>代码@3，如果释放锁后，占有次数为0，则代表该锁被释放，设置锁的占有线程为null,</p>
<p>代码@4，设置锁的state,如果返回true,表示锁被释放，如果返回false,表示，锁继续被该线程占有（重入了多次，就需要释放多次）。再次回到release方法，如果tryRelease方法返回true,表示可以释放锁，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (tryRelease(arg)) &#123;  @<span class="number">1</span></span><br><span class="line">          Node h = head;</span><br><span class="line">          <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)   <span class="comment">// @2</span></span><br><span class="line">              unparkSuccessor(h);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>代码@2为什么需要判断 h!=null &amp;&amp; h.waitStatus != 0的判断呢？，在讲解获取锁的时候，方法 shouldParkAfterFailedAcquire 中对于代码@6处的讲解，其实不难发现，一个节点在请求锁时，只有当它的前驱节点的waitStatus=Node.SIGNAL时，才会阻塞。如果 head为空，则说明 CLH 队列为空，压根就不会有线程阻塞，故无需执行 unparkSuccessor(h), 同样的道理，如果根节点的waitStatus=0，则说明压根就没有 head 后继节点判断是否要绑定的逻辑，故也没有线程被阻塞这一说。原来一个更重要的原因：改进后的CLH，head如果不为空，该节点代表获取锁的那个线程对于的Node,请看获取锁代码acquireQueued中的代码@2处，如果获得锁，setHead(node);知道这一点，就不难理解为什么在释放锁时调用unparkSuccessor(h)时，参数为head了。</p>
<p>现在将目光转移到 AbstractQueuedSynchronizer. unparkSuccessor(h)方法中:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node&#x27;s successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;  </span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)     <span class="comment">// @1</span></span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;  <span class="comment">//@2 start</span></span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125; <span class="comment">// @2 end</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>) <span class="comment">// @3</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>代码@1，目前waitStatus &gt; 0表示取消，等于0表示正常（新建），该步骤主要是   为了保护，避免重复释放。</p>
<p>代码@2 start-end,此处，主要是从占有锁的节点，往后找，找到第一个没有被取   消的节点，然后唤醒它所代表的线程。这里为什么要从尾部寻址呢？</p>
<p>代码@3，唤醒线程，释放锁的逻辑代码已经结束，那调用LockSupport.unpark(s.thread)后，会进入到哪呢？此时，请再次进入获取锁代码的 acquireQueue方法和shouldParkAfterFailedAcquire方法，先解读如下：</p>
<p>当LockSupport.unpark(s.thread)事，那acquireQueued的代码@3处parkAndCheckInterrupt方法会解除阻塞，继续放下执行，进入到 acquireQueued的for循环处：此时会有两种情况</p>
<ul>
<li>HEAD –&gt; Node  … &gt; 其中Node 为  LockSupport.unpark 中的 s;</li>
<li>HEAD –&gt; A Cancel Node –&gt;  Node(s)</li>
</ul>
<p>如果为第一种情况，直接进入 @2去尝试获取锁。</p>
<p>如果为第二种情况，shouldParkAfterFailedAcquire(prev,node) 中的 prev 为一个取消的节点，然后会重构整个 CLH 链表，删除Node 到 head 节点直接的取消节点，使得被唤醒线程的节点的上一个节点为 head,从而满足@2处的条件，进入获取锁方法。至此， lock 方法与 unlock 方法流通畅。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();    <span class="comment">//  @1</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  parkAndCheckInterrupt()  )   <span class="comment">//@3</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">与shouldParkAfterFailedAcquire方法：</span><br><span class="line">  */</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">//  @1</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)    <span class="comment">// @2</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// @3</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;   <span class="comment">// @4 start</span></span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);   <span class="comment">//@4 end</span></span><br><span class="line"></span><br><span class="line">            pred.next = node; <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @6</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">               只有前置节点的状态为 0 或 PROPAGATE,,才能进入到该代码块，表明我们需要一个信号，但暂不挂起线程，调用者需要重                  试一次，确保它不能获取到锁，从而阻塞该线程。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为了方便大家理解，给出一个简要的释放锁的流程图：</p>
<p><img src="https://img-blog.csdn.net/20161108180244374?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="3、ReentrantLock-lockInterruptibly-源码分析"><a href="#3、ReentrantLock-lockInterruptibly-源码分析" class="headerlink" title="3、ReentrantLock lockInterruptibly 源码分析"></a>3、ReentrantLock lockInterruptibly 源码分析</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br></pre></td></tr></table></figure>

<p>首先先提一个问题： void lock()，通过该方法去获取锁，如果锁被占用，线程阻塞，如果调用被阻塞线程的          interupt()方法，会取消获取锁吗？答案是否定的。</p>
<p>首先需要知道 LockSupport.park 会响应中断，但不会抛出 InterruptedException。</p>
<p>接下来，我们就从lockInterruptibly()方法入手，一步一步解析，并分析与lock方法的差异。</p>
<p>首先进入的是AbstractQueuedSynchronizer的acquireInterruptibly方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive mode, aborting if interrupted.</span></span><br><span class="line"><span class="comment">     * Implemented by first checking interrupt status, then invoking</span></span><br><span class="line"><span class="comment">     * at least once &#123;<span class="doctag">@link</span> #tryAcquire&#125;, returning on</span></span><br><span class="line"><span class="comment">     * success.  Otherwise the thread is queued, possibly repeatedly</span></span><br><span class="line"><span class="comment">     * blocking and unblocking, invoking &#123;<span class="doctag">@link</span> #tryAcquire&#125;</span></span><br><span class="line"><span class="comment">     * until success or the thread is interrupted.  This method can be</span></span><br><span class="line"><span class="comment">     * used to implement method &#123;<span class="doctag">@link</span> Lock#lockInterruptibly&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquire&#125; but is otherwise uninterpreted and</span></span><br><span class="line"><span class="comment">     *        can represent anything you like.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);   <span class="comment">// @1</span></span><br><span class="line">    &#125;</span><br><span class="line">    如果尝试获取锁失败后，进入获取锁并等待锁逻辑，doAcquireInterruptibly</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in exclusive interruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;              <span class="comment">// @2</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">//@3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node); <span class="comment">//@4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>整个获取锁的逻辑与 lock 方法一样，唯一的区别在于  @3 处，如果 parkAndCheckInterrupt 如果是通过 t.interupt 方法，使LockSupport.park 取消阻塞的话，会抛出 InterruptedException，停止尝试获取锁，然后将添加的节点取消，那重点关注一下cancelAcquire(node); </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cancels an ongoing attempt to acquire.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ignore if node doesn&#x27;t exist</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">        Node pred = node.prev;   </span><br><span class="line">        <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)  <span class="comment">// @1</span></span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">        <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">        <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">        Node predNext = pred.next; <span class="comment">//@2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">        <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">        <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">        node.waitStatus = Node.CANCELLED; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">        <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;   <span class="comment">// @3 </span></span><br><span class="line">            compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @4</span></span><br><span class="line">            <span class="comment">// If successor needs signal, try to set pred&#x27;s next-link</span></span><br><span class="line">            <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">            <span class="keyword">int</span> ws;</span><br><span class="line">            <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">                ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                 (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">                pred.thread != <span class="keyword">null</span>) &#123;   <span class="comment">// @5</span></span><br><span class="line">                Node next = node.next;</span><br><span class="line">                <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    compareAndSetNext(pred, predNext, next);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @6</span></span><br><span class="line">                unparkSuccessor(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            node.next = node; <span class="comment">// help GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码@1：此处的目的就是, 设置prev的值为从当前取消节点往head节点方向，第一个未取消节点。并将中间的取消节点脱离这条链。</p>
<p>代码@2 Node predNext = pred.next;</p>
<p>代码@3 如果被取消的节点是尾节点的话，那么将pred设置为尾节点，compareAndSetTail(node, pred)，如果设置失败，说明，有别的线程在申请锁，使得尾部节点发生了变化，那这样的话，我当前节点取消的工作，就到此可以结束了；如果设置成功了，既然pred是尾节点，那么再次将pred的next域设置为null;当然也能设置失败，表明又有新的线程在申请说，创建了节点。所以取消操作，也到此结束。</p>
<p>代码@4，如果取消的节点，不是尾部节点的话，这时，需要维护CLH链，请看代码@5</p>
<p>代码@5,首先pred不是head节点，接下来判断是否需要设置pred.next = 当前待取消节点的next。如果pred.waitStatus == Node.SIGNAL, 或者试图将 pred.waitStatus = Node.SIGNAL 状态成功，并且pred.thread 的线程不为空；此时进一步判断待取消的节点的 next 不为空，并且状态为非取消的时，将 pred.next 设置为 node.next；该取消节点被删除。</p>
<p>代码@6，如果pred为head,执行一次唤醒操作。</p>
<p>处于Node.CANCEL状态节点的删除发生在shouldParkAfterFailedAcquire，一处就发生在cancelAcquire方法。</p>
<p>本文就介绍到这里了，文章开头部分的问题能解答了没，可以加笔者微信号 ：dingwpmz，共同探讨交流。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>ReentrantLock</tag>
        <tag>可重入</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>全链路压测必备基础组件之线程上下文管理之“三剑客”</title>
    <url>/posts/497923c7.html</url>
    <content><![CDATA[<div id="vip-container"><p>说起本地线程变量，我相信大家首先会想到的是JDK默认提供的ThreadLocal，用来存储在整个调用链中都需要访问的数据，并且是线程安全的。由于本文的写作背景是笔者需要在公司落地全链路压测平台，一个基本并核心的功能需求是压测标记需要在整个调用链中进行传递，线程上下文环境成为解决这个问题最合适的技术。</p>
<blockquote>
<p>温馨提示：<br>本从从ThreadLocal原理入手分析，并抛出其缺点，再逐一引出InheritableThreadLocal、TransmittableThreadLocal。文章篇幅稍长，但由于循序渐进，层层递进，故精华部分在后面。</p>
</blockquote>
<h2 id="1、ThreadLocal详解"><a href="#1、ThreadLocal详解" class="headerlink" title="1、ThreadLocal详解"></a>1、ThreadLocal详解</h2><p>ThreadLocal对外提供;的API如下：</p>
<ul>
<li>public T get(）<br>从线程上下文环境中获取设置的值。</li>
<li>public void set(T value)<br>将值存储到线程上下文环境中，供后续使用。</li>
<li>public void remove()<br>清除线程本地上下文环境。</li>
</ul>
<p>上述API使用简单，关键是要理解ThreadLocal的内部存储结果。</p>
<h3 id="1-1-ThreadLocal存储结构"><a href="#1-1-ThreadLocal存储结构" class="headerlink" title="1.1 ThreadLocal存储结构"></a>1.1 ThreadLocal存储结构</h3><p><img src="https://img-blog.csdnimg.cn/20190720224949903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上图的几个关键点如下：</p>
<ul>
<li>数据存储位置<br>当线程调用threadLocal对象的set(Object value)方法时，数据并不是存储在ThreadLocal对象中，而是存储在Thread对象中，这也是ThreadLocal的由来，具体存储在线程对象的threadLocals属性中，其类型为ThreadLocal.ThreadLocalMap。</li>
<li>ThreadLocal.ThreadLocalMap，Map结构，即键值对，键为threadLocal对象，值为需要存储到线程上下文的值(threadLocal#set)方法的参数。</li>
</ul>
<a id="more"></a>

<h3 id="1-2-源码分析ThreadLocal"><a href="#1-2-源码分析ThreadLocal" class="headerlink" title="1.2 源码分析ThreadLocal"></a>1.2 源码分析ThreadLocal</h3><h4 id="1-2-1-源码分析get"><a href="#1-2-1-源码分析get" class="headerlink" title="1.2.1 源码分析get"></a>1.2.1 源码分析get</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();  <span class="comment">// @1</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);  <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;                                <span class="comment">// @3</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();  <span class="comment">// @4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取当前线程。</p>
<p>代码@2：获取线程的threadLocals属性，在上图中已展示其存储结构。</p>
<p>代码@3：如果线程对象的threadLocals属性不为空，则从该Map结构中，用threadLocal对象为键去查找值，如果能找到，则返回其value值，否则执行代码@4。</p>
<p>代码@4：如果线程对象的threadLocals属性为空，或未从threadLocals中找到对应的键值对，则调用该方法执行初始化。</p>
<p>ThreadLocal#setInitialValue</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();    <span class="comment">// @1</span></span><br><span class="line">    Thread t = Thread.currentThread();    <span class="comment">// @2</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);    <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)                                     <span class="comment">//@4</span></span><br><span class="line">       map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       createMap(t, value);                        <span class="comment">// @5</span></span><br><span class="line">	<span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：调用initialValue()获取默认初始化值，该方法默认返回null，子类可以重写，实现线程本地变量的初始化。</p>
<p>代码@2：获取当前线程。</p>
<p>代码@3：获取该线程对象的threadLocals属性。</p>
<p>代码@4：如果不为空，则将threadLocal:value存入线程对象的threadLocals属性中。</p>
<p>代码@5：否则初始化线程对象的threadLocals,然后将threadLocal:value键值对存入线程对象的threadLocals属性中。</p>
<h4 id="1-2-2-源码分析set"><a href="#1-2-2-源码分析set" class="headerlink" title="1.2.2 源码分析set"></a>1.2.2 源码分析set</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在掌握了get方法实现细节，set方法、remove其实现的逻辑基本一样，就是对线程对象的threadLocals属性进行操作(Map结构)。</p>
<h3 id="1-3-ThreadLocal局限性"><a href="#1-3-ThreadLocal局限性" class="headerlink" title="1.3 ThreadLocal局限性"></a>1.3 ThreadLocal局限性</h3><p>经过上面的剖析，对ThreadLocal的内部存储与set、get、remove等实现细节都已理解，但ThreadLocal无法在父子线程之间传递，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer reqId = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Service a = <span class="keyword">new</span> Service();</span><br><span class="line">        a.setRequestId(reqId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(Integer requestId)</span> </span>&#123;</span><br><span class="line">        requestIdThreadLocal.set(requestId);</span><br><span class="line">        doBussiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBussiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先打印requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在子线程中访问requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720225215561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从结果上来看，在子线程中无法访问在父线程中设置的本地线程变量，那我们该如何来解决该问题呢？</p>
<p>为了解决该问题，JDK引入了另外一个线程本地变量实现类InheritableThreadLocal，接下来将重点介绍InheritableThreadLocal的实现原理。</p>
<h2 id="2、InheritableThreadLocal"><a href="#2、InheritableThreadLocal" class="headerlink" title="2、InheritableThreadLocal"></a>2、InheritableThreadLocal</h2><p>由于ThreadLocal在父子线程交互中子线程无法访问到存储在父线程中的值，无法满足某些场景的需求，例如链路跟踪，例如如下场景：<br><img src="https://img-blog.csdnimg.cn/20190720225255699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>为了解决上述问题，JDK引入了InheritableThreadLocal，即子线程可以访问父线程中的线程本地变量，更严谨的说法是子线程可以访问在创建子线程时父线程当时的本地线程变量，因为其实现原理就是在创建子线程将父线程当前存在的本地线程变量拷贝到子线程的本地线程变量中。</p>
<h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190720225324764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从类的继承层次来看，InheritableThreadLocal只是在ThreadLocal的get、set、remove流程中，重写了getMap、createMap方法，整体流程与ThreadLocal保持一致，故我们初步来看一下InheritableThreadLocal是如何重写上述这两个方法的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码得知，ThreadLocal操作的是Thread对象的threadLocals属性，而InheritableThreadLocal操作的是Thread对象的inheritableThreadLocals属性。</p>
<blockquote>
<p>温馨提示：createMap被执行的条件是调用InheritableThreadLocal#get、set时如果线程的inheritableThreadLocals属性为空时才会被调用。</p>
</blockquote>
<p>那问题来了，InheritableThreadLocal是如何继承自父对象的线程本地变量的呢？</p>
<h3 id="2-2-线程上下文环境如何从父线程传递到子线程"><a href="#2-2-线程上下文环境如何从父线程传递到子线程" class="headerlink" title="2.2 线程上下文环境如何从父线程传递到子线程"></a>2.2 线程上下文环境如何从父线程传递到子线程</h3><p>这部分的代码入口为：Thread#init方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread parent = currentThread();                <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)    <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">        ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line"><span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line"><span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set thread ID */</span></span><br><span class="line">tid = nextThreadID();</span><br></pre></td></tr></table></figure>
<p>子线程是通过在父线程中通过调用new Thread()方法来创建子线程，Thread#init方法就是在Thread的构造方法中被调用。</p>
<p>代码@1：获取当前线程对象，即待创建的线程的父线程。</p>
<p>代码@2：如果父线程的inheritableThreadLocals不为空并且inheritThreadLocals为true(该值默认为true)，则使用父线程的inherit本地变量的值来创建子线程的inheritableThreadLocals结构，即将父线程中的本地变量复制到子线程中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">    Entry[] parentTable = parentMap.table;</span><br><span class="line">    <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">    setThreshold(len);</span><br><span class="line">    table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = parentTable[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">            <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Object value = key.childValue(e.value);</span><br><span class="line">                Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                </span><br><span class="line">		table[h] = c;</span><br><span class="line">                size++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码就不一一分析，类似于Map的复制，只不过其在Hash冲突时，不是使用链表结构，而是直接在数组中找下一个为null的槽位。</p>
<blockquote>
<p>温馨提示：子线程默认拷贝父线程的方式是浅拷贝，如果需要使用深拷贝，需要使用自定义ThreadLocal，继承InheritableThreadLocal并重写childValue方法。</p>
</blockquote>
<h3 id="2-3-验证InheritableThreadLocal的特性"><a href="#2-3-验证InheritableThreadLocal的特性" class="headerlink" title="2.3 验证InheritableThreadLocal的特性"></a>2.3 验证InheritableThreadLocal的特性</h3><p>验证代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer reqId = <span class="keyword">new</span> Integer(<span class="number">5</span>);</span><br><span class="line">        Service a = <span class="keyword">new</span> Service();</span><br><span class="line">        a.setRequestId(reqId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRequestId</span><span class="params">(Integer requestId)</span> </span>&#123;</span><br><span class="line">        requestIdThreadLocal.set(requestId);</span><br><span class="line">        doBussiness();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBussiness</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;首先打印requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        (<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;子线程启动&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;在子线程中访问requestId:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="https://img-blog.csdnimg.cn/20190720225632413.png" alt="在这里插入图片描述"><br>符合预期，在子线程中如愿访问到了在主线程中设置的本地环境变量。</p>
<h3 id="2-4-InheritableThreadLocal局限性"><a href="#2-4-InheritableThreadLocal局限性" class="headerlink" title="2.4 InheritableThreadLocal局限性"></a>2.4 InheritableThreadLocal局限性</h3><p>InheritableThreadLocal支持子线程访问在父线程的核心思想是在创建线程的时候将父线程中的本地变量值复制到子线程，即复制的时机为创建子线程时。但我们提到并发、多线程就理不开线程池的使用，因为线程池能够复用线程，减少线程的频繁创建与销毁，如果使用InheritableThreadLocal，那么线程池中的线程拷贝的数据来自于第一个提交任务的外部线程，即后面的外部线程向线程池中提交任务时，子线程访问的本地变量都来源于第一个外部线程，造成线程本地变量混乱，验证代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟tomcat线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tomcatExecutors = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程池，默认Control中异步任务执行线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService businessExecutors = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程上下文环境，模拟在Control这一层，设置环境变量，然后在这里提交一个异步任务，模拟在子线程中，是否可以访问到刚设置的环境变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ ) &#123;  <span class="comment">// 模式10个请求，每个请求执行ControlThread的逻辑，其具体实现就是，先输出父线程的名称，</span></span><br><span class="line">                                                  <span class="comment">//  然后设置本地环境变量，并将父线程名称传入到子线程中，在子线程中尝试获取在父线程中的设置的环境变量</span></span><br><span class="line">            tomcatExecutors.submit(<span class="keyword">new</span> ControlThread(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单粗暴的关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        businessExecutors.shutdown();</span><br><span class="line">        tomcatExecutors.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Control任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ControlThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                requestIdThreadLocal.set(i);</span><br><span class="line">                <span class="comment">//使用线程池异步处理任务</span></span><br><span class="line">                businessExecutors.submit(<span class="keyword">new</span> BusinessTask(Thread.currentThread().getName()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务任务，主要是模拟在Control控制层，提交任务到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String parentThreadName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BusinessTask</span><span class="params">(String parentThreadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parentThreadName = parentThreadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果与上面的能对应上来，则说明正确，否则失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;parentThreadName:&quot;</span> + parentThreadName + <span class="string">&quot;:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pool-1-thread-1:0</span><br><span class="line">pool-1-thread-2:1</span><br><span class="line">pool-1-thread-3:2</span><br><span class="line">pool-1-thread-4:3</span><br><span class="line">pool-1-thread-5:4</span><br><span class="line">pool-1-thread-6:5</span><br><span class="line">pool-1-thread-7:6</span><br><span class="line">pool-1-thread-8:7</span><br><span class="line">pool-1-thread-9:8</span><br><span class="line">pool-1-thread-10:9</span><br><span class="line">parentThreadName:pool-1-thread-7:6</span><br><span class="line">parentThreadName:pool-1-thread-4:6</span><br><span class="line">parentThreadName:pool-1-thread-3:6</span><br><span class="line">parentThreadName:pool-1-thread-2:6</span><br><span class="line">parentThreadName:pool-1-thread-1:6</span><br><span class="line">parentThreadName:pool-1-thread-9:6</span><br><span class="line">parentThreadName:pool-1-thread-10:6</span><br><span class="line">parentThreadName:pool-1-thread-8:7</span><br><span class="line">parentThreadName:pool-1-thread-6:5</span><br><span class="line">parentThreadName:pool-1-thread-5:4</span><br></pre></td></tr></table></figure>
<p>从这里可以出thread-7、thread-4、thread-3、thread-2、thread-1、thread-9、thread-10获取的都是6，在子线程中出现出现了线程本地变量混乱的现象，在全链路跟踪与压测出现这种情况是致命的。</p>
<p>问题：大家通过上面的学习，应该能解释这个现象？此处可以稍微停下来思考一番。</p>
<p>怎么解决这个问题呢？</p>
<p>TransmittableThreadLocal ”闪亮登场“。</p>
<h2 id="3、TransmittableThreadLocal"><a href="#3、TransmittableThreadLocal" class="headerlink" title="3、TransmittableThreadLocal"></a>3、TransmittableThreadLocal</h2><h3 id="3-1-TransmittableThreadLocal“何许人也”"><a href="#3-1-TransmittableThreadLocal“何许人也”" class="headerlink" title="3.1 TransmittableThreadLocal“何许人也”"></a>3.1 TransmittableThreadLocal“何许人也”</h3><p>TransmittableThreadLocal何许人也，它可是阿里巴巴开源的专门解决InheritableThreadLocal的局限性，实现线程本地变量在线程池的执行过程中，能正常的访问父线程设置的线程变量。实践是检验整理的唯一标准，我们还是以上面的示例来进行验证，看看TransmittableThreadLocal是否支持上述场景：</p>
<p>首先需要在pom.xml文件中引入如下maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transmittable-thread-local<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟tomcat线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tomcatExecutors = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务线程池，默认Control中异步任务执行线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService businessExecutors = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(<span class="number">4</span>)); <span class="comment">// 使用ttl线程池，该框架的使用，请查阅官方文档。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程上下文环境，模拟在Control这一层，设置环境变量，然后在这里提交一个异步任务，模拟在子线程中，是否可以访问到刚设置的环境变量值。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> TransmittableThreadLocal&lt;Integer&gt; requestIdThreadLocal = <span class="keyword">new</span> TransmittableThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//    private static InheritableThreadLocal&lt;Integer&gt; requestIdThreadLocal = new InheritableThreadLocal&lt;&gt;();</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i ++ ) &#123;</span><br><span class="line">            tomcatExecutors.submit(<span class="keyword">new</span> ControlThread(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单粗暴的关闭线程池</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        businessExecutors.shutdown();</span><br><span class="line">        tomcatExecutors.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟Control任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ControlThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ControlThread</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            requestIdThreadLocal.set(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//使用线程池异步处理任务</span></span><br><span class="line"></span><br><span class="line">            businessExecutors.submit(<span class="keyword">new</span> BusinessTask(Thread.currentThread().getName()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务任务，主要是模拟在Control控制层，提交任务到线程池执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String parentThreadName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BusinessTask</span><span class="params">(String parentThreadName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.parentThreadName = parentThreadName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//如果与上面的能对应上来，则说明正确，否则失败</span></span><br><span class="line">            System.out.println(<span class="string">&quot;parentThreadName:&quot;</span> + parentThreadName + <span class="string">&quot;:&quot;</span> + requestIdThreadLocal.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> pool-1-thread-10:9</span><br><span class="line"> pool-1-thread-8:7</span><br><span class="line"> pool-1-thread-7:6</span><br><span class="line"> pool-1-thread-9:8</span><br><span class="line"> pool-1-thread-6:5</span><br><span class="line"> pool-1-thread-5:4</span><br><span class="line"> pool-1-thread-4:3</span><br><span class="line"> pool-1-thread-3:2</span><br><span class="line"> pool-1-thread-2:1</span><br><span class="line">pool-1-thread-1:0</span><br><span class="line">parentThreadName:pool-1-thread-5:4</span><br><span class="line">parentThreadName:pool-1-thread-9:4</span><br><span class="line">parentThreadName:pool-1-thread-3:4</span><br><span class="line">parentThreadName:pool-1-thread-2:4</span><br><span class="line">parentThreadName:pool-1-thread-7:4</span><br><span class="line">parentThreadName:pool-1-thread-8:4</span><br><span class="line">parentThreadName:pool-1-thread-1:4</span><br><span class="line">parentThreadName:pool-1-thread-6:5</span><br><span class="line">parentThreadName:pool-1-thread-10:9</span><br><span class="line">parentThreadName:pool-1-thread-4:3</span><br></pre></td></tr></table></figure>
<p>执行结果符合预期。那TransmittableThreadLocal是如何实现的呢？</p>
<h3 id="3-2-TransmittableThreadLocal实现原理"><a href="#3-2-TransmittableThreadLocal实现原理" class="headerlink" title="3.2 TransmittableThreadLocal实现原理"></a>3.2 TransmittableThreadLocal实现原理</h3><blockquote>
<p>从InheritableThreadLocal不支持线程池的根本原因是InheritableThreadLocal是在父线程创建子线程时复制的，由于线程池的复用机制，“子线程”只会复制一次。要支持线程池中能访问提交任务线程的本地变量，其实只需要在父线程在向线程池提交任务时复制父线程的上下环境，那在子线程中就能够如愿访问到父线程中的本地遍历，实现本地环境变量在线程调用之中的透传，实现链路跟踪，这也就是TransmittableThreadLocal最本质的实现原理。</p>
</blockquote>
<h4 id="3-2-1-TransmittableThreadLocal类图"><a href="#3-2-1-TransmittableThreadLocal类图" class="headerlink" title="3.2.1 TransmittableThreadLocal类图"></a>3.2.1 TransmittableThreadLocal类图</h4><p><img src="https://img-blog.csdnimg.cn/20190720230155275.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>TransmittableThreadLocal继承自InheritableThreadLocal，接下来将从set方法为入口，开始探究TransmittableThreadLocal实现原理。</p>
<h4 id="3-2-2-set方法详解"><a href="#3-2-2-set方法详解" class="headerlink" title="3.2.2 set方法详解"></a>3.2.2 set方法详解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.set(value);                              <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">// may set null to remove value</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == value)                               <span class="comment">// @2</span></span><br><span class="line">        removeValue();</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">	addValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先调用父类的set方法，将value存入线程本地遍历，即Thread对象的inheritableThreadLocals中。</p>
<p>代码@2：如果value为空，则调用removeValue()否则调用addValue。</p>
<p>那接下来重点看看这两个方法有什么名堂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!holder.get().containsKey(<span class="keyword">this</span>)) &#123;    <span class="comment">// @1</span></span><br><span class="line">        holder.get().put(<span class="keyword">this</span>, <span class="keyword">null</span>); <span class="comment">// WeakHashMap supports null value.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    holder.get().remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：当前线程在调用threadLocal方法的set方法(即向线程本地遍历存储数据时)，如果需要设置的值不为null，则调用addValue方法，将当前ThreadLocal存储到TransmittableThreadLocal的全局静态变量holder。holder的定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; holder =</span><br><span class="line">            <span class="keyword">new</span> InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; initialValue() &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; childValue(Map&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; parentValue) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WeakHashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;(parentValue);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br></pre></td></tr></table></figure>
<p>从中可以看出，使用了线程本地变量，内部存放的结构为Map&lt;TransmittableThreadLocal<?>, ?>，即该对象缓存了线程执行过程中所有的TransmittableThreadLocal对象，并且其关联的值不为空。但这样做有什么用呢？</p>
<p>为了解开这个难题，可能需要大家对ttl这个框架的使用有一定的理解，本文由于篇幅的原因，将不会详细介绍，如有大家有兴趣，可以查阅其官网了解其使用：<a href="https://github.com/alibaba/transmittable-thread-local">https://github.com/alibaba/transmittable-thread-local</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(<span class="number">4</span>));</span><br><span class="line">TransmittableThreadLocal&lt;String&gt; parent = <span class="keyword">new</span> TransmittableThreadLocal&lt;String&gt;();</span><br><span class="line">parent.set(<span class="string">&quot;value-set-in-parent&quot;</span>);</span><br><span class="line">Runnable task = <span class="keyword">new</span> Task(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Callable call = <span class="keyword">new</span> Call(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">executorService.submit(task);</span><br><span class="line">executorService.submit(call);</span><br><span class="line"></span><br><span class="line">我们从submit为突破口，来尝试解开holder属性用途。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExecutorTtlWrapper</span> <span class="keyword">implements</span> <span class="title">Executor</span>, <span class="title">TtlEnhanced</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    ExecutorTtlWrapper(<span class="meta">@Nonnull</span> Executor executor) &#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="meta">@Nonnull</span> Runnable command)</span> </span>&#123;</span><br><span class="line">        executor.execute(TtlRunnable.get(command));  <span class="comment">// @1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Nonnull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Executor <span class="title">unwrap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在向线程池提交任务时，会使用TtlRunnable对提交任务进行包装。接下来将重点探讨TtlRunnable。</p>
<h4 id="3-2-2-TtlRunnable详解"><a href="#3-2-2-TtlRunnable详解" class="headerlink" title="3.2.2 TtlRunnable详解"></a>3.2.2 TtlRunnable详解</h4><h5 id="3-2-2-1-类图"><a href="#3-2-2-1-类图" class="headerlink" title="3.2.2.1 类图"></a>3.2.2.1 类图</h5><p><img src="https://img-blog.csdnimg.cn/20190720230352201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面一一来介绍其核心属性：</p>
<ul>
<li>AtomicReference&lt; Object&gt; capturedRef<br>“捕获”的引用，根据下文的解读，该引用指向的数据结构包含了父线程在执行过程中，通过使用TransmittableThreadLocal存储的本地线程变量，但这里的触发时机是向线程池提交任务时捕获。</li>
<li>Runnable runnable<br>提交到线程池中待执行的业务逻辑。</li>
<li>boolean releaseTtlValueReferenceAfterRun<br>默认为false。</li>
</ul>
<p>接下来重点看一下其构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TtlRunnable</span><span class="params">(<span class="meta">@Nonnull</span> Runnable runnable, <span class="keyword">boolean</span> releaseTtlValueReferenceAfterRun)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.capturedRef = <span class="keyword">new</span> AtomicReference&lt;Object&gt;(capture());   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.runnable = runnable;</span><br><span class="line">    <span class="keyword">this</span>.releaseTtlValueReferenceAfterRun = releaseTtlValueReferenceAfterRun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法没什么特别，重点看一下子线程是如何“捕获”父线程中已设置的本地线程变量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TransmittableThreadLocal$Transmitter#capture</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; captured = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (TransmittableThreadLocal&lt;?&gt; threadLocal : holder.get().keySet()) &#123;     <span class="comment">// @2</span></span><br><span class="line">        captured.put(threadLocal, threadLocal.copyValue());                              <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> captured;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先创建Map容器，用来存储父线程的本地线程变量，键为在父线程执行过程中使用到的TransmittableThreadLocal线程。</p>
<p>代码@2：holder.get()，获取父线程中使用中的ThreadLocal，因为我们从3.2.2节中发现，在当前线程在调用TransmittableThreadLocal的set方法，并且其值不为空的时候，会将TransmittableThreadLocal对象存储存储在当前线程的本地变量中。故这里使用holder.get()方法能获取父线程中已使用的ThreadLocal，并其值不为null。</p>
<p>代码@3：遍历父线程已使用的线程本地，将其值存入到captured中，注意默认是浅拷贝，如果向实现深度拷贝，请重写TransmittableThreadLocal的copyValue方法。</p>
<blockquote>
<p>温馨提示：从这里看出TransmittableThreadLocal的静态属性holder的用处吧，请重点理解holder的属性类型为：InheritableThreadLocal&lt;Map&lt;TransmittableThreadLocal<?>, ?>&gt;。</p>
</blockquote>
<p>在向线程池提交任务时，就会先捕获父线程(提交任务到线程池的线程)中的本地环境变量，接下来重点来看一下其run方法。</p>
<h5 id="3-2-2-2-run方法"><a href="#3-2-2-2-run方法" class="headerlink" title="3.2.2.2 run方法"></a>3.2.2.2 run方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object captured = capturedRef.get();             </span><br><span class="line">    <span class="keyword">if</span> (captured == <span class="keyword">null</span> || releaseTtlValueReferenceAfterRun &amp;&amp; !capturedRef.compareAndSet(captured, <span class="keyword">null</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;TTL value reference is released after run!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object backup = replay(captured);                <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runnable.run();                                           <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        restore(backup);                                        <span class="comment">// @3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：”重放”父线程的本地环境变量，即使用从父线程中捕获过来的上下文环境，在子线程中重新执行一遍，并返回原先存在与子线程中的上下文环境变量。</p>
<p>代码@2：执行业务逻辑。</p>
<p>代码@3：恢复线程池中当前执行任务的线程的上下文环境，即代码@1，会直接继承父线程中的上下文环境，但会将原先存在该线程的线程上下文环境进行备份，在任务执行完后通过执行restore方法进行恢复。</p>
<p>不得不佩服这里设计的巧妙。笔者有理由相信能看到这里的诸位读者一定是有实力有求知的欲望的人，那我们在来看一下replay、restore方法的实现。</p>
<h5 id="3-2-2-3-replay"><a href="#3-2-2-3-replay" class="headerlink" title="3.2.2.3 replay"></a>3.2.2.3 replay</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">replay</span><span class="params">(<span class="meta">@Nonnull</span> Object captured)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; capturedMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) captured;      <span class="comment">// @1</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backup = <span class="keyword">new</span> HashMap&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;();              </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();               <span class="comment">// @2</span></span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">        backup.put(threadLocal, threadLocal.get());                                                                                                                       <span class="comment">// @3</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in captured</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after replay when run task</span></span><br><span class="line">        <span class="keyword">if</span> (!capturedMap.containsKey(threadLocal)) &#123;                                                                                                                    <span class="comment">// @4</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">     <span class="comment">// set values to captured TTL</span></span><br><span class="line">      setTtlValuesTo(capturedMap);                                                                                                                                              <span class="comment">// @5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// call beforeExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">true</span>);                                                                                                                                                     <span class="comment">// @6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> backup;                                                                                                                                                                       <span class="comment">// @7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先解释一下两个局部变量的含义：</p>
<ul>
<li>capturedMap<br>子线程从父线程捕获的线程本地遍历。</li>
<li>backup<br>线程池中处理本次任务的线程中原先存在的本地线程变量。</li>
</ul>
<p>代码@2：holder.get()，这里是子线程中原先存在的本地线程变量(即线程池中分配来执行本次任务的线程)，然后遍历它，将其存储在backUp(@3)。</p>
<p>代码@4：从这里开始，开始将根据父线程的本地变量来重放当前线程，如果父线程中不包含的threadlocal对象，将从本地线程变量中移除。</p>
<p>代码@5：遍历父线程中的本地线程变量，在子线程中重新执行一次threadlocal.set方法。</p>
<p>代码@6：执行beforeExecute()狗子函数。</p>
<p>代码@7：返回线程池原线程的本地线程变量，供本次调用后恢复上下文环境。</p>
<h5 id="3-2-2-4-restore"><a href="#3-2-2-4-restore" class="headerlink" title="3.2.2.4 restore"></a>3.2.2.4 restore</h5><p>恢复线程中子线程原先的本地线程变量，即恢复线程，本次执行并不会污染线程池中线程原先的上下文环境，精妙。我们来看看其代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">restore</span><span class="params">(<span class="meta">@Nonnull</span> Object backup)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt; backupMap = (Map&lt;TransmittableThreadLocal&lt;?&gt;, Object&gt;) backup;      <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">// call afterExecute callback</span></span><br><span class="line">    doExecuteCallback(<span class="keyword">false</span>);                                                                                                                                                   <span class="comment">// @2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt;&gt; iterator = holder.get().entrySet().iterator();           <span class="comment">// @3</span></span><br><span class="line">                 iterator.hasNext(); ) &#123;</span><br><span class="line">        Map.Entry&lt;TransmittableThreadLocal&lt;?&gt;, ?&gt; next = iterator.next();</span><br><span class="line">        TransmittableThreadLocal&lt;?&gt; threadLocal = next.getKey();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clear the TTL values that is not in bac1kup</span></span><br><span class="line">        <span class="comment">// avoid the extra TTL values after restore</span></span><br><span class="line">        <span class="keyword">if</span> (!backupMap.containsKey(threadLocal)) &#123;                                                                                                                     <span class="comment">// @4</span></span><br><span class="line">            iterator.remove();</span><br><span class="line">            threadLocal.superRemove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restore TTL values</span></span><br><span class="line">    setTtlValuesTo(backupMap);                                                                                                                                                  <span class="comment">// @5</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码@1：获取备份好的线程本地上下文。</p>
<p>代码@2：执行afterExecute()钩子函数。</p>
<p>代码@3：遍历本地线程变量，将不属于backUpMap中存在的线程本地上下文移除(@4)。</p>
<p>代码@5：遍历备份的本地线程本地，在本地线程中重新执行threadlocal#set方法，实现线程本地变量的还原。</p>
<p>本文介绍到这里了，详细介绍了ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal的实现原理，并从ThreadLocal、InheritableThreadLocal的局限性，最终引出TransmittableThreadLocal，为全链路压测中压测标记的透传打下坚实的基础。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>全链路</tag>
        <tag>ThreadLocal</tag>
        <tag>InheritableThreadLocal</tag>
        <tag>ttl</tag>
      </tags>
  </entry>
  <entry>
    <title>初识Stream、流的基本操作（流计算）</title>
    <url>/posts/3f62c87c.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文中的部分示例基于如下场景：餐厅点菜，Dish为餐厅中可提供的菜品，Dish的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Dish &#123;</span><br><span class="line">    &#x2F;** 菜品名称 *&#x2F;</span><br><span class="line">	private final String name;</span><br><span class="line">	&#x2F;** 是否是素食 *&#x2F;</span><br><span class="line">	private final boolean vegetarian;</span><br><span class="line">	&#x2F;** 含卡路里 *&#x2F;</span><br><span class="line">	private final int calories;</span><br><span class="line">	&#x2F;** 类型 *&#x2F;</span><br><span class="line">	private final Type type;</span><br><span class="line">	</span><br><span class="line">	public Dish(String name, boolean vegetarian, int calories, Type type) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">		this.vegetarian &#x3D; vegetarian;</span><br><span class="line">		this.calories &#x3D; calories;</span><br><span class="line">		this.type &#x3D; type;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public enum Type &#123; MEAT, FISH, OTHER &#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 省略set get方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>菜单的数据如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; menu &#x3D; Arrays.asList(</span><br><span class="line">new Dish(&quot;pork&quot;, false, 800, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;beef&quot;, false, 700, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;chicken&quot;, false, 400, Dish.Type.MEAT),</span><br><span class="line">new Dish(&quot;french fries&quot;, true, 530, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;rice&quot;, true, 350, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;season fruit&quot;, true, 120, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;pizza&quot;, true, 550, Dish.Type.OTHER),</span><br><span class="line">new Dish(&quot;prawns&quot;, false, 300, Dish.Type.FISH),</span><br><span class="line">new Dish(&quot;salmon&quot;, false, 450, Dish.Type.FISH) );</span><br></pre></td></tr></table></figure>
<p>我们以一个简单的示例来引入流：从菜单列表中，查找出是素食的菜品，并打印其菜品的名称。</p>
<p>在Java8之前，我们通常是这样实现该需求的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; dishNames &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">for(Dish d menu) &#123;</span><br><span class="line">    if(d.isVegetarian()) &#123;</span><br><span class="line">        dishNames.add(d.getName()); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;输出帅选出来的菜品的名称：</span><br><span class="line">for(String n : dishNames) &#123;</span><br><span class="line">    System.out.println(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那在java8中，我们可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu.streams() .filter( Dish::isVegetarian).map( Dish::getName) .forEach( a -&gt; System.out.println(a) );</span><br></pre></td></tr></table></figure>
<p>其运行输出的结果：<br><img src="https://img-blog.csdnimg.cn/20190518134242508.png" alt="在这里插入图片描述"><br>怎么样，神奇吧！！！</p>
<p>在解释上面的代码之前，我们先对流做一个理论上的介绍。</p>
<h2 id="1、流是什么？"><a href="#1、流是什么？" class="headerlink" title="1、流是什么？"></a>1、流是什么？</h2><p>流，就是数据流，是元素序列，在Java8中，流的接口定义在 java.util.stream.Stream包中，并且在Collection(集合)接口中新增一个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default Stream&lt;E&gt; stream() &#123;</span><br><span class="line">        return StreamSupport.stream(spliterator(), false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流的简短定义：从支持数据处理操作的源生成的元素序列。例如集合、数组都是支持数据操作的数据结构（容器），都可以做为流的创建源，该定义的核心要素如下：</p>
<ul>
<li>源<br>流是从一个源创建来而来，而且这个源是支持数据处理的，例如集合、数组等。</li>
<li>元素序列<br>流代表一个元素序列（流水线），因为是从根据一个数据处理源而创建得来的。</li>
<li>数据处理操作<br>流的侧重点并不在数据存储，而在于数据处理，例如示例中的filter、map、forEach等。</li>
<li>迭代方式<br>流的迭代方式为内部迭代，而集合的迭代方式为外部迭代。例如我们遍历Collection接口需要用户去做迭代，例如for-each，然后在循环体中写对应的处理代码，这叫外部迭代。相反，Stream库使用内部迭代，我们只需要对流传入对应的函数即可，表示要做什么就行。</li>
</ul>
<blockquote>
<p>注意：流和迭代器Iterator一样，只能遍历一次，如果要多次遍历，请创建多个流。</p>
</blockquote>
<p>接下来我们将重点先介绍流的常用操作方法。</p>
<h2 id="2、常用的流操作方法"><a href="#2、常用的流操作方法" class="headerlink" title="2、常用的流操作方法"></a>2、常用的流操作方法</h2><h4 id="2-1-filter"><a href="#2-1-filter" class="headerlink" title="2.1 filter"></a>2.1 filter</h4><p>filter函数的方法声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.util.stream.Stream#filter</span><br><span class="line">Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>该方法接收一个谓词，返回一个流，即filter方法接收的lambda表达式需要满足 （  T  -&gt; Boolean ）。</p>
<p>示例：从菜单中选出所有是素食的菜品：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Dish&gt; vegetarianDishs &#x3D; menu.stream().filter(  Dish::isVegetarian )    &#x2F;&#x2F; 使用filter过滤流中的菜品。</span><br><span class="line">                                          .collect(toList())；              &#x2F;&#x2F; 将流转换成List，该方法将在后面介绍。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>温馨提示：流的操作可以分成中间件操作和终端操作。中间操作通常的返回结果还是流，并且在调用终端操作之前，并不会立即调用，等终端方法调用后，中间操作才会真正触发执行，该示例中的collect方法为终端方法。</p>
</blockquote>
<p>我们类比一下数据库查询操作，除了基本的筛选动作外，还有去重，分页等功能，那java8的流API能支持这些操作吗？<br>答案当然是肯定。</p>
<h4 id="2-1-1-distinct"><a href="#2-1-1-distinct" class="headerlink" title="2.1.1 distinct"></a>2.1.1 distinct</h4><p>distinct，类似于数据库中的排重函数，就是对结果集去重。<br>例如有一个数值numArr = [1,5,8,6,5,2,6]，现在要输出该数值中的所有奇数并且不能重复输出，那该如何实现呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.stream(numArr).filter(  a -&gt; a % 2 &#x3D;&#x3D; 0 ).distinict().forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-limit"><a href="#2-1-2-limit" class="headerlink" title="2.1.2 limit"></a>2.1.2 limit</h4><p>截断流，返回一个i不超过指定元素个数的流。<br>还是以上例举例，如果要输出的元素是偶数，不能重复输出，并且只输出1个元素，那又该如何实现呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Arrays.stream(numArr).filter(  a -&gt; a % 2 &#x3D;&#x3D; 0 ).distinict().limit(1).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-skip"><a href="#2-1-3-skip" class="headerlink" title="2.1.3 skip"></a>2.1.3 skip</h4><p>跳过指定元素，返回剩余元素的流，与limit互补。</p>
<a id="more"></a>

<h4 id="2-2-Map"><a href="#2-2-Map" class="headerlink" title="2.2 Map"></a>2.2 Map</h4><p>还是类比数据库操作，我们通常可以只选择一个表中的某一列，java8流操作也提供了类似的方法。<br>例如，我们需要从菜单中提取所有菜品的名称，在java8中我们可以使用如下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">版本1：List&lt;String&gt; dishNames &#x3D; menu.stream().map( (Dish d) -&gt; d.getName() ).collect(Collectors.toList());</span><br><span class="line">版本2：List&lt;String&gt; dishNames &#x3D; menu.stream().map( d -&gt; d.getName() ).collect(Collectors.toList());</span><br><span class="line">版本3：List&lt;String&gt; dishNames &#x3D; menu.stream().map(Dish::getName).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>文章的后续部分尽量使用最简洁的lambda表达式。</p>
</blockquote>
<p>我们来看一下Stream关于map方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</span><br></pre></td></tr></table></figure>
<p>接受一个函数Function，其函数声明为：T -&gt; R，接收一个T类型的对象，返回一个R类型的对象。</p>
<p>当然，java为了高效的处理基础数据类型（避免装箱、拆箱带来性能损耗）也定义了如下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</span><br><span class="line">LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper)</span><br><span class="line">DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</span><br></pre></td></tr></table></figure>

<p>思考题：对于字符数值[“Hello”,”World”] ，输出字符序列，并且去重。<br>第一次尝试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br><img src="https://img-blog.csdnimg.cn/20190518134853228.png" alt="在这里插入图片描述"><br>为什么会返回两个String[]元素呢？因为map(s -&gt; s.split()) 此时返回的流为Stream&lt;String[]&gt;，那我们是不是可以继续对该Steam[String[]],把String[]转换为字符流，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .map(Arrays::stream)</span><br><span class="line">                    .distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其返回结果：<br><img src="https://img-blog.csdnimg.cn/20190518134944653.png" alt="在这里插入图片描述"><br>还是不符合预期，其实原因也很好理解，再次经过map(Arrays:stream)后，返回的结果为 Stream&lt;Stream&lt; String&gt;&gt;，即包含两个元素，每一个元素为一个字符流，可以通过如下代码验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .map(Arrays::stream)</span><br><span class="line">                    .forEach(  (Stream&lt;String&gt; s) -&gt; &#123;</span><br><span class="line">                        System.out.println(&quot;\n --start---&quot;);</span><br><span class="line">                        s.forEach(a -&gt; System.out.print(a + &quot; &quot;));</span><br><span class="line">                        System.out.println(&quot;\n --end---&quot;);</span><br><span class="line">                    &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综合上述分析，之所以不符合预期，主要是原数组中的两个字符，经过map后返回的是两个独立的流，那有什么方法将这两个流合并成一个流，然后再进行disinic去重呢？</p>
<p>答案当然是可以的，flatMap方法闪亮登场：先看代码和显示结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test_flat_map() &#123;</span><br><span class="line">    String[] strArr &#x3D; new String[] &#123;&quot;hello&quot;, &quot;world&quot;&#125;;</span><br><span class="line">    List&lt;String&gt; strList &#x3D; Arrays.asList(strArr);</span><br><span class="line">    strList.stream().map( s -&gt; s.split(&quot;&quot;))</span><br><span class="line">                    .flatMap(Arrays::stream)</span><br><span class="line">                    .distinct().forEach( a -&gt; System.out.print(a +&quot; &quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其输出结果：<br><img src="https://img-blog.csdnimg.cn/20190518135118267.png" alt="在这里插入图片描述"><br>符合预期。一言以蔽之，flatMap可以把两个流合并成一个流进行操作。</p>
<h4 id="2-3-查找和匹配"><a href="#2-3-查找和匹配" class="headerlink" title="2.3 查找和匹配"></a>2.3 查找和匹配</h4><p>Stream API提供了allMatch、anyMatch、noneMatch、findFirst和findAny方法来实现对流中数据的匹配与查找。</p>
<h5 id="2-3-1-allMatch"><a href="#2-3-1-allMatch" class="headerlink" title="2.3.1 allMatch"></a>2.3.1 allMatch</h5><p>我们先看一下该方法的声明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean allMatch(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>接收一个谓词函数(T-&gt;boolean)，返回一个boolean值，是一个终端操作，用于判断流中的所有元素是否与Predicate相匹配，只要其中一个元素不复合，该表达式将返回false。<br>示例如下：例如存在这样一个List a,其中元素为 1,2,4,6,8。判断流中的元素是否都是偶数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().allMatch(  a -&gt; a % 2 &#x3D;&#x3D; 0 )；  &#x2F;&#x2F; 将返回false。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-2-anyMatch"><a href="#2-3-2-anyMatch" class="headerlink" title="2.3.2 anyMatch"></a>2.3.2 anyMatch</h5><p>该方法的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean anyMatch(Predicate&lt;? super T&gt; predicate)</span><br></pre></td></tr></table></figure>
<p>同样接收一个谓词Predicate( T -&gt; boolean )，表示只要流中的元素至少一个匹配谓词，即返回真。</p>
<p>示例如下：例如存在这样一个List a,其中元素为 1,2,4,6,8。判断流中的元素是否包含偶数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().anyMatch(  a -&gt; a % 2 &#x3D;&#x3D; 0 )；  &#x2F;&#x2F; 将返回true。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-3-noneMatch"><a href="#2-3-3-noneMatch" class="headerlink" title="2.3.3 noneMatch"></a>2.3.3 noneMatch</h5><p>该方法的函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean noneMatch(Predicate&lt;? super T&gt; predicate);</span><br></pre></td></tr></table></figure>
<p>同样接收一个谓词Predicate( T -&gt; boolean )，表示只要流中的元素全部不匹配谓词表达式，则返回true。</p>
<p>示例如下：例如存在这样一个List a,其中元素为 2,4,6,8。判断流中的所有元素都不式奇数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean result &#x3D; a.stream().noneMatch(  a -&gt; a % 2 &#x3D;&#x3D; 1 )；  &#x2F;&#x2F; 将返回true。</span><br></pre></td></tr></table></figure>

<h5 id="2-3-4-findFirst"><a href="#2-3-4-findFirst" class="headerlink" title="2.3.4 findFirst"></a>2.3.4 findFirst</h5><p>查找流中的一个元素，其函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; findFirst();</span><br></pre></td></tr></table></figure>
<p>返回流中的一个元素。其返回值为Optional<T>，这是jdk8中引入的一个类，俗称值容器类，其主要左右是用来避免值空指针，一种更加优雅的方式来处理null。该类的具体使用将在下一篇详细介绍。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test_find_first(List&lt;Dish&gt; menu) &#123;</span><br><span class="line">    Optional&lt;Dish&gt; dish &#x3D; menu.stream().findFirst();</span><br><span class="line">    &#x2F;&#x2F; 这个方法表示，Optional中包含Dish对象，则执行里面的代码，否则什么事不干，是不是比判断是否为null更友好</span><br><span class="line">    dish.ifPresent(a -&gt; System.out.println(a.getName()));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-5-findAny"><a href="#2-3-5-findAny" class="headerlink" title="2.3.5 findAny"></a>2.3.5 findAny</h5><p>返回流中任意一个元素，其函数声明如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; findAny();</span><br></pre></td></tr></table></figure>
<h4 id="2-4-reduce"><a href="#2-4-reduce" class="headerlink" title="2.4 reduce"></a>2.4 reduce</h4><p>reduce归约，看过大数据的人用过会非常敏感，目前的java8的流操作是不是有点map-reduce的味道，归约，就是对流中所有的元素进行统计分析，归约成一个数值。<br>首先我们看一下reduce的函数说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</span><br></pre></td></tr></table></figure>
<ul>
<li>T identity：累积器的初始值。</li>
<li>BinaryOperator&lt; T&gt; accumulator：累积函数。BinaryOperator&lt; T&gt; extend BiFunction&lt;T, U, R&gt;。BinaryOperator<T>的函数式表示，接受两个T类型的入参，返回T类型的返回值。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);</span><br></pre></td></tr></table></figure>
可以理解为没有初始值的归约，如果流为空，则会返回空，故其返回值使用了Optional类来优雅处理null值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);</span><br></pre></td></tr></table></figure>
<p>首先，最后的返回值类型为U。</p>
<ul>
<li>U identity：累积函数的初始值。</li>
<li>BiFunction&lt;U, ? super T, U&gt; accumulator：累积器函数，对流中的元素使用该累积器进行归约，在具体执行时accumulator.apply(  identity,  第二个参数的类型不做限制 )，只要最终返回U即可。</li>
<li>BinaryOperator&lt; U&gt; combiner：组合器。对累积器的结果进行组合，因为归约reduce，java流计算内部使用了fork-join框架，会对流的中的元素使用并行累积，每个线程处理流中一部分数据，最后对结果进行组合，得出最终的值。</li>
</ul>
<blockquote>
<p>温馨提示：对流API的学习，一个最最重点的就是要掌握这些函数式编程接口，然后掌握如何使用Lambda表达式进行行为参数化（lambda表达当成参数传入到函数中）。</p>
</blockquote>
<p>接下来我们举例来展示如何使用reduce。<br>示例1：对集合中的元素求和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; goodsNumber &#x3D; Arrays.asList(   3, 5, 8, 4, 2, 13 );</span><br><span class="line">java7之前的示例：</span><br><span class="line">int sum &#x3D; 0;</span><br><span class="line">for(Integer i : goodsNumber) &#123;</span><br><span class="line">sum +&#x3D; i;&#x2F;&#x2F;  sum &#x3D; sum + i;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;sum:&quot; + sum);</span><br></pre></td></tr></table></figure>
<p>求和运算符： c = a + b，也就是接受2个参数，返回一个值，并且这三个值的类型一致。</p>
<p>故我们可以使用T reduce(T identity, BinaryOperator&lt; T&gt; accumulator)来实现我们的需求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test_reduce() &#123;</span><br><span class="line">    List&lt;Integer&gt; goodsNumber &#x3D; Arrays.asList(   3, 5, 8, 4, 2, 13 );</span><br><span class="line">    int sum &#x3D; goodsNumber.stream().reduce(0, (a,b) -&gt; a + b);</span><br><span class="line">    &#x2F;&#x2F;这里也可以写成这样：</span><br><span class="line">    &#x2F;&#x2F; int sum &#x3D; goodsNumber.stream().reduce(0, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不知大家是否只读(a,b)这两个参数的来源，其实第一个参数为初始值T identity，第二个参数为流中的元素。</p>
<p>那三个参数的reduce函数主要用在什么场景下呢？接下来还是用求和的例子来展示其使用场景。在java多线程编程模型中，引入了fork-join框架，就是对一个大的任务进行先拆解，用多线程分别并行执行，最终再两两进行合并，得出最终的结果。reduce函数的第三个函数，就是组合这个动作，下面给出并行执行的流式处理示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public static void test_reduce_combiner() &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;** 初始化待操作的流 *&#x2F;</span><br><span class="line">    List&lt;Integer&gt; nums &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">    int s &#x3D; 0;</span><br><span class="line">    for(int i &#x3D; 0; i &lt; 200; i ++) &#123;</span><br><span class="line">        nums.add(i);</span><br><span class="line">        s &#x3D; s + i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 对流进行归并，求和,这里使用了流的并行执行版本 parallelStream，内部使用Fork-Join框架多线程并行执行，</span><br><span class="line">    &#x2F;&#x2F; 关于流的内部高级特性，后续再进行深入，目前先以掌握其用法为主。</span><br><span class="line">    int sum2 &#x3D; nums.parallelStream().reduce(0,Integer::sum, Integer::sum);</span><br><span class="line">    System.out.println(&quot;和为：&quot; + sum2);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 下面给出上述版本的debug版本。</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 累积器执行的次数</span><br><span class="line">    AtomicInteger accumulatorCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 组合器执行的次数（其实就是内部并行度）</span><br><span class="line">    AtomicInteger combinerCount &#x3D; new AtomicInteger(0);</span><br><span class="line"></span><br><span class="line">    int sum &#x3D; nums.parallelStream().reduce(0,(a,b) -&gt; &#123;</span><br><span class="line">                accumulatorCount.incrementAndGet();</span><br><span class="line">                return a + b;</span><br><span class="line">           &#125;, (c,d) -&gt; &#123;</span><br><span class="line">                combinerCount.incrementAndGet();</span><br><span class="line">                return  c+d;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;accumulatorCount:&quot; + accumulatorCount.get());</span><br><span class="line">    System.out.println(&quot;combinerCountCount:&quot; + combinerCount.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果上可以看出，执行了100次累积动作，但只进行了15次合并。</p>
<p>流的基本操作就介绍到这里，在此总结一下，目前接触到的流操作：<br>1、filter</p>
<ul>
<li>函数功能：过滤</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean</li>
</ul>
<p>2、distinct</p>
<ul>
<li>函数功能：去重</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
</ul>
<p>3、skip</p>
<ul>
<li>函数功能：跳过n个元素</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>接受参数：long</li>
</ul>
<p>4、limit</p>
<ul>
<li>函数功能：截断流，值返回前n个元素的流</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>接受参数：long</li>
</ul>
<p>5、map</p>
<ul>
<li>函数功能：映射</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<R></li>
<li>函数式接口：Function&lt;T,R&gt;</li>
<li>函数描述符：T -&gt; R<br>6、flatMap</li>
<li>函数功能：扁平化流，将多个流合并成一个流</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<R></li>
<li>函数式接口：Function&lt;T, Stream<R>&gt;</li>
<li>函数描述符：T -&gt; Stream<R><br>7、sorted</li>
<li>函数功能：排序</li>
<li>操作类型：中间操作</li>
<li>返回类型：Stream<T></li>
<li>函数式接口：Comparator<T></li>
<li>函数描述符：(T,T) -&gt; int<br>8、anyMatch</li>
<li>函数功能：流中任意一个匹配则返回true</li>
<li>操作类型：终端操作</li>
<li>返回类型：boolean</li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean<br>9、allMatch</li>
<li>函数功能：流中全部元素匹配则返回true</li>
<li>操作类型：终端操作</li>
<li>返回类型：boolean</li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean<br>10、 noneMatch</li>
<li>函数功能：流中所有元素都不匹配则返回true</li>
<li>操作类型：终端操作</li>
<li>返回类型：boolean</li>
<li>函数式接口：Predicate<T></li>
<li>函数描述符：T -&gt; boolean<br>11、findAny</li>
<li>函数功能：从流中任意返回一个元素</li>
<li>操作类型：终端操作</li>
<li>返回类型：Optional<T><br>12、findFirst</li>
<li>函数功能：返回流中第一个元素</li>
<li>操作类型：终端操作</li>
<li>返回类型：Optional<T><br>13、forEach</li>
<li>函数功能：遍历流</li>
<li>操作类型：终端操作</li>
<li>返回类型：void</li>
<li>函数式接口：Consumer<T></li>
<li>函数描述符：T -&gt; void<br>14、collect</li>
<li>函数功能：将流进行转换</li>
<li>操作类型：终端操作</li>
<li>返回类型：R</li>
<li>函数式接口：Collector&lt;T,A,R&gt;</li>
</ul>
<p>15、reduce</p>
<ul>
<li><p>函数功能：规约流</p>
</li>
<li><p>操作类型：终端操作 </p>
</li>
<li><p>返回类型：Optional<T></p>
</li>
<li><p>函数式接口：BinaryOperator<T></p>
</li>
<li><p>函数描述符：(T,T) -&gt; T</p>
<p>16、count</p>
</li>
<li><p>函数功能：返回流中总元素个数</p>
</li>
<li><p>操作类型：终端操作</p>
</li>
<li><p>返回类型：long</p>
</li>
</ul>
<p>由于篇幅的原因，流的基本计算就介绍到这里了，下文还将重点介绍流的创建，数值流与Optional类的使用。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>java8</category>
      </categories>
      <tags>
        <tag>java8</tag>
        <tag>Lambda</tag>
        <tag>流计算</tag>
      </tags>
  </entry>
  <entry>
    <title>探究 Canal EventParser 的设计与实现奥妙</title>
    <url>/posts/7d86d97a.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将从三个方面深度剖析 EventParser 组件。</p>
<ul>
<li>从官方文档看 EventParser 的设计思想</li>
<li>从 EventParser 初始化了解内部的是可配置项</li>
<li>从 EventParser 的启动窥探其工作实现原理</li>
</ul>
<blockquote>
<p>温馨提示：本篇篇幅较长，如果耐心阅读一定会有不错的收获，为了提高阅读体验，本文所有源码都是通过截图方式，大家可以重点阅读对应的文字说明，并在文末进行了总结。</p>
</blockquote>
<h2 id="1、官方文档看-EventParser"><a href="#1、官方文档看-EventParser" class="headerlink" title="1、官方文档看 EventParser"></a>1、官方文档看 EventParser</h2><p>首先我们先从官方文档来看 EventParser 的整体设计，其架构设计图如下所示：<br><img src="https://img-blog.csdnimg.cn/20200705153423275.jpeg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>上述图罗列出了 EventParser 的整体工作流程图，其关键步骤如下：</p>
<ol>
<li>从 Log Position 管理器中获取上一次解析的日志位点。</li>
<li>向 Mysql Master 节点发送 BINLOG_DUMP 请求。</li>
<li>Mysql Master 节点从 Slave 端传入的日志位点开始向从节点推送 binlog 日志。</li>
<li>Slave 接收 binlog 日志，调用 BinlogParser 解析 binlog日志。</li>
<li>将解析后的结构化数据传入到 EventSink 组件。</li>
<li>定时记录解析 binlog 的日志，以便重启后继续进行增量订阅。</li>
<li>上图中还罗列一个HA 特性，即需要同步的 Master 如果宕机，可以从它的其他从节点继续同步 binlog 日志，避免单点故障。</li>
</ol>
<p>官方文档有助于理解 EventParser 组件的实现原理，但关于如何使用 EventParser 的篇幅较少，故接下来将从源码的角度来反推 EventParser 的特性以及详细的工作实现原理，以便指导我们如何更好的使用 EventParser。</p>
<a id="more"></a>

<h2 id="2、源码剖析-EventParser-初始化"><a href="#2、源码剖析-EventParser-初始化" class="headerlink" title="2、源码剖析 EventParser 初始化"></a>2、源码剖析 EventParser 初始化</h2><p>从上篇文章我们即可得知，EventParser 组件是 Canal Instance 的四大核心组件之一，那本节的故事就从 CanalInstanceWithManager 的 initEventParser 方法开始。</p>
<p>CanalInstanceWithManager#initEventParser<br><img src="https://img-blog.csdnimg.cn/20200705153640787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step1：获取数据库的连接信息，上面的代码就是集合的基本操作，但从上面的代码可以窥探如何配置数据库相关的地址信息。<br>配置 canal instance 中 数据库的地址，用户名密码有如下几种方式（CanalParamter）：</p>
<ul>
<li>单库场景配置方式一：CanalParmeter 中提供了 masterAddress、masterUsername、masterPassword、standbyAddress、standbyUsername、standbyPassword 6 个属性分别用来指定主库与从库的信息，配置了从库的目的是提供 HA 机制。</li>
<li>单库场景配置方式二：CanalParamter 提供的 List<InetSocketAddress>  dbAddresses 方式进行配置，该集合的第一个元素为主库地址、第二个元素为从库地址，其数据库用户名通过 dbUsername、dbPassword 来配置。</li>
<li>多库场景：CanalParmeter 提供了 List&lt; List&lt; DataSourcing&gt;&gt; groupDbAddresses 属性用来设置 mysql 组，例如 MySQL 分库分表。groupDbAddresses 的第一个元素为主库的地址列表，第二个元素为从库的地址列表。</li>
</ul>
<blockquote>
<p>温馨提示：这里的用户名与密码是在对应服务器用于进行 binlog 日志同步的账号信息。</p>
</blockquote>
<p>关于多库场景的配置，再详细举例如下：<br><img src="https://img-blog.csdnimg.cn/20200705153927828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其对应的初始化代码如下：<br><img src="https://img-blog.csdnimg.cn/20200705154029569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>CanalInstanceWithManager#initEventParser<br><img src="https://img-blog.csdnimg.cn/2020070515412716.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step2：根据配置的 MySQL 构建 EventParser 实例。这里有如下几个关键点：</p>
<ul>
<li>如果配置的 MySQL 地址是组方式则会创建 GroupEventParser，其内部会维护一个 EventParser 列表。</li>
<li>通过调用 doInitEventParser 方法创建 EventParser 实例。</li>
</ul>
<p>接下来我们将重点查看 doInitEventParser 的实现细节。<br>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154216986.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：从这里可以看出 Canal 目前并不支持 Oracle 数据，只支持 MySQL 与 本地 binlog 文件(直接根据 binlog 日志文件解析)。</p>
<blockquote>
<p>温馨提示：接下来将重点探讨基于 MySQL binlog 日志，并且会忽略与阿里云相关的 RDS 、tsdb 等数据库辅助支持，只关系与开源 MySQL 相关的处理逻辑。</p>
</blockquote>
<p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154326555.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：MySQL 的 binlog 事件解析器实现类为 MysqlEventParser，这里我们重点来阐述一下这些参数的含义：</p>
<ul>
<li>destination<br>Canal Instance 实例的名称。</li>
<li>connectionCharset<br>字符集，解析 binlog 时会将指定的字节数据使用该编码级进行转换，默认为UTF-8。</li>
<li>connectionCharsetNumber<br>字符集的数字表现形式，UTF8对应的值为 33，该值在与 MySQL 的交互协议包中需要被用到，这里 Canal 处理的不是特别好，最好该属性设置为只读，由 connectionCharset 联动进行设置。</li>
<li>defaultConnectionTimeoutInSeconds<br>MySQL 默认连接超时时间，因为 Canal 会伪装为 MySQL 服务器的 Slave 节点，需要向 MySQL Master 发送请求，故需要先创建链接，这里就是创建连接的默认超市时间，默认为 30s。</li>
<li>sendBufferSize<br>用于网络通道发送端缓存区，目前在 Canal 中网络通道的实现类为 BioSocketChannelPool、NettySocketChannelPool，从代码的角度来看，目前这个参数并不会生效，即使用操作系统的默认值。</li>
<li>receiveBufferSize<br>用于忘了通道接收缓存区大小，目前同 sendBufferSize 参数，并不会生效。</li>
<li>detectingEnable<br>是否开启心跳检测，默认为开启。</li>
<li>detectingSQL<br>心跳检测语句，例如 select 1，show master status 等。</li>
<li>detectingIntervalInSeconds<br>心跳间隔检测，默认为 3s。</li>
<li>slaveId<br>从服务器的 id，在同一个 MySQL 复制组内不能重复。</li>
</ul>
<p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154533494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step4：如果设置了 CanalPrameter 的 List<String> positions 属性，则将其解析为 EntryPosition 实体，我们来看一下如何表征 binlog 日志的位点信息。<br><img src="https://img-blog.csdnimg.cn/20200705154618806.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>其主要的核心参数如下：</p>
<ul>
<li>long timestamp<br>时间戳，用时间戳来表示位置</li>
<li>String journalName<br>binlog 日志的文件名，例如 mysql-bin.000001。</li>
<li>Long position<br>使用偏移量来表示具体位点。</li>
<li>long serverId<br>设置 master 的 id。</li>
<li>String gtid<br>全局事务ID。</li>
</ul>
<blockquote>
<p>温馨提示：实践指导，CanalParameter 的 List&lt; String&gt; positions 不支持组模式，只能设置一组，即第一个元素为主，第二个元素可以为从节点，该属性非必填。</p>
</blockquote>
<p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154725749.png#pic_center" alt="在这里插入图片描述"><br>Step5：继续设置参数，具体看一下各个参数的含义：</p>
<ul>
<li>fallbackIntervalInSeconds<br>如果 MySQL 主节点宕机，Canal 支持切换到其从节点继续同步 binlog 日志，但为了数据的完整性，可以设置一个回退时间，即会造成数据重复下发，但尽量不丢失，该值默认为 60s。</li>
<li>profilingEnabled<br>是否开启性能采集，主要采集的是一批日志经过 EventSink 组件处理到完成 存入EventStore 的时间消耗。 </li>
<li>filterTableError<br>是否忽略表过滤异常，默认为 false，表过滤会在后续文章中详细介绍。</li>
<li>parallel<br>解析、canal 接入 prometheus 采集监控数据是否支持并发，默认为 false。</li>
<li>isGTIDMode<br>是否开启 gtid 模式。</li>
</ul>
<p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154838454.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step6：继续填充解析器相关参数，其重点实现如下：</p>
<ul>
<li>transactionSize<br>Canal 提供了一种机制，尝试讲一个数据库事务中所有的变更日志一起进行处理，这个为处理缓存事务日志的缓存区长度，默认为 1024。</li>
<li>logPositionManager<br>初始化日志位点管理器，Canal 提供了基于内存、zookeeper、内存与zookeepr混合管理器等日志位点管理器，这个后续会详细介绍。</li>
<li>AviaterRegexFilter<br>提供了基于 aviater 的正则表达式，对 table 名称进行过滤。</li>
<li>blackFilter<br>canal 提供了黑名单配置，提供黑名单正则表达式对 table 名称进行过滤。</li>
</ul>
<p>CanalInstanceWithManager#doInitEventParser<br><img src="https://img-blog.csdnimg.cn/20200705154936822.png#pic_center" alt="在这里插入图片描述"><br>Step7：如果解析器是 MySQL 解析器，提供了 HA 机制，即如果 MySQL Master 宕机，Canal 还能主动切换到 MYSQL Slave 节点，继续同步 binlog 日志。</p>
<h2 id="3、EventParser-工作流程详解"><a href="#3、EventParser-工作流程详解" class="headerlink" title="3、EventParser 工作流程详解"></a>3、EventParser 工作流程详解</h2><p>上面已经详细介绍了EventParser 的初始化过程，有助于大家对 CanalInstance 相关配置参数的理解，本节将相信介绍 EventParser 的工作流程，其实现代码入口为 EventParser 的 start 方法。本文重点将探究 MySQL binlog 日志的解析，故其实现类为：MysqlEventParser。</p>
<p>MysqlEventParser 的 start 方法代码如下：<br><img src="https://img-blog.csdnimg.cn/20200705155037845.png#pic_center" alt="在这里插入图片描述"><br>主要调用的是其父类的 start 方法。接下来对其进行详细解读。</p>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155122667.png#pic_center" alt="在这里插入图片描述"><br>Step1：创建环形缓存区，其主要的作用是 Canal 在解析 binlog 日志后，会尽量尝试将一个数据库事务所产生的全部变更日志（一个事务所有变更数据）当成一个整体提交给 EventSink 组件，从而 Canal 的消费方能一次将一个事务的数据全部同步，数据的完整性得到了保证。</p>
<blockquote>
<p>温馨提示：关于环形缓存区的具体实现细节将在下文详细介绍，这里先简单说一下 Canal 目前无法百分之百保证一个事务的数据就一定是一次消费，如果一个事务产生的变更日志超过了环形缓存区的容量，则会被强制提交消费，一个事务的数据会被分开消费，默认环形缓存区的长度为 1024.</p>
</blockquote>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155210317.png#pic_center" alt="在这里插入图片描述"><br>Step2：构建一个 binlog 解析器，该方法在 AbstractEventParser 中为一个抽象方法，具体的实现在其子类中，其代码截图如下：AbstractMysqlEventParser，在 MySQL binlog 解析的实现类为 LogEventConvert，所处的模块为 parse，该部分是整个 Canal EventParser 的核心，将在后续文章中单独详细介绍。<br><img src="https://img-blog.csdnimg.cn/20200705155320470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155756282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step3：启动一个独立的线程来负责 binlog 的解析，其线程包含了 Canal Instance 的 destination、address 等信息，方便利用 jstack 去诊断 binlog 解析相关问题。接下来就是解读该线程的 run 方法，从而探究 binlog 的解析流程。</p>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705155856428.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step31：首先创建一条到需要解析 binlog 日志的服务器，例如需要同步 192.168.1.166:3306 这个数据库实例的 binlog 日志，那 Canal 首先会使用拥有该库复制权限的账号去创建一条TCP连接，本文并不会详细去介绍这里的实现细节，这里代表一个领域，即需要知晓 MySQL 通讯协议，通过TCP与MySQL建立连接，并按照 MySQL 通讯协议发送命令，例如 select、dump 等请求，这个后续在学完 Canal 等核心组件后，可能会深入学习该部分的内容，这里我重点点出其实现的几个关键要点：</p>
<ul>
<li>首先创建一条TCP连接，连接到 MySQL 服务器，Canal 提供了 BIO 与 Netty 两种实现方式。</li>
<li>TCP 三次握手后成功建立TCP连接后，需要与 MySQL  进行握手，完成协议约定，客户端登录校验等，例如握手实现代码见：MysqlConnector negotiate。</li>
<li>一言以蔽之，MySqlConnection 的职责就是实现一个 MySQL 客户端。其效果等同于实现我们常用的 SQL 连接客户端，关于这方面的编程其实不难，如果大家有志成为一名数据库中间件方面的技术人员，只需按照 MySQL 官方文档中有关通讯协议即可。</li>
</ul>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160027515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step32：发送心跳包，这里的关键实现点如下：</p>
<ul>
<li>利用 Timer 实现定时调度，心跳包发送间隔通过 detectingIntervalInSeconds 指定。</li>
<li>心跳包主要是构建一个 CanalEntry.Entry,其类型为EntryType.HEARTBEAT。<br>心跳包并不是发送给远端 MySQL 服务器，而是将 Entry 下发到 EventSink 组件。</li>
<li>该心跳包的用意合作，在这里先留一个伏笔，后续文章会依依揭晓。</li>
</ul>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160316604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step33：执行发送 dump 命令正式从 MySQL 服务器接收 binlog 日志之前的准备工作，具体准备工作如下：</p>
<ul>
<li>首先再创建一条专属数据库连接，主要用于查找 MySQL 的一些配置信息，统称元数据。</li>
<li>向 MySQL 服务器发送 show variables like ‘binlog_format‘ 语句查询服务端配置的 binlog 格式，MySQL 支持 STATEMENT、ROW、MIXED 三种模式。</li>
<li>向 MySQL 服务起发送 show variables like ‘binlog_row_image’ 语句查询服务器断配置的 binlog_row_image。</li>
</ul>
<p>扩展阅读：binlog_format 我相信大家都不陌生，对 binlog_row_image 见过的估计比较少，那 binlog_row_image 有何作用呢？</p>
<p>binlog_row_image 主要是在 binlog_format 为 ROW 模式下，控制记录 binlog 事件的方式，binlog 的作用是记录数据的变化，例如 update 请求，需要记录一行记录变化之前的数据以及变化后的数据，在 binlog event 分别用 before 、after 记录变化前后的数据，但有一个问题，是只发生变化的字段的前后值呢，还是记录一行中所有字段修改前后的值呢？故引入了 binlog_row_image，该值支持如下选项：</p>
<ul>
<li>full：在 before 与 after 中记录所有字段的值，针对每一个字段，使用 update 来表示该字段是否发生变化，该选项为默认值。</li>
<li>minimal：在 before 与 after 中只记录发生变化的字段，并且包含能够唯一识一行数据的值，例如主键。</li>
<li>noblob：在 before 与 after 中记录所有的列值，但 BLOB 与 TEXT 类型的字段列除外（如未更改）。</li>
</ul>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160549515.png#pic_center" alt="在这里插入图片描述"><br>Step34：向 MySQL 服务端发送 show variables like ‘server_id’ 语句，查询服务端配置的 serverId。</p>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160640818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step35：通过日志位点管理器获取需要同步的位点，后续会详细展开。</p>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160732298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step36：通过向 MySQL 发送 dump 请求，从服务器接收 binlog 日志，并进行处理，为了提高性能，Canal 支持该过程进行并行化处理，通过 parallel 属性设置是否支持并发，从而引入 disruptor 高性能并发框架，详情后在后续文章中详细解读。</p>
<p>AbstractEventParser#start<br><img src="https://img-blog.csdnimg.cn/20200705160817485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>Step37：通过接收到 MySQL 服务端返回的日志并解析为 Canal.Entry 对象，并传输到 EventSink 组件。</p>
<p>上述过程反复执行，持续完成 binlog 日志的解析，实现数据的同步。</p>
<p>4、总结<br>本文首先结合官方文档了解了 EventParser，但 Canal 的官方手册并不特别详细，故需要我们通过源码去反推 canal instance 中关于 EventParser 有哪些参数，并且这些参数有何意义，是如何工作的。</p>
<p>众所周知，EventParser 的主要职责就是与 MySQL 服务器“打交道”，将自己伪装成 MySQL 服务器的一个从节点，从服务器端接收 binlog 日志，并将二进制流解码成 Canal.Entry，看似简单，但实现起来还是比较困难的，下面这些方面是后续值得我们研究探讨的点：</p>
<ol>
<li>环形缓存区的使用与技巧。</li>
<li>实现 MySQL 通讯协议，向 MySQL 发送相关SQL语句并解析返回结果\，具体由 MysqlConnection 对象实现。</li>
<li>日志解析位点管理机制。</li>
<li>基于GTID、日志位点偏移量两种方式定位 binlog 日志方式。</li>
<li>dump 命令的发送、高性能设计（ disruptor 框架的引入）</li>
</ol>
<p>本文由于篇幅的问题，对上述知识点只是点到为止，后续会按需要进行深入探讨。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>canal</category>
      </categories>
      <tags>
        <tag>canal</tag>
        <tag>数据异构</tag>
        <tag>EventParser</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 Kafka 消息发送流程(文末附流程图)</title>
    <url>/posts/f81e58bb.html</url>
    <content><![CDATA[<div id="vip-container"><blockquote>
<p>温馨提示：本文基于 Kafka 2.2.1 版本。本文主要是以源码的手段一步一步探究消息发送流程，如果对源码不感兴趣，可以直接跳到文末查看消息发送流程图与消息发送本地缓存存储结构。</p>
</blockquote>
<p>从上文 <a href="https://blog.csdn.net/prestigeding/article/details/102881472">初识 Kafka Producer 生产者</a>，可以通过 KafkaProducer 的 send 方法发送消息，send 方法的声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record)</span></span></span><br><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span></span><br></pre></td></tr></table></figure>
<p>从上面的 API 可以得知，用户在使用 KafkaProducer 发送消息时，首先需要将待发送的消息封装成 ProducerRecord，返回的是一个 Future 对象，典型的 Future 设计模式。在发送时也可以指定一个 Callable 接口用来执行消息发送的回调。</p>
<p>我们在学习消息发送流程之前先来看一下用于封装一条消息的 ProducerRecord 的类图，先来认识一下 kafka 是如何对一条消息进行抽象的。</p>
<h2 id="1、ProducerRecord-类图"><a href="#1、ProducerRecord-类图" class="headerlink" title="1、ProducerRecord 类图"></a>1、ProducerRecord 类图</h2><p><img src="https://img-blog.csdnimg.cn/201911100956254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们首先来看一下 ProducerRecord 的核心属性，即构成 消息的6大核心要素：</p>
<ul>
<li>String topic<br>消息所属的主题。</li>
<li>Integer partition<br>消息所在主题的队列数，可以人为指定，如果指定了 key 的话，会使用 key 的 hashCode 与队列总数进行取模来选择分区，如果前面两者都未指定，则会轮询主题下的所有分区。</li>
<li>Headers headers<br>该消息的额外属性对，与消息体分开存储.</li>
<li>K key<br>消息键，如果指定该值，则会使用该值的 hashcode 与 队列数进行取模来选择分区。</li>
<li>V value<br>消息体。</li>
<li>Long timestamp<br>消息时间戳，根据 topic 的配置信息 message.timestamp.type 的值来赋予不同的值。<ul>
<li>CreateTime<br>发送客户端发送消息时的时间戳。</li>
<li>LogAppendTime<br>消息在 broker 追加时的时间戳。</li>
</ul>
</li>
</ul>
<p>其中Headers是一系列的 key-value 键值对。</p>
<p>在了解 ProducerRecord 后我们开始来探讨 Kafka 的消息发送流程。</p>
<a id="more"></a>

<h2 id="2、Kafka-消息追加流程"><a href="#2、Kafka-消息追加流程" class="headerlink" title="2、Kafka 消息追加流程"></a>2、Kafka 消息追加流程</h2><p>KafkaProducer 的 send 方法，并不会直接向 broker 发送消息，kafka 将消息发送异步化，即分解成两个步骤，send 方法的职责是将消息追加到内存中(分区的缓存队列中)，然后会由专门的 Send 线程异步将缓存中的消息批量发送到 Kafka Broker 中。</p>
<p>消息追加入口为 KafkaProducer#send</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// intercept the record, which can be potentially modified; this method does not throw exceptions</span></span><br><span class="line">    ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors.onSend(record);                <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> doSend(interceptedRecord, callback);                                                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先执行消息发送拦截器，拦截器通过 interceptor.classes 指定，类型为 List&lt; String &gt;，每一个元素为拦截器的全类路径限定名。<br>代码@2：执行 doSend 方法，后续我们需要留意一下 Callback  的调用时机。</p>
<p>接下来我们来看 doSend 方法。</p>
<h3 id="2-1-doSend"><a href="#2-1-doSend" class="headerlink" title="2.1 doSend"></a>2.1 doSend</h3><p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClusterAndWaitTime clusterAndWaitTime;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    clusterAndWaitTime = waitOnMetadata(record.topic(), record.partition(), maxBlockTimeMs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (metadata.isClosed())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>, e);</span><br><span class="line">	<span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> remainingWaitMs = Math.max(<span class="number">0</span>, maxBlockTimeMs - clusterAndWaitTime.waitedOnMetadataMs);</span><br></pre></td></tr></table></figure>
<p>Step1：获取 topic 的分区列表，如果本地没有该topic的分区信息，则需要向远端 broker 获取，该方法会返回拉取元数据所耗费的时间。在消息发送时的最大等待时间时会扣除该部分损耗的时间。</p>
<blockquote>
<p>温馨提示：本文不打算对该方法进行深入学习，后续会有专门的文章来分析 Kafka 元数据的同步机制，类似于专门介绍 RocketMQ 的 Nameserver 类似。</p>
</blockquote>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] serializedKey;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedKey = keySerializer.serialize(record.topic(), record.headers(), record.key());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Can&#x27;t convert key of class &quot;</span> + record.key().getClass().getName() +</span><br><span class="line">                        <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                        <span class="string">&quot; specified in key.serializer&quot;</span>, cce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：序列化 key。注意：序列化方法虽然有传入 topic、Headers 这两个属性，但参与序列化的只是 key 。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] serializedValue;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    serializedValue = valueSerializer.serialize(record.topic(), record.headers(), record.value());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassCastException cce) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SerializationException(<span class="string">&quot;Can&#x27;t convert value of class &quot;</span> + record.value().getClass().getName() +</span><br><span class="line">                        <span class="string">&quot; to class &quot;</span> + producerConfig.getClass(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG).getName() +</span><br><span class="line">                        <span class="string">&quot; specified in value.serializer&quot;</span>, cce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：对消息体内容进行序列化。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> partition = partition(record, serializedKey, serializedValue, cluster);</span><br><span class="line">tp = <span class="keyword">new</span> TopicPartition(record.topic(), partition);</span><br></pre></td></tr></table></figure>
<p>Step4：根据分区负载算法计算本次消息发送该发往的分区。其默认实现类为 DefaultPartitioner，路由算法如下：</p>
<ul>
<li>如果指定了 key ，则使用 key 的 hashcode 与分区数取模。</li>
<li>如果未指定 key，则轮询所有的分区。</li>
</ul>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">setReadOnly(record.headers());</span><br><span class="line">Header[] headers = record.headers().toArray();</span><br></pre></td></tr></table></figure>
<p>Step5：如果是消息头信息(RecordHeaders)，则设置为只读。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> serializedSize = AbstractRecords.estimateSizeInBytesUpperBound(apiVersions.maxUsableProduceMagic(),</span><br><span class="line">                    compressionType, serializedKey, serializedValue, headers);</span><br><span class="line">ensureValidRecordSize(serializedSize);</span><br></pre></td></tr></table></figure>
<p>Step5：根据使用的版本号，按照消息协议来计算消息的长度，并是否超过指定长度，如果超过则抛出异常。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> timestamp = record.timestamp() == <span class="keyword">null</span> ? time.milliseconds() : record.timestamp();</span><br><span class="line">log.trace(<span class="string">&quot;Sending record &#123;&#125; with callback &#123;&#125; to topic &#123;&#125; partition &#123;&#125;&quot;</span>, record, callback, record.topic(), partition);</span><br><span class="line">Callback interceptCallback = <span class="keyword">new</span> InterceptorCallback&lt;&gt;(callback, <span class="keyword">this</span>.interceptors, tp);</span><br></pre></td></tr></table></figure>
<p>Step6：先初始化消息时间戳，并对传入的 Callable(回调函数) 加入到拦截器链中。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (transactionManager != <span class="keyword">null</span> &amp;&amp; transactionManager.isTransactional())</span><br><span class="line">    transactionManager.maybeAddPartitionToTransaction(tp);</span><br></pre></td></tr></table></figure>
<p>Step7：如果事务处理器不为空，执行事务管理相关的，本节不考虑事务消息相关的实现细节，后续估计会有对应的文章进行解析。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RecordAccumulator.RecordAppendResult result = accumulator.append(tp, timestamp, serializedKey, serializedValue, headers, interceptCallback, remainingWaitMs);</span><br><span class="line"><span class="keyword">if</span> (result.batchIsFull || result.newBatchCreated) &#123;</span><br><span class="line">    log.trace(<span class="string">&quot;Waking up the sender since topic &#123;&#125; partition &#123;&#125; is either full or getting a new batch&quot;</span>, record.topic(), partition);</span><br><span class="line">                <span class="keyword">this</span>.sender.wakeup();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result.future;</span><br></pre></td></tr></table></figure>
<p>Step8：将消息追加到缓存区，这将是本文重点需要探讨的。如果当前缓存区已写满或创建了一个新的缓存区，则唤醒 Sender(消息发送线程)，将缓存区中的消息发送到 broker 服务器，最终返回 future。这里是经典的 Future 设计模式，从这里也能得知，doSend 方法执行完成后，此时消息还不一定成功发送到 broker。</p>
<p>KafkaProducer#doSend</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#125; catch (ApiException e) &#123;</span><br><span class="line">    log.debug(&quot;Exception occurred during message send:&quot;, e);</span><br><span class="line">    if (callback !&#x3D; null)</span><br><span class="line">        callback.onCompletion(null, e);</span><br><span class="line">        </span><br><span class="line">	this.errors.record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">        return new FutureFailure(e);</span><br><span class="line">&#125; catch (InterruptedException e) &#123;</span><br><span class="line">    this.errors.record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw new InterruptException(e);</span><br><span class="line">&#125; catch (BufferExhaustedException e) &#123;</span><br><span class="line">    this.errors.record();</span><br><span class="line">    this.metrics.sensor(&quot;buffer-exhausted-records&quot;).record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125; catch (KafkaException e) &#123;</span><br><span class="line">    this.errors.record();</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    &#x2F;&#x2F; we notify interceptor about all exceptions, since onSend is called before anything else in this method</span><br><span class="line">    this.interceptors.onSendError(record, tp, e);</span><br><span class="line">    throw e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step9：针对各种异常，进行相关信息的收集。</p>
<p>接下来将重点介绍如何将消息追加到生产者的发送缓存区，其实现类为：RecordAccumulator。</p>
<h3 id="2-2-RecordAccumulator-append-方法详解"><a href="#2-2-RecordAccumulator-append-方法详解" class="headerlink" title="2.2 RecordAccumulator append 方法详解"></a>2.2 RecordAccumulator append 方法详解</h3><p>RecordAccumulator#append</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RecordAppendResult <span class="title">append</span><span class="params">(TopicPartition tp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] key,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">byte</span>[] value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Header[] headers,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Callback callback,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> maxTimeToBlock)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br></pre></td></tr></table></figure>
<p>在介绍该方法之前，我们首先来看一下该方法的参数。</p>
<ul>
<li>TopicPartition tp<br>topic 与分区信息，即发送到哪个 topic 的那个分区。</li>
<li>long timestamp<br>客户端发送时的时间戳。</li>
<li>byte[] key<br>消息的 key。</li>
<li>byte[] value<br>消息体。</li>
<li>Header[] headers<br>消息头，可以理解为额外消息属性。</li>
<li>Callback callback<br>回调方法。</li>
<li>long maxTimeToBlock<br>消息追加超时时间。</li>
</ul>
<p>RecordAccumulator#append</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;ProducerBatch&gt; dq = getOrCreateDeque(tp);</span><br><span class="line"><span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>);</span><br><span class="line">    RecordAppendResult appendResult = tryAppend(timestamp, key, value, headers, callback, dq);</span><br><span class="line">    <span class="keyword">if</span> (appendResult != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：尝试根据 topic与分区在 kafka 中获取一个双端队列，如果不存在，则创建一个，然后调用 tryAppend 方法将消息追加到缓存中。Kafka 会为每一个 topic 的每一个分区创建一个消息缓存区，消息先追加到缓存中，然后消息发送 API 立即返回，然后由单独的线程 Sender 将缓存区中的消息定时发送到 broker 。这里的缓存区的实现使用的是 ArrayQeque。然后调用 tryAppend 方法尝试将消息追加到其缓存区，如果追加成功，则返回结果。</p>
<p>在讲解下一个流程之前，我们先来看一下 Kafka 双端队列的存储结构：<br><img src="https://img-blog.csdnimg.cn/20191110101227257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>RecordAccumulator#append</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> size = Math.max(<span class="keyword">this</span>.batchSize, AbstractRecords.estimateSizeInBytesUpperBound(maxUsableMagic, compression, key, value, headers));</span><br><span class="line">log.trace(<span class="string">&quot;Allocating a new &#123;&#125; byte message buffer for topic &#123;&#125; partition &#123;&#125;&quot;</span>, size, tp.topic(), tp.partition());</span><br><span class="line">buffer = free.allocate(size, maxTimeToBlock);</span><br></pre></td></tr></table></figure>
<p>Step2：如果第一步未追加成功，说明当前没有可用的 ProducerBatch，则需要创建一个 ProducerBatch，故先从 BufferPool 中申请 batch.size 的内存空间，为创建 ProducerBatch 做准备，如果由于 BufferPool 中未有剩余内存，则最多等待 maxTimeToBlock ，如果在指定时间内未申请到内存，则抛出异常。</p>
<p>RecordAccumulator#append</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (dq) &#123;</span><br><span class="line">    <span class="comment">// Need to check if producer is closed again after grabbing the dequeue lock.</span></span><br><span class="line">    <span class="keyword">if</span> (closed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Producer closed while send in progress&quot;</span>);</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    MemoryRecordsBuilder recordsBuilder = recordsBuilder(buffer, maxUsableMagic);</span><br><span class="line">    ProducerBatch batch = <span class="keyword">new</span> ProducerBatch(tp, recordsBuilder, time.milliseconds());</span><br><span class="line">    FutureRecordMetadata future = Utils.notNull(batch.tryAppend(timestamp, key, value, headers, callback, time.milliseconds()));</span><br><span class="line">    dq.addLast(batch);</span><br><span class="line">    incomplete.add(batch);</span><br><span class="line">    <span class="comment">// Don&#x27;t deallocate this buffer in the finally block as it&#x27;s being used in the record batch</span></span><br><span class="line">    buffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecordAppendResult(future, dq.size() &gt; <span class="number">1</span> || batch.isFull(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：创建一个新的批次 ProducerBatch，并将消息写入到该批次中，并返回追加结果，这里有如下几个关键点：</p>
<ul>
<li>创建 ProducerBatch ，其内部持有一个 MemoryRecordsBuilder对象，该对象负责将消息写入到内存中，即写入到 ProducerBatch 内部持有的内存，大小等于 batch.size。</li>
<li>将消息追加到 ProducerBatch 中。</li>
<li>将新创建的 ProducerBatch  添加到双端队列的末尾。</li>
<li>将该批次加入到 incomplete 容器中，该容器存放未完成发送到 broker 服务器中的消息批次，当 Sender 线程将消息发送到 broker 服务端后，会将其移除并释放所占内存。</li>
<li>返回追加结果。</li>
</ul>
<p>纵观 RecordAccumulator  append 的流程，基本上就是从双端队列获取一个未填充完毕的 ProducerBatch（消息批次），然后尝试将其写入到该批次中（缓存、内存中），如果追加失败，则尝试创建一个新的 ProducerBatch 然后继续追加。</p>
<p>接下来我们继续探究如何向 ProducerBatch 中写入消息。</p>
<h3 id="2-3-ProducerBatch-tryAppend方法详解"><a href="#2-3-ProducerBatch-tryAppend方法详解" class="headerlink" title="2.3 ProducerBatch  tryAppend方法详解"></a>2.3 ProducerBatch  tryAppend方法详解</h3><p>ProducerBatch #tryAppend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FutureRecordMetadata <span class="title">tryAppend</span><span class="params">(<span class="keyword">long</span> timestamp, <span class="keyword">byte</span>[] key, <span class="keyword">byte</span>[] value, Header[] headers, Callback callback, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) &#123;  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Long checksum = <span class="keyword">this</span>.recordsBuilder.append(timestamp, key, value, headers);                    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">this</span>.maxRecordSize = Math.max(<span class="keyword">this</span>.maxRecordSize, AbstractRecords.estimateSizeInBytesUpperBound(magic(),</span><br><span class="line">                    recordsBuilder.compressionType(), key, value, headers));               <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">this</span>.lastAppendTime = now;                                                                          <span class="comment">//                                                     </span></span><br><span class="line">        FutureRecordMetadata future = <span class="keyword">new</span> FutureRecordMetadata(<span class="keyword">this</span>.produceFuture, <span class="keyword">this</span>.recordCount,</span><br><span class="line">                                                                   timestamp, checksum,</span><br><span class="line">                                                                   key == <span class="keyword">null</span> ? -<span class="number">1</span> : key.length,</span><br><span class="line">                                                                   value == <span class="keyword">null</span> ? -<span class="number">1</span> : value.length,</span><br><span class="line">                                                                   Time.SYSTEM);                                        <span class="comment">// @4</span></span><br><span class="line">        <span class="comment">// we have to keep every future returned to the users in case the batch needs to be</span></span><br><span class="line">        <span class="comment">// split to several new batches and resent.</span></span><br><span class="line">        thunks.add(<span class="keyword">new</span> Thunk(callback, future));                                                           <span class="comment">// @5</span></span><br><span class="line">        <span class="keyword">this</span>.recordCount++;</span><br><span class="line">        <span class="keyword">return</span> future;                                                                            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先判断 ProducerBatch  是否还能容纳当前消息，如果剩余内存不足，将直接返回 null。如果返回 null ，会尝试再创建一个新的ProducerBatch。</p>
<p>代码@2：通过 MemoryRecordsBuilder 将消息写入按照 Kafka 消息格式写入到内存中，即写入到 在创建 ProducerBatch  时申请的 ByteBuffer 中。本文先不详细介绍 Kafka 各个版本的消息格式，后续会专门写一篇文章介绍 Kafka 各个版本的消息格式。</p>
<p>代码@3：更新 ProducerBatch  的 maxRecordSize、lastAppendTime 属性，分别表示该批次中最大的消息长度与最后一次追加消息的时间。</p>
<p>代码@4：构建 FutureRecordMetadata 对象，这里是典型的 Future模式，里面主要包含了该条消息对应的批次的 produceFuture、消息在该批消息的下标，key 的长度、消息体的长度以及当前的系统时间。</p>
<p>代码@5：将 callback 、本条消息的凭证(Future) 加入到该批次的 thunks 中，该集合存储了 一个批次中所有消息的发送回执。</p>
<p>流程执行到这里，KafkaProducer 的 send 方法就执行完毕了，返回给调用方的就是一个 FutureRecordMetadata 对象。</p>
<p>源码的阅读比较枯燥，接下来用一个流程图简单的阐述一下消息追加的关键要素，重点关注一下各个 Future。</p>
<h3 id="2-4-Kafka-消息追加流程图与总结"><a href="#2-4-Kafka-消息追加流程图与总结" class="headerlink" title="2.4 Kafka 消息追加流程图与总结"></a>2.4 Kafka 消息追加流程图与总结</h3><p><img src="https://img-blog.csdnimg.cn/201911101014500.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上面的消息发送，其实用消息追加来表达更加贴切，因为 Kafka 的 send 方法，并不会直接向 broker 发送消息，而是首先先追加到生产者的内存缓存中，其内存存储结构如下：ConcurrentMap&lt; TopicPartition, Deque&lt; ProducerBatch&gt;&gt; batches，那我们自然而然的可以得知，Kafka 的生产者为会每一个 topic 的每一个 分区单独维护一个队列，即 ArrayDeque，内部存放的元素为 ProducerBatch，即代表一个批次，即 Kafka 消息发送是按批发送的。其缓存结果图如下：<br><img src="https://img-blog.csdnimg.cn/20191110101523210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>KafkaProducer 的 send 方法最终返回的 FutureRecordMetadata ，是 Future 的子类，即 Future 模式。那 kafka 的消息发送怎么实现异步发送、同步发送的呢？</p>
<p>其实答案也就蕴含在 send 方法的返回值，如果项目方需要使用同步发送的方式，只需要拿到 send 方法的返回结果后，调用其 get() 方法，此时如果消息还未发送到 Broker 上，该方法会被阻塞，等到 broker 返回消息发送结果后该方法会被唤醒并得到消息发送结果。如果需要异步发送，则建议使用 send(ProducerRecord&lt; K, V &gt; record, Callback callback),但不能调用 get 方法即可。Callback 会在收到 broker 的响应结果后被调用，并且支持拦截器。</p>
<p>消息追加流程就介绍到这里了，消息被追加到缓存区后，什么是会被发送到 broker 端呢？将在下一篇文章中详细介绍。</p>
<p>如果文章对您有所帮助的话，麻烦帮忙点个赞，谢谢您的认可与支持。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>kafka</tag>
        <tag>ProducerRecord</tag>
        <tag>双端队列</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 RocketMQ DLedger 多副本即主从切换实现原理</title>
    <url>/posts/433e34a1.html</url>
    <content><![CDATA[<div id="vip-container"><p>DLedger 基于 raft 协议，故天然支持主从切换，即主节点(Leader)发生故障，会重新触发选主，在集群内再选举出新的主节点。</p>
<p>RocketMQ 中主从同步，从节点不仅会从主节点同步数据，也会同步元数据，包含 topic 路由信息、消费进度、延迟队列处理队列、消费组订阅配置等信息。那主从切换后元数据如何同步呢？特别是主从切换过程中，对消息消费有多大的影响，会丢失消息吗？</p>
<blockquote>
<p>温馨提示：本文假设大家已经对 RocketMQ4.5 版本之前的主从同步实现有一定的了解，这部分内容在《RocketMQ技术内幕》一书中有详细的介绍，大家也可以参考如下两篇文章：<br>1、 <a href="https://blog.csdn.net/prestigeding/article/details/93672079">RocketMQ HA机制(主从同步)</a> 。<br>2、<a href="https://blog.csdn.net/prestigeding/article/details/101629440">RocketMQ 整合 DLedger(多副本)即主从切换实现平滑升级的设计技巧</a></p>
</blockquote>
<h2 id="1、BrokerController-中与主从相关的方法详解"><a href="#1、BrokerController-中与主从相关的方法详解" class="headerlink" title="1、BrokerController 中与主从相关的方法详解"></a>1、BrokerController 中与主从相关的方法详解</h2><p>本节先对 BrokerController 中与主从切换相关的方法。</p>
<h3 id="1-1-startProcessorByHa"><a href="#1-1-startProcessorByHa" class="headerlink" title="1.1 startProcessorByHa"></a>1.1 startProcessorByHa</h3><p>BrokerController#startProcessorByHa</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startProcessorByHa</span><span class="params">(BrokerRole role)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BrokerRole.SLAVE != role) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageCheckService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.transactionalMessageCheckService.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉该方法的取名较为随意，该方法的作用是开启事务状态回查处理器，即当节点为主节点时，开启对应的事务状态回查处理器，对PREPARE状态的消息发起事务状态回查请求。</p>
<h3 id="1-2-shutdownProcessorByHa"><a href="#1-2-shutdownProcessorByHa" class="headerlink" title="1.2 shutdownProcessorByHa"></a>1.2 shutdownProcessorByHa</h3><p>BrokerController#shutdownProcessorByHa</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shutdownProcessorByHa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.transactionalMessageCheckService != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.transactionalMessageCheckService.shutdown(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关闭事务状态回查处理器，当节点从主节点变更为从节点后，该方法被调用。</p>
<h3 id="1-3-handleSlaveSynchronize"><a href="#1-3-handleSlaveSynchronize" class="headerlink" title="1.3 handleSlaveSynchronize"></a>1.3 handleSlaveSynchronize</h3><p>BrokerController#handleSlaveSynchronize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSlaveSynchronize</span><span class="params">(BrokerRole role)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (role == BrokerRole.SLAVE) &#123;   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != slaveSyncFuture) &#123;   </span><br><span class="line">            slaveSyncFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.slaveSynchronize.setMasterAddr(<span class="keyword">null</span>);   <span class="comment">// </span></span><br><span class="line">        slaveSyncFuture = <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    BrokerController.<span class="keyword">this</span>.slaveSynchronize.syncAll();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;ScheduledTask SlaveSynchronize syncAll error.&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">1000</span> * <span class="number">3</span>, <span class="number">1000</span> * <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">//handle the slave synchronise</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != slaveSyncFuture) &#123;</span><br><span class="line">            slaveSyncFuture.cancel(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.slaveSynchronize.setMasterAddr(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要作用是处理从节点的元数据同步，即从节点向主节点主动同步 topic 的路由信息、消费进度、延迟队列处理队列、消费组订阅配置等信息。</p>
<p>代码@1：如果当前节点的角色为从节点：</p>
<ul>
<li>如果上次同步的 future 不为空，则首先先取消。</li>
<li>然后设置 slaveSynchronize 的 master 地址为空。不知大家是否与笔者一样，有一个疑问，从节点的时候，如果将 master 地址设置为空，那如何同步元数据，那这个值会在什么时候设置呢？</li>
<li>开启定时同步任务，每 10s 从主节点同步一次元数据。 </li>
</ul>
<p>代码@2：如果当前节点的角色为主节点，则取消定时同步任务并设置 master 的地址为空。</p>
<h3 id="1-4-changeToSlave"><a href="#1-4-changeToSlave" class="headerlink" title="1.4 changeToSlave"></a>1.4 changeToSlave</h3><p>BrokerController#changeToSlave</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToSlave</span><span class="params">(<span class="keyword">int</span> brokerId)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">&quot;Begin to change to slave brokerName=&#123;&#125; brokerId=&#123;&#125;&quot;</span>, brokerConfig.getBrokerName(), brokerId);</span><br><span class="line">    <span class="comment">//change the role</span></span><br><span class="line">    brokerConfig.setBrokerId(brokerId == <span class="number">0</span> ? <span class="number">1</span> : brokerId); <span class="comment">//TO DO check       // @1</span></span><br><span class="line">    messageStoreConfig.setBrokerRole(BrokerRole.SLAVE);                            <span class="comment">// @2</span></span><br><span class="line">    <span class="comment">//handle the scheduled service</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.handleScheduleMessageService(BrokerRole.SLAVE);    <span class="comment">//  @3</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;[MONITOR] handleScheduleMessageService failed when changing to slave&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handle the transactional service</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.shutdownProcessorByHa();                                                                    <span class="comment">//  @4</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;[MONITOR] shutdownProcessorByHa failed when changing to slave&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handle the slave synchronise</span></span><br><span class="line">    handleSlaveSynchronize(BrokerRole.SLAVE);                                               <span class="comment">// @5</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">true</span>, brokerConfig.isForceRegister());              <span class="comment">// @6</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;Finish to change to slave brokerName=&#123;&#125; brokerId=&#123;&#125;&quot;</span>, brokerConfig.getBrokerName(), brokerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Broker 状态变更为从节点。其关键实现如下：</p>
<ul>
<li>设置 brokerId，如果broker的id为0，则设置为1，这里在使用的时候，注意规划好集群内节点的 brokerId。</li>
<li>设置 broker  的状态为 BrokerRole.SLAVE。</li>
<li>如果是从节点，则关闭定时调度线程(处理 RocketMQ 延迟队列)，如果是主节点，则启动该线程。</li>
<li>关闭事务状态回查处理器。</li>
<li>从节点需要启动元数据同步处理器，即启动 SlaveSynchronize 定时从主服务器同步元数据。</li>
<li>立即向集群内所有的 nameserver 告知 broker  信息状态的变更。</li>
</ul>
<h3 id="1-5-changeToMaster"><a href="#1-5-changeToMaster" class="headerlink" title="1.5 changeToMaster"></a>1.5 changeToMaster</h3><p>BrokerController#changeToMaster</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeToMaster</span><span class="params">(BrokerRole role)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (role == BrokerRole.SLAVE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;Begin to change to master brokerName=&#123;&#125;&quot;</span>, brokerConfig.getBrokerName());</span><br><span class="line">    <span class="comment">//handle the slave synchronise</span></span><br><span class="line">    handleSlaveSynchronize(role);   <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">//handle the scheduled service</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageStore.handleScheduleMessageService(role);      <span class="comment">// @2</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;[MONITOR] handleScheduleMessageService failed when changing to master&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//handle the transactional service</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.startProcessorByHa(BrokerRole.SYNC_MASTER);         <span class="comment">// @3</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;[MONITOR] startProcessorByHa failed when changing to master&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//if the operations above are totally successful, we change to master</span></span><br><span class="line">    brokerConfig.setBrokerId(<span class="number">0</span>); <span class="comment">//TO DO check                              // @4</span></span><br><span class="line">    messageStoreConfig.setBrokerRole(role);                               </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.registerBrokerAll(<span class="keyword">true</span>, <span class="keyword">true</span>, brokerConfig.isForceRegister()); <span class="comment">// @5</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">&quot;Finish to change to master brokerName=&#123;&#125;&quot;</span>, brokerConfig.getBrokerName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是 Broker 角色从从节点变更为主节点的处理逻辑，其实现要点如下：</p>
<ul>
<li>关闭元数据同步器，因为主节点无需同步。</li>
<li>开启定时任务处理线程。</li>
<li>开启事务状态回查处理线程。</li>
<li>设置 brokerId 为 0。</li>
<li>向 nameserver 立即发送心跳包以便告知 broker 服务器当前最新的状态。</li>
</ul>
<p>主从节点状态变更的核心方法就介绍到这里了，接下来看看如何触发主从切换。</p>
<h2 id="2、如何触发主从切换"><a href="#2、如何触发主从切换" class="headerlink" title="2、如何触发主从切换"></a>2、如何触发主从切换</h2><p>从前面的文章我们可以得知，RocketMQ DLedger 是基于 raft 协议实现的，在该协议中就实现了主节点的选举与主节点失效后集群会自动进行重新选举，经过协商投票产生新的主节点，从而实现高可用。</p>
<p>BrokerController#initialize</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (messageStoreConfig.isEnableDLegerCommitLog()) &#123;</span><br><span class="line">    DLedgerRoleChangeHandler roleChangeHandler = <span class="keyword">new</span> DLedgerRoleChangeHandler(<span class="keyword">this</span>, (DefaultMessageStore) messageStore);</span><br><span class="line">    ((DLedgerCommitLog)((DefaultMessageStore) messageStore).getCommitLog()).getdLedgerServer().getdLedgerLeaderElector().addRoleChangeHandler(roleChangeHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码片段截取自 BrokerController 的 initialize 方法，我们可以得知在 Broker 启动时，如果开启了 多副本机制，即 enableDLedgerCommitLog 参数设置为 true，会为 集群节点选主器添加 roleChangeHandler 事件处理器，即节点发送变更后的事件处理器。</p>
<a id="more"></a>

<p>接下来我们将重点探讨 DLedgerRoleChangeHandler 。</p>
<h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20191006174148582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>DLedgerRoleChangeHandler 继承自 RoleChangeHandler，即节点状态发生变更后的事件处理器。上述的属性都很简单，在这里就重点介绍一下 ExecutorService executorService，事件处理线程池，但只会开启一个线程，故事件将一个一个按顺序执行。</p>
<p>接下来我们来重点看一下 handle 方法的执行。</p>
<h3 id="2-2-handle-主从状态切换处理逻辑"><a href="#2-2-handle-主从状态切换处理逻辑" class="headerlink" title="2.2 handle 主从状态切换处理逻辑"></a>2.2 handle 主从状态切换处理逻辑</h3><p>DLedgerRoleChangeHandler#handle</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(<span class="keyword">long</span> term, MemberState.Role role)</span> </span>&#123;</span><br><span class="line">    Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">boolean</span> succ = <span class="keyword">true</span>;</span><br><span class="line">                log.info(<span class="string">&quot;Begin handling broker role change term=&#123;&#125; role=&#123;&#125; currStoreRole=&#123;&#125;&quot;</span>, term, role, messageStore.getMessageStoreConfig().getBrokerRole());</span><br><span class="line">                <span class="keyword">switch</span> (role) &#123;</span><br><span class="line">                    <span class="keyword">case</span> CANDIDATE:    <span class="comment">// @1</span></span><br><span class="line">                        <span class="keyword">if</span> (messageStore.getMessageStoreConfig().getBrokerRole() != BrokerRole.SLAVE) &#123;</span><br><span class="line">                            brokerController.changeToSlave(dLedgerCommitLog.getId());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> FOLLOWER:         <span class="comment">// @2</span></span><br><span class="line">                        brokerController.changeToSlave(dLedgerCommitLog.getId());</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> LEADER:           <span class="comment">// @3</span></span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!dLegerServer.getMemberState().isLeader()) &#123;</span><br><span class="line">                                succ = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (dLegerServer.getdLedgerStore().getLedgerEndIndex() == -<span class="number">1</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (dLegerServer.getdLedgerStore().getLedgerEndIndex() == dLegerServer.getdLedgerStore().getCommittedIndex()</span><br><span class="line">                                &amp;&amp; messageStore.dispatchBehindBytes() == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (succ) &#123;</span><br><span class="line">                            messageStore.recoverTopicQueueTable();</span><br><span class="line">                            brokerController.changeToMaster(BrokerRole.SYNC_MASTER);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                log.info(<span class="string">&quot;Finish handling broker role change succ=&#123;&#125; term=&#123;&#125; role=&#123;&#125; currStoreRole=&#123;&#125; cost=&#123;&#125;&quot;</span>, succ, term, role, messageStore.getMessageStoreConfig().getBrokerRole(), DLedgerUtils.elapsed(start));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;[MONITOR]Failed handling broker role change term=&#123;&#125; role=&#123;&#125; currStoreRole=&#123;&#125; cost=&#123;&#125;&quot;</span>, term, role, messageStore.getMessageStoreConfig().getBrokerRole(), DLedgerUtils.elapsed(start), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    executorService.submit(runnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果当前节点状态机状态为 CANDIDATE，表示正在发起 Leader 节点，如果该服务器的角色不是 SLAVE 的话，需要将状态切换为 SLAVE。</p>
<p>代码@2：如果当前节点状态机状态为 FOLLOWER，broker 节点将转换为 从节点。</p>
<p>代码@3：如果当前节点状态机状态为 Leader，说明该节点被选举为 Leader，在切换到 Master 节点之前，首先需要等待当前节点追加的数据都已经被提交后才可以将状态变更为 Master，其关键实现如下：</p>
<ul>
<li>如果 ledgerEndIndex 为 -1，表示当前节点还未又数据转发，直接跳出循环，无需等待。</li>
<li>如果 ledgerEndIndex 不为 -1 ，则必须等待数据都已提交，即 ledgerEndIndex 与 committedIndex 相等。</li>
<li>并且需要等待  commitlog 日志全部已转发到 consumequeue中，即 ReputMessageService 中的 reputFromOffset 与 commitlog 的 maxOffset 相等。</li>
</ul>
<p>等待上述条件满足后，即可以进行状态的变更，需要恢复 ConsumeQueue，维护每一个 queue 对应的 maxOffset，然后将 broker 角色转变为 master。</p>
<p>经过上面的步骤，就能实时完成 broker 主节点的自动切换。由于单从代码的角度来看主从切换不够直观，下面我将给出主从切换的流程图。</p>
<h3 id="2-3-主从切换流程图"><a href="#2-3-主从切换流程图" class="headerlink" title="2.3 主从切换流程图"></a>2.3 主从切换流程图</h3><p>由于从源码的角度或许不够直观，故本节给出其流程图。</p>
<blockquote>
<p>温馨提示：该流程图的前半部分在 源码分析 RocketMQ 整合 DLedger(多副本)实现平滑升级的设计技巧 该文中有所阐述。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20191006174334194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="3、主从切换若干问题思考"><a href="#3、主从切换若干问题思考" class="headerlink" title="3、主从切换若干问题思考"></a>3、主从切换若干问题思考</h2><p>我相信经过上面的讲解，大家应该对主从切换的实现原理有了一个比较清晰的理解，我更相信读者朋友们会抛出一个疑问，主从切换会不会丢失消息，消息消费进度是否会丢失而导致重复消费呢？</p>
<h3 id="3-1-消息消费进度是否存在丢失风险"><a href="#3-1-消息消费进度是否存在丢失风险" class="headerlink" title="3.1 消息消费进度是否存在丢失风险"></a>3.1 消息消费进度是否存在丢失风险</h3><p>首先，由于 RocketMQ 元数据，当然也包含消息消费进度的同步是采用的从服务器定时向主服务器拉取进行更新，存在时延，引入 DLedger 机制，也并不保证其一致性，DLedger 只保证 commitlog 文件的一致性。</p>
<p>当主节点宕机后，各个从节点并不会完成同步了消息消费进度，于此同时，消息消费继续，此时消费者会继续从从节点拉取消息进行消费，但汇报的从节点并不一定会成为新的主节点，故消费进度在 broker 端存在丢失的可能性。当然并不是一定会丢失，因为消息消费端只要不重启，消息消费进度会存储在内存中。</p>
<p>综合所述，消息消费进度在 broker  端会有丢失的可能性，存在重复消费的可能性，不过问题不大，因为 RocketMQ 本身也不承若不会重复消费。</p>
<h3 id="3-2-消息是否存在丢失风险"><a href="#3-2-消息是否存在丢失风险" class="headerlink" title="3.2 消息是否存在丢失风险"></a>3.2 消息是否存在丢失风险</h3><p>消息会不会丢失的关键在于，日志复制进度较慢的从节点是否可以被选举为主节点，如果在一个集群中，从节点的复制进度落后与从主节点，但当主节点宕机后，如果该从节点被选举成为新的主节点，那这将是一个灾难，将会丢失数据。关于一个节点是否给另外一个节点投赞成票的逻辑在 <a href="https://blog.csdn.net/prestigeding/article/details/99697323">源码分析 RocketMQ DLedger 多副本之 Leader 选主</a> 的 2.4.2 handleVote 方法中已详细介绍，在这里我以截图的方式再展示其核心点：<br><img src="https://img-blog.csdnimg.cn/20191006175156723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191006175216215.png" alt="在这里插入图片描述"><br>从上面可以得知，如果发起投票节点的复制进度比自己小的话，会投拒绝票。其<br><img src="https://img-blog.csdnimg.cn/20191006175250767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191006175310688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>必须得到集群内超过半数节点认可，即最终选举出来的主节点的当前复制进度一定是比绝大多数的从节点要大，并且也会等于承偌给客户端的已提交偏移量。故得出的结论是不会丢消息。</p>
<p>本文的介绍就到此为止了，最后抛出一个思考题与大家相互交流学习，也算是对 DLedger 多副本即主从切换一个总结回顾。答案我会以留言的方式或在下一篇文章中给出。</p>
<h2 id="4、思考题"><a href="#4、思考题" class="headerlink" title="4、思考题"></a>4、思考题</h2><p>例如一个集群内有5个节点的 DLedgr 集群。<br>Leader Node:  n0-broker-a<br>folloer Node:   n1-broker-a,n2-broker-a,n3-broker-a,n4-broker-a</p>
<p>从节点的复制进度可能不一致，例如：<br>n1-broker-a复制进度为 100<br>n2-broker-a复制进度为 120<br>n3-broker-a复制进度为 90<br>n4-broker-a负载进度为 90</p>
<p>如果此时 n0-broker-a 节点宕机，触发选主，如果  n1率先发起投票，由于 n1,的复制进度大于 n3,n4，再加上自己一票，是有可能成为leader的，此时消息会丢失吗？为什么？</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
        <tag>DLedger</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 RocketMQ DLedger(多副本) 之日志追加流程</title>
    <url>/posts/d35cbb14.html</url>
    <content><![CDATA[<div id="vip-container"><p>根据 raft 协议可知，当整个集群完成 Leader 选主后，集群中的主节点就可以接受客户端的请求，而集群中的从节点只负责从主节点同步数据，而不会处理读写请求，与M-S结构的读写分离有着巨大的区别。</p>
<p>有了前篇文章的基础，本文将直接从 Leader 处理客户端请求入口开始，其入口为：DLedgerServer 的 handleAppend 方法开始讲起。</p>
<h2 id="1、日志复制基本流程"><a href="#1、日志复制基本流程" class="headerlink" title="1、日志复制基本流程"></a>1、日志复制基本流程</h2><p>在正式分析 RocketMQ DLedger 多副本复制之前，我们首先来了解客户端发送日志的请求协议字段，其类图如下所示：<br><img src="https://img-blog.csdnimg.cn/20190914204415722.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们先一一介绍各个字段的含义：</p>
<ul>
<li>String group<br>该集群所属组名。</li>
<li>String remoteId<br>请求目的节点ID。</li>
<li>String localId<br>节点ID。</li>
<li>int code<br>请求响应字段，表示返回响应码。</li>
<li>String leaderId = null<br>集群中的Leader Id。</li>
<li>long term<br>集群当前的选举轮次。</li>
<li>byte[] body<br>待发送的数据。</li>
</ul>
<p>日志的请求处理处理入口为 DLedgerServer 的 handleAppend 方法。</p>
<p>DLedgerServer#handleAppend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreConditions.check(memberState.getSelfId().equals(request.getRemoteId()), DLedgerResponseCode.UNKNOWN_MEMBER, <span class="string">&quot;%s != %s&quot;</span>, request.getRemoteId(), memberState.getSelfId());</span><br><span class="line">reConditions.check(memberState.getGroup().equals(request.getGroup()), DLedgerResponseCode.UNKNOWN_GROUP, <span class="string">&quot;%s != %s&quot;</span>, request.getGroup(), memberState.getGroup());</span><br><span class="line">PreConditions.check(memberState.isLeader(), DLedgerResponseCode.NOT_LEADER);</span><br></pre></td></tr></table></figure>
<p>Step1：首先验证请求的合理性：</p>
<ul>
<li>如果请求的节点ID不是当前处理节点，则抛出异常。</li>
<li>如果请求的集群不是当前节点所在的集群，则抛出异常。</li>
<li>如果当前节点不是主节点，则抛出异常。</li>
</ul>
<p>DLedgerServer#handleAppend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> currTerm = memberState.currTerm();</span><br><span class="line"><span class="keyword">if</span> (dLedgerEntryPusher.isPendingFull(currTerm)) &#123;  <span class="comment">// @1</span></span><br><span class="line">    AppendEntryResponse appendEntryResponse = <span class="keyword">new</span> AppendEntryResponse();</span><br><span class="line">    appendEntryResponse.setGroup(memberState.getGroup());</span><br><span class="line">    appendEntryResponse.setCode(DLedgerResponseCode.LEADER_PENDING_FULL.getCode());</span><br><span class="line">    appendEntryResponse.setTerm(currTerm);</span><br><span class="line">    appendEntryResponse.setLeaderId(memberState.getSelfId());</span><br><span class="line">    <span class="keyword">return</span> AppendFuture.newCompletedFuture(-<span class="number">1</span>, appendEntryResponse);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;   <span class="comment">// @2</span></span><br><span class="line">    DLedgerEntry dLedgerEntry = <span class="keyword">new</span> DLedgerEntry();</span><br><span class="line">    dLedgerEntry.setBody(request.getBody());</span><br><span class="line">    DLedgerEntry resEntry = dLedgerStore.appendAsLeader(dLedgerEntry);</span><br><span class="line">    <span class="keyword">return</span> dLedgerEntryPusher.waitAck(resEntry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果预处理队列已经满了，则拒绝客户端请求，返回 LEADER_PENDING_FULL 错误码；如果未满，将请求封装成 DledgerEntry，则调用 dLedgerStore 方法追加日志，并且通过使用 dLedgerEntryPusher 的 waitAck 方法同步等待副本节点的复制响应，并最终将结果返回给调用方法。</p>
<ul>
<li>代码@1：如果 dLedgerEntryPusher 的 push 队列已满，则返回追加一次，其错误码为 LEADER_PENDING_FULL。</li>
<li>代码@2：追加消息到 Leader 服务器，并向从节点广播，在指定时间内如果未收到从节点的确认，则认为追加失败。</li>
</ul>
<p>接下来就按照上述三个要点进行展开：</p>
<ul>
<li>判断 Push 队列是否已满</li>
<li>Leader 节点存储消息</li>
<li>主节点等待从节点复制 ACK</li>
</ul>
<h3 id="1-1-如何判断-Push-队列是否已满"><a href="#1-1-如何判断-Push-队列是否已满" class="headerlink" title="1.1  如何判断 Push 队列是否已满"></a>1.1  如何判断 Push 队列是否已满</h3><p>DLedgerEntryPusher#isPendingFull</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPendingFull</span><span class="params">(<span class="keyword">long</span> currTerm)</span> </span>&#123;</span><br><span class="line">    checkTermForPendingMap(currTerm, <span class="string">&quot;isPendingFull&quot;</span>);     <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> pendingAppendResponsesByTerm.get(currTerm).size() &gt; dLedgerConfig.getMaxPendingRequestsNum(); <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要分两个步骤：<br>代码@1：检查当前投票轮次是否在 PendingMap 中，如果不在，则初始化，其结构为：Map&lt; Long/* 投票轮次*/, ConcurrentMap&lt;Long, TimeoutFuture&lt; AppendEntryResponse&gt;&gt;&gt;。</p>
<p>代码@2：检测当前等待从节点返回结果的个数是否超过其最大请求数量，可通过maxPendingRequests<br>Num 配置，该值默认为：10000。</p>
<p>上述逻辑比较简单，但疑问随着而来，ConcurrentMap&lt;Long, TimeoutFuture&lt; AppendEntryResponse&gt;&gt; 中的数据是从何而来的呢？我们不妨接着往下看。</p>
<a id="more"></a>

<h3 id="1-2-Leader-节点存储数据"><a href="#1-2-Leader-节点存储数据" class="headerlink" title="1.2  Leader 节点存储数据"></a>1.2  Leader 节点存储数据</h3><p>Leader 节点的数据存储主要由 DLedgerStore 的 appendAsLeader 方法实现。DLedger 分别实现了基于内存、基于文件的存储实现，本文重点关注基于文件的存储实现，其实现类为：DLedgerMmapFileStore。</p>
<p>下面重点来分析一下数据存储流程，其入口为DLedgerMmapFileStore 的 appendAsLeader 方法。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PreConditions.check(memberState.isLeader(), DLedgerResponseCode.NOT_LEADER);</span><br><span class="line">PreConditions.check(!isDiskFull, DLedgerResponseCode.DISK_FULL);</span><br></pre></td></tr></table></figure>
<p>Step1：首先判断是否可以追加数据，其判断依据主要是如下两点：</p>
<ul>
<li>当前节点的状态是否是 Leader，如果不是，则抛出异常。</li>
<li>当前磁盘是否已满，其判断依据是 DLedger 的根目录或数据文件目录的使用率超过了允许使用的最大值，默认值为85%。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer dataBuffer = localEntryBuffer.get();</span><br><span class="line">ByteBuffer indexBuffer = localIndexBuffer.get();</span><br></pre></td></tr></table></figure>
<p>Step2：从本地线程变量获取一个数据与索引 buffer。其中用于存储数据的 ByteBuffer，其容量固定为 4M ，索引的 ByteBuffer 为两个索引条目的长度，固定为64个字节。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DLedgerEntryCoder.encode(entry, dataBuffer);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(DLedgerEntry entry, ByteBuffer byteBuffer)</span> </span>&#123;</span><br><span class="line">    byteBuffer.clear();</span><br><span class="line">    <span class="keyword">int</span> size = entry.computSizeInBytes();</span><br><span class="line">    <span class="comment">//always put magic on the first position</span></span><br><span class="line">    byteBuffer.putInt(entry.getMagic());</span><br><span class="line">    byteBuffer.putInt(size);</span><br><span class="line">    byteBuffer.putLong(entry.getIndex());</span><br><span class="line">    byteBuffer.putLong(entry.getTerm());</span><br><span class="line">    byteBuffer.putLong(entry.getPos());</span><br><span class="line">    byteBuffer.putInt(entry.getChannel());</span><br><span class="line">    byteBuffer.putInt(entry.getChainCrc());</span><br><span class="line">    byteBuffer.putInt(entry.getBodyCrc());</span><br><span class="line">    byteBuffer.putInt(entry.getBody().length);</span><br><span class="line">    byteBuffer.put(entry.getBody());</span><br><span class="line">    byteBuffer.flip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：将 DLedgerEntry，即将数据写入到 ByteBuffer中，从这里看出，每一次写入会调用 ByteBuffer 的 clear 方法，将数据清空，从这里可以看出，每一次数据追加，只能存储4M的数据。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (memberState) &#123;</span><br><span class="line">    PreConditions.check(memberState.isLeader(), DLedgerResponseCode.NOT_LEADER, <span class="keyword">null</span>);</span><br><span class="line">	<span class="comment">// ... 省略代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：锁定状态机，并再一次检测节点的状态是否是 Leader 节点。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> nextIndex = ledgerEndIndex + <span class="number">1</span>;</span><br><span class="line">entry.setIndex(nextIndex);</span><br><span class="line">entry.setTerm(memberState.currTerm());</span><br><span class="line">entry.setMagic(CURRENT_MAGIC);</span><br><span class="line">DLedgerEntryCoder.setIndexTerm(dataBuffer, nextIndex, memberState.currTerm(), CURRENT_MAGIC);</span><br></pre></td></tr></table></figure>
<p>Step5：为当前日志条目设置序号，即 entryIndex 与 entryTerm (投票轮次)。并将魔数、entryIndex、entryTerm 等写入到 bytebuffer 中。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> prePos = dataFileList.preAppend(dataBuffer.remaining());</span><br><span class="line">entry.setPos(prePos);</span><br><span class="line">PreConditions.check(prePos != -<span class="number">1</span>, DLedgerResponseCode.DISK_ERROR, <span class="keyword">null</span>);</span><br><span class="line">DLedgerEntryCoder.setPos(dataBuffer, prePos);</span><br></pre></td></tr></table></figure>
<p>Step6：计算新的消息的起始偏移量，关于 dataFileList 的 preAppend 后续详细介绍其实现，然后将该偏移量写入日志的 bytebuffer 中。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (AppendHook writeHook : appendHooks) &#123;</span><br><span class="line">    writeHook.doHook(entry, dataBuffer.slice(), DLedgerEntry.BODY_OFFSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step7：执行钩子函数。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> dataPos = dataFileList.append(dataBuffer.array(), <span class="number">0</span>, dataBuffer.remaining());</span><br><span class="line">PreConditions.check(dataPos != -<span class="number">1</span>, DLedgerResponseCode.DISK_ERROR, <span class="keyword">null</span>);</span><br><span class="line">PreConditions.check(dataPos == prePos, DLedgerResponseCode.DISK_ERROR, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>Step8：将数据追加到 pagecache 中。该方法稍后详细介绍。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DLedgerEntryCoder.encodeIndex(dataPos, entrySize, CURRENT_MAGIC, nextIndex, memberState.currTerm(), indexBuffer);</span><br><span class="line"><span class="keyword">long</span> indexPos = indexFileList.append(indexBuffer.array(), <span class="number">0</span>, indexBuffer.remaining(), <span class="keyword">false</span>);</span><br><span class="line">PreConditions.check(indexPos == entry.getIndex() * INDEX_UNIT_SIZE, DLedgerResponseCode.DISK_ERROR, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>Step9：构建条目索引并将索引数据追加到 pagecache。</p>
<p>DLedgerMmapFileStore#appendAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ledgerEndIndex++;</span><br><span class="line">ledgerEndTerm = memberState.currTerm();</span><br><span class="line"><span class="keyword">if</span> (ledgerBeginIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">    ledgerBeginIndex = ledgerEndIndex;</span><br><span class="line">&#125;</span><br><span class="line">updateLedgerEndIndexAndTerm();</span><br></pre></td></tr></table></figure>
<p>Step10：ledgerEndeIndex 加一（下一个条目）的序号。并设置 leader 节点的状态机的 ledgerEndIndex 与 ledgerEndTerm。</p>
<p>Leader 节点数据追加就介绍到这里，稍后会重点介绍与存储相关方法的实现细节。</p>
<h3 id="1-3-主节点等待从节点复制-ACK"><a href="#1-3-主节点等待从节点复制-ACK" class="headerlink" title="1.3 主节点等待从节点复制 ACK"></a>1.3 主节点等待从节点复制 ACK</h3><p>其实现入口为 dLedgerEntryPusher 的 waitAck 方法。</p>
<p>DLedgerEntryPusher#waitAck</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;AppendEntryResponse&gt; <span class="title">waitAck</span><span class="params">(DLedgerEntry entry)</span> </span>&#123;</span><br><span class="line">    updatePeerWaterMark(entry.getTerm(), memberState.getSelfId(), entry.getIndex());    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (memberState.getPeerMap().size() == <span class="number">1</span>) &#123;                                                                  <span class="comment">// @2</span></span><br><span class="line">        AppendEntryResponse response = <span class="keyword">new</span> AppendEntryResponse();</span><br><span class="line">        response.setGroup(memberState.getGroup());</span><br><span class="line">        response.setLeaderId(memberState.getSelfId());</span><br><span class="line">        response.setIndex(entry.getIndex());</span><br><span class="line">        response.setTerm(entry.getTerm());</span><br><span class="line">        response.setPos(entry.getPos());</span><br><span class="line">        <span class="keyword">return</span> AppendFuture.newCompletedFuture(entry.getPos(), response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        checkTermForPendingMap(entry.getTerm(), <span class="string">&quot;waitAck&quot;</span>);                                            </span><br><span class="line">        AppendFuture&lt;AppendEntryResponse&gt; future = <span class="keyword">new</span> AppendFuture&lt;&gt;(dLedgerConfig.getMaxWaitAckTimeMs()); <span class="comment">// @3</span></span><br><span class="line">        future.setPos(entry.getPos());</span><br><span class="line">        CompletableFuture&lt;AppendEntryResponse&gt; old = pendingAppendResponsesByTerm.get(entry.getTerm()).put(entry.getIndex(), future);     <span class="comment">// @4</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;[MONITOR] get old wait at index=&#123;&#125;&quot;</span>, entry.getIndex());</span><br><span class="line">        &#125;</span><br><span class="line">        wakeUpDispatchers();                                       <span class="comment">// @5</span></span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：更新当前节点的 push 水位线。<br>代码@2：如果集群的节点个数为1，无需转发，直接返回成功结果。<br>代码@3：构建 append 响应 Future 并设置超时时间，默认值为：2500 ms，可以通过 maxWaitAckTimeMs 配置改变其默认值。<br>代码@4：将构建的 Future 放入等待结果集合中。<br>代码@5：唤醒 Entry 转发线程，即将主节点中的数据 push 到各个从节点。</p>
<p>接下来分别对上述几个关键点进行解读。</p>
<h4 id="1-3-1-updatePeerWaterMark-方法"><a href="#1-3-1-updatePeerWaterMark-方法" class="headerlink" title="1.3.1 updatePeerWaterMark 方法"></a>1.3.1 updatePeerWaterMark 方法</h4><p>DLedgerEntryPusher#updatePeerWaterMark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePeerWaterMark</span><span class="params">(<span class="keyword">long</span> term, String peerId, <span class="keyword">long</span> index)</span> </span>&#123;    <span class="comment">// 代码@1</span></span><br><span class="line">    <span class="keyword">synchronized</span> (peerWaterMarksByTerm) &#123; </span><br><span class="line">       checkTermForWaterMark(term, <span class="string">&quot;updatePeerWaterMark&quot;</span>);                     <span class="comment">// 代码@2</span></span><br><span class="line">        <span class="keyword">if</span> (peerWaterMarksByTerm.get(term).get(peerId) &lt; index) &#123;                   <span class="comment">// 代码@3</span></span><br><span class="line">            peerWaterMarksByTerm.get(term).put(peerId, index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：先来简单介绍该方法的两个参数：</p>
<ul>
<li>long term<br>当前的投票轮次。</li>
<li>String peerId<br>当前节点的ID。</li>
<li>long index<br>当前追加数据的序号。</li>
</ul>
<p>代码@2：初始化 peerWaterMarksByTerm 数据结构，其结果为 &lt; Long /** term  */, Map&lt; String /** peerId */, Long /** entry index*/&gt;。</p>
<p>代码@3：如果 peerWaterMarksByTerm 存储的 index 小于当前数据的 index，则更新。</p>
<h4 id="1-3-2-wakeUpDispatchers-详解"><a href="#1-3-2-wakeUpDispatchers-详解" class="headerlink" title="1.3.2  wakeUpDispatchers 详解"></a>1.3.2  wakeUpDispatchers 详解</h4><p>DLedgerEntryPusher#updatePeerWaterMark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wakeUpDispatchers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (EntryDispatcher dispatcher : dispatcherMap.values()) &#123;</span><br><span class="line">        dispatcher.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要就是遍历转发器并唤醒。本方法的核心关键就是 EntryDispatcher，在详细介绍它之前我们先来看一下该集合的初始化。</p>
<p>DLedgerEntryPusher 构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (String peer : memberState.getPeerMap().keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!peer.equals(memberState.getSelfId())) &#123;</span><br><span class="line">        dispatcherMap.put(peer, <span class="keyword">new</span> EntryDispatcher(peer, logger));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来在构建 DLedgerEntryPusher 时会为每一个从节点创建一个 EntryDispatcher 对象。</p>
<p>显然，日志的复制由 DLedgerEntryPusher 来实现。由于篇幅的原因，该部分内容将在下篇文章中继续。</p>
<p>上面在讲解 Leader 追加日志时并没有详细分析存储相关的实现，为了知识体系的完备，接下来我们来分析一下其核心实现。</p>
<h2 id="2、日志存储实现详情"><a href="#2、日志存储实现详情" class="headerlink" title="2、日志存储实现详情"></a>2、日志存储实现详情</h2><p>本节主要对 MmapFileList 的 preAppend 与 append 方法进行详细讲解。</p>
<blockquote>
<p>存储部分的设计请查阅笔者的博客：<a href="https://blog.csdn.net/prestigeding/article/details/100177780">源码分析 RocketMQ DLedger 多副本存储实现</a>，MmapFileList 对标 RocketMQ 的MappedFileQueue。</p>
</blockquote>
<h3 id="2-1-MmapFileList-的-preAppend-详解"><a href="#2-1-MmapFileList-的-preAppend-详解" class="headerlink" title="2.1 MmapFileList 的 preAppend 详解"></a>2.1 MmapFileList 的 preAppend 详解</h3><p>该方法最终会调用两个参数的 preAppend方法，故我们直接来看两个参数的 preAppend 方法。</p>
<p>MmapFileList#preAppend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">preAppend</span><span class="params">(<span class="keyword">int</span> len, <span class="keyword">boolean</span> useBlank)</span> </span>&#123;                <span class="comment">// @1</span></span><br><span class="line">    MmapFile mappedFile = getLastMappedFile();                   <span class="comment">// @2 start</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile || mappedFile.isFull()) &#123;</span><br><span class="line">        mappedFile = getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Create mapped file for &#123;&#125;&quot;</span>, storePath);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;                                                                                            <span class="comment">// @2 end</span></span><br><span class="line">    <span class="keyword">int</span> blank = useBlank ? MIN_BLANK_LEN : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len + blank &gt; mappedFile.getFileSize() - mappedFile.getWrotePosition()) &#123;   <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (blank &lt; MIN_BLANK_LEN) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Blank &#123;&#125; should ge &#123;&#125;&quot;</span>, blank, MIN_BLANK_LEN);</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ByteBuffer byteBuffer = ByteBuffer.allocate(mappedFile.getFileSize() - mappedFile.getWrotePosition());     <span class="comment">// @4</span></span><br><span class="line">            byteBuffer.putInt(BLANK_MAGIC_CODE);                                                                                                      <span class="comment">// @5</span></span><br><span class="line">            byteBuffer.putInt(mappedFile.getFileSize() - mappedFile.getWrotePosition());                                               <span class="comment">// @6</span></span><br><span class="line">            <span class="keyword">if</span> (mappedFile.appendMessage(byteBuffer.array())) &#123;                                                                                     <span class="comment">// @7</span></span><br><span class="line">                <span class="comment">//need to set the wrote position</span></span><br><span class="line">                mappedFile.setWrotePosition(mappedFile.getFileSize());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Append blank error for &#123;&#125;&quot;</span>, storePath);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mappedFile = getLastMappedFile(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == mappedFile) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Create mapped file for &#123;&#125;&quot;</span>, storePath);</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();<span class="comment">// @8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍其参数的含义：</p>
<ul>
<li>int len 需要申请的长度。</li>
<li>boolean useBlank 是否需要填充，默认为true。</li>
</ul>
<p>代码@2：获取最后一个文件，即获取当前正在写的文件。</p>
<p>代码@3：如果需要申请的资源超过了当前文件可写字节时，需要处理的逻辑。代码@4-@7都是其处理逻辑。</p>
<p>代码@4：申请一个当前文件剩余字节的大小的bytebuffer。</p>
<p>代码@5：先写入魔数。</p>
<p>代码@6：写入字节长度，等于当前文件剩余的总大小。</p>
<p>代码@7：写入空字节，代码@4-@7的用意就是写一条空Entry，填入魔数与 size，方便解析。</p>
<p>代码@8：如果当前文件足以容纳待写入的日志，则直接返回其物理偏移量。</p>
<p>经过上述代码解读，我们很容易得出该方法的作用，就是返回待写入日志的起始物理偏移量。</p>
<h3 id="2-2-MmapFileList-的-append-详解"><a href="#2-2-MmapFileList-的-append-详解" class="headerlink" title="2.2 MmapFileList 的 append 详解"></a>2.2 MmapFileList 的 append 详解</h3><p>最终会调用4个参数的 append 方法，其代码如下：<br>MmapFileList#append</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">append</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> pos, <span class="keyword">int</span> len, <span class="keyword">boolean</span> useBlank)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (preAppend(len, useBlank) == -<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    MmapFile mappedFile = getLastMappedFile();                               <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">long</span> currPosition = mappedFile.getFileFromOffset() + mappedFile.getWrotePosition();   <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">if</span> (!mappedFile.appendMessage(data, pos, len)) &#123;            <span class="comment">// @4</span></span><br><span class="line">        logger.error(<span class="string">&quot;Append error for &#123;&#125;&quot;</span>, storePath);</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> currPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍一下各个参数：</p>
<ul>
<li>byte[] data<br>待写入的数据，即待追加的日志。</li>
<li>int pos<br>从 data 字节数组哪个位置开始读取。</li>
<li>int len<br>待写入的字节数量。</li>
<li>boolean useBlank<br>是否使用填充，默认为 true。</li>
</ul>
<p>代码@2：获取最后一个文件，即当前可写的文件。</p>
<p>代码@3：获取当前写入指针。</p>
<p>代码@4：追加消息。</p>
<p>最后我们再来看一下 appendMessage，具体的消息追加实现逻辑。</p>
<p>DefaultMmapFile#appendMessage</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">appendMessage</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] data, <span class="keyword">final</span> <span class="keyword">int</span> offset, <span class="keyword">final</span> <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currentPos = <span class="keyword">this</span>.wrotePosition.get();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((currentPos + length) &lt;= <span class="keyword">this</span>.fileSize) &#123;</span><br><span class="line">        ByteBuffer byteBuffer = <span class="keyword">this</span>.mappedByteBuffer.slice(); <span class="comment">// @1</span></span><br><span class="line">        byteBuffer.position(currentPos);</span><br><span class="line">        byteBuffer.put(data, offset, length);</span><br><span class="line">        <span class="keyword">this</span>.wrotePosition.addAndGet(length);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法我主要是想突出一下写入的方式是 mappedByteBuffer，是通过 FileChannel 的 map 方法创建，即我们常说的 PageCache，即消息追加首先是写入到 pageCache 中。</p>
<p><strong>本文详细介绍了 Leader 节点处理客户端消息追加请求的前面两个步骤，即 判断 Push 队列是否已满 与 Leader 节点存储消息。考虑到篇幅的问题，各个节点的数据同步将在下一篇文章中详细介绍。</strong></p>
<p>在进入下一篇的文章学习之前，我们不妨思考一下如下问题：</p>
<ol>
<li>如果主节点追加成功（写入到 PageCache)，但同步到从节点过程失败或此时主节点宕机，集群中的数据如何保证一致性？</li>
</ol>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
        <tag>DLedger</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo 泛化调用与泛化实现原理</title>
    <url>/posts/5f7d793b.html</url>
    <content><![CDATA[<div id="vip-container"><ul>
<li>本文将重点分析Dubbo的两个重要特性：泛化调用与泛化实现。<br> 1、泛化引用：<br> <img src="https://img-blog.csdn.net/20181005211034328?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> 通常是服务调用方没有引入API包，也就不包含接口中的实体类，故服务调用方只能提供Map形式的数据，由服务提供者根据Map转化成对应的实体。<br> 2、泛化实现<br> <img src="https://img-blog.csdn.net/20181005211118267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"><br> 泛化实现，是指服务提供者未引入API包，也就不包含接口用于传输数据的实体类，故客户端发起调用前，需要将mode转化为Map。<br> 从上面分析，其实所谓的泛化本质上就是Map与Bean的转换。</li>
</ul>
<a id="more"></a>

<h2 id="3、源码分析客户端用于泛化调用的过滤器GenericImplFilter"><a href="#3、源码分析客户端用于泛化调用的过滤器GenericImplFilter" class="headerlink" title="3、源码分析客户端用于泛化调用的过滤器GenericImplFilter"></a>3、源码分析客户端用于泛化调用的过滤器GenericImplFilter</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        String generic &#x3D; invoker.getUrl().getParameter(Constants.GENERIC_KEY);</span><br><span class="line">        if (ProtocolUtils.isGeneric(generic)                                                                                  &#x2F;&#x2F; @1</span><br><span class="line">                &amp;&amp; !Constants.$INVOKE.equals(invocation.getMethodName())</span><br><span class="line">                &amp;&amp; invocation instanceof RpcInvocation) &#123;</span><br><span class="line">            RpcInvocation invocation2 &#x3D; (RpcInvocation) invocation;</span><br><span class="line">            String methodName &#x3D; invocation2.getMethodName();</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes &#x3D; invocation2.getParameterTypes();</span><br><span class="line">            Object[] arguments &#x3D; invocation2.getArguments();</span><br><span class="line"></span><br><span class="line">            String[] types &#x3D; new String[parameterTypes.length];</span><br><span class="line">            for (int i &#x3D; 0; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">                types[i] &#x3D; ReflectUtils.getName(parameterTypes[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Object[] args;</span><br><span class="line">            if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                args &#x3D; new Object[arguments.length];</span><br><span class="line">                for (int i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">                    args[i] &#x3D; JavaBeanSerializeUtil.serialize(arguments[i], JavaBeanAccessor.METHOD);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                args &#x3D; PojoUtils.generalize(arguments);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            invocation2.setMethodName(Constants.$INVOKE);</span><br><span class="line">            invocation2.setParameterTypes(GENERIC_PARAMETER_TYPES);</span><br><span class="line">            invocation2.setArguments(new Object[]&#123;methodName, types, args&#125;);</span><br><span class="line">            Result result &#x3D; invoker.invoke(invocation2);</span><br><span class="line"></span><br><span class="line">            if (!result.hasException()) &#123;</span><br><span class="line">                Object value &#x3D; result.getValue();</span><br><span class="line">                try &#123;</span><br><span class="line">                    Method method &#x3D; invoker.getInterface().getMethod(methodName, parameterTypes);</span><br><span class="line">                    if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                        if (value &#x3D;&#x3D; null) &#123;</span><br><span class="line">                            return new RpcResult(value);</span><br><span class="line">                        &#125; else if (value instanceof JavaBeanDescriptor) &#123;</span><br><span class="line">                            return new RpcResult(JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) value));</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RpcException(</span><br><span class="line">                                    &quot;The type of result value is &quot; +</span><br><span class="line">                                            value.getClass().getName() +</span><br><span class="line">                                            &quot; other than &quot; +</span><br><span class="line">                                            JavaBeanDescriptor.class.getName() +</span><br><span class="line">                                            &quot;, and the result is &quot; +</span><br><span class="line">                                            value);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        return new RpcResult(PojoUtils.realize(value, method.getReturnType(), method.getGenericReturnType()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                    throw new RpcException(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (result.getException() instanceof GenericException) &#123;</span><br><span class="line">                GenericException exception &#x3D; (GenericException) result.getException();</span><br><span class="line">                try &#123;</span><br><span class="line">                    String className &#x3D; exception.getExceptionClass();</span><br><span class="line">                    Class&lt;?&gt; clazz &#x3D; ReflectUtils.forName(className);</span><br><span class="line">                    Throwable targetException &#x3D; null;</span><br><span class="line">                    Throwable lastException &#x3D; null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        targetException &#x3D; (Throwable) clazz.newInstance();</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        lastException &#x3D; e;</span><br><span class="line">                        for (Constructor&lt;?&gt; constructor : clazz.getConstructors()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                targetException &#x3D; (Throwable) constructor.newInstance(new Object[constructor.getParameterTypes().length]);</span><br><span class="line">                                break;</span><br><span class="line">                            &#125; catch (Throwable e1) &#123;</span><br><span class="line">                                lastException &#x3D; e1;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (targetException !&#x3D; null) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Field field &#x3D; Throwable.class.getDeclaredField(&quot;detailMessage&quot;);</span><br><span class="line">                            if (!field.isAccessible()) &#123;</span><br><span class="line">                                field.setAccessible(true);</span><br><span class="line">                            &#125;</span><br><span class="line">                            field.set(targetException, exception.getExceptionMessage());</span><br><span class="line">                        &#125; catch (Throwable e) &#123;</span><br><span class="line">                            logger.warn(e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                        result &#x3D; new RpcResult(targetException);</span><br><span class="line">                    &#125; else if (lastException !&#x3D; null) &#123;</span><br><span class="line">                        throw lastException;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    throw new RpcException(&quot;Can not deserialize exception &quot; + exception.getExceptionClass() + &quot;, message: &quot; + exception.getExceptionMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (invocation.getMethodName().equals(Constants.$INVOKE)                             &#x2F;&#x2F; @2</span><br><span class="line">                &amp;&amp; invocation.getArguments() !&#x3D; null</span><br><span class="line">                &amp;&amp; invocation.getArguments().length &#x3D;&#x3D; 3</span><br><span class="line">                &amp;&amp; ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line"></span><br><span class="line">            Object[] args &#x3D; (Object[]) invocation.getArguments()[2];</span><br><span class="line">            if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;</span><br><span class="line"></span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    if (!(byte[].class &#x3D;&#x3D; arg.getClass())) &#123;</span><br><span class="line">                        error(byte[].class.getName(), arg.getClass().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                for (Object arg : args) &#123;</span><br><span class="line">                    if (!(arg instanceof JavaBeanDescriptor)) &#123;</span><br><span class="line">                        error(JavaBeanDescriptor.class.getName(), arg.getClass().getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ((RpcInvocation) invocation).setAttachment(</span><br><span class="line">                    Constants.GENERIC_KEY, invoker.getUrl().getParameter(Constants.GENERIC_KEY));</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(invocation);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：该分支是泛化实现，如果是泛化实现，则根据generic的值进行序列化，然后调用$invoke方法，因为服务端实现为泛化实现，所有的服务提供者实现GenericeServer#$invoker方法，其实现方式就是将Bean转换成Map。这些细节将在服务端GenericFilter序列中详细讲解。</p>
<p>代码@2：泛化引用，调用方是直接通过GenericService#$invoke方法进行调用，以此来区分是泛化调用还是泛化引用，那不经要问，为什么invoker.getUrl().getParameter(Constants.GENERIC_KEY)中获取的generic参数到底是&lt; dubbo:service/&gt;中配置的还是&lt; dubbo:reference/&gt;中配置的呢？其实不难理解：</p>
<ol>
<li>dubbo:servcie未配置而dubbo:reference配置了，则代表的是消费端的，必然是泛化引用。</li>
<li>dubbo:servcie配置而dubbo:reference未配置了，则代表的是服务端的，必然是泛化实现。</li>
<li>如果两者都配置了，generic以消费端为主。消费端参数与服务端参数的合并在服务发现时，注册中心首先会将服务提供者的URL通知消费端，然后消费端会使用当前的配置与服务提供者URL中的配置进行合并，如遇到相同参数，则消费端覆盖服务端。</li>
</ol>
<blockquote>
<p>注：这里我就不深入去探讨其实现细节，因为这部分在下文源码分析GenericFilter时会详细介绍Map与Bean转换的细节，包含是否序列化，之所以这里没有细说，主要是因为我先看的是GenericFilter。</p>
</blockquote>
<h2 id="4、源码分析泛化引用-GenericFilter（服务提供者）"><a href="#4、源码分析泛化引用-GenericFilter（服务提供者）" class="headerlink" title="4、源码分析泛化引用 GenericFilter（服务提供者）"></a>4、源码分析泛化引用 GenericFilter（服务提供者）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Activate(group &#x3D; Constants.PROVIDER, order &#x3D; -20000)</span><br><span class="line">public class GenericFilter implements Filter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation inv) throws RpcException &#123;</span><br><span class="line">        if (inv.getMethodName().equals(Constants.$INVOKE)</span><br><span class="line">                &amp;&amp; inv.getArguments() !&#x3D; null</span><br><span class="line">                &amp;&amp; inv.getArguments().length &#x3D;&#x3D; 3</span><br><span class="line">                &amp;&amp; !ProtocolUtils.isGeneric(invoker.getUrl().getParameter(Constants.GENERIC_KEY))) &#123;       &#x2F;&#x2F; @1</span><br><span class="line">            String name &#x3D; ((String) inv.getArguments()[0]).trim();</span><br><span class="line">            String[] types &#x3D; (String[]) inv.getArguments()[1];</span><br><span class="line">            Object[] args &#x3D; (Object[]) inv.getArguments()[2];</span><br><span class="line">            try &#123;</span><br><span class="line">                Method method &#x3D; ReflectUtils.findMethodByMethodSignature(invoker.getInterface(), name, types);             &#x2F;&#x2F; @2</span><br><span class="line">                Class&lt;?&gt;[] params &#x3D; method.getParameterTypes();</span><br><span class="line">                if (args &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    args &#x3D; new Object[params.length];</span><br><span class="line">                &#125;</span><br><span class="line">                String generic &#x3D; inv.getAttachment(Constants.GENERIC_KEY);</span><br><span class="line">                if (StringUtils.isEmpty(generic)</span><br><span class="line">                        || ProtocolUtils.isDefaultGenericSerialization(generic)) &#123;                                                             &#x2F;&#x2F; @3</span><br><span class="line">                    args &#x3D; PojoUtils.realize(args, params, method.getGenericParameterTypes());</span><br><span class="line">                &#125; else if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;                                                             &#x2F;&#x2F; @4</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                        if (byte[].class &#x3D;&#x3D; args[i].getClass()) &#123;</span><br><span class="line">                            try &#123;</span><br><span class="line">                                UnsafeByteArrayInputStream is &#x3D; new UnsafeByteArrayInputStream((byte[]) args[i]);</span><br><span class="line">                                args[i] &#x3D; ExtensionLoader.getExtensionLoader(Serialization.class)</span><br><span class="line">                                        .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA)</span><br><span class="line">                                        .deserialize(null, is).readObject();</span><br><span class="line">                            &#125; catch (Exception e) &#123;</span><br><span class="line">                                throw new RpcException(&quot;Deserialize argument [&quot; + (i + 1) + &quot;] failed.&quot;, e);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RpcException(</span><br><span class="line">                                    &quot;Generic serialization [&quot; +</span><br><span class="line">                                            Constants.GENERIC_SERIALIZATION_NATIVE_JAVA +</span><br><span class="line">                                            &quot;] only support message type &quot; +</span><br><span class="line">                                            byte[].class +</span><br><span class="line">                                            &quot; and your message type is &quot; +</span><br><span class="line">                                            args[i].getClass());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;                                                 &#x2F;&#x2F; @5</span><br><span class="line">                    for (int i &#x3D; 0; i &lt; args.length; i++) &#123;</span><br><span class="line">                        if (args[i] instanceof JavaBeanDescriptor) &#123;</span><br><span class="line">                            args[i] &#x3D; JavaBeanSerializeUtil.deserialize((JavaBeanDescriptor) args[i]);</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new RpcException(</span><br><span class="line">                                    &quot;Generic serialization [&quot; +</span><br><span class="line">                                            Constants.GENERIC_SERIALIZATION_BEAN +</span><br><span class="line">                                            &quot;] only support message type &quot; +</span><br><span class="line">                                            JavaBeanDescriptor.class.getName() +</span><br><span class="line">                                            &quot; and your message type is &quot; +</span><br><span class="line">                                            args[i].getClass().getName());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                Result result &#x3D; invoker.invoke(new RpcInvocation(method, args, inv.getAttachments()));    &#x2F;&#x2F; @6</span><br><span class="line">                if (result.hasException()</span><br><span class="line">                        &amp;&amp; !(result.getException() instanceof GenericException)) &#123;</span><br><span class="line">                    return new RpcResult(new GenericException(result.getException()));</span><br><span class="line">                &#125;</span><br><span class="line">                if (ProtocolUtils.isJavaGenericSerialization(generic)) &#123;                                                        &#x2F;&#x2F; @7</span><br><span class="line">                    try &#123;</span><br><span class="line">                        UnsafeByteArrayOutputStream os &#x3D; new UnsafeByteArrayOutputStream(512);</span><br><span class="line">                        ExtensionLoader.getExtensionLoader(Serialization.class)</span><br><span class="line">                                .getExtension(Constants.GENERIC_SERIALIZATION_NATIVE_JAVA)</span><br><span class="line">                                .serialize(null, os).writeObject(result.getValue());</span><br><span class="line">                        return new RpcResult(os.toByteArray());</span><br><span class="line">                    &#125; catch (IOException e) &#123;</span><br><span class="line">                        throw new RpcException(&quot;Serialize result failed.&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (ProtocolUtils.isBeanGenericSerialization(generic)) &#123;</span><br><span class="line">                    return new RpcResult(JavaBeanSerializeUtil.serialize(result.getValue(), JavaBeanAccessor.METHOD));</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return new RpcResult(PojoUtils.generalize(result.getValue()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">                throw new RpcException(e.getMessage(), e);</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                throw new RpcException(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(inv);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果方法名为$invoker，并且只有3个参数，并且服务端实现为非返回实现，则认为本次服务调用时客户端泛化引用服务端，客户端的泛化调用，需要将请求参数反序列化为该接口真实的pojo对象。<br>代码@2：根据接口名（API类）、方法名、方法参数类型列表，根据反射机制获取对应的方法。<br>代码@3：处理普通的泛化引用调用，即处理&lt;dubbo:referecnce generic=”true”  …/&gt;,只需要将参数列表Object[]反序列化为pojo即可，具体的反序列化为PojoUtils#realize,其实现原理如下：<br>在JAVA的世界中，pojo通常用map来表示，也就是一个Map可以用来表示一个对象的值，那从一个Map如果序列化一个对象呢？其关键的要素是要在Map中保留该对象的类路径名。例如现在有这样一个对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">	private int id;</span><br><span class="line">	private String name;</span><br><span class="line">	private Team team;</span><br><span class="line">	&#x2F;&#x2F;省略get set方法</span><br><span class="line">&#125;</span><br><span class="line">public class Team &#123;</span><br><span class="line">	private int id;</span><br><span class="line">	private String name;</span><br><span class="line">	&#x2F;&#x2F; 省略其他属性与set get方法</span><br><span class="line">&#125;</span><br><span class="line">用Map表示Student为：</span><br><span class="line">&#123;</span><br><span class="line">	“class”:&quot;somepackeage.Student&quot;,</span><br><span class="line">	&quot;id&quot;:1,</span><br><span class="line">	&quot;name&quot;:&quot;dingw&quot;,</span><br><span class="line">	&quot;team&quot;:</span><br><span class="line">	&#123;</span><br><span class="line">		&quot;class&quot; : &quot;somepackage.Team&quot;,</span><br><span class="line">		&quot;id&quot;:2,</span><br><span class="line">		&quot;name&quot;:&quot;t&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是通过class来标识该Map需要反序列化的pojo类型。<br>代码@4：处理&lt; dubbo:reference generic=”nativejava” /&gt; 启用泛化引用，并使用nativejava序列化参数，在服务端这边通过nativejava反序列化参数成pojo对象。<br>代码@5：处理&lt; dubbo:reference generic=”bean” /&gt; 启用泛化引用，并使用javabean序列化参数，在服务端这边通过javabean反序列化参数成pojo对象。<br>代码@6：序列化API方法中声明的类型，构建new RpcInvocation(method, args, inv.getAttachments())调用环境，继续调用后续过滤器。<br>代码@7：处理执行结果，如果是nativejava或bean，则需要对返回结果序列化，如果是generic=true，则使用PojoUtils.generalize序列化，也即将pojo序列化为Map。<br>泛化调用与泛化引用，就介绍到这里了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>泛化调用</tag>
        <tag>泛化实现</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo服务提供者启动流程-上篇</title>
    <url>/posts/80b68fd8.html</url>
    <content><![CDATA[<div id="vip-container"><p>本节将详细分析Dubbo服务提供者的启动流程，请带着如下几个疑问进行本节的阅读，因为这几个问题将是接下来几篇文章分析的重点内容。</p>
<ol>
<li>什么时候建立与注册中心的连接。</li>
<li>服务提供者什么时候向注册中心注册服务。</li>
<li>服务提供者与注册中心的心跳机制。</li>
</ol>
<a id="more"></a>

<p>从上文中我们得知，服务提供者启动的核心入口为ServiceBean,本节将从源码级别详细剖析ServcieBean的实现原理，即Dubbo服务提供者的启动流程，ServiceBean的继承层次如图所示，dubbo:service标签的所有属性都被封装在此类图结构中。<br><img src="https://img-blog.csdn.net/20180601130421654?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="1、源码分析ServiceBean-afterPropertiesSet"><a href="#1、源码分析ServiceBean-afterPropertiesSet" class="headerlink" title="1、源码分析ServiceBean#afterPropertiesSet"></a>1、源码分析ServiceBean#afterPropertiesSet</h2><p> ServiceBean#afterPropertiesSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (getProvider() &#x3D;&#x3D; null) &#123;  &#x2F;&#x2F; @1</span><br><span class="line">    Map&lt;String, ProviderConfig&gt; provide</span><br><span class="line">             ConfigMap &#x3D; applicationContext &#x3D;&#x3D; null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, ProviderConfig.class,   false, false); &#x2F;&#x2F; @2</span><br><span class="line">              &#x2F;&#x2F; ......  具体解析代码省略。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果provider为空，说明dubbo:service标签未设置provider属性，如果一个dubbo:provider标签，则取该实例，如果存在多个dubbo:provider配置则provider属性不能为空，否则抛出异常：”Duplicate provider configs”。</p>
<p>ServiceBean#afterPropertiesSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (getApplication() &#x3D;&#x3D; null</span><br><span class="line">        &amp;&amp; (getProvider() &#x3D;&#x3D; null || getProvider().getApplication() &#x3D;&#x3D; null)) &#123;</span><br><span class="line">      Map&lt;String, ApplicationConfig&gt; applicationConfigMap &#x3D; applicationContext &#x3D;&#x3D; null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, </span><br><span class="line">                 ApplicationConfig.class, false, false);</span><br><span class="line">       &#x2F;&#x2F; ...省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果application为空,则尝试从BeanFactory中查询dubbo:application实例，如果存在多个dubbo:application配置，则抛出异常：”Duplicate application configs”。</p>
<p>Step3：如果ServiceBean的module为空，则尝试从BeanFactory中查询dubbo:module实例，如果存在多个dubbo:module，则抛出异常：”Duplicate module configs: “。</p>
<p>Step4：尝试从BeanFactory中加载所有的注册中心，注意ServiceBean的List&lt; RegistryConfig&gt; registries属性，为注册中心集合。</p>
<p>Step5：尝试从BeanFacotry中加载一个监控中心，填充ServiceBean的MonitorConfig monitor属性，如果存在多个dubbo:monitor配置，则抛出”Duplicate monitor configs: “。</p>
<p>Step6：尝试从BeanFactory中加载所有的协议，注意：ServiceBean的List&lt; ProtocolConfig&gt; protocols是一个集合，也即一个服务可以通过多种协议暴露给消费者。</p>
<p>ServiceBean#afterPropertiesSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (getPath() &#x3D;&#x3D; null || getPath().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">       if (beanName !&#x3D; null &amp;&amp; beanName.length() &gt; 0 &amp;&amp; getInterface() !&#x3D; null &amp;&amp; getInterface().length() &gt; 0  &amp;&amp; beanName.startsWith(getInterface())) &#123;</span><br><span class="line">                setPath(beanName);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Step7：设置ServiceBean的path属性，path属性存放的是dubbo:service的beanName（dubbo:service id)。</p>
<p>ServiceBean#afterPropertiesSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!isDelay()) &#123;</span><br><span class="line">     export();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step8：如果为启用延迟暴露机制，则调用export暴露服务。首先看一下isDelay的实现，然后重点分析export的实现原理（服务暴露的整个实现原理）。</p>
<p>ServiceBean#isDelay</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean isDelay() &#123;</span><br><span class="line">        Integer delay &#x3D; getDelay();</span><br><span class="line">        ProviderConfig provider &#x3D; getProvider();</span><br><span class="line">        if (delay &#x3D;&#x3D; null &amp;&amp; provider !&#x3D; null) &#123;</span><br><span class="line">            delay &#x3D; provider.getDelay();</span><br><span class="line">        &#125;</span><br><span class="line">        return supportedApplicationListener &amp;&amp; (delay &#x3D;&#x3D; null || delay &#x3D;&#x3D; -1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果有设置dubbo:service或dubbo:provider的属性delay，或配置delay为-1,都表示启用延迟机制，单位为毫秒，设置为-1，表示等到Spring容器初始化后再暴露服务。从这里也可以看出，Dubbo暴露服务的处理入口为ServiceBean#export—》ServiceConfig#export。</p>
<h3 id="1-1-源码分析ServiceConfig-export-暴露服务"><a href="#1-1-源码分析ServiceConfig-export-暴露服务" class="headerlink" title="1.1 源码分析ServiceConfig#export 暴露服务"></a>1.1 源码分析ServiceConfig#export 暴露服务</h3><p>调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void export() &#123;</span><br><span class="line">        if (provider !&#x3D; null) &#123;</span><br><span class="line">            if (export &#x3D;&#x3D; null) &#123;</span><br><span class="line">                export &#x3D; provider.getExport();</span><br><span class="line">            &#125;</span><br><span class="line">            if (delay &#x3D;&#x3D; null) &#123;</span><br><span class="line">                delay &#x3D; provider.getDelay();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (export !&#x3D; null &amp;&amp; !export) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (delay !&#x3D; null &amp;&amp; delay &gt; 0) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            delayExportExecutor.schedule(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    doExport();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, delay, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            doExport();    &#x2F;&#x2F;@3</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：判断是否暴露服务，由dubbo:service export=”true|false”来指定。<br>代码@2：如果启用了delay机制，如果delay大于0，表示延迟多少毫秒后暴露服务，使用ScheduledExecutorService延迟调度，最终调用doExport方法。<br>代码@3：执行具体的暴露逻辑doExport，需要大家留意：delay=-1的处理逻辑（基于Spring事件机制触发）。</p>
<h3 id="1-2-源码分析ServiceConfig-doExport暴露服务"><a href="#1-2-源码分析ServiceConfig-doExport暴露服务" class="headerlink" title="1.2 源码分析ServiceConfig#doExport暴露服务"></a>1.2 源码分析ServiceConfig#doExport暴露服务</h3><p>调用链：ServiceBean#afterPropertiesSet—调用——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport</p>
<p>ServiceConfig#checkDefault</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkDefault() &#123;</span><br><span class="line">        if (provider &#x3D;&#x3D; null) &#123;</span><br><span class="line">            provider &#x3D; new ProviderConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        appendProperties(provider);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Step1:如果dubbo:servce标签也就是ServiceBean的provider属性为空，调用appendProperties方法，填充默认属性，其具体加载顺序：</p>
<ol>
<li>从系统属性加载对应参数值，参数键：dubbo.provider.属性名，System.getProperty。</li>
<li>加载属性配置文件的值。属性配置文件，可通过系统属性：dubbo.properties.file，如果该值未配置，则默认取dubbo.properties属性配置文件。</li>
</ol>
<p>ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ref instanceof GenericService) &#123;</span><br><span class="line">      interfaceClass &#x3D; GenericService.class;</span><br><span class="line">      if (StringUtils.isEmpty(generic)) &#123;</span><br><span class="line">           generic &#x3D; Boolean.TRUE.toString();</span><br><span class="line">      &#125;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">            interfaceClass &#x3D; Class.forName(interfaceName, true, Thread.currentThread()</span><br><span class="line">                        .getContextClassLoader());</span><br><span class="line">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">       checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">       checkRef();</span><br><span class="line">       generic &#x3D; Boolean.FALSE.toString();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Step2：校验ref与interface属性。如果ref是GenericService，则为dubbo的泛化实现，然后验证interface接口与ref引用的类型是否一致。</p>
<p>ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (local !&#x3D; null) &#123;</span><br><span class="line">      if (&quot;true&quot;.equals(local)) &#123;</span><br><span class="line">            local &#x3D; interfaceName + &quot;Local&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">      Class&lt;?&gt; localClass;</span><br><span class="line">      try &#123;</span><br><span class="line">             localClass &#x3D; ClassHelper.forNameWithThreadContextClassLoader(local);</span><br><span class="line">       &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">       &#125;</span><br><span class="line">      if (!interfaceClass.isAssignableFrom(localClass)) &#123;</span><br><span class="line">           throw new IllegalStateException(&quot;The local implementation class &quot; + localClass.getName() + &quot; not implement interface &quot; + interfaceName);</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Step3：dubbo:service local机制，已经废弃，被stub属性所替换。<br>Step4：处理本地存根Stub，&lt;dubbo:service 的stub属性，可以设置为true，此时Stub的类名为：interface+Stub，stub也可以指定自定义的全类名。本地存根说明如图所示（Dubbo官方文档）<br><img src="https://img-blog.csdn.net/2018060113090393?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkApplication();</span><br><span class="line">checkRegistry();</span><br><span class="line">checkProtocol();</span><br><span class="line">appendProperties(this);</span><br></pre></td></tr></table></figure>
<p>Step5：校验ServiceBean的application、registry、protocol是否为空，并从系统属性（优先）、资源文件中填充其属性。<br> 系统属性、资源文件属性的配置如下：<br> application     dubbo.application.属性名，例如    dubbo.application.name<br> registry          dubbo.registry.属性名，例如    dubbo.registry.address<br> protocol         dubbo.protocol.属性名，例如 dubbo.protocol.port<br> service           dubbo.service.属性名，例如 dubbo.service.stub</p>
<p>ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkStubAndMock(interfaceClass);</span><br></pre></td></tr></table></figure>
<p>Step6：校验stub、mock类的合理性，是否是interface的实现类。</p>
<p>ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doExportUrls();</span><br></pre></td></tr></table></figure>
<p>Step7：执行doExportUrls()方法暴露服务，接下来会重点分析该方法。</p>
<p> ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ProviderModel providerModel &#x3D; new ProviderModel(getUniqueServiceName(), this, ref);</span><br><span class="line">ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);</span><br></pre></td></tr></table></figure>
<p>Step8：将服务提供者信息注册到ApplicationModel实例中。</p>
<h3 id="1-3-源码分析ServiceConfig-doExportUrls暴露服务具体实现逻辑"><a href="#1-3-源码分析ServiceConfig-doExportUrls暴露服务具体实现逻辑" class="headerlink" title="1.3 源码分析ServiceConfig#doExportUrls暴露服务具体实现逻辑"></a>1.3 源码分析ServiceConfig#doExportUrls暴露服务具体实现逻辑</h3><p> 调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void doExportUrls() &#123;</span><br><span class="line">        List&lt;URL&gt; registryURLs &#x3D; loadRegistries(true);  &#x2F;&#x2F; @1</span><br><span class="line">        for (ProtocolConfig protocolConfig : protocols) &#123;</span><br><span class="line">            doExportUrlsFor1Protocol(protocolConfig, registryURLs);    &#x2F;&#x2F; @2</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先遍历ServiceBean的List&lt; RegistryConfig&gt; registries（所有注册中心的配置信息），然后将地址封装成URL对象，关于注册中心的所有配置属性，最终转换成url的属性(?属性名=属性值)，loadRegistries(true)，参数的意思：true，代表服务提供者，false：代表服务消费者，如果是服务提供者，则检测注册中心的配置，如果配置了register=”false”，则忽略该地址，如果是服务消费者，并配置了subscribe=”false”则表示不从该注册中心订阅服务，故也不返回，一个注册中心URL示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;pid&#x3D;7072&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1527308268041</span><br></pre></td></tr></table></figure>

<p> 代码@2：然后遍历配置的所有协议，根据每个协议，向注册中心暴露服务，接下来重点分析doExportUrlsFor1Protocol方法的实现细节。</p>
<h3 id="1-4-源码分析doExportUrlsFor1Protocol"><a href="#1-4-源码分析doExportUrlsFor1Protocol" class="headerlink" title="1.4 源码分析doExportUrlsFor1Protocol"></a>1.4 源码分析doExportUrlsFor1Protocol</h3><p> 调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport——&gt;ServiceConfig#doExportUrlsFor1Protocol<br> ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String name &#x3D; protocolConfig.getName();</span><br><span class="line">if (name &#x3D;&#x3D; null || name.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">     name &#x3D; &quot;dubbo&quot;;</span><br><span class="line">&#125;</span><br><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);</span><br><span class="line">map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">&#125;</span><br><span class="line">appendParameters(map, application);</span><br><span class="line">appendParameters(map, module);</span><br><span class="line">appendParameters(map, provider, Constants.DEFAULT_KEY);</span><br><span class="line">appendParameters(map, protocolConfig);</span><br><span class="line">appendParameters(map, this);</span><br></pre></td></tr></table></figure>
<p>Step1：用Map存储该协议的所有配置参数，包括协议名称、dubbo版本、当前系统时间戳、进程ID、application配置、module配置、默认服务提供者参数(ProviderConfig)、协议配置、服务提供Dubbo:service的属性。</p>
<p> ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (methods !&#x3D; null &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">            for (MethodConfig method : methods) &#123;</span><br><span class="line">                appendParameters(map, method, method.getName());</span><br><span class="line">                String retryKey &#x3D; method.getName() + &quot;.retry&quot;;</span><br><span class="line">                if (map.containsKey(retryKey)) &#123;</span><br><span class="line">                    String retryValue &#x3D; map.remove(retryKey);</span><br><span class="line">                    if (&quot;false&quot;.equals(retryValue)) &#123;</span><br><span class="line">                        map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;ArgumentConfig&gt; arguments &#x3D; method.getArguments();</span><br><span class="line">                if (arguments !&#x3D; null &amp;&amp; !arguments.isEmpty()) &#123;</span><br><span class="line">                    for (ArgumentConfig argument : arguments) &#123;</span><br><span class="line">                        &#x2F;&#x2F; convert argument type</span><br><span class="line">                        if (argument.getType() !&#x3D; null &amp;&amp; argument.getType().length() &gt; 0) &#123;</span><br><span class="line">                            Method[] methods &#x3D; interfaceClass.getMethods();</span><br><span class="line">                            &#x2F;&#x2F; visit all methods</span><br><span class="line">                            if (methods !&#x3D; null &amp;&amp; methods.length &gt; 0) &#123;</span><br><span class="line">                                for (int i &#x3D; 0; i &lt; methods.length; i++) &#123;</span><br><span class="line">                                    String methodName &#x3D; methods[i].getName();</span><br><span class="line">                                    &#x2F;&#x2F; target the method, and get its signature</span><br><span class="line">                                    if (methodName.equals(method.getName())) &#123;</span><br><span class="line">                                        Class&lt;?&gt;[] argtypes &#x3D; methods[i].getParameterTypes();</span><br><span class="line">                                        &#x2F;&#x2F; one callback in the method</span><br><span class="line">                                        if (argument.getIndex() !&#x3D; -1) &#123;</span><br><span class="line">                                            if (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());</span><br><span class="line">                                            &#125; else &#123;</span><br><span class="line">                                                throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attribute not match :index :&quot; + argument.getIndex() + &quot;, type:&quot; + </span><br><span class="line">                                                      argument.getType());</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125; else &#123;</span><br><span class="line">                                            &#x2F;&#x2F; multiple callbacks in the method</span><br><span class="line">                                            for (int j &#x3D; 0; j &lt; argtypes.length; j++) &#123;</span><br><span class="line">                                                Class&lt;?&gt; argclazz &#x3D; argtypes[j];</span><br><span class="line">                                                if (argclazz.getName().equals(argument.getType())) &#123;</span><br><span class="line">                                                    appendParameters(map, argument, method.getName() + &quot;.&quot; + j);</span><br><span class="line">                                                    if (argument.getIndex() !&#x3D; -1 &amp;&amp; argument.getIndex() !&#x3D; j) &#123;</span><br><span class="line">                                                        throw new IllegalArgumentException(&quot;argument config error : the index attribute and type attribute not match :index :&quot; + argument.getIndex() + &quot;, </span><br><span class="line">                                                             type:&quot; + argument.getType());</span><br><span class="line">                                                    &#125;</span><br><span class="line">                                                &#125;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else if (argument.getIndex() !&#x3D; -1) &#123;</span><br><span class="line">                            appendParameters(map, argument, method.getName() + &quot;.&quot; + argument.getIndex());</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            throw new IllegalArgumentException(&quot;argument config must set index or type attribute.eg: &lt;dubbo:argument index&#x3D;&#39;0&#39; ...&#x2F;&gt; or &lt;dubbo:argument type&#x3D;xxx ...&#x2F;&gt;&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; &#x2F;&#x2F; end of methods for</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果dubbo:service有dubbo:method子标签，则dubbo:method以及其子标签的配置属性，都存入到Map中，属性名称加上对应的方法名作为前缀。dubbo:method的子标签dubbo:argument,其键为方法名.参数序号。</p>
<p>ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (ProtocolUtils.isGeneric(generic)) &#123;</span><br><span class="line">      map.put(Constants.GENERIC_KEY, generic);</span><br><span class="line">      map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">      String revision &#x3D; Version.getVersion(interfaceClass, version);</span><br><span class="line">      if (revision !&#x3D; null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">          map.put(&quot;revision&quot;, revision);</span><br><span class="line">      &#125;</span><br><span class="line">      String[] methods &#x3D; Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">      if (methods.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">           map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">           map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：添加methods键值对，存放dubbo:service的所有方法名，多个方法名用,隔开，如果是泛化实现，填充genric=true,methods为”*”；</p>
<p>ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!ConfigUtils.isEmpty(token)) &#123;</span><br><span class="line">      if (ConfigUtils.isDefault(token)) &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">            map.put(Constants.TOKEN_KEY, token);</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4:根据是否开启令牌机制，如果开启，设置token键，值为静态值或uuid。</p>
<p>ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;</span><br><span class="line">       protocolConfig.setRegister(false);</span><br><span class="line">       map.put(&quot;notify&quot;, &quot;false&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5:如果协议为本地协议(injvm)，则设置protocolConfig#register属性为false，表示不向注册中心注册服务，在map中存储键为notify,值为false,表示当注册中心监听到服务提供者发送变化（服务提供者增加、服务提供者减少等事件时不通知。</p>
<p>ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; export service</span><br><span class="line">String contextPath &#x3D; protocolConfig.getContextpath();</span><br><span class="line">if ((contextPath &#x3D;&#x3D; null || contextPath.length() &#x3D;&#x3D; 0) &amp;&amp; provider !&#x3D; null) &#123;</span><br><span class="line">     contextPath &#x3D; provider.getContextpath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6:设置协议的contextPath,如果未配置，默认为/interfacename</p>
<p>ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String host &#x3D; this.findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">Integer port &#x3D; this.findConfigedPorts(protocolConfig, name, map);</span><br></pre></td></tr></table></figure>
<p>Step7：解析服务提供者的IP地址与端口。<br>服务IP地址解析顺序：（序号越小越优先）</p>
<ol>
<li>系统环境变量，变量名：DUBBO_DUBBO_IP_TO_BIND  </li>
<li>系统属性,变量名：DUBBO_DUBBO_IP_TO_BIND</li>
<li>系统环境变量，变量名：DUBBO_IP_TO_BIND</li>
<li>系统属性，变量名：DUBBO_IP_TO_BIND</li>
<li>dubbo:protocol 标签的host属性  –》 dubbo:provider 标签的host属性</li>
<li>默认网卡IP地址，通过InetAddress.getLocalHost().getHostAddress()获取，如果IP地址不符合要求，继续下一个匹配。</li>
</ol>
<p>判断IP地址是否符合要求的标准是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static boolean isInvalidLocalHost(String host) &#123;</span><br><span class="line">     return host &#x3D;&#x3D; null</span><br><span class="line">             || host.length() &#x3D;&#x3D; 0</span><br><span class="line">             || host.equalsIgnoreCase(&quot;localhost&quot;)</span><br><span class="line">             || host.equals(&quot;0.0.0.0&quot;)</span><br><span class="line">             || (LOCAL_IP_PATTERN.matcher(host).matches());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ol start="7">
<li><p>选择第一个可用网卡，其实现方式是建立socket，连接注册中心，获取socket的IP地址。其代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Socket socket &#x3D; new Socket();</span><br><span class="line">        try &#123;</span><br><span class="line">              SocketAddress addr &#x3D; new InetSocketAddress(registryURL.getHost(), registryURL.getPort());</span><br><span class="line">              socket.connect(addr, 1000);</span><br><span class="line">              hostToBind &#x3D; socket.getLocalAddress().getHostAddress();</span><br><span class="line">              break;</span><br><span class="line">         &#125; finally &#123;</span><br><span class="line">              try &#123;</span><br><span class="line">                      socket.close();</span><br><span class="line">              &#125; catch (Throwable e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>服务提供者端口解析顺序：（序号越小越优先）</p>
</li>
<li><p>系统环境变量，变量名：DUBBO_DUBBO_PORT_TO_BIND</p>
</li>
<li><p>系统属性，变量名：DUBBO_DUBBO_PORT_TO_BIND</p>
</li>
<li><p>系统环境变量，变量名：DUBBO_PORT_TO_BIND</p>
</li>
<li><p>系统属性，变量名DUBBO_PORT_TO_BIND</p>
</li>
<li><p>dubbo:protocol标签port属性、dubbo:provider标签的port属性。</p>
</li>
<li><p>随机选择一个端口。</p>
<p>ServiceConfig#doExportUrlsFor1Protocol</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL url &#x3D; new URL(name, host, port, (contextPath &#x3D;&#x3D; null || contextPath.length() &#x3D;&#x3D; 0 ? &quot;&quot; : contextPath + &quot;&#x2F;&quot;) + path, map);</span><br></pre></td></tr></table></figure>
<p> Step8：根据协议名称、协议host、协议端口、contextPath、相关配置属性（application、module、provider、protocolConfig、service及其子标签）构建服务提供者URI。<br> URL运行效果图:<br><img src="https://img-blog.csdn.net/20180601131950233?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 以dubbo协议为例，展示最终服务提供者的URL信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo:&#x2F;&#x2F;192.168.56.1:20880&#x2F;com.alibaba.dubbo.demo.DemoService?anyhost&#x3D;true&amp;application&#x3D;demo-provider&amp;bind.ip&#x3D;192.168.56.1&amp;bind.port&#x3D;20880&amp;dubbo&#x3D;2.0.0&amp;generic&#x3D;false&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;5916&amp;qos.port&#x3D;22222&amp;side&#x3D;provider&amp;timestamp&#x3D;1527168070857</span><br></pre></td></tr></table></figure>

<p> ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String scope &#x3D; url.getParameter(Constants.SCOPE_KEY);</span><br><span class="line">&#x2F;&#x2F; don&#39;t export when none is configured</span><br><span class="line">if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;</span><br><span class="line">     &#x2F;&#x2F; 接口暴露实现逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step9：获取dubbo:service标签的scope属性，其可选值为none(不暴露)、local(本地)、remote(远程)，如果配置为none，则不暴露。默认为local。</p>
<p> ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; export to local if the config is not remote (export to remote only when config is remote)</span><br><span class="line">if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">       exportLocal(url);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; export to remote if the config is not local (export to local only when config is local)</span><br><span class="line">if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;     &#x2F;&#x2F; @2</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">              logger.info(&quot;Export dubbo service &quot; + interfaceClass.getName() + &quot; to url &quot; + url);</span><br><span class="line">         &#125;</span><br><span class="line">        if (registryURLs !&#x3D; null &amp;&amp; !registryURLs.isEmpty()) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">              for (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    url &#x3D; url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));  &#x2F;&#x2F; @4</span><br><span class="line">                    URL monitorUrl &#x3D; loadMonitor(registryURL);       &#x2F;&#x2F; @5</span><br><span class="line">                    if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">                        url &#x3D; url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());  </span><br><span class="line">                    &#125;</span><br><span class="line">                    if (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">                    &#125;</span><br><span class="line">                   Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));  &#x2F;&#x2F; @6</span><br><span class="line">                   DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);    </span><br><span class="line">                   Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);    &#x2F;&#x2F; @7</span><br><span class="line">                   exporters.add(exporter);</span><br><span class="line">               &#125;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">               Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">               DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line">               Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);</span><br><span class="line">               exporters.add(exporter);</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step10：根据scope来暴露服务，如果scope不配置，则默认本地与远程都会暴露，如果配置成local或remote，那就只能是二选一。</p>
<ul>
<li><p>代码@1：如果scope不为remote，则先在本地暴露(injvm):，具体暴露服务的具体实现，将在remote 模式中详细分析。</p>
</li>
<li><p>代码@2：如果scope不为local,则将服务暴露在远程。 </p>
</li>
<li><p>代码@3：remote方式，检测当前配置的所有注册中心，如果注册中心不为空，则遍历注册中心，将服务依次在不同的注册中心进行注册。</p>
</li>
<li><p>代码@4：如果dubbo:service的dynamic属性未配置， 尝试取dubbo:registry的dynamic属性，该属性的作用是否启用动态注册，如果设置为false，服务注册后，其状态显示为disable，需要人工启用，当服务不可用时，也不会自动移除，同样需要人工处理，此属性不要在生产环境上配置。</p>
</li>
<li><p>代码@5：根据注册中心url(注册中心url)，构建监控中心的URL，如果监控中心URL不为空，则在服务提供者URL上追加monitor，其值为监控中心url(已编码)。</p>
</li>
<li><p>如果dubbo spring xml配置文件中没有配置监控中心(dubbo:monitor),如果从系统属性-Ddubbo.monitor.address，-Ddubbo.monitor.protocol构建MonitorConfig对象，否则从dubbo的properties配置文件中寻找这个两个参数，如果没有配置，则返回null。</p>
</li>
<li><p>如果有配置，则追加相关参数，dubbo:monitor标签只有两个属性：address、protocol，其次会追加interface(MonitorService)、协议等。</p>
</li>
<li><p>代码@6：通过动态代理机制创建Invoker，dubbo的远程调用实现类。<br><img src="https://img-blog.csdn.net/20180601132122916?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> Dubbo远程调用器如何构建，这里不详细深入，重点关注WrapperInvoker的url为:registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.0&amp;export=dubbo%3A%2F%2F192.168.56.1%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.56.1%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D6328%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1527255510215&amp;pid=6328&amp;qos.port=22222&amp;registry=zookeeper&amp;timestamp=1527255510202，这里有两个重点值得关注：</p>
</li>
<li><p>path属性：com.alibaba.dubbo.registry.RegistryService，注册中心也类似于服务提供者。</p>
</li>
<li><p>export属性：值为服务提供者的URL，为什么需要关注这个URL呢？请看代码@7，protocol属性为Protocol$Adaptive，Dubbo在加载组件实现类时采用SPI(插件机制，有关于插件机制，在该专题后续文章将重点分析)，在这里我们只需要知道，根据URL冒号之前的协议名将会调用相应的方法。<br><img src="https://img-blog.csdn.net/20180601132156636?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br> 其映射关系(列出与服务启动相关协议实现类)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dubbo&#x3D;com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol       &#x2F;&#x2F;文件位于dubbo-rpc-dubbo&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;dubbo&#x2F;internal&#x2F;com.alibaba.dubbo.rpc.Protocol</span><br><span class="line">registry&#x3D;com.alibaba.dubbo.registry.integration.RegistryProtocol   &#x2F;&#x2F;文件位于dubbo-registry-api&#x2F;src&#x2F;main&#x2F;resources&#x2F;META-INF&#x2F;dubbo&#x2F;internal&#x2F;com.alibaba.dubbo.rpc.Protocol</span><br></pre></td></tr></table></figure>

<p> 代码@7：根据代码@6的分析，将调用RegistryProtocol#export方法。</p>
</li>
</ul>
<h3 id="1-5-源码分析RegistryProtocol-export方法"><a href="#1-5-源码分析RegistryProtocol-export方法" class="headerlink" title="1.5 源码分析RegistryProtocol#export方法"></a>1.5 源码分析RegistryProtocol#export方法</h3><p> 调用链：ServiceBean#afterPropertiesSet——&gt;ServiceConfig#export——&gt;ServiceConfig#doExport——&gt;ServiceConfig#doExportUrlsFor1Protocol——&gt;RegistryProtocol#export</p>
<p> RegistryProtocol#export</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public &lt;T&gt; Exporter&lt;T&gt; export(final Invoker&lt;T&gt; originInvoker) throws RpcException &#123;</span><br><span class="line">        &#x2F;&#x2F;export invoker</span><br><span class="line">        final ExporterChangeableWrapper&lt;T&gt; exporter &#x3D; doLocalExport(originInvoker);   &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">        URL registryUrl &#x3D; getRegistryUrl(originInvoker);       &#x2F;&#x2F; @2</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;registry provider</span><br><span class="line">        final Registry registry &#x3D; getRegistry(originInvoker);                          &#x2F;&#x2F; @3</span><br><span class="line">        final URL registedProviderUrl &#x3D; getRegistedProviderUrl(originInvoker);     &#x2F;&#x2F; @4start</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;to judge to delay publish whether or not</span><br><span class="line">        boolean register &#x3D; registedProviderUrl.getParameter(&quot;register&quot;, true);  </span><br><span class="line"></span><br><span class="line">        ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registedProviderUrl);</span><br><span class="line"></span><br><span class="line">        if (register) &#123;  </span><br><span class="line">            register(registryUrl, registedProviderUrl);      &#x2F;&#x2F; @4 end</span><br><span class="line">            ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Subscribe the override data</span><br><span class="line">        &#x2F;&#x2F; FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call the same service. Because the subscribed is cached key with the name of the service, it causes the subscription information to cover.</span><br><span class="line">        final URL overrideSubscribeUrl &#x3D; getSubscribedOverrideUrl(registedProviderUrl);          &#x2F;&#x2F; @5 start</span><br><span class="line">        final OverrideListener overrideSubscribeListener &#x3D; new OverrideListener(overrideSubscribeUrl, originInvoker);</span><br><span class="line">        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);</span><br><span class="line">        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);            &#x2F;&#x2F; @5 end</span><br><span class="line">        &#x2F;&#x2F;Ensure that a new exporter instance is returned every time export</span><br><span class="line">        return new DestroyableExporter&lt;T&gt;(exporter, originInvoker, overrideSubscribeUrl, registedProviderUrl);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：启动服务提供者服务，监听指定端口，准备服务消费者的请求，这里其实就是从WrapperInvoker中的url(注册中心url)中提取export属性，描述服务提供者的url，然后启动服务提供者。<br><img src="https://img-blog.csdn.net/20180601132318446?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从上图中，可以看出，将调用DubboProtocol#export完成dubbo服务的启动，利用netty构建一个微型服务端，监听端口，准备接受服务消费者的网络请求，本节旨在梳理其启动流程，具体实现细节，将在后续章节中详解，这里我们只要知道，&lt; dubbo:protocol name=”dubbo” port=”20880” /&gt;,会再此次监听该端口，然后将dubbo:service的服务handler加入到命令处理器中，当有消息消费者连接该端口时，通过网络解包，将需要调用的服务和参数等信息解析处理后，转交给对应的服务实现类处理即可。<br> 代码@2：获取真实注册中心的URL,例如zookeeper注册中心的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL:zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;export&#x3D;dubbo%3A%2F%2F192.168.56.1%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.56.1%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D10252%26qos.port%3D22222%26side%3Dprovider%26timestamp%3D1527263060882&amp;pid&#x3D;10252&amp;qos.port&#x3D;22222&amp;timestamp&#x3D;1527263060867</span><br></pre></td></tr></table></figure>

<p>代码@3：根据注册中心URL，从注册中心工厂中获取指定的注册中心实现类：zookeeper注册中心的实现类为：ZookeeperRegistry</p>
<p>代码@4：获取服务提供者URL中的register属性，如果为true,则调用注册中心的ZookeeperRegistry#register方法向注册中心注册服务（实际由其父类FailbackRegistry实现）。</p>
<p>代码@5：服务提供者向注册中心订阅自己，主要是为了服务提供者URL发送变化后重新暴露服务，当然，会将dubbo:reference的check属性设置为false。</p>
<p>到这里就对文章开头提到的问题1，问题2做了一个解答，其与注册中心的心跳机制等将在后续章节中详细分析。</p>
<p>文字看起来可能不是很直观，现整理一下Dubbo服务提供者启动流程图如下：<br><img src="https://img-blog.csdn.net/20180601132342644?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>本文重点梳理了Dubbo服务提供者启动流程，其中Dubbo服务提供者在指定端口监听服务的启动流程将在下一节中详细分析。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>ServcieBean</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo服务消费端启动流程</title>
    <url>/posts/cc583494.html</url>
    <content><![CDATA[<div id="vip-container"><p>通过前面文章详解，我们知道Dubbo服务消费者标签dubbo:reference最终会在Spring容器中创建一个对应的ReferenceBean实例，而ReferenceBean实现了Spring生命周期接口：InitializingBean，接下来应该看一下其afterPropertiesSet方法的实现。</p>
<a id="more"></a>

<h2 id="1、源码分析ReferenceBean-afterPropertiesSet"><a href="#1、源码分析ReferenceBean-afterPropertiesSet" class="headerlink" title="1、源码分析ReferenceBean#afterPropertiesSet"></a>1、源码分析ReferenceBean#afterPropertiesSet</h2><p>ReferenceBean#afterPropertiesSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (getConsumer() &#x3D;&#x3D; null) &#123;</span><br><span class="line">            Map&lt;String, ConsumerConfig&gt; consumerConfigMap &#x3D; applicationContext &#x3D;&#x3D; null ? null : BeanFactoryUtils.beansOfTypeIncludingAncestors(applicationContext, </span><br><span class="line">                 ConsumerConfig.class, false, false);</span><br><span class="line">            if (consumerConfigMap !&#x3D; null &amp;&amp; consumerConfigMap.size() &gt; 0) &#123;</span><br><span class="line">                ConsumerConfig consumerConfig &#x3D; null;</span><br><span class="line">                for (ConsumerConfig config : consumerConfigMap.values()) &#123;</span><br><span class="line">                    if (config.isDefault() &#x3D;&#x3D; null || config.isDefault().booleanValue()) &#123;</span><br><span class="line">                        if (consumerConfig !&#x3D; null) &#123;</span><br><span class="line">                            throw new IllegalStateException(&quot;Duplicate consumer configs: &quot; + consumerConfig + &quot; and &quot; + config);</span><br><span class="line">                        &#125;</span><br><span class="line">                        consumerConfig &#x3D; config;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                if (consumerConfig !&#x3D; null) &#123;</span><br><span class="line">                    setConsumer(consumerConfig);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果consumer为空，说明dubbo:reference标签未设置consumer属性，如果一个dubbo:consumer标签，则取该实例，如果存在多个dubbo:consumer 配置，则consumer必须设置，否则会抛出异常：”Duplicate consumer configs”。</p>
<p>Step2：如果application为空,则尝试从BeanFactory中查询dubbo:application实例，如果存在多个dubbo:application配置，则抛出异常：”Duplicate application configs”。</p>
<p>Step3：如果ServiceBean的module为空，则尝试从BeanFactory中查询dubbo:module实例，如果存在多个dubbo:module，则抛出异常：”Duplicate module configs: “。</p>
<p>Step4：尝试从BeanFactory中加载所有的注册中心，注意ServiceBean的List&lt; RegistryConfig&gt; registries属性，为注册中心集合。</p>
<p>Step5：尝试从BeanFacotry中加载一个监控中心，填充ServiceBean的MonitorConfig monitor属性，如果存在多个dubbo:monitor配置，则抛出”Duplicate monitor configs: “。</p>
<p>ReferenceBean#afterPropertiesSet</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean b &#x3D; isInit();</span><br><span class="line">if (b &#x3D;&#x3D; null &amp;&amp; getConsumer() !&#x3D; null) &#123;</span><br><span class="line">      b &#x3D; getConsumer().isInit();</span><br><span class="line">&#125;</span><br><span class="line">if (b !&#x3D; null &amp;&amp; b.booleanValue()) &#123;</span><br><span class="line">      getObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6：判断是否初始化，如果为初始化，则调用getObject()方法，该方法也是FactoryBean定义的方法，ReferenceBean是dubbo:reference所真实引用的类(interface)的实例工程，getObject发返回的是interface的实例，而不是ReferenceBean实例。</p>
<h3 id="1-1-源码分析getObject"><a href="#1-1-源码分析getObject" class="headerlink" title="1.1 源码分析getObject()"></a>1.1 源码分析getObject()</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object getObject() throws Exception &#123;</span><br><span class="line">        return get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReferenceBean#getObject()方法直接调用其父类的get方法,get方法内部调用init()方法进行初始化</p>
<h3 id="1-2-源码分析ReferenceConfig-init方法"><a href="#1-2-源码分析ReferenceConfig-init方法" class="headerlink" title="1.2 源码分析ReferenceConfig#init方法"></a>1.2 源码分析ReferenceConfig#init方法</h3><p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (initialized) &#123;</span><br><span class="line">     return;</span><br><span class="line"> &#125;</span><br><span class="line">initialized &#x3D; true;</span><br><span class="line">if (interfaceName &#x3D;&#x3D; null || interfaceName.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;&lt;dubbo:reference interface&#x3D;\&quot;\&quot; &#x2F;&gt; interface not allow null!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果已经初始化，直接返回，如果interfaceName为空，则抛出异常。</p>
<p>ReferenceConfig#init调用ReferenceConfig#checkDefault</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void checkDefault() &#123;</span><br><span class="line">        if (consumer &#x3D;&#x3D; null) &#123;</span><br><span class="line">            consumer &#x3D; new ConsumerConfig();</span><br><span class="line">        &#125;</span><br><span class="line">        appendProperties(consumer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Step2:如果dubbo:reference标签也就是ReferenceBean的consumer属性为空，调用appendProperties方法，填充默认属性，其具体加载顺序：</p>
<ol>
<li>从系统属性加载对应参数值，参数键：dubbo.consumer.属性名，从系统属性中获取属性值的方法为：System.getProperty(key)。</li>
<li>加载属性配置文件的值。属性配置文件，可通过系统属性：dubbo.properties.file，如果该值未配置，则默认取dubbo.properties属性配置文件。<br>ReferenceConfig#init<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendProperties(this);</span><br></pre></td></tr></table></figure>
Step3：调用appendProperties方法，填充ReferenceBean的属性，属性值来源与step2一样，当然只填充ReferenceBean中属性为空的属性。</li>
</ol>
<p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (getGeneric() &#x3D;&#x3D; null &amp;&amp; getConsumer() !&#x3D; null) &#123;</span><br><span class="line">      setGeneric(getConsumer().getGeneric());</span><br><span class="line">&#125;</span><br><span class="line">if (ProtocolUtils.isGeneric(getGeneric())) &#123;</span><br><span class="line">      interfaceClass &#x3D; GenericService.class;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">              interfaceClass &#x3D; Class.forName(interfaceName, true, Thread.currentThread().getContextClassLoader());</span><br><span class="line">      &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                throw new IllegalStateException(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      checkInterfaceAndMethods(interfaceClass, methods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：如果使用返回引用，将interface值替换为GenericService全路径名，如果不是，则加载interfacename，并检验dubbo:reference子标签dubbo:method引用的方法是否在interface指定的接口中存在。</p>
<p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String resolve &#x3D; System.getProperty(interfaceName);      &#x2F;&#x2F; @1</span><br><span class="line">String resolveFile &#x3D; null;</span><br><span class="line">if (resolve &#x3D;&#x3D; null || resolve.length() &#x3D;&#x3D; 0) &#123;                       &#x2F;&#x2F; @2</span><br><span class="line">     resolveFile &#x3D; System.getProperty(&quot;dubbo.resolve.file&quot;);    &#x2F;&#x2F; @3 start</span><br><span class="line">     if (resolveFile &#x3D;&#x3D; null || resolveFile.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          File userResolveFile &#x3D; new File(new File(System.getProperty(&quot;user.home&quot;)), &quot;dubbo-resolve.properties&quot;);</span><br><span class="line">          if (userResolveFile.exists()) &#123;</span><br><span class="line">               resolveFile &#x3D; userResolveFile.getAbsolutePath();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;    &#x2F;&#x2F; @3 end</span><br><span class="line">     if (resolveFile !&#x3D; null &amp;&amp; resolveFile.length() &gt; 0) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">          Properties properties &#x3D; new Properties();</span><br><span class="line">          FileInputStream fis &#x3D; null;</span><br><span class="line">          try &#123;</span><br><span class="line">               fis &#x3D; new FileInputStream(new File(resolveFile));</span><br><span class="line">               properties.load(fis);</span><br><span class="line">           &#125; catch (IOException e) &#123;</span><br><span class="line">               throw new IllegalStateException(&quot;Unload &quot; + resolveFile + &quot;, cause: &quot; + e.getMessage(), e);</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               try &#123;</span><br><span class="line">                    if (null !&#x3D; fis) fis.close();</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                    logger.warn(e.getMessage(), e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">          resolve &#x3D; properties.getProperty(interfaceName);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> if (resolve !&#x3D; null &amp;&amp; resolve.length() &gt; 0) &#123;  &#x2F;&#x2F; @5</span><br><span class="line">      url &#x3D; resolve;</span><br><span class="line">      if (logger.isWarnEnabled()) &#123;</span><br><span class="line">         if (resolveFile !&#x3D; null &amp;&amp; resolveFile.length() &gt; 0) &#123;</span><br><span class="line">             logger.warn(&quot;Using default dubbo resolve file &quot; + resolveFile + &quot; replace &quot; + interfaceName + &quot;&quot; + resolve + &quot; to p2p invoke remote service.&quot;);</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">            logger.warn(&quot;Using -D&quot; + interfaceName + &quot;&#x3D;&quot; + resolve + &quot; to p2p invoke remote service.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5：处理dubbo服务消费端resolve机制，也就是说消息消费者只连服务提供者，绕过注册中心。</p>
<ul>
<li>代码@1：从系统属性中获取该接口的直连服务提供者，如果存在 -Dinterface=dubbo://127.0.0.1:20880,其中interface为dubbo:reference interface属性的值。</li>
<li>代码@2：如果未指定-D属性，尝试从resolve配置文件中查找，从这里看出-D的优先级更高。</li>
<li>代码@3：首先尝试获取resolve配置文件的路径，其来源可以通过-Ddubbo.resolve.file=文件路径名来指定，如果未配置该系统参数，则默认从${user.home}/dubbo-resolve.properties,如果过文件存在，则设置resolveFile的值，否则resolveFile为null。</li>
<li>代码@4：如果resolveFile不为空，则加载resolveFile文件中内容，然后通过interface获取其配置的直连服务提供者URL。</li>
<li>代码@5：如果resolve不为空，则填充ReferenceBean的url属性为resolve(点对点服务提供者URL)，打印日志，点对点URL的来源（系统属性、resolve配置文件）。</li>
</ul>
<p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">checkApplication();</span><br><span class="line">checkStubAndMock(interfaceClass);</span><br></pre></td></tr></table></figure>
<p>Step6：校验ReferenceBean的application是否为空,如果为空，new 一个application，并尝试从系统属性（优先）、资源文件中填充其属性；同时校验stub、mock实现类与interface的兼容性。系统属性、资源文件属性的配置如下：<br>application     dubbo.application.属性名，例如    dubbo.application.name</p>
<p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map &#x3D; new HashMap&lt;String, String&gt;();</span><br><span class="line">Map&lt;Object, Object&gt; attributes &#x3D; new HashMap&lt;Object, Object&gt;();</span><br><span class="line">map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);</span><br><span class="line">map.put(Constants.DUBBO_VERSION_KEY, Version.getVersion());</span><br><span class="line">map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">if (ConfigUtils.getPid() &gt; 0) &#123;</span><br><span class="line">     map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step7：构建Map,封装服务消费者引用服务提供者URL的属性，这里主要填充side:consume（消费端)、dubbo：2.0.0(版本)、timestamp、pid:进程ID。</p>
<p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!isGeneric()) &#123;</span><br><span class="line">    String revision &#x3D; Version.getVersion(interfaceClass, version);</span><br><span class="line">    if (revision !&#x3D; null &amp;&amp; revision.length() &gt; 0) &#123;</span><br><span class="line">         map.put(&quot;revision&quot;, revision);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] methods &#x3D; Wrapper.getWrapper(interfaceClass).getMethodNames();</span><br><span class="line">    if (methods.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">           logger.warn(&quot;NO method found in service interface &quot; + interfaceClass.getName());</span><br><span class="line">           map.put(&quot;methods&quot;, Constants.ANY_VALUE);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">          map.put(&quot;methods&quot;, StringUtils.join(new HashSet&lt;String&gt;(Arrays.asList(methods)), &quot;,&quot;));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step8：如果不是泛化引用，增加methods:interface的所有方法名，多个用逗号隔开。<br>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map.put(Constants.INTERFACE_KEY, interfaceName);</span><br><span class="line">appendParameters(map, application);</span><br><span class="line">appendParameters(map, module);</span><br><span class="line">appendParameters(map, consumer, Constants.DEFAULT_KEY);</span><br><span class="line">appendParameters(map, this);</span><br></pre></td></tr></table></figure>
<p>Step9：用Map存储application配置、module配置、默认消费者参数(ConsumerConfig)、服务消费者dubbo:reference的属性。<br>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String prefix &#x3D; StringUtils.getServiceKey(map);</span><br><span class="line">if (methods !&#x3D; null &amp;&amp; !methods.isEmpty()) &#123;</span><br><span class="line">    for (MethodConfig method : methods) &#123;</span><br><span class="line">         appendParameters(map, method, method.getName());</span><br><span class="line">         String retryKey &#x3D; method.getName() + &quot;.retry&quot;;</span><br><span class="line">         if (map.containsKey(retryKey)) &#123;</span><br><span class="line">              String retryValue &#x3D; map.remove(retryKey);</span><br><span class="line">              if (&quot;false&quot;.equals(retryValue)) &#123;</span><br><span class="line">                  map.put(method.getName() + &quot;.retries&quot;, &quot;0&quot;);</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         appendAttributes(attributes, method, prefix + &quot;.&quot; + method.getName());</span><br><span class="line">         checkAndConvertImplicitConfig(method, map, attributes);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step10：获取服务键值 /{group}/interface:版本，如果group为空，则为interface:版本,其值存为prifex，然后将dubbo:method的属性名称也填入map中，键前缀为dubbo.method.methodname.属性名。dubbo:method的子标签dubbo:argument标签的属性也追加到attributes map中，键为 prifex + methodname.属性名。</p>
<p>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String hostToRegistry &#x3D; ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);</span><br><span class="line">if (hostToRegistry &#x3D;&#x3D; null || hostToRegistry.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      hostToRegistry &#x3D; NetUtils.getLocalHost();</span><br><span class="line">&#125; else if (isInvalidLocalHost(hostToRegistry)) &#123;</span><br><span class="line">      throw new IllegalArgumentException(&quot;Specified invalid registry ip from property:&quot; + Constants.DUBBO_IP_TO_REGISTRY + &quot;, value:&quot; + </span><br><span class="line">           hostToRegistry);</span><br><span class="line">&#125;</span><br><span class="line">map.put(Constants.REGISTER_IP_KEY, hostToRegistry);</span><br></pre></td></tr></table></figure>
<p>Step11：填充register.ip属性，该属性是消息消费者连接注册中心的IP，并不是注册中心自身的IP。<br>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ref &#x3D; createProxy(map);</span><br></pre></td></tr></table></figure>
<p>Step12：调用createProxy方法创建消息消费者代理，下面详细分析其实现细节。<br>ReferenceConfig#init</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConsumerModel consumerModel &#x3D; new ConsumerModel(getUniqueServiceName(), this, ref, interfaceClass.getMethods());</span><br><span class="line">ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);</span><br></pre></td></tr></table></figure>
<p>Step13：将消息消费者缓存在ApplicationModel中。</p>
<h4 id="1-2-1-源码分析ReferenceConfig-createProxy方法"><a href="#1-2-1-源码分析ReferenceConfig-createProxy方法" class="headerlink" title="1.2.1 源码分析ReferenceConfig#createProxy方法"></a>1.2.1 源码分析ReferenceConfig#createProxy方法</h4><p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL tmpUrl &#x3D; new URL(&quot;temp&quot;, &quot;localhost&quot;, 0, map);</span><br><span class="line">final boolean isJvmRefer;</span><br><span class="line">if (isInjvm() &#x3D;&#x3D; null) &#123;</span><br><span class="line">    if (url !&#x3D; null &amp;&amp; url.length() &gt; 0) &#123; &#x2F;&#x2F; if a url is specified, don&#39;t do local reference</span><br><span class="line">          isJvmRefer &#x3D; false;</span><br><span class="line">    &#125; else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) &#123;</span><br><span class="line">         &#x2F;&#x2F; by default, reference local service if there is</span><br><span class="line">         isJvmRefer &#x3D; true;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">         isJvmRefer &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    isJvmRefer &#x3D; isInjvm().booleanValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：判断该消费者是否是引用本(JVM)内提供的服务。<br>如果dubbo:reference标签的injvm(已过期，被local属性替换)如果不为空，则直接取该值，如果该值未配置，则判断ReferenceConfig的url属性是否为空，如果不为空，则isJvmRefer =false，表明该服务消费者将直连该URL的服务提供者；如果url属性为空，则判断该协议是否是isInjvm，其实现逻辑：获取dubbo:reference的scop属性，根据其值判断：</p>
<ul>
<li>如果为空，isJvmRefer为false。</li>
<li>如果协议为injvm，就是表示为本地协议，既然提供了本地协议的实现，则无需配置isJvmRefer该标签为true，故，isJvmRerfer=false。</li>
<li> 如果scope=local或injvm=true，isJvmRefer=true。</li>
<li>如果scope=remote，isJvmRefer设置为false。</li>
<li>如果是泛化引用，isJvmRefer设置为false。</li>
<li>其他默认情况，isJvmRefer设置为true。</li>
</ul>
<p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (isJvmRefer) &#123;</span><br><span class="line">   URL url &#x3D; new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);</span><br><span class="line">   invoker &#x3D; refprotocol.refer(interfaceClass, url);</span><br><span class="line">   if (logger.isInfoEnabled()) &#123;</span><br><span class="line">         logger.info(&quot;Using injvm service &quot; + interfaceClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Step2：如果消费者引用本地JVM中的服务，则利用InjvmProtocol创建Invoker，dubbo中的invoker主要负责服务调用的功能，是其核心实现，后续会在专门的章节中详细分析，在这里我们需要知道，会创建于协议相关的Invoker即可。</p>
<p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (url !&#x3D; null &amp;&amp; url.length() &gt; 0) &#123; &#x2F;&#x2F; user specified URL, could be peer-to-peer address, or register center&#39;s address.</span><br><span class="line">     String[] us &#x3D; Constants.SEMICOLON_SPLIT_PATTERN.split(url);   &#x2F;&#x2F; @1</span><br><span class="line">     if (us !&#x3D; null &amp;&amp; us.length &gt; 0) &#123;</span><br><span class="line">           for (String u : us) &#123;</span><br><span class="line">                  URL url &#x3D; URL.valueOf(u);</span><br><span class="line">                  if (url.getPath() &#x3D;&#x3D; null || url.getPath().length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                       url &#x3D; url.setPath(interfaceName);</span><br><span class="line">                  &#125;</span><br><span class="line">                 if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;   &#x2F;&#x2F; @2</span><br><span class="line">                      urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                      urls.add(ClusterUtils.mergeUrl(url, map));  &#x2F;&#x2F; @3</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Step3：处理直连情况，与step2互斥。</p>
<ul>
<li>代码@1：对直连URL进行分割，多个直连URL用分号隔开，如果URL中不包含path属性，则为URL设置path属性为interfaceName。</li>
<li>代码@2：如果直连提供者的协议为registry，则对url增加refer属性，其值为消息消费者所有的属性。(表示从注册中心发现服务提供者)</li>
<li>代码@3：如果是其他协议提供者，则合并服务提供者与消息消费者的属性，并移除服务提供者默认属性。以default开头的属性。</li>
</ul>
<p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;URL&gt; us &#x3D; loadRegistries(false);   &#x2F;&#x2F; @1</span><br><span class="line">if (us !&#x3D; null &amp;&amp; !us.isEmpty()) &#123;</span><br><span class="line">     for (URL u : us) &#123;</span><br><span class="line">           URL monitorUrl &#x3D; loadMonitor(u);   &#x2F;&#x2F; @2</span><br><span class="line">           if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">                 map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));   &#x2F;&#x2F; @3</span><br><span class="line">            &#125;</span><br><span class="line">            urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));  &#x2F;&#x2F; @4</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">if (urls &#x3D;&#x3D; null || urls.isEmpty()) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;No such any registry to reference &quot; + interfaceName + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please config &lt;dubbo:registry </span><br><span class="line">          address&#x3D;\&quot;...\&quot; &#x2F;&gt; to your spring config.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：普通消息消费者，从注册中心订阅服务。</p>
<ul>
<li>代码@1：获取所有注册中心URL，其中参数false表示消费端，需要排除dubbo:registry subscribe=false的注册中心，其值为false表示不接受订阅。</li>
<li>代码@2：根据注册中心URL，构建监控中心URL。</li>
<li>代码@3：如果监控中心不为空，在注册中心URL后增加属性monitor。</li>
<li>代码@4：在注册中心URL中，追加属性refer，其值为消费端的所有配置组成的URL。</li>
</ul>
<p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (urls.size() &#x3D;&#x3D; 1) &#123;</span><br><span class="line">    invoker &#x3D; refprotocol.refer(interfaceClass, urls.get(0));     &#x2F;&#x2F; @1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    List&lt;Invoker&lt;?&gt;&gt; invokers &#x3D; new ArrayList&lt;Invoker&lt;?&gt;&gt;();    &#x2F;&#x2F; @2,多个服务提供者URL，集群模式</span><br><span class="line">    URL registryURL &#x3D; null;</span><br><span class="line">    for (URL url : urls) &#123;</span><br><span class="line">         invokers.add(refprotocol.refer(interfaceClass, url));    &#x2F;&#x2F; @2</span><br><span class="line">         if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;</span><br><span class="line">               registryURL &#x3D; url; &#x2F;&#x2F; use last registry url</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     if (registryURL !&#x3D; null) &#123; &#x2F;&#x2F; registry url is available</span><br><span class="line">          &#x2F;&#x2F; use AvailableCluster only when register&#39;s cluster is available</span><br><span class="line">          URL u &#x3D; registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);</span><br><span class="line">          invoker &#x3D; cluster.join(new StaticDirectory(u, invokers));    &#x2F;&#x2F; @3</span><br><span class="line">     &#125; else &#123; &#x2F;&#x2F; not a registry url</span><br><span class="line">          invoker &#x3D; cluster.join(new StaticDirectory(invokers));</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Step5：根据URL获取对应协议的Invoker。</p>
<ul>
<li>代码@1：如果只有一个服务提供者URL,则直接根据协议构建Invoker，具体有如下协议：<br><img src="https://img-blog.csdn.net/20180608122049691?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></li>
<li>代码@2：如果有多个服务提供者，则众多服务提供者构成一个集群。<br>首先根据协议构建服务Invoker，默认Dubbo基于服务注册于发现，在服务消费端不会指定url属性，从注册中心获取服务提供者列表，此时的URL：registry://开头，url中会包含register属性，其值为注册中心的类型，例如zookeeper，将使用RedisProtocol构建Invoker，该方法将自动发现注册在注册中心的服务提供者，后续文章将会zookeeper注册中心为例，详细分析其实现原理。</li>
<li>代码@3：返回集群模式实现的Invoker，Dubbo中的Invoker类继承体系如下：<br><img src="https://img-blog.csdn.net/20180608122123696?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>集群模式的Invoker和单个协议Invoker一样实现Invoker接口，然后在集群Invoker中利用Directory保证一个一个协议的调用器，十分的巧妙，在后续章节中将重点分析Dubbo Invoker实现原理，包含集群实现机制。</li>
</ul>
<p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Boolean c &#x3D; check;</span><br><span class="line">if (c &#x3D;&#x3D; null &amp;&amp; consumer !&#x3D; null) &#123;</span><br><span class="line">      c &#x3D; consumer.isCheck();</span><br><span class="line">&#125;</span><br><span class="line">if (c &#x3D;&#x3D; null) &#123;</span><br><span class="line">      c &#x3D; true; &#x2F;&#x2F; default true</span><br><span class="line">&#125;</span><br><span class="line">if (c &amp;&amp; !invoker.isAvailable()) &#123;</span><br><span class="line">       throw new IllegalStateException(&quot;Failed to check the status of the service &quot; + interfaceName + &quot;. No provider available for the service &quot; + (group   </span><br><span class="line">              &#x3D;&#x3D; null ? &quot;&quot; : group + &quot;&#x2F;&quot;) + interfaceName + (version &#x3D;&#x3D; null ? &quot;&quot; : &quot;:&quot; + version) + &quot; from the url &quot; + invoker.getUrl() + &quot; to the consumer &quot; + </span><br><span class="line">             NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码@4：如果dubbo:referecnce的check=true或默认为空，则需要判断服务提供者是否存在。</li>
</ul>
<p>ReferenceConfig#createProxy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">return (T) proxyFactory.getProxy(invoker);</span><br><span class="line">AbstractProxyFactory#getProxy</span><br><span class="line">public &lt;T&gt; T getProxy(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces &#x3D; null;</span><br><span class="line">        String config &#x3D; invoker.getUrl().getParameter(&quot;interfaces&quot;);     &#x2F;&#x2F; @1</span><br><span class="line">        if (config !&#x3D; null &amp;&amp; config.length() &gt; 0) &#123;</span><br><span class="line">            String[] types &#x3D; Constants.COMMA_SPLIT_PATTERN.split(config);</span><br><span class="line">            if (types !&#x3D; null &amp;&amp; types.length &gt; 0) &#123;</span><br><span class="line">                interfaces &#x3D; new Class&lt;?&gt;[types.length + 2];</span><br><span class="line">                interfaces[0] &#x3D; invoker.getInterface();</span><br><span class="line">                interfaces[1] &#x3D; EchoService.class;        &#x2F;&#x2F; @2</span><br><span class="line">                for (int i &#x3D; 0; i &lt; types.length; i++) &#123;</span><br><span class="line">                    interfaces[i + 1] &#x3D; ReflectUtils.forName(types[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (interfaces &#x3D;&#x3D; null) &#123;</span><br><span class="line">            interfaces &#x3D; new Class&lt;?&gt;[]&#123;invoker.getInterface(), EchoService.class&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        return getProxy(invoker, interfaces);    &#x2F;&#x2F; @3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>根据invoker获取代理类，其实现逻辑如下：</p>
<ul>
<li>代码@1：从消费者URL中获取interfaces的值，用,分隔出单个服务应用接口。</li>
<li>代码@2：增加默认接口EchoService接口。</li>
<li>代码@3:根据需要实现的接口，使用jdk或Javassist创建代理类。<br>最后给出消息消费者启动时序图：<br><img src="https://img-blog.csdn.net/20180608122248962?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>本节关于Dubbo服务消费者（服务调用者）的启动流程就梳理到这里，下一篇将重点关注Invoker（服务调用相关的实现细节）。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>启动</tag>
        <tag>服务消费者</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo服务注册与发现机制RegistryDirectory)</title>
    <url>/posts/7c2dea71.html</url>
    <content><![CDATA[<div id="vip-container"><p>RegistryDirectory，基于注册中心的服务发现，本文将重点探讨Dubbo是如何实现服务的自动注册与发现。从上篇文章，得知在消息消费者在创建服务调用器(Invoker)【消费者在初始时】时需要根据不同的协议，例如dubbo、registry(从注册中心获取服务提供者)来构建，其调用的方法为Protocol#refer，基于注册中心发现服务提供者的实现协议为RegistryProtocol。</p>
<p>RegistryProtocol#refer —-&gt; doRefer方法。</p>
<p>RegistryProtocol#doRefer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; Invoker&lt;T&gt; doRefer(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url) &#123;    &#x2F;&#x2F; @1</span><br><span class="line">        RegistryDirectory&lt;T&gt; directory &#x3D; new RegistryDirectory&lt;T&gt;(type, url);   &#x2F;&#x2F; @2</span><br><span class="line">        directory.setRegistry(registry);</span><br><span class="line">        directory.setProtocol(protocol);   &#x2F;&#x2F; @3</span><br><span class="line">        &#x2F;&#x2F; all attributes of REFER_KEY</span><br><span class="line">        Map&lt;String, String&gt; parameters &#x3D; new HashMap&lt;String, String&gt;(directory.getUrl().getParameters());   &#x2F;&#x2F; @4</span><br><span class="line">        URL subscribeUrl &#x3D; new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);  &#x2F;&#x2F; @5</span><br><span class="line">        if (!Constants.ANY_VALUE.equals(url.getServiceInterface())</span><br><span class="line">                &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123;</span><br><span class="line">            registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,</span><br><span class="line">                    Constants.CHECK_KEY, String.valueOf(false)));</span><br><span class="line">        &#125;   &#x2F;&#x2F; @6</span><br><span class="line">        directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,</span><br><span class="line">                Constants.PROVIDERS_CATEGORY</span><br><span class="line">                        + &quot;,&quot; + Constants.CONFIGURATORS_CATEGORY</span><br><span class="line">                        + &quot;,&quot; + Constants.ROUTERS_CATEGORY));     &#x2F;&#x2F; @7</span><br><span class="line"></span><br><span class="line">        Invoker invoker &#x3D; cluster.join(directory);    &#x2F;&#x2F; @8</span><br><span class="line">        ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);     &#x2F;&#x2F; @9</span><br><span class="line">        return invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数详解</p>
<ul>
<li>Cluster cluster：集群策略。</li>
<li> Registry registry：注册中心实现类。</li>
<li>Class<T> type：引用服务名，dubbo:reference interface。</li>
<li>URL url：注册中心URL。</li>
</ul>
<p>代码@2：构建RegistryDirectory对象，基于注册中心动态发现服务提供者（服务提供者新增或减少），本节重点会剖析该类的实现细节。</p>
<p>代码@3：为RegistryDirectory设置注册中心、协议。</p>
<p>代码@4：获取服务消费者的配置属性。</p>
<p>代码@5：构建消费者URL，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure>
<p>代码@6：向注册中心消息消费者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;consumers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure>
<p>相比第5步的URL，增加了category=consumers、check=false，其中category表示在注册中心的命名空间，这里代表消费端。该步骤的作用就是向注册中心为服务增加一个消息消费者，其生成的效果如下：【以zookeeper为例】。<br><img src="https://img-blog.csdn.net/20180618220050346?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>代码@7：为消息消费者添加category=providers,configurators,routers属性后，然后向注册中心订阅该URL，关注该服务下的providers,configurators,routers发生变化时通知RegistryDirectory，以便及时发现服务提供者、配置、路由规则的变化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;providers,configurators,routers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure>
<p>其订阅关系调用的入口为：RegistryDirectory#subscribe方法，是接下来需要重点分析的重点。</p>
<p>代码@8：根据Directory，利用集群策略返回集群Invoker。</p>
<p>代码@9：缓存服务消费者、服务提供者对应关系。</p>
<p>从这里发现，服务的注册与发现与RegistryDirectory联系非常紧密，接下来让我们来详细分析RegistryDirectory的实现细节。</p>
<h2 id="1、RegistryDirectory类图"><a href="#1、RegistryDirectory类图" class="headerlink" title="1、RegistryDirectory类图"></a>1、RegistryDirectory类图</h2><p><img src="https://img-blog.csdn.net/20180618223543475?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ul>
<li>private static final Cluster cluster = ExtensionLoader.getExtensionLoader(Cluster.class).getAdaptiveExtension();<pre><code>集群策略，默认为failover。</code></pre>
</li>
<li>private static final RouterFactory routerFactory = ExtensionLoader.getExtensionLoader (RouterFactory.class).getAdaptiveExtension()路由工厂，可以通过监控中心或治理中心配置。</li>
<li>private static final ConfiguratorFactory configuratorFactory = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class).getAdaptiveExtension();配置实现工厂类。</li>
<li>private final String serviceKey;  服务key，默认为服务接口名。com.alibaba.dubbo.registry.RegistryService，注册中心在Dubbo中也是使用服务暴露。</li>
<li>private final Class&lt; T &gt; serviceType;服务提供者接口类，例如interface com.alibaba.dubbo.demo.DemoService</li>
<li>private final Map&lt; String, String&gt; queryMap：服务消费者URL中的所有属性。</li>
<li>private final URL directoryUrl;注册中心URL，只保留消息消费者URL查询属性，也就是queryMap。</li>
<li>private final String[] serviceMethods：引用服务提供者方法数组。</li>
<li>private final boolean multiGroup：是否引用多个服务组。</li>
<li>private Protocol protocol：协议。</li>
<li>private Registry registry：注册中心实现者。</li>
<li>private volatile List&lt; Configurator&gt; configurators;配置信息。</li>
<li>private volatile Map&lt; String, Invoker&lt; T&gt;&gt; urlInvokerMap; 服务URL对应的Invoker(服务提供者调用器)。</li>
<li>private volatile Map&lt; String, List&lt; Invoker&lt; T&gt;&gt;&gt; methodInvokerMap; methodName : List&lt; Invoker&lt; T &gt;&gt;，<pre><code>   dubbo:method 对应的Invoker缓存表。</code></pre>
</li>
<li>private volatile Set&lt; URL &gt; cachedInvokerUrls; 当前缓存的所有URL提供者URL。</li>
</ul>
<a id="more"></a>

<h2 id="2、RegistryDirectory-构造方法详解"><a href="#2、RegistryDirectory-构造方法详解" class="headerlink" title="2、RegistryDirectory 构造方法详解"></a>2、RegistryDirectory 构造方法详解</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public RegistryDirectory(Class&lt;T&gt; serviceType, URL url) &#123;    &#x2F;&#x2F; @1</span><br><span class="line">        super(url);</span><br><span class="line">        if (serviceType &#x3D;&#x3D; null)</span><br><span class="line">            throw new IllegalArgumentException(&quot;service type is null.&quot;);</span><br><span class="line">        if (url.getServiceKey() &#x3D;&#x3D; null || url.getServiceKey().length() &#x3D;&#x3D; 0)</span><br><span class="line">            throw new IllegalArgumentException(&quot;registry serviceKey is null.&quot;);</span><br><span class="line">        this.serviceType &#x3D; serviceType;  </span><br><span class="line">        this.serviceKey &#x3D; url.getServiceKey();     &#x2F;&#x2F; @2</span><br><span class="line">        this.queryMap &#x3D; StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));  &#x2F;&#x2F; @3</span><br><span class="line">        this.overrideDirectoryUrl &#x3D; this.directoryUrl &#x3D; url.setPath(url.getServiceInterface()).clearParameters().addParameters(queryMap).removeParameter(Constants.MONITOR_KEY); &#x2F;&#x2F;@4</span><br><span class="line">        String group &#x3D; directoryUrl.getParameter(Constants.GROUP_KEY, &quot;&quot;);</span><br><span class="line">        this.multiGroup &#x3D; group !&#x3D; null &amp;&amp; (&quot;*&quot;.equals(group) || group.contains(&quot;,&quot;));</span><br><span class="line">        String methods &#x3D; queryMap.get(Constants.METHODS_KEY);</span><br><span class="line">        this.serviceMethods &#x3D; methods &#x3D;&#x3D; null ? null : Constants.COMMA_SPLIT_PATTERN.split(methods);   &#x2F;&#x2F; @5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数描述，serviceType：消费者引用的服务&lt; dubbo:reference interface=”” …/&gt;;URL url：注册中心的URL，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zookeeper:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-consumer&amp;dubbo&#x3D;2.0.0&amp;pid&#x3D;5552&amp;qos.port&#x3D;33333&amp;refer&#x3D;application%3Ddemo-consumer%26check%3Dfalse%26dubbo%3D2.0.0%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D5552%26qos.port%3D33333%26register.ip%3D192.168.56.1%26side%3Dconsumer%26timestamp%3D1528379076123&amp;timestamp&#x3D;1528379076179</span><br></pre></td></tr></table></figure>
<p>代码@2：获取注册中心URL的serviceKey：com.alibaba.dubbo.registry.RegistryService。</p>
<p>代码@3：获取注册中心URL消费提供者的所有配置参数:从url属性的refer。</p>
<p>代码@4：初始化haulovverrideDirecotryUrl、directoryUrl：注册中心的URL，移除监控中心以及其他属性值，只保留消息消费者的配置属性。</p>
<p>代码@5：获取服务消费者单独配置的方法名dubbo:method。</p>
<h2 id="3、RegistryDirectory-subscribe"><a href="#3、RegistryDirectory-subscribe" class="headerlink" title="3、RegistryDirectory#subscribe"></a>3、RegistryDirectory#subscribe</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void subscribe(URL url) &#123;</span><br><span class="line">     setConsumerUrl(url);   &#x2F;&#x2F; @1</span><br><span class="line">     registry.subscribe(url, this); &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：设置RegistryDirectory的consumerUrl为消费者URL。<br>代码@2：调用注册中心订阅消息消息消费者URL，首先看一下接口Registry#subscribe的接口声明：<br>RegistryService:void subscribe(URL url, NotifyListener listener); 这里传入的NotifyListener为RegistryDirectory，其注册中心的subscribe方法暂时不深入去跟踪，不过根据上面URL上面的特点，应该能猜出如下实现关键点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer:&#x2F;&#x2F;192.168.56.1&#x2F;com.alibaba.dubbo.demo.DemoService?application&#x3D;demo-consumer&amp;category&#x3D;providers,configurators,routers&amp;check&#x3D;false&amp;dubbo&#x3D;2.0.0&amp;interface&#x3D;com.alibaba.dubbo.demo.DemoService&amp;methods&#x3D;sayHello&amp;pid&#x3D;9892&amp;qos.port&#x3D;33333&amp;side&#x3D;consumer&amp;timestamp&#x3D;1528380277185</span><br></pre></td></tr></table></figure>
<ul>
<li>根据消息消费者URL，获取服务名。</li>
<li>根据category=providers、configurators、routers，分别在该服务名下的providers目录、configurators目录、routers目录建立事件监听，监听该目录下节点的创建、更新、删除事件，然后一旦事件触发，将回调RegistryDirectory#void notify(List&lt; URL&gt; urls)。</li>
</ul>
<h2 id="4、RegistryDirectory-notify"><a href="#4、RegistryDirectory-notify" class="headerlink" title="4、RegistryDirectory#notify"></a>4、RegistryDirectory#notify</h2><p>首先该方法是在注册中心providers、configurators、routers目录下的节点发生变化后，通知RegistryDirectory，已便更新最新信息，实现”动态“发现机制。</p>
<p>RegistryDirectory#notify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;URL&gt; invokerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">List&lt;URL&gt; routerUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">List&lt;URL&gt; configuratorUrls &#x3D; new ArrayList&lt;URL&gt;();</span><br><span class="line">for (URL url : urls) &#123;</span><br><span class="line">     String protocol &#x3D; url.getProtocol();    &#x2F;&#x2F; @1 </span><br><span class="line">     String category &#x3D; url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);   &#x2F;&#x2F; @2</span><br><span class="line">     if (Constants.ROUTERS_CATEGORY.equals(category) || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">           routerUrls.add(url);</span><br><span class="line">      &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category) || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;   &#x2F;&#x2F; @4</span><br><span class="line">           configuratorUrls.add(url);</span><br><span class="line">     &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;    &#x2F;&#x2F; @5</span><br><span class="line">           invokerUrls.add(url);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">          logger.warn(&quot;Unsupported category &quot; + category + &quot; in notified url: &quot; + url + &quot; from registry &quot; + getUrl().getAddress() + &quot; to consumer &quot; + </span><br><span class="line">                NetUtils.getLocalHost());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：根据通知的URL的前缀，分别添加到：invokerUrls(提供者url)、routerUrls（路由信息）、configuratorUrls （配置url）。</p>
<ul>
<li>代码@1：从url中获取协议字段，例如condition://、route://、script://、override://等。</li>
<li>代码@2：获取url的category,在注册中心的命令空间，例如:providers、configurators、routers。</li>
<li>代码@3：如果category等于routers或协议等于route，则添加到routerUrls中。</li>
<li>代码@4：如果category等于configurators或协议等于override，则添加到configuratorUrls中。</li>
<li>代码@5：如果category等于providers，则表示服务提供者url，加入到invokerUrls中。</li>
</ul>
<p>RegistryDirectory#notify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; configurators</span><br><span class="line">if (configuratorUrls !&#x3D; null &amp;&amp; !configuratorUrls.isEmpty()) &#123;</span><br><span class="line">    this.configurators &#x3D; toConfigurators(configuratorUrls);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：将configuratorUrls转换为配置对象List&lt; Configurator&gt; configurators，该方法将在《源码分析Dubbo配置规则实现细节》一文中详细讲解。</p>
<p>RegistryDirectory#notify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; routers</span><br><span class="line">if (routerUrls !&#x3D; null &amp;&amp; !routerUrls.isEmpty()) &#123;</span><br><span class="line">      List&lt;Router&gt; routers &#x3D; toRouters(routerUrls);</span><br><span class="line">      if (routers !&#x3D; null) &#123; &#x2F;&#x2F; null - do nothing</span><br><span class="line">            setRouters(routers);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：将routerUrls路由URL转换为Router对象，该部分内容将在《源码分析Dubbo路由机制实现细节》一文中详细分析。</p>
<p>RegistryDirectory#notify</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; providers</span><br><span class="line">refreshInvoker(invokerUrls);</span><br></pre></td></tr></table></figure>
<p>Step4：根据回调通知刷新服务提供者集合。</p>
<h2 id="5、RegistryDirectory-refreshInvoker"><a href="#5、RegistryDirectory-refreshInvoker" class="headerlink" title="5、RegistryDirectory#refreshInvoker"></a>5、RegistryDirectory#refreshInvoker</h2><p>RegistryDirectory#refreshInvoker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (invokerUrls !&#x3D; null &amp;&amp; invokerUrls.size() &#x3D;&#x3D; 1 &amp;&amp; invokerUrls.get(0) !&#x3D; null</span><br><span class="line">         &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;</span><br><span class="line">     this.forbidden &#x3D; true; &#x2F;&#x2F; Forbid to access</span><br><span class="line">     this.methodInvokerMap &#x3D; null; &#x2F;&#x2F; Set the method invoker map to null</span><br><span class="line">     destroyAllInvokers(); &#x2F;&#x2F; Close all invokers</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Step1：如果invokerUrls不为空并且长度为1，并且协议为empty,表示该服务的所有服务提供者都下线了。需要销毁当前所有的服务提供者Invoker。</p>
<p>RegistryDirectory#refreshInvoker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.forbidden &#x3D; false; &#x2F;&#x2F; Allow to access</span><br><span class="line">Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls !&#x3D; null) &#123;</span><br><span class="line">        invokerUrls.addAll(this.cachedInvokerUrls);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      this.cachedInvokerUrls &#x3D; new HashSet&lt;URL&gt;();</span><br><span class="line">      this.cachedInvokerUrls.addAll(invokerUrls);&#x2F;&#x2F;Cached invoker urls, convenient for comparison</span><br><span class="line">&#125;</span><br><span class="line">if (invokerUrls.isEmpty()) &#123;</span><br><span class="line">      return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2： 如果invokerUrls为空，并且已缓存的invokerUrls不为空，将缓存中的invoker url复制到invokerUrls中，这里可以说明如果providers目录未发送变化，invokerUrls则为空，表示使用上次缓存的服务提供者URL对应的invoker；如果invokerUrls不为空，则用iinvokerUrls中的值替换原缓存的invokerUrls，这里说明，如果providers发生变化，invokerUrls中会包含此时注册中心所有的服务提供者。如果invokerUrls为空，则无需处理，结束本次更新服务提供者Invoker操作。</p>
<p>RegistryDirectory#refreshInvoker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap &#x3D; toInvokers(invokerUrls);&#x2F;&#x2F; Translate url list to Invoker map</span><br><span class="line">Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; newMethodInvokerMap &#x3D; toMethodInvokers(newUrlInvokerMap); &#x2F;&#x2F; Change method name to map Invoker Map</span><br></pre></td></tr></table></figure>
<p>Step3：将invokerUrls转换为对应的Invoke，然后根据服务级的url:invoker映射关系创建method:List&lt; Invoker&gt;映射关系，将在下文相信分析。</p>
<p>RegistryDirectory#refreshInvoker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.methodInvokerMap &#x3D; multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;</span><br><span class="line">this.urlInvokerMap &#x3D; newUrlInvokerMap;</span><br><span class="line">try &#123;</span><br><span class="line">        destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); &#x2F;&#x2F; Close the unused Invoker</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">        logger.warn(&quot;destroyUnusedInvokers error. &quot;, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：如果支持multiGroup机制，则合并methodInvoker，将在下文分析，然后根据toInvokers、toMethodInvokers刷新当前最新的服务提供者信息。</p>
<h2 id="6、RegistryDirectory-toInvokers"><a href="#6、RegistryDirectory-toInvokers" class="headerlink" title="6、RegistryDirectory#toInvokers"></a>6、RegistryDirectory#toInvokers</h2><p>RegistryDirectory#toInvokers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String queryProtocols &#x3D; this.queryMap.get(Constants.PROTOCOL_KEY);</span><br><span class="line">for (URL providerUrl : urls) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：获取消息消费者URL中的协议类型，&lt; dubbo:reference protocol=”” …/&gt;属性值，然后遍历所有的Invoker Url(服务提供者URL)。</p>
<p>RegistryDirectory#toInvokers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (queryProtocols !&#x3D; null &amp;&amp; queryProtocols.length() &gt; 0) &#123;</span><br><span class="line">       boolean accept &#x3D; false;</span><br><span class="line">       String[] acceptProtocols &#x3D; queryProtocols.split(&quot;,&quot;);</span><br><span class="line">       for (String acceptProtocol : acceptProtocols) &#123;</span><br><span class="line">            if (providerUrl.getProtocol().equals(acceptProtocol)) &#123;</span><br><span class="line">                  accept &#x3D; true;</span><br><span class="line">                  break;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      if (!accept) &#123;</span><br><span class="line">            continue;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2： 从这一步开始，代码都包裹在for(URL providerUrl : urls)中，一个一个处理提供者URL。如果dubbo:referecnce标签的protocol不为空，则需要对服务提供者URL进行过滤，匹配其协议与protocol属性相同的服务，如果不匹配，则跳过后续处理逻辑，接着处理下一个服务提供者URL。</p>
<p>RegistryDirectory#toInvokers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;</span><br><span class="line">      continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：如果协议为empty，跳过，处理下一个服务提供者URL。</p>
<p>RegistryDirectory#toInvokers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;</span><br><span class="line">       logger.error(new IllegalStateException(&quot;Unsupported protocol &quot; + providerUrl.getProtocol() + &quot; in notified url: &quot; + providerUrl + &quot; from registry &quot; + getUrl().getAddress() + &quot; to </span><br><span class="line">                 consumer &quot; + NetUtils.getLocalHost()</span><br><span class="line">                        + &quot;, supported protocol: &quot; + ExtensionLoader.getExtensionLoader(Protocol.class).getSupportedExtensions()));</span><br><span class="line">   continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：验证服务提供者协议，如果不支持，则跳过。</p>
<p>RegistryDirectory#toInvokers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL url &#x3D; mergeUrl(providerUrl);</span><br></pre></td></tr></table></figure>
<p>Step5：合并URL中的属性，其具体实现细节如下：</p>
<ol>
<li>消费端属性覆盖生产者端属性（配置属性消费者端优先生产者端属性），其具体实现方法：ClusterUtils.mergeUrl(providerUrl, queryMap)，其中queryMap为消费端属性。<br>  a、首先移除只在服务提供者端生效的属性（线程池相关）：threadname、default.threadname、threadpool、default.threadpool、corethreads、default.corethreads、threads、default.threads、queues、default.queues、alive、default.alive、transporter、default.transporter，服务提供者URL中的这些属性来源于dubbo:protocol、dubbo:provider。<br> b、用消费端配置属性覆盖服务端属性。<br> c、如下属性以服务端优先：dubbo(dubbo信息)、version（版本）、group（服务组）、methods（服务方法）、timestamp（时间戳）。<br> d、合并服务端，消费端Filter,其配置属性（reference.filter），返回结果为：provider#reference.filter,<br> consumer#reference.filter。<br> e、合并服务端，消费端Listener，其配置属性(invoker.listener)，返回结果为：provider#invoker.listener，consumer#invoker.listener。</li>
<li>合并configuratorUrls 中的属性，我们现在应该知道，dubbo可以在监控中心或管理端(dubbo-admin)覆盖覆盖服务提供者的属性，其使用协议为override，该部分的实现逻辑见：《源码分析Dubbo配置规则机制（override协议）》</li>
<li>为服务提供者URL增加check=false，默认只有在服务调用时才检查服务提供者是否可用。</li>
<li>重新复制overrideDirectoryUrl，providerUrl在进过第一步参数合并后（包含override协议覆盖后的属性）赋值给overrideDirectoryUrl。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String key &#x3D; url.toFullString(); &#x2F;&#x2F; The parameter urls are sorted</span><br><span class="line">if (keys.contains(key)) &#123; &#x2F;&#x2F; Repeated url</span><br><span class="line">      continue;</span><br><span class="line">&#125;</span><br><span class="line">keys.add(key);</span><br></pre></td></tr></table></figure>
Step6：获取url所有属性构成的key,该key也是RegistryDirectory中Map&lt;String, Invoker<T>&gt; urlInvokerMap;中的key。</li>
</ol>
<p>RegistryDirectory#toInvokers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap &#x3D; this.urlInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">Invoker&lt;T&gt; invoker &#x3D; localUrlInvokerMap &#x3D;&#x3D; null ? null : localUrlInvokerMap.get(key);</span><br><span class="line">if (invoker &#x3D;&#x3D; null) &#123; &#x2F;&#x2F; Not in the cache, refer again</span><br><span class="line">   try &#123;</span><br><span class="line">         boolean enabled &#x3D; true;</span><br><span class="line">         if (url.hasParameter(Constants.DISABLED_KEY)) &#123;</span><br><span class="line">               enabled &#x3D; !url.getParameter(Constants.DISABLED_KEY, false);</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">               enabled &#x3D; url.getParameter(Constants.ENABLED_KEY, true);</span><br><span class="line">           &#125;</span><br><span class="line">           if (enabled) &#123;</span><br><span class="line">                invoker &#x3D; new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">           &#125;</span><br><span class="line">     &#125; catch (Throwable t) &#123;</span><br><span class="line">               logger.error(&quot;Failed to refer invoker for interface:&quot; + serviceType + &quot;,url:(&quot; + url + &quot;)&quot; + t.getMessage(), t);</span><br><span class="line">      &#125;</span><br><span class="line">      if (invoker !&#x3D; null) &#123; &#x2F;&#x2F; Put new invoker in cache</span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">      &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">       newUrlInvokerMap.put(key, invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step7：如果localUrlInvokerMap中未包含invoker并且该provider状态为启用，则创建该URL对应的Invoker，并添加到newUrlInvokerMap中。toInvokers运行结束后，回到refreshInvoker方法中继续往下执行，根据 最新的服务提供者映射关系Map&lt; String,Invoker&gt;，构建Map&lt; String,List&lt; Invoker&gt;&gt;,其中键为methodName。然后更新RegistryDirectory的urlInvokerMap、methodInvokerMap属性，并销毁老的Invoker对象，完成一次路由发现过程。</p>
<p>上面整个过程完成了一次动态服务提供者发现流程，下面再分析一下RegistryDirectory的另外一个重要方法，doList，再重复一遍RegistryDirectory的作用，服务提供者目录服务，在集群Invoker的实现中，内部持有一个Direcotry对象，在进行服务调用之前，首先先从众多的Invoker中选择一个来执行，那众多的Invoker从哪来呢？其来源于集群Invoker中会调用Direcotry的public List&lt; Invoker&lt; T&gt;&gt; list(Invocation invocation)，首先将调用AbstractDirectory#list方法，然后再内部调用doList方法，doList方法有其子类实现。</p>
<h2 id="7、RegistryDirectory-doList-Invocation-invocation-方法详解"><a href="#7、RegistryDirectory-doList-Invocation-invocation-方法详解" class="headerlink" title="7、RegistryDirectory#doList(Invocation invocation) 方法详解"></a>7、RegistryDirectory#doList(Invocation invocation) 方法详解</h2><p>RegistryDirectory#doList</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (forbidden) &#123;</span><br><span class="line">      &#x2F;&#x2F; 1. No service provider 2. Service providers are disabled</span><br><span class="line">      throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,</span><br><span class="line">            &quot;No provider available from registry &quot; + getUrl().getAddress() + &quot; for service &quot; + getConsumerUrl().getServiceKey() + &quot; on consumer &quot; +  NetUtils.getLocalHost()</span><br><span class="line">                  + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, please check status of providers(disabled, not registered or in blacklist).&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果禁止访问（如果没有服务提供者，或服务提供者被禁用），则抛出没有提供者异常。</p>
<p>RegistryDirectory#doList</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;String, List&lt;Invoker&lt;T&gt;&gt;&gt; localMethodInvokerMap &#x3D; this.methodInvokerMap; &#x2F;&#x2F; local reference</span><br><span class="line">if (localMethodInvokerMap !&#x3D; null &amp;&amp; localMethodInvokerMap.size() &gt; 0) &#123;</span><br><span class="line">    String methodName &#x3D; RpcUtils.getMethodName(invocation);</span><br><span class="line">    Object[] args &#x3D; RpcUtils.getArguments(invocation);</span><br><span class="line">    if (args !&#x3D; null &amp;&amp; args.length &gt; 0 &amp;&amp; args[0] !&#x3D; null</span><br><span class="line">             &amp;&amp; (args[0] instanceof String || args[0].getClass().isEnum())) &#123;</span><br><span class="line">          invokers &#x3D; localMethodInvokerMap.get(methodName + &quot;.&quot; + args[0]); &#x2F;&#x2F; The routing can be enumerated according to the first parameter</span><br><span class="line">     &#125;</span><br><span class="line">    if (invokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">          invokers &#x3D; localMethodInvokerMap.get(methodName);</span><br><span class="line">    &#125;</span><br><span class="line">    if (invokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">          invokers &#x3D; localMethodInvokerMap.get(Constants.ANY_VALUE);</span><br><span class="line">     &#125;</span><br><span class="line">     if (invokers &#x3D;&#x3D; null) &#123;</span><br><span class="line">         Iterator&lt;List&lt;Invoker&lt;T&gt;&gt;&gt; iterator &#x3D; localMethodInvokerMap.values().iterator();</span><br><span class="line">         if (iterator.hasNext()) &#123;</span><br><span class="line">              invokers &#x3D; iterator.next();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">return invokers &#x3D;&#x3D; null ? new ArrayList&lt;Invoker&lt;T&gt;&gt;(0) : invokers;</span><br></pre></td></tr></table></figure>
<p>Step2：根据方法名称，从Map&lt; String,List&lt; Invoker&gt;&gt;这个集合中找到合适的List&lt; Invoker&gt;，如果方法名未命中，则返回所有的Invoker，localMethodInvokerMap中方法名，主要是dubbo:service的子标签dubbo:method，最终返回invokers。</p>
<p>本文详细介绍了服务消费者基于注册中心的服务发现机制，其中对routers(路由)与configurators(override协议)并未详细展开，下节先重点分析configurators与routers(路由)实现细节。</p>
<p>总结一下服务注册与发现机制：<br>基于注册 中心的事件通知（订阅与发布），一切支持事件订阅与发布的框架都可以作为Dubbo注册中心的选型。</p>
<ol>
<li><p>服务提供者在暴露服务时，会向注册中心注册自己，具体就是在${service interface}/providers目录下添加 一个节点（临时），服务提供者需要与注册中心保持长连接，一旦连接断掉（重试连接）会话信息失效后，注册中心会认为该服务提供者不可用（提供者节点会被删除）。</p>
</li>
<li><p>消费者在启动时，首先也会向注册中心注册自己，具体在${interface interface}/consumers目录下创建一个节点。</p>
</li>
<li><p>消费者订阅${service interface}/ [  providers、configurators、routers ]三个目录，这些目录下的节点删除、新增事件都胡通知消费者，根据通知，重构服务调用器(Invoker)。</p>
</li>
</ol>
<p>以上就是Dubbo服务注册与动态发现机制的原理与实现细节。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>服务发现</tag>
        <tag>RegistryDirectory</tag>
        <tag>服务注册</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo服务调用-服务提供者如何处理请求命令与再谈Invoker</title>
    <url>/posts/fd487dee.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将重点剖析服务调用流程，也就是消费端通过网络发起RPC服务调用时，服务提供者是如何进行服务请求响应的。</p>
<h2 id="1、源码分析Dubbo服务调用流程"><a href="#1、源码分析Dubbo服务调用流程" class="headerlink" title="1、源码分析Dubbo服务调用流程"></a>1、源码分析Dubbo服务调用流程</h2><p>了解过Netty网络编程的童鞋们应该知道，netty的命令处理基于ChannelHandler（事件处理链），编码、网络传输、解码、处理等，下面是关于NettyServer的初始化过程，该部分在<a href="https://blog.csdn.net/prestigeding/article/details/81165691">《源码分析Dubbo网络通信篇NettyServer、HeaderExchangeServer》</a>时已经讲过，本节先做一个简单的回顾：<br><img src="https://img-blog.csdn.net/20180821120924239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<a id="more"></a>

<p>根据服务暴露的协议，本文以dubbo协议为例：首先通过DubboProtocol通过export暴露服务时，会尝试创建关于该协议的Server服务器,服务器按ip:port进行缓存，本文重点关注ChannelHandler的包装链条，首先看一下NettyServer创建时关于Handler的绑定，代码如下：<br>NettyServer#doOpen</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">final NettyHandler nettyHandler &#x3D; new NettyHandler(getUrl(), this);</span><br><span class="line">channels &#x3D; nettyHandler.getChannels();</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-365</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;issues.jboss.org&#x2F;browse&#x2F;NETTY-379</span><br><span class="line">&#x2F;&#x2F; final Timer timer &#x3D; new HashedWheelTimer(new NamedThreadFactory(&quot;NettyIdleTimer&quot;, true));</span><br><span class="line">bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ChannelPipeline getPipeline() &#123;</span><br><span class="line">         NettyCodecAdapter adapter &#x3D; new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);</span><br><span class="line">         ChannelPipeline pipeline &#x3D; Channels.pipeline();</span><br><span class="line">         pipeline.addLast(&quot;decoder&quot;, adapter.getDecoder());    &#x2F;&#x2F; @start</span><br><span class="line">         pipeline.addLast(&quot;encoder&quot;, adapter.getEncoder());    </span><br><span class="line">         pipeline.addLast(&quot;handler&quot;, nettyHandler);                  &#x2F;&#x2F; @end</span><br><span class="line">         return pipeline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看出，传入Netty框架的事件处理Handler主要是3个：1、解码器；2、编码器；3、业务类NettyHandler。也就是说当服务端(Server)的读事件就绪后，进行网络读写后，会将二进制流传入解码器(Decoder)，解码出一个一个的RPC请求，然后针对每一个RPC请求，交给NettyHandler相关事件处理方法去处理，在这里传入NettyHandler的ChannelHandler为NettyServer,以网络读命令为例，最终将调用NettyServer的父类AbstractPeer的received方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public void received(Channel ch, Object msg) throws RemotingException &#123;</span><br><span class="line">     if (closed) &#123;</span><br><span class="line">         return;</span><br><span class="line">     &#125;</span><br><span class="line">     handler.received(ch, msg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>那AbstractPeer中的ChannelHandler又是“何许人也”，是通过调用NettyServer(URL url, ChannelHandler handler)中传入的，结合上图中NettyServer的构建流程，可以追溯其流程如下：</p>
<ol>
<li>DubboProtocol#createServer<br>server = Exchangers.bind(url, requestHandler);       // @1, requestHandler，为最原始的ChannelHandler，接下来整个过程都是对该handler的包装。</li>
<li>HeaderExchanger#bind<br>return new HeaderExchangeServer(Transporters.bind(url, new<br>DecodeHandler(new HeaderExchangeHandler(handler))));其包装顺序为 DecodeHandler 》HeaderExchangeHandler 》(DubboProtocol#requestHandler)</li>
<li>NettyTransporter#bind</li>
<li>NettyServer构造函数<br>super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));这里主要包装的是事件的派发Handler，例如AllChannelHandler、ExecutionChannelHandler【Dispatch】业务Handler最终的包装顺序为：事件派发模型handler[AllChannelHandler] 》DecodeHandler 》HeaderExchangeHandler 》 DubboProtocol#requestHandler(最终的业务Handler)。结合网络Netty的处理Handler，服务端事件Handler的处理为：DubboCodec2(解码器) 》 事件派发模型handler[AllChannelHandler] 》DecodeHandler 》 HeaderExchangeHandler》 DubboProtocol#requestHandler(最终的业务Handler)。<br>上述Handler都在前面的章节中详细介绍了，接下来重点分析服务调用流程，自然需要从DubboProtocol$requestHandler入手。<br>DubboProtocol$requestHandler#recive<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">     if (message instanceof Invocation) &#123;</span><br><span class="line">          reply((ExchangeChannel) channel, message);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">          super.received(channel, message);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
如果是服务调用，就进入到reply方法中，否则调用父类进行请求响应。<br>DubboProtocol$requestHandler#reply<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;</span><br><span class="line">     if (message instanceof Invocation) &#123;</span><br><span class="line">          Invocation inv &#x3D; (Invocation) message;                                                &#x2F;&#x2F; @1</span><br><span class="line">          Invoker&lt;?&gt; invoker &#x3D; getInvoker(channel, inv);                                   &#x2F;&#x2F; @2</span><br><span class="line">          &#x2F;&#x2F; need to consider backward-compatibility if it&#39;s a callback</span><br><span class="line">          if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;</span><br><span class="line">                String methodsStr &#x3D; invoker.getUrl().getParameters().get(&quot;methods&quot;);</span><br><span class="line">                boolean hasMethod &#x3D; false;</span><br><span class="line">                if (methodsStr &#x3D;&#x3D; null || methodsStr.indexOf(&quot;,&quot;) &#x3D;&#x3D; -1) &#123;</span><br><span class="line">                      hasMethod &#x3D; inv.getMethodName().equals(methodsStr);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                     String[] methods &#x3D; methodsStr.split(&quot;,&quot;);</span><br><span class="line">                     for (String method : methods) &#123;</span><br><span class="line">                          if (inv.getMethodName().equals(method)) &#123;</span><br><span class="line">                             hasMethod &#x3D; true;</span><br><span class="line">                             break;</span><br><span class="line">                           &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               if (!hasMethod) &#123;</span><br><span class="line">                   logger.warn(new IllegalStateException(&quot;The methodName &quot; + inv.getMethodName()</span><br><span class="line">                                + &quot; not found in callback service interface ,invoke will be ignored.&quot;</span><br><span class="line">                                + &quot; please update the api interface. url is:&quot;</span><br><span class="line">                                + invoker.getUrl()) + &quot; ,invocation is :&quot; + inv);</span><br><span class="line">                   return null;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">         RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());</span><br><span class="line">         return invoker.invoke(inv);                    &#x2F;&#x2F; @3</span><br><span class="line">   &#125;</span><br><span class="line">  throw new RemotingException(channel, &quot;Unsupported request: &quot;</span><br><span class="line">                    + (message &#x3D;&#x3D; null ? null : (message.getClass().getName() + &quot;: &quot; + message))</span><br><span class="line">                    + &quot;, channel: consumer: &quot; + channel.getRemoteAddress() + &quot; --&gt; provider: &quot; + channel.getLocalAddress());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
代码@1：获取服务调用信息，例如调用服务类名(interface)、服务方法名、参数类型，参数值。<br>代码@2：获取调用者Invoker。<br>代码@3：调用Invoker，执行具体的方法调用。<br>上述过程非常简单，但其关键点在于Invoker，那这个Invoker到底是什么呢？<br>回顾一下我们在讲解：<a href="https://blog.csdn.net/prestigeding/article/details/80536385">Dubbo服务提供者启动流程</a>中已提到Invoker，在本篇中我们再次对该文进行补充说明。</li>
</ol>
<h2 id="2、再谈Dubbo服务提供者暴露服务（Invoker）"><a href="#2、再谈Dubbo服务提供者暴露服务（Invoker）" class="headerlink" title="2、再谈Dubbo服务提供者暴露服务（Invoker）"></a>2、再谈Dubbo服务提供者暴露服务（Invoker）</h2><h3 id="2-1-服务提供者视角看Invoker"><a href="#2-1-服务提供者视角看Invoker" class="headerlink" title="2.1 服务提供者视角看Invoker"></a>2.1 服务提供者视角看Invoker</h3><p>我们应该记得，服务提供者在暴露服务时(export)会创建Invoker，其代码片段如下：<br>ServiceConfig#doExportUrlsFor1Protocol</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (registryURLs !&#x3D; null &amp;&amp; !registryURLs.isEmpty()) &#123;</span><br><span class="line">      for (URL registryURL : registryURLs) &#123;</span><br><span class="line">          url &#x3D; url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));</span><br><span class="line">          URL monitorUrl &#x3D; loadMonitor(registryURL);</span><br><span class="line">          if (monitorUrl !&#x3D; null) &#123;</span><br><span class="line">              url &#x3D; url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">          &#125;</span><br><span class="line">          if (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(&quot;Register dubbo service &quot; + interfaceClass.getName() + &quot; url &quot; + url + &quot; to registry &quot; + registryURL);</span><br><span class="line">          &#125;</span><br><span class="line">          Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));  &#x2F;&#x2F; @1</span><br><span class="line">          DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);     &#x2F;&#x2F; @2</span><br><span class="line">          Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);    &#x2F;&#x2F; @3</span><br><span class="line">          exporters.add(exporter);</span><br><span class="line">       &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">      Invoker&lt;?&gt; invoker &#x3D; proxyFactory.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">      DelegateProviderMetaDataInvoker wrapperInvoker &#x3D; new DelegateProviderMetaDataInvoker(invoker, this);</span><br><span class="line">      Exporter&lt;?&gt; exporter &#x3D; protocol.export(wrapperInvoker);</span><br><span class="line">      exporters.add(exporter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据&lt;dubbo:service ref = “interfaceImpl” interface = “”  /&gt; 首先获取ref的代理对象，真正的服务实现类proxy，然后通过proxyFactory【JavassistProxyFactory、JdkProxyFactory】创建最原始的Invoker，即AbstractProxyInvoker，使用的是匿名实现类，即提供反射方式进行方法的调用。<br><img src="https://img-blog.csdn.net/20180821122113242?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从abstract Object doInvoker(T proxy, String methodName, Class&lt; ? &gt;[] parameterTypes, Object[] arguments) 可以最终是通过对象发射方式进行方法调用。</p>
<p>代码@2：首先使用DelegateProviderMetaDataInvoker对AbstractProxyInvoker进行包装，主要是将ServerConfig对象与Invoker一起保存。</p>
<p>代码@3：根据具体协议对服务端Invoker进行导出（继续包装）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;com.alibaba.dubbo.registry.RegistryService?application&#x3D;demo-provider&amp;dubbo&#x3D;2.0.0&amp;export&#x3D;dubbo%3A%2F%2F192.168.56.1%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider%26bind.ip%3D192.168.56.1%26bind.port%3D20880%26dubbo%3D2.0.0%26generic%3Dfalse%26interface%3Dcom.alibaba.dubbo.demo.DemoService%26methods%3DsayHello%26pid%3D14360%26qos.port%3D22222%26side%3Dprovider%26stub%3Dcom.alibaba.dubbo.demo.provider.DemoServiceStub%26timestamp%3D1533944510702&amp;pid&#x3D;14360&amp;qos.port&#x3D;22222&amp;registry&#x3D;zookeeper&amp;timestamp&#x3D;1533944510687</span><br></pre></td></tr></table></figure>
<p>协议前缀:registry，故根据SPI机制，具体的协议为RegistryProtocol。<br>registry=zookeeper ：代表注册中心使用zookeeper，在连接注册中心时根据该值进行策略选择。export= dubbo://…   :  根据export，在服务端按照协议启动对应的服务端程序，该协议注意指定请求包的二进制协议，例如协议头和协议体。</p>
<p>按照registry协议，应该会直接调用RegistryProtocol#export，但我们忽略了Dubbo的另一机制，该部分也是在<a href="https://blog.csdn.net/prestigeding/article/details/80536385">服务提供者启动流程</a>中被遗漏。Dubbo为了对服务调用进行包装，采用了过滤器Filter 链模式，在AbstractProxyInvoker调用之前，先执行一系列的过滤器Filter，Dubbo协议默认的协议层面的过滤器代理实现为：com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper,SPI定义文件见：<br>dubbo-rpc-api/src/main/resources/METAINF/dubbo/internal/com.alibaba.dubbo.rpc.Pr<br>otocol：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper</span><br><span class="line">listener&#x3D;com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper</span><br><span class="line">mock&#x3D;com.alibaba.dubbo.rpc.support.MockProtocol</span><br></pre></td></tr></table></figure>
<p>ProtocolFilterWrapper#export</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; Exporter&lt;T&gt; export(Invoker&lt;T&gt; invoker) throws RpcException &#123;</span><br><span class="line">     if (Constants.REGISTRY_PROTOCOL.equals(invoker.getUrl().getProtocol())) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">        return protocol.export(invoker);</span><br><span class="line">     &#125;</span><br><span class="line">     return protocol.export(buildInvokerChain(invoker, Constants.SERVICE_FILTER_KEY, Constants.PROVIDER));    &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果协议为registry，则直接调用RegistryProtocol#expoert完成协议导出，协议为registry其含义是通过注册中心暴露，最终会根据expoert，调用具体的协议进行服务暴露，最终会再次进入该方法。<br>代码@2：如果为具体协议，例如dubbo等，则通过buildInvokerChain构建Invoker链。<br>ProtocolFilterWrapper#buildInvokerChain</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static &lt;T&gt; Invoker&lt;T&gt; buildInvokerChain(final Invoker&lt;T&gt; invoker, String key, String group) &#123;</span><br><span class="line">        Invoker&lt;T&gt; last &#x3D; invoker;</span><br><span class="line">        List&lt;Filter&gt; filters &#x3D; ExtensionLoader.getExtensionLoader(Filter.class).getActivateExtension(invoker.getUrl(), key, group);    &#x2F;&#x2F; @1</span><br><span class="line">        if (!filters.isEmpty()) &#123;</span><br><span class="line">            for (int i &#x3D; filters.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">                final Filter filter &#x3D; filters.get(i);</span><br><span class="line">                final Invoker&lt;T&gt; next &#x3D; last;</span><br><span class="line">                last &#x3D; new Invoker&lt;T&gt;() &#123;       &#x2F;&#x2F; @2</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public Class&lt;T&gt; getInterface() &#123;</span><br><span class="line">                        return invoker.getInterface();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public URL getUrl() &#123;</span><br><span class="line">                        return invoker.getUrl();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public boolean isAvailable() &#123;</span><br><span class="line">                        return invoker.isAvailable();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public Result invoke(Invocation invocation) throws RpcException &#123;</span><br><span class="line">                        return filter.invoke(next, invocation);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void destroy() &#123;</span><br><span class="line">                        invoker.destroy();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public String toString() &#123;</span><br><span class="line">                        return invoker.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：加载系统配置的所有Filer，并根据作用对象（服务提供者、服务消费者），返回合适的Filter链表。、</p>
<p>代码@2：根据Filter构建Invoker链。<br>Dubbo默认提供的Filter在dubbo-rpc-api/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中定义，其内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo&#x3D;com.alibaba.dubbo.rpc.filter.EchoFilter</span><br><span class="line">generic&#x3D;com.alibaba.dubbo.rpc.filter.GenericFilter</span><br><span class="line">genericimpl&#x3D;com.alibaba.dubbo.rpc.filter.GenericImplFilter</span><br><span class="line">token&#x3D;com.alibaba.dubbo.rpc.filter.TokenFilter</span><br><span class="line">accesslog&#x3D;com.alibaba.dubbo.rpc.filter.AccessLogFilter</span><br><span class="line">activelimit&#x3D;com.alibaba.dubbo.rpc.filter.ActiveLimitFilter</span><br><span class="line">classloader&#x3D;com.alibaba.dubbo.rpc.filter.ClassLoaderFilter</span><br><span class="line">context&#x3D;com.alibaba.dubbo.rpc.filter.ContextFilter</span><br><span class="line">consumercontext&#x3D;com.alibaba.dubbo.rpc.filter.ConsumerContextFilter</span><br><span class="line">exception&#x3D;com.alibaba.dubbo.rpc.filter.ExceptionFilter</span><br><span class="line">executelimit&#x3D;com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter</span><br><span class="line">deprecated&#x3D;com.alibaba.dubbo.rpc.filter.DeprecatedFilter</span><br><span class="line">compatible&#x3D;com.alibaba.dubbo.rpc.filter.CompatibleFilter</span><br><span class="line">timeout&#x3D;com.alibaba.dubbo.rpc.filter.TimeoutFilter</span><br></pre></td></tr></table></figure>
<p>当然这些过滤器并不全是服务提供者端的，每个过滤器通过@Activate注解来定义属于服务端还是消费端。<br>Dubbo还为服务暴露(export)和服务引用(reference)提供了事件回调通知，其实现与Filter类似，其实现类为：com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper,其事件只是在服务expoert、或服务reference时执行，与调用执行的Filter不一样，因为是针对服务暴露与服务引用的事件。<br>DubboCodec2(解码器) 》 事件派发模型handler[AllChannelHandler] 》 DecodeHandler  》  HeaderExchangeHandler 》 DubboProtocol#requestHandler(最终的业务Handler) 》Filter Chain 》AbstractProxyInvoker(JavassistProxyFactory#getInvoker),通过反射进行服务端方法调用。</p>
<h3 id="2-2-从消费端的视角看Invoker"><a href="#2-2-从消费端的视角看Invoker" class="headerlink" title="2.2 从消费端的视角看Invoker"></a>2.2 从消费端的视角看Invoker</h3><p>从消费者的视角看Invoker，即我们常说的服务调用器，结合集群容错功能的Invoker,服务调用的门面（同一封装），例如DubboInvoker，根据dubbo协议，封装服务调用请求并通过网络向服务器发送请求包。其主要子类为AbstractInvoker、AbstractClusterInvoker（集群模式）。消费端服务发起请求时，同样会被ProtocolFilterWrapper拦截，引入调用链（获取消费端的Filter Chain）。关于消费端的Invoker，请大家参考如下两篇博文：<br><a href="https://blog.csdn.net/prestigeding/article/details/80963998">Dubbo集群容错模式</a><br><a href="https://blog.csdn.net/prestigeding/article/details/80642774">Dubbo Invoker概述</a><br><a href="https://blog.csdn.net/prestigeding/article/details/80621535">Dubbo消费者启动流程</a></p>
<p>综上所述，服务端的Invoker职责通过反射机制，根据服务名、方法名、参数调用方法完成服务端的响应，其类主要为com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker，客户端的Invoker职责主要是按照协议组织请求包，通过网络发送服务调用请求，其代表为AbstractInvoker、AbstractClusterInvoker。<br>服务调用的整体流程就介绍到这里了，从下一篇开始，将重点分析Dubbo Filter机制。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>invoker</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo监控中心实现原理</title>
    <url>/posts/4fb5ca23.html</url>
    <content><![CDATA[<div id="vip-container"><p>Dubbo监控的实现基本原理就是在服务调用时收集服务调用并发度、服务响应时间，然后以一定频率向监控中心汇报统计数据。</p>
<h2 id="1、源码分析MonitorFilter过滤器"><a href="#1、源码分析MonitorFilter过滤器" class="headerlink" title="1、源码分析MonitorFilter过滤器"></a>1、源码分析MonitorFilter过滤器</h2><ul>
<li>过滤器作用<br>监控过滤器，向监控中心汇报服务调用数据。</li>
<li>使用场景<br>搭建监控中心监控Dubbo服务调用。</li>
<li>阻断条件<br>非阻断过滤器。</li>
</ul>
<a id="more"></a>

<h3 id="1-1-MonitorFilter声明"><a href="#1-1-MonitorFilter声明" class="headerlink" title="1.1 MonitorFilter声明"></a>1.1 MonitorFilter声明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * MonitorFilter. (SPI, Singleton, ThreadSafe)</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Activate(group &#x3D; &#123;Constants.PROVIDER, Constants.CONSUMER&#125;)</span><br><span class="line">public class MonitorFilter implements Filter &#123;</span><br><span class="line">     &#x2F;&#x2F; 省略具体代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：MonitorFilter会在生产者、消费者两端生效。</p>
<h3 id="1-2-getConcurrent方法详解"><a href="#1-2-getConcurrent方法详解" class="headerlink" title="1.2 getConcurrent方法详解"></a>1.2 getConcurrent方法详解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; concurrent counter</span><br><span class="line">    private AtomicInteger getConcurrent(Invoker&lt;?&gt; invoker, Invocation invocation) &#123;</span><br><span class="line">        String key &#x3D; invoker.getInterface().getName() + &quot;.&quot; + invocation.getMethodName();    &#x2F;&#x2F; @1</span><br><span class="line">        AtomicInteger concurrent &#x3D; concurrents.get(key);                     </span><br><span class="line">        if (concurrent &#x3D;&#x3D; null) &#123;</span><br><span class="line">            concurrents.putIfAbsent(key, new AtomicInteger());                                                  &#x2F;&#x2F; @2</span><br><span class="line">            concurrent &#x3D; concurrents.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return concurrent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>主要是获取当前调用服务的调用次数计算器。<br>代码@1：使用的是ConcurrentMap&lt; String, AtomicInteger &gt;作为缓存容器，其key为：interfaceName + “.” + methodName。<br>代码@2：如果是第一次调用，则创建AtomicInteger，否则返回原先的计数器。</p>
<h3 id="1-3-invoker方法详解"><a href="#1-3-invoker方法详解" class="headerlink" title="1.3 invoker方法详解"></a>1.3 invoker方法详解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Result invoke(Invoker&lt;?&gt; invoker, Invocation invocation) throws RpcException &#123;</span><br><span class="line">        if (invoker.getUrl().hasParameter(Constants.MONITOR_KEY)) &#123;      &#x2F;&#x2F; @1</span><br><span class="line">            RpcContext context &#x3D; RpcContext.getContext(); &#x2F;&#x2F; provider must fetch context before invoke() gets called              &#x2F;&#x2F; @2</span><br><span class="line">            String remoteHost &#x3D; context.getRemoteHost();</span><br><span class="line">            long start &#x3D; System.currentTimeMillis(); &#x2F;&#x2F; record start timestamp                       </span><br><span class="line">            getConcurrent(invoker, invocation).incrementAndGet(); &#x2F;&#x2F; count up                                                &#x2F;&#x2F; @3</span><br><span class="line">            try &#123;</span><br><span class="line">                Result result &#x3D; invoker.invoke(invocation); &#x2F;&#x2F; proceed invocation chain                                       &#x2F;&#x2F; @4</span><br><span class="line">                collect(invoker, invocation, result, remoteHost, start, false);                                                        &#x2F;&#x2F; @5</span><br><span class="line">                return result;</span><br><span class="line">            &#125; catch (RpcException e) &#123;</span><br><span class="line">                collect(invoker, invocation, null, remoteHost, start, true);                                                            &#x2F;&#x2F; @6</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                getConcurrent(invoker, invocation).decrementAndGet(); &#x2F;&#x2F; count down                                     &#x2F;&#x2F; @7</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return invoker.invoke(invocation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果url中存在monitor,则设置了监控中心，收集调用信息。<br>代码@2：获取本次服务调用的上下文环境。<br>代码@3：服务调用并发次数增加1，（非服务调用总次数，而是当前服务的并发调用）。<br>代码@4：执行方法之前先记录当前时间，然后调用下一个过滤器，直到真实服务被调用。<br>代码@5：调用collect方法收集调用信息。<br>代码@6：如果调用发送RPC异常，则收集错误信息。<br>代码@7：一次服务调用结束，并发次数减一。<br>接下来分析一下collect方法。</p>
<h3 id="1-4-invoker方法详解"><a href="#1-4-invoker方法详解" class="headerlink" title="1.4 invoker方法详解"></a>1.4 invoker方法详解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; collect info</span><br><span class="line">    private void collect(Invoker&lt;?&gt; invoker, Invocation invocation, Result result, String remoteHost, long start, boolean error) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; ---- service statistics ----                                                                                                                                                      &#x2F;&#x2F; @2 start</span><br><span class="line">            long elapsed &#x3D; System.currentTimeMillis() - start; &#x2F;&#x2F; invocation cost                                                   </span><br><span class="line">            int concurrent &#x3D; getConcurrent(invoker, invocation).get(); &#x2F;&#x2F; current concurrent count</span><br><span class="line">            String application &#x3D; invoker.getUrl().getParameter(Constants.APPLICATION_KEY);</span><br><span class="line">            String service &#x3D; invoker.getInterface().getName(); &#x2F;&#x2F; service name</span><br><span class="line">            String method &#x3D; RpcUtils.getMethodName(invocation); &#x2F;&#x2F; method name</span><br><span class="line">            String group &#x3D; invoker.getUrl().getParameter(Constants.GROUP_KEY);</span><br><span class="line">            String version &#x3D; invoker.getUrl().getParameter(Constants.VERSION_KEY);</span><br><span class="line">            URL url &#x3D; invoker.getUrl().getUrlParameter(Constants.MONITOR_KEY);                                                                             &#x2F;&#x2F; @2 end</span><br><span class="line">            Monitor monitor &#x3D; monitorFactory.getMonitor(url);                                                                                                     &#x2F;&#x2F; @3</span><br><span class="line">            if (monitor &#x3D;&#x3D; null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            int localPort;</span><br><span class="line">            String remoteKey;</span><br><span class="line">            String remoteValue;</span><br><span class="line">            if (Constants.CONSUMER_SIDE.equals(invoker.getUrl().getParameter(Constants.SIDE_KEY))) &#123;                  &#x2F;&#x2F; @4</span><br><span class="line">                &#x2F;&#x2F; ---- for service consumer ----</span><br><span class="line">                localPort &#x3D; 0;</span><br><span class="line">                remoteKey &#x3D; MonitorService.PROVIDER;</span><br><span class="line">                remoteValue &#x3D; invoker.getUrl().getAddress();</span><br><span class="line">            &#125; else &#123;                                                                                                                                                               &#x2F;&#x2F; @5</span><br><span class="line">                &#x2F;&#x2F; ---- for service provider ----</span><br><span class="line">                localPort &#x3D; invoker.getUrl().getPort();</span><br><span class="line">                remoteKey &#x3D; MonitorService.CONSUMER;</span><br><span class="line">                remoteValue &#x3D; remoteHost;</span><br><span class="line">            &#125;</span><br><span class="line">            String input &#x3D; &quot;&quot;, output &#x3D; &quot;&quot;;</span><br><span class="line">            if (invocation.getAttachment(Constants.INPUT_KEY) !&#x3D; null) &#123;                                                                       &#x2F;&#x2F; @6</span><br><span class="line">                input &#x3D; invocation.getAttachment(Constants.INPUT_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            if (result !&#x3D; null &amp;&amp; result.getAttachment(Constants.OUTPUT_KEY) !&#x3D; null) &#123;                                               &#x2F;&#x2F; @7</span><br><span class="line">                output &#x3D; result.getAttachment(Constants.OUTPUT_KEY);</span><br><span class="line">            &#125;</span><br><span class="line">            monitor.collect(new URL(Constants.COUNT_PROTOCOL,                                                                          &#x2F;&#x2F; @8</span><br><span class="line">                    NetUtils.getLocalHost(), localPort,</span><br><span class="line">                    service + &quot;&#x2F;&quot; + method,</span><br><span class="line">                    MonitorService.APPLICATION, application,</span><br><span class="line">                    MonitorService.INTERFACE, service,</span><br><span class="line">                    MonitorService.METHOD, method,</span><br><span class="line">                    remoteKey, remoteValue,</span><br><span class="line">                    error ? MonitorService.FAILURE : MonitorService.SUCCESS, &quot;1&quot;,</span><br><span class="line">                    MonitorService.ELAPSED, String.valueOf(elapsed),</span><br><span class="line">                    MonitorService.CONCURRENT, String.valueOf(concurrent),</span><br><span class="line">                    Constants.INPUT_KEY, input,</span><br><span class="line">                    Constants.OUTPUT_KEY, output,</span><br><span class="line">                    Constants.GROUP_KEY, group,</span><br><span class="line">                    Constants.VERSION_KEY, version));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            logger.error(&quot;Failed to monitor count service &quot; + invoker.getUrl() + &quot;, cause: &quot; + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数说明。</p>
<ul>
<li>Invoker&lt; ? &gt; invoker<br>服务调用Invoker。</li>
<li>Invocation invocation<br>本次服务调用信息</li>
<li>Result result<br>执行结果</li>
<li>String remoteHost<br>调用者host信息。</li>
<li>long start<br>服务开始调用时间。</li>
<li>boolean error<br>是否发生错误。</li>
</ul>
<p>代码@2：统计基础信息字段说明：</p>
<ul>
<li>elapsed ：服务调用时长。</li>
<li>concurrent ：当前并发度。（当前服务并发调用次数）。</li>
<li>application ：服务归属应用名。</li>
<li>service ：服务名。</li>
<li>method ：方法名。</li>
<li>group ：服务所属组。</li>
<li>version ：服务版本号</li>
<li>URL url：监控中心url。</li>
</ul>
<p>代码@3：根据监控中心获取监控中心实现类，这是监控中心实现扩展点，默认使用com.alibaba.dubbo.monitor.dubbo.DubboMonitor。</p>
<p>代码@4：如果是消费端，由于Monitor在消费端与服务端都会生效：</p>
<ul>
<li>localPort ：本地端口设置为0；</li>
<li>remoteKey：MonitorService.PROVIDER，表示为服务端。</li>
<li>remoteValue：为invoker.getUrl().getAddress()，其值为（注册中心地址）或服务提供者地址（客户端直连服务端）。</li>
</ul>
<p>代码@5：如果为服务端：</p>
<ul>
<li>localPort ：为服务端的服务端口号。</li>
<li>remoteKey：MonitorService.CONSUMER，表示远端为服务消费者。</li>
<li>remoteValue：消费者host(ip:port)。</li>
</ul>
<p>代码@6：获取本次服务调用请求包的字节数，在服务端解码时会在RpcContext中。</p>
<p>代码@7：获取本次服务调用响应包的字节数，在服务端对响应包编码时会写入，具体代码请参考DubboCountCodec类。</p>
<p>代码@8：调用monitor#collect收集调用信息，Monitor默认实现为DubboMonitor。使用的协议为count://localhost:localPort/service/method?application=applicationName&amp;remoteKey=remoteValue&amp;success|failure=1&amp;elapsed=调用开销&amp;concurrent=并发调用次数&amp;input=入参字节数&amp;output=响应字节数&amp;group=服务所属组&amp;version=版本。</p>
<h2 id="2、源码分析DubboMonitor实现原理"><a href="#2、源码分析DubboMonitor实现原理" class="headerlink" title="2、源码分析DubboMonitor实现原理"></a>2、源码分析DubboMonitor实现原理</h2><p>Dubbo中默认的Monitor监控实现类为DubboMonitor：<br><img src="https://img-blog.csdn.net/20180831120406607?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>核心属性介绍：</p>
<ul>
<li><p>private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(3, new NamedThreadFactory(“DubboMonitorSendTimer”,<br>true))：定时调度线程池，使用3个线程的线程池，线程名称以DubboMonitorSendTimer。</p>
</li>
<li><p>private final ScheduledFuture&lt; ? &gt; sendFuture：调度任务future。<br>private final Invoker&lt; MonitorService &gt; monitorInvoker：监控调度Invoker，Dubbo中的监控中心会作为服务提供者暴露服务，服务提供者，服务消费者可以通过注册中心订阅服务，通过该Invoker向监控中心汇报调用统计数据，也就是一次上报就是一次Dubbo RPC服务调用，其实现类为DubboInvoker，也就是可以通过该Invoker使用dubbo协议调用远程Monitor服务。</p>
</li>
<li><p>private final MonitorService monitorService：对monitorInvoker的proxy代理，主要是对toString、hashcode、equals无需通过RPC向MonitorServer服务提供者发起调<br> 用。主要是通过AbstractProxyFactory#getProxy创建，默认子类为JavassistProxyFactory，动态代理的InvokerHandler为：<br>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler#invoke。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        String methodName &#x3D; method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes &#x3D; method.getParameterTypes();</span><br><span class="line">        if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">            return method.invoke(invoker, args);</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;toString&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return invoker.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;hashCode&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return invoker.hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">        if (&quot;equals&quot;.equals(methodName) &amp;&amp; parameterTypes.length &#x3D;&#x3D; 1) &#123;</span><br><span class="line">            return invoker.equals(args[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker.invoke(new RpcInvocation(method, args)).recreate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>private final long monitorInterval：向监控中心汇报的频率，也就是调用MonitorService RPC服务的调用频率，默认为1分钟。</p>
</li>
<li><p>private final ConcurrentMap&lt; Statistics, AtomicReference&lt; long[]&gt;&gt; statisticsMap：统计信息Map。</p>
</li>
</ul>
<h3 id="2-1-构造函数分析"><a href="#2-1-构造函数分析" class="headerlink" title="2.1 构造函数分析"></a>2.1 构造函数分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DubboMonitor(Invoker&lt;MonitorService&gt; monitorInvoker, MonitorService monitorService) &#123;</span><br><span class="line">        this.monitorInvoker &#x3D; monitorInvoker;</span><br><span class="line">        this.monitorService &#x3D; monitorService;</span><br><span class="line">        this.monitorInterval &#x3D; monitorInvoker.getUrl().getPositiveParameter(&quot;interval&quot;, 60000);      &#x2F;&#x2F; @1 </span><br><span class="line">        &#x2F;&#x2F; collect timer for collecting statistics data</span><br><span class="line">        sendFuture &#x3D; scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;      &#x2F;&#x2F; @2</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                &#x2F;&#x2F; collect data</span><br><span class="line">                try &#123;</span><br><span class="line">                    send();</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Unexpected error occur at send statistic, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, monitorInterval, monitorInterval, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1，从url参数中获取interval属性，如果为空，默认为60000，代表60S。<br>代码@2：启动定时调度任务，默认60S的间隔执行send()方法，向监控中心汇报服务调用统计数据。</p>
<h3 id="2-2-collect-收集统计信息方法"><a href="#2-2-collect-收集统计信息方法" class="headerlink" title="2.2 collect 收集统计信息方法"></a>2.2 collect 收集统计信息方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void collect(URL url) &#123;</span><br><span class="line">        &#x2F;&#x2F; data to collect from url</span><br><span class="line">        int success &#x3D; url.getParameter(MonitorService.SUCCESS, 0);</span><br><span class="line">        int failure &#x3D; url.getParameter(MonitorService.FAILURE, 0);</span><br><span class="line">        int input &#x3D; url.getParameter(MonitorService.INPUT, 0);</span><br><span class="line">        int output &#x3D; url.getParameter(MonitorService.OUTPUT, 0);</span><br><span class="line">        int elapsed &#x3D; url.getParameter(MonitorService.ELAPSED, 0);</span><br><span class="line">        int concurrent &#x3D; url.getParameter(MonitorService.CONCURRENT, 0);</span><br><span class="line">        &#x2F;&#x2F; init atomic reference</span><br><span class="line">        Statistics statistics &#x3D; new Statistics(url);</span><br><span class="line">        AtomicReference&lt;long[]&gt; reference &#x3D; statisticsMap.get(statistics);</span><br><span class="line">        if (reference &#x3D;&#x3D; null) &#123;</span><br><span class="line">            statisticsMap.putIfAbsent(statistics, new AtomicReference&lt;long[]&gt;());</span><br><span class="line">            reference &#x3D; statisticsMap.get(statistics);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; use CompareAndSet to sum</span><br><span class="line">        long[] current;</span><br><span class="line">        long[] update &#x3D; new long[LENGTH];</span><br><span class="line">        do &#123;</span><br><span class="line">            current &#x3D; reference.get();</span><br><span class="line">            if (current &#x3D;&#x3D; null) &#123;</span><br><span class="line">                update[0] &#x3D; success;</span><br><span class="line">                update[1] &#x3D; failure;</span><br><span class="line">                update[2] &#x3D; input;</span><br><span class="line">                update[3] &#x3D; output;</span><br><span class="line">                update[4] &#x3D; elapsed;</span><br><span class="line">                update[5] &#x3D; concurrent;</span><br><span class="line">                update[6] &#x3D; input;</span><br><span class="line">                update[7] &#x3D; output;</span><br><span class="line">                update[8] &#x3D; elapsed;</span><br><span class="line">                update[9] &#x3D; concurrent;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                update[0] &#x3D; current[0] + success;</span><br><span class="line">                update[1] &#x3D; current[1] + failure;</span><br><span class="line">                update[2] &#x3D; current[2] + input;</span><br><span class="line">                update[3] &#x3D; current[3] + output;</span><br><span class="line">                update[4] &#x3D; current[4] + elapsed;</span><br><span class="line">                update[5] &#x3D; (current[5] + concurrent) &#x2F; 2;</span><br><span class="line">                update[6] &#x3D; current[6] &gt; input ? current[6] : input;</span><br><span class="line">                update[7] &#x3D; current[7] &gt; output ? current[7] : output;</span><br><span class="line">                update[8] &#x3D; current[8] &gt; elapsed ? current[8] : elapsed;</span><br><span class="line">                update[9] &#x3D; current[9] &gt; concurrent ? current[9] : concurrent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; while (!reference.compareAndSet(current, update));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>收集的信息主要是10个字段<br>update[0] ：调用成功的次数<br>update[1] ：调用失败的次数<br>update[2] ：总调用流量（请求包的总大小）。<br>update[3] ：总响应流量（响应包的总大小）。<br>update[4] ：总响应时长（总服务调用开销）。<br>update[5] ：一次收集周期的平均TPS。<br>update[6] ：最大请求包大小。<br>update[7] ：最大响应包大小。<br>update[8] ：最大响应时间。<br>update[9] ：最大TPS。</p>
<h3 id="2-3-send方法"><a href="#2-3-send方法" class="headerlink" title="2.3 send方法"></a>2.3 send方法</h3><p>通过monitorService，最终通过monitorInvoker去调用RPC服务向监控中心汇报数据。接下来看一下监控中心的具体实现。</p>
<h2 id="3、Dubbo监控中心实现原理"><a href="#3、Dubbo监控中心实现原理" class="headerlink" title="3、Dubbo监控中心实现原理"></a>3、Dubbo监控中心实现原理</h2><p>Dubbo官方提供了简易版本的监控中心，其项目为dubbo-ops:dubbo-monitor-simple。该项目是个spring-boot项目，启动后可以看到后台管理界面。<br>该项目服务提供者文件如下：<br><img src="https://img-blog.csdn.net/20180831121101811?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>从中可以看出，监控中心服务提供者实现类为SimpleMonitorService，其实现接口为MonitorService。<br>接下来重点分析SimpleMonitorService监控中心的实现，关注如下两个点：<br>1、监控数据持久化。<br>2、监控报表生成逻辑。<br>核心属性说明：</p>
<ul>
<li>ScheduledExecutorService scheduledExecutorService：定时调度线程，将监控数据写入饼图的定时任务，固定1个线程。</li>
<li>Thread writeThread：监控数据持久化线程。</li>
<li>BlockingQueue&lt; URL &gt; queue：持久化数据任务阻塞队列。</li>
<li>String statisticsDirectory = “statistics”：数据持久化目录，SimpleMonitorService将数据持久化到磁盘文件。该值指定目录名称。</li>
<li>String chartsDirectory = “charts”：饼图存储目录。</li>
<li>private volatile boolean running = true：持久化数据线程是否处于运行状态。</li>
</ul>
<h3 id="3-1-SimpleMonitorService构造函数"><a href="#3-1-SimpleMonitorService构造函数" class="headerlink" title="3.1 SimpleMonitorService构造函数"></a>3.1 SimpleMonitorService构造函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SimpleMonitorService() &#123;</span><br><span class="line">        queue &#x3D; new LinkedBlockingQueue&lt;URL&gt;(Integer.parseInt(ConfigUtils.getProperty(&quot;dubbo.monitor.queue&quot;, &quot;100000&quot;)));    &#x2F;&#x2F; @1</span><br><span class="line">        writeThread &#x3D; new Thread(new Runnable() &#123;                      &#x2F;&#x2F; @2 start</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while (running) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        write(); &#x2F;&#x2F; write statistics</span><br><span class="line">                    &#125; catch (Throwable t) &#123;</span><br><span class="line">                        logger.error(&quot;Unexpected error occur at write stat log, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                        try &#123;</span><br><span class="line">                            Thread.sleep(5000); &#x2F;&#x2F; retry after 5 secs</span><br><span class="line">                        &#125; catch (Throwable t2) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        writeThread.setDaemon(true);</span><br><span class="line">        writeThread.setName(&quot;DubboMonitorAsyncWriteLogThread&quot;);    </span><br><span class="line">        writeThread.start();                                                                        &#x2F;&#x2F; @2 end</span><br><span class="line">        chartFuture &#x3D; scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    draw(); &#x2F;&#x2F; draw chart</span><br><span class="line">                &#125; catch (Throwable t) &#123;</span><br><span class="line">                    logger.error(&quot;Unexpected error occur at draw stat chart, cause: &quot; + t.getMessage(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1, 300, TimeUnit.SECONDS);     &#x2F;&#x2F; @3</span><br><span class="line">        statisticsDirectory &#x3D; ConfigUtils.getProperty(&quot;dubbo.statistics.directory&quot;);</span><br><span class="line">        chartsDirectory &#x3D; ConfigUtils.getProperty(&quot;dubbo.charts.directory&quot;);  &#x2F;&#x2F; @4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：创建有界阻塞队列LinkedBlockingQueue，容量默认为100000个，可通过配置参数dubbo.monitor.queue改变默认值，如果队列中已挤压未被处理，后续监控数据将被默认丢弃。<br>代码@2：创建持久化监控数据线程，名称为DubboMonitorAsyncWriteLogThread，其使命是从LinkedBlockingQueue中获取监控原始数据，如果队列中没数据则被阻塞，然后写入文件中。<br>代码@3：开启定时调度任务，已每个5分钟的频率，根据持久化的监控数据，生成饼图。<br>代码@4：获取数据持久化目录与饼图存放目录。</p>
<h3 id="3-2-SimpleMonitorService-write"><a href="#3-2-SimpleMonitorService-write" class="headerlink" title="3.2 SimpleMonitorService#write"></a>3.2 SimpleMonitorService#write</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void write() throws Exception &#123;</span><br><span class="line">        URL statistics &#x3D; queue.take();</span><br><span class="line">        if (POISON_PROTOCOL.equals(statistics.getProtocol())) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        String timestamp &#x3D; statistics.getParameter(Constants.TIMESTAMP_KEY);</span><br><span class="line">        Date now;</span><br><span class="line">        if (timestamp &#x3D;&#x3D; null || timestamp.length() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            now &#x3D; new Date();</span><br><span class="line">        &#125; else if (timestamp.length() &#x3D;&#x3D; &quot;yyyyMMddHHmmss&quot;.length()) &#123;</span><br><span class="line">            now &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).parse(timestamp);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            now &#x3D; new Date(Long.parseLong(timestamp));</span><br><span class="line">        &#125;</span><br><span class="line">        String day &#x3D; new SimpleDateFormat(&quot;yyyyMMdd&quot;).format(now);</span><br><span class="line">        SimpleDateFormat format &#x3D; new SimpleDateFormat(&quot;HHmm&quot;);</span><br><span class="line">        for (String key : types) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                String type;</span><br><span class="line">                String consumer;</span><br><span class="line">                String provider;</span><br><span class="line">                if (statistics.hasParameter(PROVIDER)) &#123;</span><br><span class="line">                    type &#x3D; CONSUMER;</span><br><span class="line">                    consumer &#x3D; statistics.getHost();</span><br><span class="line">                    provider &#x3D; statistics.getParameter(PROVIDER);</span><br><span class="line">                    int i &#x3D; provider.indexOf(&#39;:&#39;);</span><br><span class="line">                    if (i &gt; 0) &#123;</span><br><span class="line">                        provider &#x3D; provider.substring(0, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    type &#x3D; PROVIDER;</span><br><span class="line">                    consumer &#x3D; statistics.getParameter(CONSUMER);</span><br><span class="line">                    int i &#x3D; consumer &#x3D;&#x3D; null ? -1 : consumer.indexOf(&#39;:&#39;);</span><br><span class="line">                    if (i &gt; 0) &#123;</span><br><span class="line">                        consumer &#x3D; consumer.substring(0, i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    provider &#x3D; statistics.getHost();</span><br><span class="line">                &#125;</span><br><span class="line">                String filename &#x3D; statisticsDirectory</span><br><span class="line">                        + &quot;&#x2F;&quot; + day</span><br><span class="line">                        + &quot;&#x2F;&quot; + statistics.getServiceInterface()</span><br><span class="line">                        + &quot;&#x2F;&quot; + statistics.getParameter(METHOD)</span><br><span class="line">                        + &quot;&#x2F;&quot; + consumer</span><br><span class="line">                        + &quot;&#x2F;&quot; + provider</span><br><span class="line">                        + &quot;&#x2F;&quot; + type + &quot;.&quot; + key;</span><br><span class="line">                File file &#x3D; new File(filename);</span><br><span class="line">                File dir &#x3D; file.getParentFile();</span><br><span class="line">                if (dir !&#x3D; null &amp;&amp; !dir.exists()) &#123;</span><br><span class="line">                    dir.mkdirs();</span><br><span class="line">                &#125;</span><br><span class="line">                FileWriter writer &#x3D; new FileWriter(file, true);</span><br><span class="line">                try &#123;</span><br><span class="line">                    writer.write(format.format(now) + &quot; &quot; + statistics.getParameter(key, 0) + &quot;\n&quot;);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    writer.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.error(t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>数据存储在物理磁盘上，其文件为为：”${dubbo.statistics.directory} /${day}/${interfacename}/${method}/${consumer}/ ${provider}/[consume|provider]/key”，<br>key:{SUCCESS, FAILURE, ELAPSED, CONCURRENT, MAX_ELAPSED, MAX_CONCURRENT},分别调用成功次数、调用失败次数、调用开销（响应时间），TPS、最大响应时间，最大TPS。其文件存储如下：<br><img src="https://img-blog.csdn.net/20180831122010384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>以provider.concurrent为例，说明一下其内容：<br><img src="https://img-blog.csdn.net/20180831122045595?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>其内容组织方式为：时间（时分：采集的值）。</p>
<h3 id="3-3-draw"><a href="#3-3-draw" class="headerlink" title="3.3 draw"></a>3.3 draw</h3><p>根据持久化的数据，在特定的目录下创建饼图，创建饼图方法createChart，具体使用JFreeChart相关类图，在这里就不细细讲解了，感兴趣的朋友可以百度查询相关用法。</p>
<h2 id="3-4-监控中心使用效果一览"><a href="#3-4-监控中心使用效果一览" class="headerlink" title="3.4 监控中心使用效果一览"></a>3.4 监控中心使用效果一览</h2><h3 id="3-4-1-应用一览表"><a href="#3-4-1-应用一览表" class="headerlink" title="3.4.1 应用一览表"></a>3.4.1 应用一览表</h3><p>这个功能可以描述系统与系统的关联关系。<br><img src="https://img-blog.csdn.net/20180831122140555?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>表格字段说明：<br>1、Application Name：应用名称<br>2、Providers：该应用包含的服务提供者信息，点击进去可以查看具体的服务提供者URL。<br>3、Consumers(1)：该应用包含的服务消费者信息，点击进去可以查看具体的服务消费者URL。<br>4、Depends On：该应用依懒的应用。<br><img src="https://img-blog.csdn.net/20180831122232257?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>5、Used By：该应用被依懒的应用。<br><img src="https://img-blog.csdn.net/20180831122309186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>3.4.2服务一览表<br><img src="https://img-blog.csdn.net/20180831122512794?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>表格字段说明：<br>Service Name：服务名。<br>Application：服务所属应用名。<br>Providers：服务提供者信息，点击进去，可以看到详细的服务提供者信息。<br><img src="https://img-blog.csdn.net/20180831122619913?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Consumers：该服务的消费者信息。<br><img src="https://img-blog.csdn.net/20180831122656831?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Statistics：表格统计信息<br><img src="https://img-blog.csdn.net/20180831122730268?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>Charts：饼图统计信息<br><img src="https://img-blog.csdn.net/20180831122810968?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>饼图统计信息，主要从两个维度展示:QPS(接口每秒请求数)、平均响应时间（包含最大，最小响应时间）。</p>
<h3 id="3-4-3、-Dubbo简易监控中心使用方法"><a href="#3-4-3、-Dubbo简易监控中心使用方法" class="headerlink" title="3.4.3、 Dubbo简易监控中心使用方法"></a>3.4.3、 Dubbo简易监控中心使用方法</h3><p>1、安装Dubbo简易监控中心<br>从github dubbo仓库中下载dubbo-simple-monitor即可。<br>2、应用程序如何使用Dubbo监控中心<br>成功安装完监控中心还只是第一步，为了监控中心能收集服务调用信息，需要在Dubbo服务提、Dubbo消费者供者所在的应用的dubbo配置文件中加上如下内容：<br>&lt; dubbo:monitor protocol=”registry” /&gt;，表示从注册中心发现监控中心的地址，并将服务调用信息提交到监控中心。<br>服务提供者默认以一分钟的频率（可配置）调用监控中心的dubbo服务，向监控中心上报服务调用信息。监控中心宕机，并不影响消费者，服务提供者的正常工作。<br>如果要配置其调用频率，可通过如下配置，默认建议保持一分钟的频率，甚至更小，这个频率设置低点，对整个服务器的压力不会增加更大</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; dubbo:monitor protocol&#x3D;&quot;registry&quot;&gt;</span><br><span class="line">	&lt;dubbo:parameter key &#x3D; &quot;interval&quot; value&#x3D;&quot;60000&quot;&gt; &lt;!-- 单位为毫秒--&gt;</span><br><span class="line">&lt;&#x2F; dubbo:monitor&gt;</span><br></pre></td></tr></table></figure>
<p>注：Dubbo监控中心，服务提供者、服务消费者都可以单独按需配置。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>监控中心</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo网络通讯篇之NettyServer网络事件派发机制(Dispatch)</title>
    <url>/posts/dff42af6.html</url>
    <content><![CDATA[<div id="vip-container"><p>本节将主要学习Dubbo是如何使用Netty来实现网络通讯的。<br>从官网我们得知，Dubbo协议是使用单一长连接来进行网络传输，也就是说服务调用方持久与服务提供者建立一条连接，所有的服务调用调用信息通过。<br>一条TCP连接进行传输，在网络层至少要考虑如下问题：<br>1、服务端，客户端网络通讯模型（线程模型）<br>2、传输（编码解码、序列化）。<br>3、服务端转发策略等。<br>Dubbo服务端的网络启动流程，在上篇中已给出序列图，本节还是以该图为切入点，引入本文的两个主人公：NettyServer、NettyClient。<br><img src="https://img-blog.csdn.net/20180717115949813?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<a id="more"></a>

<p>dubbo使用SPI机制，根据配置，可以支持如下框架实现网络通讯模型，例如netty3,netty4、mina、grizzly，本文重点分析基于Netty4的实现，包路径：dubbo-remoting-netty4。<br>从上面的流程图，NettyTransport的职责就是调用new NettyServer的构造方法，从而构建NettyServer对象，在深入NettyServer对象构造过程之前，先来看一下NettyServer的类继承层次：<br><img src="https://img-blog.csdn.net/20180717120028786?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>NettyServer构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123;  &#x2F;&#x2F; @1</span><br><span class="line">        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));    &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：URL url：服务提供者URL；ChannelHandler网络事件处理器，<br><img src="https://img-blog.csdn.net/20180717120125818?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>也就是当相应网络事件触发时，执行的事件处理器。</p>
<ul>
<li>void connected(Channel channel) throws RemotingException<br>  连接事件，当收到客户端的连接事件时，执行该方法处理相关业务操作。</li>
<li>void disconnected(Channel channel) throws RemotingException：连接断开事件</li>
<li>void sent(Channel channel, Object message) throws RemotingException<br> 当可写事件触发时，服务端向客户端返回响应数据，就是通过该方法发送的。</li>
<li>void received(Channel channel, Object message) throws RemotingException<br> 当读事件触发时执行该方法，服务端在收到客户端的请求数据是，调用该方法执行解包等操作。</li>
<li>void caught(Channel channel, Throwable exception) throws RemotingException<br>  发生异常时，调用该方法。</li>
</ul>
<p>代码@2：调用ChannelHandlers.wrap对原生Handler进行包装，然后调用其父类的构造方法，首先，设置Dubbo服务端线程池中线程的名称，可以通过参数threadname来指定线程池中线程的前缀，默认为：DubboServerHandler + dubbo服务端IP与接口号。我比较好奇的是这里为什么需要对ChannelHandler进行包装呢？是增加了些什么逻辑呢？带着者问题，引出本节重点探讨的内容：事件派发机制。<br>事件派发机制指的是网络事件（连接、读、写）等事件触发后，这些事件如何执行，是由IO线程还是派发到线程池中执行。Dubbo定义了如下5种事件派发机制：<br><img src="https://img-blog.csdn.net/20180717120858860?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>本文将详细分析各种事件的派发实现原理。<br>ChannelHandlers#wrapInternal</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected ChannelHandler wrapInternal(ChannelHandler handler, URL url) &#123;</span><br><span class="line">        return new MultiMessageHandler(new HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher.class)</span><br><span class="line">                .getAdaptiveExtension().dispatch(handler, url)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是典型的装饰模式，MultiMessageHandler，多消息处理Handler,HeartbeatHandler，心跳Handler,其主要功能是处理心跳返回与心跳请求，直接在IO线程中执行，每次收到信息，更新通道的读事件戳，每次发送数据时，记录通道的写事件戳。这里的核心关键是利用SPI自适配，返回合适的事件派发机制。Dispatcher的类层次结构如图所示：<br><img src="https://img-blog.csdn.net/20180717120945500?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h2 id="1、源码分析AllDispatcher实现原理"><a href="#1、源码分析AllDispatcher实现原理" class="headerlink" title="1、源码分析AllDispatcher实现原理"></a>1、源码分析AllDispatcher实现原理</h2><p>线程派发机制：所有的消息都派发到线程池，包括请求、响应、连接事件、断开事件、心跳等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AllDispatcher implements Dispatcher &#123;</span><br><span class="line">    public static final String NAME &#x3D; &quot;all&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123;</span><br><span class="line">        return new AllChannelHandler(handler, url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看出，事件派发类继承图分两个维度，Dispatcher（事件派发器）、与之对应的ChannelHandler,例如AllChannelHandler。</p>
<h3 id="1-1-WrappedChannelHandler"><a href="#1-1-WrappedChannelHandler" class="headerlink" title="1.1 WrappedChannelHandler"></a>1.1 WrappedChannelHandler</h3><p>接下来分析事件派发机制，重点关注ChannelHandler类的实现体系。<br><img src="https://img-blog.csdn.net/20180717121040241?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>纵观Dubbo ChannelHanler体系的设计，是经典的类装饰器模式，上述派发器主要解决的问题，是相关网络事件（连接、读（请求）、写（响应）、心跳请求、心跳响应）是在IO线程、还是在额外定义的线程池，故WrappedChannelHandler的主要职责是定义线程池相关的逻辑，具体是在IO线程上执行，还是在定义的线程池中执行，则由子类具体去定制，WrappedChannelHandler默认实现ChannelHandler的所有方法，各个方法的实现直接调用被装饰Handler的方法，见下图：<br><img src="https://img-blog.csdn.net/20180717121110311?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>接下来先重点关注一下WrappedChannelHandler的成员变量和构造方法的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected static final ExecutorService SHARED_EXECUTOR &#x3D; Executors.newCachedThreadPool(new NamedThreadFactory(&quot;DubboSharedHandler&quot;, true));</span><br><span class="line">protected final ExecutorService executor;</span><br><span class="line">protected final ChannelHandler handler;</span><br><span class="line">protected final URL url;</span><br></pre></td></tr></table></figure>

<ul>
<li>ExecutorService SHARED_EXECUTOR：共享线程池，默认线程池，如果<br>ExecutorService executor为空，则使用SHARED_EXECUTOR </li>
<li>ExecutorService executor 定义的线程池</li>
<li>ChannelHandler handler：被装饰的ChannelHandler</li>
<li>URL url 服务提供者URL<br>接下来关注一下其构造函数：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public WrappedChannelHandler(ChannelHandler handler, URL url) &#123;</span><br><span class="line">        this.handler &#x3D; handler;</span><br><span class="line">        this.url &#x3D; url;</span><br><span class="line">        executor &#x3D; (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url);    &#x2F;&#x2F; @1</span><br><span class="line"></span><br><span class="line">        String componentKey &#x3D; Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</span><br><span class="line">        if (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</span><br><span class="line">            componentKey &#x3D; Constants.CONSUMER_SIDE;</span><br><span class="line">        &#125;</span><br><span class="line">        DataStore dataStore &#x3D; ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</span><br><span class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);  &#x2F;&#x2F; @2</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
代码@1：构建线程池，这里基于SPI机制，用户可选择cached、eager、fixed、limited，将在本节下面详细介绍，这里只需要知道是构建了一个线程池。<br>代码@2：将服务端都与线程池缓存起来，在服务端，线程池的缓存级别是 服务提供者协议（端口）：线程池。<h3 id="1-2-AllChannelHandler"><a href="#1-2-AllChannelHandler" class="headerlink" title="1.2 AllChannelHandler"></a>1.2 AllChannelHandler</h3>事件派发机制：所有网络事件在线程池中执行，其实现机制肯定是重写ChannelHandler的所有网络事件方法，将调用其修饰的ChannelHanlder在线程池中执行。由于AllChannelHandler是第一个事件派发机制，故对其实现做一个详细描述。</li>
</ul>
<h4 id="1-2-1-AllChannelHandler-connected"><a href="#1-2-1-AllChannelHandler-connected" class="headerlink" title="1.2.1 AllChannelHandler#connected"></a>1.2.1 AllChannelHandler#connected</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void connected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        ExecutorService cexecutor &#x3D; getExecutorService();</span><br><span class="line">        try &#123;</span><br><span class="line">            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new ExecutionException(&quot;connect event&quot;, channel, getClass() + &quot; error when process connected event .&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>连接事件，其主要实现是，首先先获取执行线程池，其获取逻辑是如果executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).<br>getAdaptiveExtension().getExecutor(url);获取不到线程池，则使用共享线程池。可以看出，连接事件的业务调用时异步执行，基于线程池。<br>注：调用时机，服务端收到客户端连接后，该方法会被调用。</p>
<h4 id="2-2-2-AllChannelHandler-disconnected"><a href="#2-2-2-AllChannelHandler-disconnected" class="headerlink" title="2.2.2 AllChannelHandler#disconnected"></a>2.2.2 AllChannelHandler#disconnected</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void disconnected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        ExecutorService cexecutor &#x3D; getExecutorService();</span><br><span class="line">        try &#123;</span><br><span class="line">            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new ExecutionException(&quot;disconnect event&quot;, channel, getClass() + &quot; error when process disconnected event .&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其基本实现与connected相同，就是将具体的disconnected 事件所对应的业务扩展方法在线程池中执行。<br>注：调用时机，服务端收到客户端断开连接后，该方法会被调用。</p>
<h4 id="2-2-3-AllChannelHandler-received"><a href="#2-2-3-AllChannelHandler-received" class="headerlink" title="2.2.3 AllChannelHandler#received"></a>2.2.3 AllChannelHandler#received</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        ExecutorService cexecutor &#x3D; getExecutorService();</span><br><span class="line">        try &#123;</span><br><span class="line">            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            &#x2F;&#x2F;TODO A temporary solution to the problem that the exception information can not be sent to the opposite end after the thread pool is full. Need a refactoring</span><br><span class="line">            &#x2F;&#x2F;fix The thread pool is full, refuses to call, does not return, and causes the consumer to wait for time out</span><br><span class="line">        	if(message instanceof Request &amp;&amp; t instanceof RejectedExecutionException)&#123;</span><br><span class="line">        		Request request &#x3D; (Request)message;</span><br><span class="line">        		if(request.isTwoWay())&#123;</span><br><span class="line">        			String msg &#x3D; &quot;Server side(&quot; + url.getIp() + &quot;,&quot; + url.getPort() + &quot;) threadpool is exhausted ,detail msg:&quot; + t.getMessage();</span><br><span class="line">        			Response response &#x3D; new Response(request.getId(), request.getVersion());</span><br><span class="line">        			response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);</span><br><span class="line">        			response.setErrorMessage(msg);</span><br><span class="line">        			channel.send(response);</span><br><span class="line">        			return;</span><br><span class="line">        		&#125;</span><br><span class="line">        	&#125;</span><br><span class="line">            throw new ExecutionException(message, channel, getClass() + &quot; error when process received event .&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>调用时机：当服务端收到客户端发送的请求后，经过IO线程（Netty）会首先从二进制流中解码出一个个的请求，参数Object message，就是调用请求，然后在提交给线程池执行，执行完后，当业务处理完毕后，组装结果后，必然会在该线程中调用通道(Channel#write,flush)方法，向通道写入响应结果。<br>注：all事件派发机制，ChannelHandler#recive是在线程池中执行。</p>
<h4 id="2-2-4-AllChannelHandler-caught"><a href="#2-2-4-AllChannelHandler-caught" class="headerlink" title="2.2.4 AllChannelHandler#caught"></a>2.2.4 AllChannelHandler#caught</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void caught(Channel channel, Throwable exception) throws RemotingException &#123;</span><br><span class="line">        ExecutorService cexecutor &#x3D; getExecutorService();</span><br><span class="line">        try &#123;</span><br><span class="line">            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new ExecutionException(&quot;caught event&quot;, channel, getClass() + &quot; error when process caught event .&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当发生异常时，ChannelHandler#caught也在线程池中执行。<br>令人颇感意外的是，AllChannelHandler并未重写WrappedChannelHandler的sent方法，也就是说ChannelHandler#sent事件回调方法，是在IO线程中执行。<br>WrappedChannelHandler#sent</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void sent(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        handler.sent(channel, message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个和官方文档还是有一定出入的。<br><img src="https://img-blog.csdn.net/20180717121431231?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="1-3-ExecutionChannelHandler"><a href="#1-3-ExecutionChannelHandler" class="headerlink" title="1.3 ExecutionChannelHandler"></a>1.3 ExecutionChannelHandler</h3><p>对应事件派件器：ExecutionDispatcher，其配置值：execution,从其源码的实现来看，与AllDispatcher实现基本类似，唯一的区别是，如果executor线程池为空时，并不会使用共享线程池，目前我还想不出什么情况下，线程池会初始化失败。</p>
<h3 id="1-4-DirectDispatcher"><a href="#1-4-DirectDispatcher" class="headerlink" title="1.4 DirectDispatcher"></a>1.4 DirectDispatcher</h3><p>直接派发，也就是所有的事件全部在IO线程中执行，故其实现非常简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DirectDispatcher implements Dispatcher &#123;</span><br><span class="line">    public static final String NAME &#x3D; &quot;direct&quot;;</span><br><span class="line">    @Override</span><br><span class="line">    public ChannelHandler dispatch(ChannelHandler handler, URL url) &#123;</span><br><span class="line">        return handler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-MessageOnlyDispatcher、MessageOnlyChannelHandler"><a href="#1-5-MessageOnlyDispatcher、MessageOnlyChannelHandler" class="headerlink" title="1.5 MessageOnlyDispatcher、MessageOnlyChannelHandler"></a>1.5 MessageOnlyDispatcher、MessageOnlyChannelHandler</h3><p>事件派发器：只有请求事件在线程池中执行，其他响应事件、心跳，连接，断开连接等事件在IO线程上执行，故其只需要重写recive方法即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void received(Channel channel, Object message) throws RemotingException &#123;</span><br><span class="line">        ExecutorService cexecutor &#x3D; executor;</span><br><span class="line">        if (cexecutor &#x3D;&#x3D; null || cexecutor.isShutdown()) &#123;</span><br><span class="line">            cexecutor &#x3D; SHARED_EXECUTOR;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new ExecutionException(message, channel, getClass() + &quot; error when process received event .&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-ConnectionOrderedDispatcher-ConnectionOrderedChannelHandler"><a href="#1-6-ConnectionOrderedDispatcher-ConnectionOrderedChannelHandler" class="headerlink" title="1.6 ConnectionOrderedDispatcher ConnectionOrderedChannelHandler"></a>1.6 ConnectionOrderedDispatcher ConnectionOrderedChannelHandler</h3><p>事件派发器：连接、断开连接事件排队执行，并可通过connect.queue.capacity属性设置队列长度，请求事件、异常事件在线程池中执行。</p>
<h4 id="1-6-1-构造方法"><a href="#1-6-1-构造方法" class="headerlink" title="1.6.1 构造方法"></a>1.6.1 构造方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConnectionOrderedChannelHandler(ChannelHandler handler, URL url) &#123;</span><br><span class="line">        super(handler, url);</span><br><span class="line">        String threadName &#x3D; url.getParameter(Constants.THREAD_NAME_KEY, Constants.DEFAULT_THREAD_NAME);</span><br><span class="line">        connectionExecutor &#x3D; new ThreadPoolExecutor(1, 1,</span><br><span class="line">                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                new LinkedBlockingQueue&lt;Runnable&gt;(url.getPositiveParameter(Constants.CONNECT_QUEUE_CAPACITY, Integer.MAX_VALUE)),</span><br><span class="line">                new NamedThreadFactory(threadName, true),</span><br><span class="line">                new AbortPolicyWithReport(threadName, url)</span><br><span class="line">        );  &#x2F;&#x2F; FIXME There&#39;s no place to release connectionExecutor!</span><br><span class="line">        queuewarninglimit &#x3D; url.getParameter(Constants.CONNECT_QUEUE_WARNING_SIZE, Constants.DEFAULT_CONNECT_QUEUE_WARNING_SIZE);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重点关注一下connectionExecutor ，用来执行连接、断开事件的线程池，线程池中只有一个线程，并且队列可以选择时有界队列，通过connect.queue.capacity属性配置，超过的事件，则拒绝执行。</p>
<h4 id="1-6-2-ConnectionOrderedChannelHandler-connected"><a href="#1-6-2-ConnectionOrderedChannelHandler-connected" class="headerlink" title="1.6.2 ConnectionOrderedChannelHandler#connected"></a>1.6.2 ConnectionOrderedChannelHandler#connected</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void connected(Channel channel) throws RemotingException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            checkQueueLength();</span><br><span class="line">            connectionExecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));</span><br><span class="line">        &#125; catch (Throwable t) &#123;</span><br><span class="line">            throw new ExecutionException(&quot;connect event&quot;, channel, getClass() + &quot; error when process connected event .&quot;, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>检查队列长度，如果超过警告值，则输出警告信息，然后提交连接线程池中执行，disconnected事件类似。其他received、caught事件，则与AllDispatcher相同，就不在重复。</p>
<p><strong>总结</strong>：本文主要是分析阐述了Dubbo Dispatch机制，但与官方文档存在出入，先归纳如下：Dispatch所有的sent事件方法、心跳请求全部在IO线程上执行。</p>
<ul>
<li>all<br>除sent事件回调方法、心跳外，全部在线程池上执行。</li>
<li>execution<br>与all类似，唯一区就是all在线程池未指定时，可以使用共享线程池，这个差别等同于没有。</li>
<li>message<br>只有请求事件在线程池中执行，其他在IO线程上执行。</li>
<li>connection<br>请求事件在线程池中执行，连接、断开连接事件排队执行（含一个线程的线程池）</li>
<li>direct<br>所有事件都在IO线程中执行。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>线程模型</tag>
        <tag>dispatch</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo负载算法</title>
    <url>/posts/398539d9.html</url>
    <content><![CDATA[<div id="vip-container"><p>Dubbo支持在服务调用方对服务提供者采用负载均衡算法，LoadBalance 接口定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SPI(RandomLoadBalance.NAME)</span><br><span class="line">public interface LoadBalance &#123;</span><br><span class="line"></span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * select one invoker in list.</span><br><span class="line">	 * </span><br><span class="line">	 * @param invokers invokers.</span><br><span class="line">	 * @param url refer url</span><br><span class="line">	 * @param invocation invocation.</span><br><span class="line">	 * @return selected invoker.</span><br><span class="line">	 *&#x2F;</span><br><span class="line">    @Adaptive(&quot;loadbalance&quot;)</span><br><span class="line">	&lt;T&gt; Invoker&lt;T&gt; select(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) throws RpcException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中透露出如下几个信息：默认如果不配置，使用RandomLoadBalance策略(加权随机负载算法）。整个Dubbo的负载均衡类图如下所示：<br><img src="https://img-blog.csdn.net/20180706123312775?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>上述各种路由负载策略，对应的配置值如下：dubbo-cluster\src\main\resources\META-INF\dubbo\internal\com.alibaba.dubbo.rpc.cluster.LoadBalance</p>
<ul>
<li>random<br> random=com.alibaba.dubbo.rpc.cluster.loadbalance.RandomLoadBalance</li>
<li>roundrobin<br> roundrobin=com.alibaba.dubbo.rpc.cluster.loadbalance.RoundRobinLoadBalance</li>
<li>leastactive<br> leastactive=com.alibaba.dubbo.rpc.cluster.loadbalance.LeastActiveLoadBalance</li>
<li>consistenthash<br>consistenthash=com.alibaba.dubbo.rpc.cluster.loadbalance.ConsistentHashLoadBalance<br>其配置使用，通常一般在&lt; dubbo:consumer/&gt;、&lt; dubbo:service /&gt;、&lt; dubbo:reference /&gt;的loadbalance属性配置，通常&lt; dubbo:consumer/&gt;这个属性指定消费端的默认策略，某些服务需要指定特殊负载均衡策略的话，一般通过&lt; dubbo:reference /&gt;来指定。<br>如果各位对其源码实现比较有兴趣的话，可以看接下来的部分，源码分析各种负载算法的具体实现细节。</li>
</ul>
<h2 id="1、源码分析ConsistentHashLoadBalance（一致性Hash算法）"><a href="#1、源码分析ConsistentHashLoadBalance（一致性Hash算法）" class="headerlink" title="1、源码分析ConsistentHashLoadBalance（一致性Hash算法）"></a>1、源码分析ConsistentHashLoadBalance（一致性Hash算法）</h2><p><img src="https://img-blog.csdn.net/20180706123621108?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>一致Hash算法，通常用在缓存领域，主要解决的问题是当数据节点数量发送变化后，尽量减少数据的迁移，在负责算法领域，个人不建议使用。Dubbo一致性Hash算法的实现逻辑主要分布在ConsistentHashLoadBalance$ConsistentHashSelector中。</p>
<h3 id="1-1-核心属性与构造方法"><a href="#1-1-核心属性与构造方法" class="headerlink" title="1.1 核心属性与构造方法"></a>1.1 核心属性与构造方法</h3><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">private final int                       replicaNumber;</span><br><span class="line">private final int                       identityHashCode;</span><br><span class="line">private final int[]                     argumentIndex;</span><br></pre></td></tr></table></figure>
<p>TreeMap&lt; Long, Invoker&lt; T&gt;&gt; virtualInvokers：虚拟节点，使用TreeMap实现Hash环，将Invoker分布在环上。</p>
<ul>
<li>int                       replicaNumber：虚拟节点个数。</li>
<li> int                       identityHashCode：HashCode。</li>
<li>int[]                     argumentIndex：需要参与hash的参数索引,,argumentIndex = [0,1]表示服务方法的第一个，第二个参数参与hashcode计算。<br>接下来看一下其构造方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, int identityHashCode) &#123;</span><br><span class="line">    this.virtualInvokers &#x3D; new TreeMap&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">    this.identityHashCode &#x3D; System.identityHashCode(invokers);    &#x2F;&#x2F; @1</span><br><span class="line">    URL url &#x3D; invokers.get(0).getUrl();</span><br><span class="line">    this.replicaNumber &#x3D; url.getMethodParameter(methodName, &quot;hash.nodes&quot;, 160);   &#x2F;&#x2F; @2</span><br><span class="line">    String[] index &#x3D; Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, &quot;hash.arguments&quot;, &quot;0&quot;));   &#x2F;&#x2F; @3 start</span><br><span class="line">    argumentIndex &#x3D; new int[index.length];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; index.length; i ++) &#123;</span><br><span class="line">          argumentIndex[i] &#x3D; Integer.parseInt(index[i]);</span><br><span class="line">    &#125;  &#x2F;&#x2F; @3 end</span><br><span class="line">    for (Invoker&lt;T&gt; invoker : invokers) &#123;    &#x2F;&#x2F; @4</span><br><span class="line">         for (int i &#x3D; 0; i &lt; replicaNumber &#x2F; 4; i++) &#123;</span><br><span class="line">               byte[] digest &#x3D; md5(invoker.getUrl().toFullString() + i);</span><br><span class="line">               for (int h &#x3D; 0; h &lt; 4; h++) &#123; </span><br><span class="line">                     long m &#x3D; hash(digest, h);</span><br><span class="line">                     virtualInvokers.put(m, invoker);  </span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125; &#x2F;&#x2F; @4 end</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据所有的调用者生成一个HashCode，用该HashCode值来判断服务提供者是否发生了变化。</p>
<p>代码@2：获取服务提供者&lt; dubbo:method/&gt;标签的hash.nodes属性，如果为空，默认为160，表示一致性hash算法中虚拟节点数量。其配置方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt; dubbo:method ... &gt;</span><br><span class="line">    &lt; dubbo:parameter key&#x3D;&quot;hash.nodes&quot; value&#x3D;&quot;160&quot; &#x2F;&gt;</span><br><span class="line">    &lt; dubbo:parameter key&#x3D;&quot;hash.arguments&quot; value&#x3D;&quot;0,1&quot; &#x2F;&gt;</span><br><span class="line">&lt; &#x2F;dubbo:method&#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>代码@3：一致性Hash算法，在dubbo中，相同的服务调用参数走固定的节点，hash.arguments表示哪些参数参与hashcode，默认值“0”，表示第一个参数。</p>
<p>代码@4：为每一个Invoker创建replicaNumber 个虚拟节点，每一个节点的Hashcode不同。同一个Invoker不同hashcode的创建逻辑为：invoker.getUrl().toFullString() + i (0-39) 的值，对其md5,然后用该值+h(0-3)的值取hash。一致性hash实现的一个关键是如果将一个Invoker创建的replicaNumber 个虚拟节点(hashcode)能够均匀分布在Hash环上，Dubbo给出的实现如下，由于能力有限，目前并未真正理解如下方法的实现依据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private long hash(byte[] digest, int number) &#123;</span><br><span class="line">            return (((long) (digest[3 + number * 4] &amp; 0xFF) &lt;&lt; 24)</span><br><span class="line">                    | ((long) (digest[2 + number * 4] &amp; 0xFF) &lt;&lt; 16)</span><br><span class="line">                    | ((long) (digest[1 + number * 4] &amp; 0xFF) &lt;&lt; 8)</span><br><span class="line">                    | (digest[number * 4] &amp; 0xFF))</span><br><span class="line">                    &amp; 0xFFFFFFFFL;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，构造函数主要完成一致性Hash算法Hash环的构建，利用了TreeMap的有序性来实现。</p>
<h3 id="1-2-源码分析public-Invoker-lt-T-gt-select-Invocation-invocation"><a href="#1-2-源码分析public-Invoker-lt-T-gt-select-Invocation-invocation" class="headerlink" title="1.2 源码分析public Invoker&lt; T&gt; select(Invocation invocation)"></a>1.2 源码分析public Invoker&lt; T&gt; select(Invocation invocation)</h3><p>根据调用环境根据一致性Hash算法选择一个Invoker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Invoker&lt;T&gt; select(Invocation invocation) &#123;</span><br><span class="line">     String key &#x3D; toKey(invocation.getArguments());   &#x2F;&#x2F; @1</span><br><span class="line">     byte[] digest &#x3D; md5(key);                                      &#x2F;&#x2F; @2</span><br><span class="line">     return selectForKey(hash(digest, 0));                   &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据调用参数，并根据hash.arguments配置值，获取指定的位置的参数值，追加一起返回。<br>代码@2：对Key进行md5签名。<br>代码@3：根据key进行选择调用者。</p>
<h4 id="1-2-1-ConsistentHashLoadBalance-ConsistentHashSelector-selectForKey"><a href="#1-2-1-ConsistentHashLoadBalance-ConsistentHashSelector-selectForKey" class="headerlink" title="1.2.1 ConsistentHashLoadBalance$ConsistentHashSelector#selectForKey"></a>1.2.1 ConsistentHashLoadBalance$ConsistentHashSelector#selectForKey</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">     Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.tailMap(hash, true).firstEntry();    &#x2F;&#x2F; @1</span><br><span class="line">     if (entry &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">     	entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">     &#125;</span><br><span class="line">     return entry.getValue();   &#x2F;&#x2F; @3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1，对虚拟节点，从virtualInvokers中选取一个子集，subMap(hash,ture,lastKey,true),其实就是实现根据待查找hashcode(key)顺时针，选中大于等于指定key的第一个key。<br>代码@2，如果未找到，则返回virtualInvokers第一个key。<br>代码@3：根据key返回指定的Invoker即可。<br>这里实现，应该可以不使用tailMap，代码修改如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Invoker&lt;T&gt; selectForKey(long hash) &#123;</span><br><span class="line">     Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry &#x3D; virtualInvokers.ceilingEntry(hash);</span><br><span class="line">     if(entry &#x3D;&#x3D; null ) &#123;</span><br><span class="line">     	entry &#x3D; virtualInvokers.firstEntry();</span><br><span class="line">     &#125;</span><br><span class="line">     return entry.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要了解TreeMap关于这一块的特性(tailMap、ceillingEntry、headMap)等API的详细解释，可以查看我的另外一篇博文：<a href="https://blog.csdn.net/prestigeding/article/details/80821576">https://blog.csdn.net/prestigeding/article/details/80821576</a></p>
<h2 id="2、源码分析RandomLoadBalance"><a href="#2、源码分析RandomLoadBalance" class="headerlink" title="2、源码分析RandomLoadBalance"></a>2、源码分析RandomLoadBalance</h2><h3 id="2-1-Dubbo预热机制（权重）"><a href="#2-1-Dubbo预热机制（权重）" class="headerlink" title="2.1 Dubbo预热机制（权重）"></a>2.1 Dubbo预热机制（权重）</h3><p>由于roundrobin（加权轮询）、random（加权随机）、leastactive（最小活跃连接数）都与权重有关系，在介绍这两种负载均衡算法之前，我们首先看一下Dubbo关于权重的获取逻辑，代码见AbstractLoadBalance#getWeigh方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected int getWeight(Invoker&lt;?&gt; invoker, Invocation invocation) &#123;</span><br><span class="line">        int weight &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);   &#x2F;&#x2F; @1</span><br><span class="line">        if (weight &gt; 0) &#123;</span><br><span class="line">            long timestamp &#x3D; invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);  &#x2F;&#x2F; @2</span><br><span class="line">            if (timestamp &gt; 0L) &#123;</span><br><span class="line">                int uptime &#x3D; (int) (System.currentTimeMillis() - timestamp);</span><br><span class="line">                int warmup &#x3D; invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);  &#x2F;&#x2F; @3</span><br><span class="line">                if (uptime &gt; 0 &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                    weight &#x3D; calculateWarmupWeight(uptime, warmup, weight);   &#x2F;&#x2F; @4</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return weight;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先获取服务提供者的权重(weight)。</p>
<p>代码@2：获取服务提供者的启动时间，在服务提供者启动时，会将启动时间戳存储在服务提供者的URL中，在服务发现(RegistryDirecotry)服务发现时，会将服务提供者的时间戳KEY，换成REMOTE_TIMESTAMP_KEY，避免与服务消费者的启动时间戳冲突。</p>
<p>代码@3：获取服务提供者是否开启预热机制，通过服务提供者&lt; dubbo:service warmup=””/&gt;参数来设置，如果未设置，去默认值10 * 60 * 1000（10分钟）。</p>
<p>代码@4：如果服务提供者启动时间小于预热时间（预热期间），需要根据启动时间，来计算预热期间服务提供者的权重。<br>AbstractLoadBalance#calculateWarmupWeight</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static int calculateWarmupWeight(int uptime, int warmup, int weight) &#123; &#x2F;&#x2F; @1</span><br><span class="line">        int ww &#x3D; (int) ((float) uptime &#x2F; ((float) warmup &#x2F; (float) weight));</span><br><span class="line">        return ww &lt; 1 ? 1 : (ww &gt; weight ? weight : ww);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数说明，uptime：服务提供者启动时间；warmup：设置的预热时间;weight：服务提供者的权重，该方法在uptime &lt; warmup时被调用<br>该方法的实现，就是在预热期间，根据启动时间，动态返回该服务提供者的权重，并且启动时间越长，返回的权重越接近weight，启动时间超过预热时间，则直接返回weight。<br>该方法单元测试：<br><img src="https://img-blog.csdn.net/20180706124209836?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>其输出结果：<br><img src="https://img-blog.csdn.net/20180706124240681?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="2-2-RandomLoadBalance-加权随机算法实现分析"><a href="#2-2-RandomLoadBalance-加权随机算法实现分析" class="headerlink" title="2.2 RandomLoadBalance 加权随机算法实现分析"></a>2.2 RandomLoadBalance 加权随机算法实现分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size(); &#x2F;&#x2F; Number of invokers                    </span><br><span class="line">        int totalWeight &#x3D; 0; &#x2F;&#x2F; The sum of weights       &#x2F;&#x2F; @1 start</span><br><span class="line">        boolean sameWeight &#x3D; true; &#x2F;&#x2F; Every invoker has the same weight?</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            totalWeight +&#x3D; weight; &#x2F;&#x2F; Sum</span><br><span class="line">            if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                    &amp;&amp; weight !&#x3D; getWeight(invokers.get(i - 1), invocation)) &#123;</span><br><span class="line">                sameWeight &#x3D; false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   &#x2F;&#x2F; @1 end</span><br><span class="line">        if (totalWeight &gt; 0 &amp;&amp; !sameWeight) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            &#x2F;&#x2F; If (not every invoker has the same weight &amp; at least one invoker&#39;s weight&gt;0), select randomly based on totalWeight.</span><br><span class="line">            int offset &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; Return a invoker based on the random value.</span><br><span class="line">            for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">                offset -&#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">                if (offset &lt; 0) &#123;</span><br><span class="line">                    return invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; If all invokers have the same weight value or totalWeight&#x3D;0, return evenly.</span><br><span class="line">        return invokers.get(random.nextInt(length));  &#x2F;&#x2F; @3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先求所有服务提供者的总权重，并判断每个服务提供者的权重是否相同。</p>
<p>代码@2：如果提供者之间的权重不相同，则产生一个随机数(0-totalWeight)，视为offset,然后依次用offset减去服务提供者的权重，如果减去(offset - provider.weight &lt; 0),则该invoker命中。</p>
<p>代码@3：如果服务提供者的权重相同，则随机产生[0-invoker.size)即可。</p>
<h3 id="2-3-RoundRobinLoadBalance-加权轮询算法分析"><a href="#2-3-RoundRobinLoadBalance-加权轮询算法分析" class="headerlink" title="2.3 RoundRobinLoadBalance 加权轮询算法分析"></a>2.3 RoundRobinLoadBalance 加权轮询算法分析</h3><p>加权轮询算法的核心算法是按权重轮询，一个基本点是应该是一个当前序号与服务提供者数量取模，需要结合权重。Dubbo使用如下数据结构存储当前序号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private final ConcurrentMap&lt;String, AtomicPositiveInteger&gt; sequences &#x3D; new ConcurrentHashMap&lt;String, AtomicPositiveInteger&gt;();键值：serviceKey(&lt;dubbo:service interface&#x3D;&quot;&quot;&#x2F;&gt;+ methodname)，每个方法采用不同的计数器。</span><br><span class="line">RoundRobinLoadBalance #doSelect</span><br><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        String key &#x3D; invokers.get(0).getUrl().getServiceKey() + &quot;.&quot; + invocation.getMethodName();    &#x2F;&#x2F; @1</span><br><span class="line">        int length &#x3D; invokers.size(); &#x2F;&#x2F; Number of invokers</span><br><span class="line">        int maxWeight &#x3D; 0; &#x2F;&#x2F; The maximum weight</span><br><span class="line">        int minWeight &#x3D; Integer.MAX_VALUE; &#x2F;&#x2F; The minimum weight</span><br><span class="line">        final LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; invokerToWeightMap &#x3D; new LinkedHashMap&lt;Invoker&lt;T&gt;, IntegerWrapper&gt;();   &#x2F;&#x2F; @2 start</span><br><span class="line">        int weightSum &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;</span><br><span class="line">            int weight &#x3D; getWeight(invokers.get(i), invocation);</span><br><span class="line">            maxWeight &#x3D; Math.max(maxWeight, weight); &#x2F;&#x2F; Choose the maximum weight</span><br><span class="line">            minWeight &#x3D; Math.min(minWeight, weight); &#x2F;&#x2F; Choose the minimum weight</span><br><span class="line">            if (weight &gt; 0) &#123;</span><br><span class="line">                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));</span><br><span class="line">                weightSum +&#x3D; weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   &#x2F;&#x2F; @2 end </span><br><span class="line">        AtomicPositiveInteger sequence &#x3D; sequences.get(key);</span><br><span class="line">        if (sequence &#x3D;&#x3D; null) &#123;</span><br><span class="line">            sequences.putIfAbsent(key, new AtomicPositiveInteger());</span><br><span class="line">            sequence &#x3D; sequences.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        int currentSequence &#x3D; sequence.getAndIncrement();    &#x2F;&#x2F; @3</span><br><span class="line">        if (maxWeight &gt; 0 &amp;&amp; minWeight &lt; maxWeight) &#123;   &#x2F;&#x2F; @4</span><br><span class="line">            int mod &#x3D; currentSequence % weightSum;</span><br><span class="line">            for (int i &#x3D; 0; i &lt; maxWeight; i++) &#123;</span><br><span class="line">                for (Map.Entry&lt;Invoker&lt;T&gt;, IntegerWrapper&gt; each : invokerToWeightMap.entrySet()) &#123;</span><br><span class="line">                    final Invoker&lt;T&gt; k &#x3D; each.getKey();</span><br><span class="line">                    final IntegerWrapper v &#x3D; each.getValue();</span><br><span class="line">                    if (mod &#x3D;&#x3D; 0 &amp;&amp; v.getValue() &gt; 0) &#123;</span><br><span class="line">                        return k;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (v.getValue() &gt; 0) &#123;</span><br><span class="line">                        v.decrement();</span><br><span class="line">                        mod--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; Round robin</span><br><span class="line">        return invokers.get(currentSequence % length);   &#x2F;&#x2F; @5</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：构建ConcurrentMap&lt; String, AtomicPositiveInteger&gt; sequences中的key,以interface+methodname为键，里面存储的是当前序号（轮询）。</p>
<p>代码@2：构建LinkedHashMap&lt; Invoker&lt; T&gt;, IntegerWrapper&gt;存储结构，通过遍历所有Invoker，构建每个Invoker的权重，与此同时算出总权重，并且得出所有服务提供者权重是否相同。</p>
<p>代码@3：获取当前的轮询序号，用于取模。</p>
<p>代码@4：如果服务提供者之间的权重有差别，需要按权重轮询，实现方式是：</p>
<ul>
<li>用当前轮询序号与服务提供者总权重取模，余数为mod。</li>
<li>然后从0循环直到最大权重，针对每一次循环，按同一顺序遍历所有服务提供者，如果mod等于0并且对应的Invoker的权重计算器大于0，则选择该服务提供者；否则，mod–,invoker对应的权重减一，权重是临时比那里LinkedHashMap&lt; Invoker&lt; T&gt;, IntegerWrapper&gt;。由于外层循环的次数为所有服务提供者的最大权重，内层循环当mod等于0时，肯定会有一个服务提供者的权重计数器大于0,而返回对应的服务提供者。返回的服务提供者是第一个满足的服务提供者，后续的服务提供者在下一次就会有机会， 因为下一次mod会增大1，后续的服务提供者通过轮询会被选择，选择的机会，取决于权重的大小。</li>
</ul>
<p>代码@5：如果各服务提供者权重相同，则直接对服务提供者取模即可，轮询后递增。</p>
<h3 id="2-4-LeastActiveLoadBalance"><a href="#2-4-LeastActiveLoadBalance" class="headerlink" title="2.4 LeastActiveLoadBalance"></a>2.4 LeastActiveLoadBalance</h3><p>最少活跃连接数负载均衡算法分析，最小活跃连接数，其核心实现就是，首先找到服务提供者当前最小的活跃连接数，如果一个服务提供者的服务连接数比其他的都要小，则选择这个活跃连接数最小的服务提供者发起调用，如果存在多个服务提供者的活跃连接数，并且是最小的，则在这些服务提供者之间选择加权随机算法选择一个服务提供者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected &lt;T&gt; Invoker&lt;T&gt; doSelect(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation) &#123;</span><br><span class="line">        int length &#x3D; invokers.size(); &#x2F;&#x2F; Number of invokers                                                                                            &#x2F;&#x2F; @1 start</span><br><span class="line">        int leastActive &#x3D; -1; &#x2F;&#x2F; The least active value of all invokers</span><br><span class="line">        int leastCount &#x3D; 0; &#x2F;&#x2F; The number of invokers having the same least active value (leastActive)</span><br><span class="line">        int[] leastIndexs &#x3D; new int[length]; &#x2F;&#x2F; The index of invokers having the same least active value (leastActive)</span><br><span class="line">        int totalWeight &#x3D; 0; &#x2F;&#x2F; The sum of weights</span><br><span class="line">        int firstWeight &#x3D; 0; &#x2F;&#x2F; Initial value, used for comparision</span><br><span class="line">        boolean sameWeight &#x3D; true; &#x2F;&#x2F; Every invoker has the same weight value?                                                      &#x2F;&#x2F; @1 end</span><br><span class="line">        for (int i &#x3D; 0; i &lt; length; i++) &#123;                                                                                                                             &#x2F;&#x2F; @2 </span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; invokers.get(i);</span><br><span class="line">            int active &#x3D; RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive(); &#x2F;&#x2F; Active number</span><br><span class="line">            int weight &#x3D; invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT); &#x2F;&#x2F;          </span><br><span class="line">                                                    &#x2F;&#x2F; Weight</span><br><span class="line">            if (leastActive &#x3D;&#x3D; -1 || active &lt; leastActive) &#123; &#x2F;&#x2F; Restart, when find a invoker having smaller least active value.              &#x2F;&#x2F; @3</span><br><span class="line">                leastActive &#x3D; active; &#x2F;&#x2F; Record the current least active value</span><br><span class="line">                leastCount &#x3D; 1; &#x2F;&#x2F; Reset leastCount, count again based on current leastCount</span><br><span class="line">                leastIndexs[0] &#x3D; i; &#x2F;&#x2F; Reset</span><br><span class="line">                totalWeight &#x3D; weight; &#x2F;&#x2F; Reset</span><br><span class="line">                firstWeight &#x3D; weight; &#x2F;&#x2F; Record the weight the first invoker</span><br><span class="line">                sameWeight &#x3D; true; &#x2F;&#x2F; Reset, every invoker has the same weight value?</span><br><span class="line">            &#125; else if (active &#x3D;&#x3D; leastActive) &#123; &#x2F;&#x2F; If current invoker&#39;s active value equals with leaseActive, then accumulating.       &#x2F;&#x2F; @4</span><br><span class="line">                leastIndexs[leastCount++] &#x3D; i; &#x2F;&#x2F; Record index number of this invoker</span><br><span class="line">                totalWeight +&#x3D; weight; &#x2F;&#x2F; Add this invoker&#39;s weight to totalWeight.</span><br><span class="line">                &#x2F;&#x2F; If every invoker has the same weight?</span><br><span class="line">                if (sameWeight &amp;&amp; i &gt; 0</span><br><span class="line">                        &amp;&amp; weight !&#x3D; firstWeight) &#123;</span><br><span class="line">                    sameWeight &#x3D; false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; assert(leastCount &gt; 0)</span><br><span class="line">        if (leastCount &#x3D;&#x3D; 1) &#123;     &#x2F;&#x2F; @5</span><br><span class="line">            &#x2F;&#x2F; If we got exactly one invoker having the least active value, return this invoker directly.</span><br><span class="line">            return invokers.get(leastIndexs[0]);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!sameWeight &amp;&amp; totalWeight &gt; 0) &#123;    &#x2F;&#x2F; @6</span><br><span class="line">            &#x2F;&#x2F; If (not every invoker has the same weight &amp; at least one invoker&#39;s weight&gt;0), select randomly based on totalWeight.</span><br><span class="line">            int offsetWeight &#x3D; random.nextInt(totalWeight);</span><br><span class="line">            &#x2F;&#x2F; Return a invoker based on the random value.</span><br><span class="line">            for (int i &#x3D; 0; i &lt; leastCount; i++) &#123;</span><br><span class="line">                int leastIndex &#x3D; leastIndexs[i];</span><br><span class="line">                offsetWeight -&#x3D; getWeight(invokers.get(leastIndex), invocation);</span><br><span class="line">                if (offsetWeight &lt;&#x3D; 0)</span><br><span class="line">                    return invokers.get(leastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; If all invokers have the same weight value or totalWeight&#x3D;0, return evenly.</span><br><span class="line">        return invokers.get(leastIndexs[random.nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：解释相关局部变量。</p>
<ul>
<li>length ：服务提供者数量。</li>
<li> leastActive ：服务提供者的最小活跃连接数，初始化为-1。</li>
<li>  leastCount ：服务提供者中都是活跃连接数的个数，例如，3个服务提供者当前的活跃连接数分别为 100,102,100,则leastCount 为2。</li>
<li> leastIndexs：存放拥有活跃连接数的Invoker索引，例如上面100,102,100,则leastIndexs[0]=0， leastIndexs[1] = 2；</li>
<li>  totalWeight：拥有最小活跃连接数的Invoker的总权重。</li>
<li>  firstWeight ：第一个最小活跃连接数的Invoker的权重。</li>
<li>  sameWeight ：拥有最小活跃连接数的Invoker权重是否相同。</li>
</ul>
<p>代码@2：遍历所有的服务提供者，计算上述变量的值。</p>
<p>代码@3：如果leastActive （最小活跃连接数为-1，表示第一次遍历）或最新连接数大于当前遍历的Invoker的活跃连接数,需要reset如下值，重新计算：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leastActive &#x3D; active; &#x2F;&#x2F; Record the current least active value</span><br><span class="line">leastCount &#x3D; 1; &#x2F;&#x2F; Reset leastCount, count again based on current leastCount leastIndexs[0] &#x3D; i; &#x2F;&#x2F; Reset</span><br><span class="line">totalWeight &#x3D; weight; &#x2F;&#x2F; Reset</span><br><span class="line">firstWeight &#x3D; weight; &#x2F;&#x2F; Record the weight the first invoker</span><br><span class="line">sameWeight &#x3D; true; &#x2F;&#x2F; Reset, every invoker has the same weight value?</span><br></pre></td></tr></table></figure>

<p>代码@4：如果当前遍历的服务提供者的活跃数等于leastActive ，则将总权重想加，并在leastIndexs中记录服务提供者序号。</p>
<p>代码@5，如果最小活跃连接数的服务提供者数量只有一个，则直接返回该服务提供者。</p>
<p>代码@6，如果最小活跃连接数的服务提供者有多个，则使用加权随机算法选取服务提供者。</p>
<p>关于Dubbo的4种负载均衡算法的实现细节就分析到这里了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>LoadBalance</tag>
        <tag>一致性Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo集群容错策略</title>
    <url>/posts/b5542131.html</url>
    <content><![CDATA[<div id="vip-container"><p>前面的文章，已经单独对服务发现(Directory、RegistryDirectory)、路由机制(Router)、负载均衡机制(LoadBalance),本节将重点分析集群容错机制(AbstractClusterInvoker) ,AbstractClusterInvoker 就是将上述机制融合在一起，整个集群容错中，上述组件扮演的角色见下图所示，本文将重点分析AbstractClusterInvoker是如何融合这些组件的。<img src="https://img-blog.csdn.net/20180708230808373?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>AbstractClusterInvoker#invoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Result invoke(final Invocation invocation) throws RpcException &#123;</span><br><span class="line">        checkWhetherDestroyed();</span><br><span class="line">        LoadBalance loadbalance &#x3D; null;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers &#x3D; list(invocation);    &#x2F;&#x2F; @1</span><br><span class="line">        if (invokers !&#x3D; null &amp;&amp; !invokers.isEmpty()) &#123;</span><br><span class="line">            loadbalance &#x3D; ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()</span><br><span class="line">                    .getMethodParameter(invocation.getMethodName(), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));      &#x2F;&#x2F; @2</span><br><span class="line">        &#125;</span><br><span class="line">        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);   </span><br><span class="line">        return doInvoke(invocation, invokers, loadbalance);  &#x2F;&#x2F; @3</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据调用上下文，获取服务提供者列表，服务提供者从Directory中获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) throws RpcException &#123;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; invokers &#x3D; directory.list(invocation);</span><br><span class="line">        return invokers;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>最终会调用RegistryDirecotry的list方法，该方法的服务提供者是当该消费者订阅的服务的服务提供者列表发送变化后，会在注册中心产生事件，然后通知消费者更新服务提供者列表（本地缓存）。需要注意的是RegistryDirecotry在返回Invoker之前，已经使用Router进行了一次筛选，具体实现在RegistryDirectory#notify方法时。</p>
<p>代码@2：根据SPI机制，获取负载均衡算法的实现类,根据&lt; dubbo:consumer loadbalance=””/&gt;、&lt; dubbo:reference loadbalance=””/&gt;等标签的配置值，默认为random，加权随机算法。</p>
<p>代码@3：根据调用上下文，服务提供者列表，负载均衡算法选择一服务提供者，具体代码由AbstractClusterInvoker的各个子类实现。</p>
<a id="more"></a>

<p>Dubbo目前支持的集群容错策略在中/dubbo-cluster/src/main/resources/META-INF/dubbo/internal/com.alibaba.dubbo.rpc.cluster.Cluster定义，具体内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mock&#x3D;com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterWrapper</span><br><span class="line">failover&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailoverCluster</span><br><span class="line">failfast&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailfastCluster</span><br><span class="line">failsafe&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailsafeCluster</span><br><span class="line">failback&#x3D;com.alibaba.dubbo.rpc.cluster.support.FailbackCluster</span><br><span class="line">forking&#x3D;com.alibaba.dubbo.rpc.cluster.support.ForkingCluster</span><br><span class="line">available&#x3D;com.alibaba.dubbo.rpc.cluster.support.AvailableCluster</span><br><span class="line">mergeable&#x3D;com.alibaba.dubbo.rpc.cluster.support.MergeableCluster</span><br><span class="line">broadcast&#x3D;com.alibaba.dubbo.rpc.cluster.support.BroadcastCluster</span><br></pre></td></tr></table></figure>
<p>上述各种集群策略，对应的执行器为Cluser+Invoker,例如FailoverCluster对应的Invoker为：FailoverClusterInvoker。</p>
<p>在讲解各种集群容错策略之前，我们首先关注一下AbstractClusterInvoker具体从服务提供者中按照不同的负载均衡算法选取服务提供者的算法。</p>
<h2 id="1、源码分析AbstractClusterInvoker-select"><a href="#1、源码分析AbstractClusterInvoker-select" class="headerlink" title="1、源码分析AbstractClusterInvoker#select"></a>1、源码分析AbstractClusterInvoker#select</h2><p>AbstractClusterInvoker#select</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Invoker&lt;T&gt; select(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws </span><br><span class="line">        RpcException &#123;    &#x2F;&#x2F; @1</span><br><span class="line">    if (invokers &#x3D;&#x3D; null || invokers.isEmpty())</span><br><span class="line">         return null;</span><br><span class="line">    String methodName &#x3D; invocation &#x3D;&#x3D; null ? &quot;&quot; : invocation.getMethodName();</span><br><span class="line">    boolean sticky &#x3D; invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, </span><br><span class="line">                Constants.DEFAULT_CLUSTER_STICKY);     &#x2F;&#x2F; @2</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;ignore overloaded method</span><br><span class="line">            if (stickyInvoker !&#x3D; null &amp;&amp; !invokers.contains(stickyInvoker)) &#123;</span><br><span class="line">                stickyInvoker &#x3D; null;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;ignore concurrency problem</span><br><span class="line">            if (sticky &amp;&amp; stickyInvoker !&#x3D; null &amp;&amp; (selected &#x3D;&#x3D; null || !selected.contains(stickyInvoker))) &#123;</span><br><span class="line">                if (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;</span><br><span class="line">                    return stickyInvoker;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; doSelect(loadbalance, invocation, invokers, selected);   &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">        if (sticky) &#123;</span><br><span class="line">            stickyInvoker &#x3D; invoker;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：参数说明</p>
<ul>
<li>LoadBalance loadbalance：负载均衡算法。</li>
<li>Invocation invocation：服务调用上下文环境。</li>
<li>List&lt; Invoker&lt; T&gt;&gt; invokers：待选的服务提供者列表。</li>
<li>List&lt; Invoker&lt; T&gt;&gt; selected：本次集群测试，已选择的服务提供者。<br>代码@2：sticky机制（粘性），如果开启了粘性机制的话。通过&lt; dubbo:method sticky=”true”/&gt;,默认不开启。如果开启，上一次该服务调用的是哪个服务提供者，只要调用过程中不发生错误，后续都会选择该服务提供者进行调用。<br>代码@3：执行doSelect选择。</li>
</ul>
<h3 id="1-1-源码分析AbstractClusterInvoker-doSelect"><a href="#1-1-源码分析AbstractClusterInvoker-doSelect" class="headerlink" title="1.1 源码分析AbstractClusterInvoker#doSelect"></a>1.1 源码分析AbstractClusterInvoker#doSelect</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Invoker&lt;T&gt; doSelect(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, List&lt;Invoker&lt;T&gt;&gt; selected) throws RpcException &#123;</span><br><span class="line">        if (invokers &#x3D;&#x3D; null || invokers.isEmpty())</span><br><span class="line">            return null;</span><br><span class="line">        if (invokers.size() &#x3D;&#x3D; 1)    &#x2F;&#x2F; @1</span><br><span class="line">            return invokers.get(0);</span><br><span class="line">        &#x2F;&#x2F; If we only have two invokers, use round-robin instead.</span><br><span class="line">        if (invokers.size() &#x3D;&#x3D; 2 &amp;&amp; selected !&#x3D; null &amp;&amp; !selected.isEmpty()) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            return selected.get(0) &#x3D;&#x3D; invokers.get(0) ? invokers.get(1) : invokers.get(0);</span><br><span class="line">        &#125;</span><br><span class="line">        if (loadbalance &#x3D;&#x3D; null) &#123;</span><br><span class="line">            loadbalance &#x3D; ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; loadbalance.select(invokers, getUrl(), invocation);    &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;If the &#96;invoker&#96; is in the  &#96;selected&#96; or invoker is unavailable &amp;&amp; availablecheck is true, reselect.</span><br><span class="line">        if ((selected !&#x3D; null &amp;&amp; selected.contains(invoker))</span><br><span class="line">                || (!invoker.isAvailable() &amp;&amp; getUrl() !&#x3D; null &amp;&amp; availablecheck)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Invoker&lt;T&gt; rinvoker &#x3D; reselect(loadbalance, invocation, invokers, selected, availablecheck);    &#x2F;&#x2F; @4</span><br><span class="line">                if (rinvoker !&#x3D; null) &#123;</span><br><span class="line">                    invoker &#x3D; rinvoker;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    &#x2F;&#x2F;Check the index of current selected invoker, if it&#39;s not the last one, choose the one at index+1.</span><br><span class="line">                    int index &#x3D; invokers.indexOf(invoker);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        &#x2F;&#x2F;Avoid collision</span><br><span class="line">                        invoker &#x3D; index &lt; invokers.size() - 1 ? invokers.get(index + 1) : invoker;</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        logger.warn(e.getMessage() + &quot; may because invokers list dynamic change, ignore.&quot;, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                logger.error(&quot;cluster reselect fail reason is :&quot; + t.getMessage() + &quot; if can not solve, you can set cluster.availablecheck&#x3D;false in url&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return invoker;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果可选Invoker只有一个的话，直接返回该Invoker。<br>代码@2：如果只有两个Invoker，并且其中一个已被选择，返回另外一个未选择的Invoker。<br>代码@3：调用loadBalance负载均衡算法，选择一个服务提供者。<br>代码@4：如果选择的Invoker已被选择，则重新选择，这里有一个疑问，为什么不在选之前，先过滤掉已被选的Invoker。</p>
<p>从服务提供者列表中选择一个服务提供者算法就介绍到这里，接下来将一一分析Dubbo提供的集群容错方式。</p>
<h2 id="2、源码分析Dubbo集群策略"><a href="#2、源码分析Dubbo集群策略" class="headerlink" title="2、源码分析Dubbo集群策略"></a>2、源码分析Dubbo集群策略</h2><h3 id="2-1-源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）"><a href="#2-1-源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）" class="headerlink" title="2.1 源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）"></a>2.1 源码分析FailoverClusterInvoker（FailoverCluster，dubbo默认策略）</h3><p>策略：失败后自动选择其他服务提供者进行重试，重试次数由retries属性设置，&lt; dubbo:reference retries = “2”/&gt;设置，默认为2，代表重试2次，最多执行3次。</p>
<p>FailoverClusterInvoker#doInvoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">      List&lt;Invoker&lt;T&gt;&gt; copyinvokers &#x3D; invokers;</span><br><span class="line">      checkInvokers(copyinvokers, invocation);</span><br><span class="line">      int len &#x3D; getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;      &#x2F;&#x2F; @1</span><br><span class="line">      if (len &lt;&#x3D; 0) &#123;</span><br><span class="line">          len &#x3D; 1;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; retry loop.</span><br><span class="line">      RpcException le &#x3D; null; &#x2F;&#x2F; last exception.</span><br><span class="line">      List&lt;Invoker&lt;T&gt;&gt; invoked &#x3D; new ArrayList&lt;Invoker&lt;T&gt;&gt;(copyinvokers.size()); &#x2F;&#x2F; invoked invokers.</span><br><span class="line">      Set&lt;String&gt; providers &#x3D; new HashSet&lt;String&gt;(len);      &#x2F;&#x2F; @2</span><br><span class="line">      for (int i &#x3D; 0; i &lt; len; i++) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">          &#x2F;&#x2F;Reselect before retry to avoid a change of candidate &#96;invokers&#96;.</span><br><span class="line">          &#x2F;&#x2F;NOTE: if &#96;invokers&#96; changed, then &#96;invoked&#96; also lose accuracy.</span><br><span class="line">          if (i &gt; 0) &#123;     &#x2F;&#x2F; @4</span><br><span class="line">              checkWhetherDestroyed();</span><br><span class="line">              copyinvokers &#x3D; list(invocation);</span><br><span class="line">              &#x2F;&#x2F; check again</span><br><span class="line">              checkInvokers(copyinvokers, invocation);</span><br><span class="line">          &#125;</span><br><span class="line">          Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, copyinvokers, invoked);    &#x2F;&#x2F; @5</span><br><span class="line">          invoked.add(invoker);</span><br><span class="line">          RpcContext.getContext().setInvokers((List) invoked);</span><br><span class="line">          try &#123;</span><br><span class="line">              Result result &#x3D; invoker.invoke(invocation);                                                        &#x2F;&#x2F; @6</span><br><span class="line">              if (le !&#x3D; null &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">                  logger.warn(&quot;Although retry the method &quot; + invocation.getMethodName()</span><br><span class="line">                          + &quot; in the service &quot; + getInterface().getName()</span><br><span class="line">                          + &quot; was successful by the provider &quot; + invoker.getUrl().getAddress()</span><br><span class="line">                          + &quot;, but there have been failed providers &quot; + providers</span><br><span class="line">                          + &quot; (&quot; + providers.size() + &quot;&#x2F;&quot; + copyinvokers.size()</span><br><span class="line">                          + &quot;) from the registry &quot; + directory.getUrl().getAddress()</span><br><span class="line">                          + &quot; on the consumer &quot; + NetUtils.getLocalHost()</span><br><span class="line">                          + &quot; using the dubbo version &quot; + Version.getVersion() + &quot;. Last error is: &quot;</span><br><span class="line">                          + le.getMessage(), le);</span><br><span class="line">              &#125;</span><br><span class="line">              return result;</span><br><span class="line">          &#125; catch (RpcException e) &#123;</span><br><span class="line">              if (e.isBiz()) &#123; &#x2F;&#x2F; biz exception.</span><br><span class="line">                  throw e;</span><br><span class="line">              &#125;</span><br><span class="line">              le &#x3D; e;</span><br><span class="line">          &#125; catch (Throwable e) &#123;</span><br><span class="line">              le &#x3D; new RpcException(e.getMessage(), e);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              providers.add(invoker.getUrl().getAddress());       &#x2F;&#x2F; @7</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      throw new RpcException(le !&#x3D; null ? le.getCode() : 0, &quot;Failed to invoke the method &quot;</span><br><span class="line">              + invocation.getMethodName() + &quot; in the service &quot; + getInterface().getName()</span><br><span class="line">              + &quot;. Tried &quot; + len + &quot; times of the providers &quot; + providers</span><br><span class="line">              + &quot; (&quot; + providers.size() + &quot;&#x2F;&quot; + copyinvokers.size()</span><br><span class="line">              + &quot;) from the registry &quot; + directory.getUrl().getAddress()</span><br><span class="line">              + &quot; on the consumer &quot; + NetUtils.getLocalHost() + &quot; using the dubbo version &quot;</span><br><span class="line">              + Version.getVersion() + &quot;. Last error is: &quot;</span><br><span class="line">              + (le !&#x3D; null ? le.getMessage() : &quot;&quot;), le !&#x3D; null &amp;&amp; le.getCause() !&#x3D; null ? le.getCause() : le);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先校验服务提供者列表，如果为空，则抛出RpcException，提示没有可用的服务提供者。</p>
<p>代码@2：构建Set&lt; Stirng&gt; providers,主要用来已调用服务提供者的地址，如果本次调用失败，将在日志信息中打印已调用的服务提供者信息。</p>
<p>代码@3，循环执行次数，等于retries + 1 次。</p>
<p>代码@4：如果i&gt;0，表示服务调用，在重试，此时需要重新调用Directory#list方法，获取最小的服务提供者列表。</p>
<p>代码@5：根据负载均衡算法，选择Invoker，后续详细分析。</p>
<p>代码@6：根据负载算法，路由算法从服务提供者列表选一个服务提供者，发起RPC调用。</p>
<p>代码@7：将本次服务提供者的地址添加到providers集合中，如果多次重试后，无法完成正常的调用，将在错误日志中包含这些信息。</p>
<h3 id="2-2-源码分析AvailableClusterInvoker"><a href="#2-2-源码分析AvailableClusterInvoker" class="headerlink" title="2.2 源码分析AvailableClusterInvoker"></a>2.2 源码分析AvailableClusterInvoker</h3><p>策略：选择集群第一个可用的服务提供者。<br>缺点：相当于服务的主备，但同时只有一个服务提供者承载流量，并没有使用集群的负载均衡机制。<br>AvailableClusterInvoker#doInvoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        for (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            if (invoker.isAvailable()) &#123;</span><br><span class="line">                return invoker.invoke(invocation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new RpcException(&quot;No provider available in &quot; + invokers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历服务提供者列表，选择第一个可用服务提供者，然后执行RPC服务调用，如果调用失败，则失败。</p>
<h3 id="2-3-源码分析BroadcastClusterInvoker"><a href="#2-3-源码分析BroadcastClusterInvoker" class="headerlink" title="2.3 源码分析BroadcastClusterInvoker"></a>2.3 源码分析BroadcastClusterInvoker</h3><p>策略：广播调用，将调用所有服务提供者，一个服务调用者失败，并不会熔断，并且一个服务提供者调用失败，整个调用认为失败。<br>场景：刷新缓存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result doInvoke(final Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);                                     &#x2F;&#x2F; @1</span><br><span class="line">        RpcContext.getContext().setInvokers((List) invokers);</span><br><span class="line">        RpcException exception &#x3D; null;</span><br><span class="line">        Result result &#x3D; null;</span><br><span class="line">        for (Invoker&lt;T&gt; invoker : invokers) &#123;   &#x2F;&#x2F; @2</span><br><span class="line">            try &#123;    </span><br><span class="line">                result &#x3D; invoker.invoke(invocation);</span><br><span class="line">            &#125; catch (RpcException e) &#123;</span><br><span class="line">                exception &#x3D; e;</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                exception &#x3D; new RpcException(e.getMessage(), e);</span><br><span class="line">                logger.warn(e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (exception !&#x3D; null) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">            throw exception;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检测服务提供者列表，如果为空，则抛出没有服务提供的异常。<br>代码@2：遍历服务提供者列表，依次调用服务提供者的invoker,每个服务调用用try catch语句包裹，当服务调用发生异常时，记录异常信息，但并不立即返回，广播模式，每个服务提供者调用是异步还是同步，取决服务调用的配置，默认是同步调用。<br>代码@3：只要其中一个服务调用发送一次，将抛出异常 信息，异常信息被封装为RpcException。</p>
<h3 id="2-4-源码分析FailbackClusterInvoker"><a href="#2-4-源码分析FailbackClusterInvoker" class="headerlink" title="2.4 源码分析FailbackClusterInvoker"></a>2.4 源码分析FailbackClusterInvoker</h3><p>策略：调用失败后，返回成功，但会在后台定时重试，重试次数（反复）<br>场景：通常用于消息通知，但消费者重启后，重试任务丢失。</p>
<p>FailbackClusterInvoker#doInvoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            checkInvokers(invokers, invocation);  &#x2F;&#x2F; @1</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);   &#x2F;&#x2F; @2</span><br><span class="line">            return invoker.invoke(invocation);   &#x2F;&#x2F; @3</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.error(&quot;Failback to invoke method &quot; + invocation.getMethodName() + &quot;, wait for retry in background. Ignored exception: &quot;</span><br><span class="line">                    + e.getMessage() + &quot;, &quot;, e);</span><br><span class="line">            addFailed(invocation, this);   &#x2F;&#x2F; @4</span><br><span class="line">            return new RpcResult(); &#x2F;&#x2F; ignore</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：校验服务提供者列表，如果为空，则抛出没有服务提供者错误。<br>代码@2：根据负载均衡机制，选择一个服务提供者。<br>代码@3：发起远程服务调用，如果出现异常，调用addFailed方法，添加重试任务，然后返回给调用方成功。</p>
<p>接下来看一下addFailed方法。</p>
<p>FailbackClusterInvoker#addFailed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void addFailed(Invocation invocation, AbstractClusterInvoker&lt;?&gt; router) &#123;  &#x2F;&#x2F; @1 </span><br><span class="line">        if (retryFuture &#x3D;&#x3D; null) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">            synchronized (this) &#123;</span><br><span class="line">                if (retryFuture &#x3D;&#x3D; null) &#123;</span><br><span class="line">                    retryFuture &#x3D; scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;     &#x2F;&#x2F; @3</span><br><span class="line"></span><br><span class="line">                        @Override</span><br><span class="line">                        public void run() &#123;</span><br><span class="line">                            &#x2F;&#x2F; collect retry statistics</span><br><span class="line">                            try &#123;</span><br><span class="line">                                retryFailed();</span><br><span class="line">                            &#125; catch (Throwable t) &#123; &#x2F;&#x2F; Defensive fault tolerance</span><br><span class="line">                                logger.error(&quot;Unexpected error occur at collect statistic&quot;, t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        failed.put(invocation, router);   &#x2F;&#x2F; @4</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：Invocation invocation：调用上下文；AbstractClusterInvoker&lt; ?&gt; router：调用集群策略。</p>
<p>代码@2：如果retryFuture（ScheduledFuture&lt; ?&gt; retryFuture）为空，则加锁创建一个定时调度任务，任务以每隔5s的频率调用retryFailed方法。</p>
<p>代码@3：添加重试任务（ConcurrentMap&lt; Invocation, AbstractClusterInvoker&lt; ?&gt;&gt; failed）。想必retryFailed方法就是遍历failed，一个一个重复调用，如果调用成功则移除，调用不成功，继续放入。</p>
<p>FailbackClusterInvoker#retryFailed</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void retryFailed() &#123;</span><br><span class="line">        if (failed.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for (Map.Entry&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt; entry : new HashMap&lt;Invocation, AbstractClusterInvoker&lt;?&gt;&gt;(    &#x2F;&#x2F; @1</span><br><span class="line">                failed).entrySet()) &#123;</span><br><span class="line">            Invocation invocation &#x3D; entry.getKey();</span><br><span class="line">            Invoker&lt;?&gt; invoker &#x3D; entry.getValue();</span><br><span class="line">            try &#123;</span><br><span class="line">                invoker.invoke(invocation);   &#x2F;&#x2F; @2</span><br><span class="line">                failed.remove(invocation);    &#x2F;&#x2F; @3</span><br><span class="line">            &#125; catch (Throwable e) &#123;</span><br><span class="line">                logger.error(&quot;Failed retry to invoke method &quot; + invocation.getMethodName() + &quot;, waiting again.&quot;, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：遍历待重试列表，然后发起远程调用，如果调用成功，则从集合中移除，如果只选失败，并不会从待重试列表中移除，也就是在消费端不重启的情况下，会一直重复调用，直到成功。</p>
<h3 id="2-5-源码分析FailfastClusterInvoker"><a href="#2-5-源码分析FailfastClusterInvoker" class="headerlink" title="2.5 源码分析FailfastClusterInvoker"></a>2.5 源码分析FailfastClusterInvoker</h3><p>策略：快速失败，服务调用失败后立马抛出异常，不进行重试。<br>场景：是否修改类服务（未实行幂等的服务调用）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);     &#x2F;&#x2F; @1</span><br><span class="line">        Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);   &#x2F;&#x2F; @2</span><br><span class="line">        try &#123;</span><br><span class="line">            return invoker.invoke(invocation);    &#x2F;&#x2F; @3</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            if (e instanceof RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123; &#x2F;&#x2F; biz exception.</span><br><span class="line">                throw (RpcException) e;</span><br><span class="line">            &#125;</span><br><span class="line">            throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, &quot;Failfast invoke providers &quot; + invoker.getUrl() + &quot; &quot; +   </span><br><span class="line">                 loadbalance.getClass().getSimpleName() + &quot; select from all providers &quot; + invokers + &quot; for service &quot; + getInterface().getName() + &quot; method &quot; + </span><br><span class="line">                 invocation.getMethodName() + &quot; on consumer &quot; + NetUtils.getLocalHost() + &quot; use dubbo version &quot; + Version.getVersion() + &quot;, but no luck to </span><br><span class="line">                 perform the invocation. Last error is: &quot; + e.getMessage(), e.getCause() !&#x3D; null ? e.getCause() : e);    &#x2F;&#x2F; @4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检查服务提供者，如果服务提供者列表为空，抛出没有服务提供者错误。<br>代码@2：根据负载算法选择一个服务提供者。<br>代码@3：发起RPC服务调用。<br>代码@4：如果服务调用异常，抛出异常，打印服务消费者，服务提供者信息。</p>
<h3 id="2-6-源码分析FailsafeClusterInvoker"><a href="#2-6-源码分析FailsafeClusterInvoker" class="headerlink" title="2.6 源码分析FailsafeClusterInvoker"></a>2.6 源码分析FailsafeClusterInvoker</h3><p>策略：服务调用失败后，只打印错误日志，然后返回服务调用成功。<br>场景：调用审计，日志类服务接口。</p>
<p>FailsafeClusterInvoker#doInvoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            checkInvokers(invokers, invocation);   &#x2F;&#x2F; @1</span><br><span class="line">            Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, null);  &#x2F;&#x2F; @2</span><br><span class="line">            return invoker.invoke(invocation);   &#x2F;&#x2F; @3</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            logger.error(&quot;Failsafe ignore exception: &quot; + e.getMessage(), e);</span><br><span class="line">            return new RpcResult(); &#x2F;&#x2F; ignore</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检查服务提供者，如果服务提供者列表为空，抛出没有服务提供者错误。<br>代码@2：根据负载算法选择一个服务提供者。<br>代码@3：发起RPC服务调用，如果出现异常，记录错误堆栈信息，并返回成功。</p>
<h3 id="2-7-源码分析ForkingClusterInvoker"><a href="#2-7-源码分析ForkingClusterInvoker" class="headerlink" title="2.7 源码分析ForkingClusterInvoker"></a>2.7 源码分析ForkingClusterInvoker</h3><p>策略：并行调用多个服务提供者，当一个服务提供者返回成功，则返回成功。<br>场景：实时性要求比较高的场景，但浪费服务器资源，通常可以通过forks参数设置并发调用度。</p>
<p>ForkingClusterInvoker#doInvoke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Result doInvoke(final Invocation invocation, List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance) throws RpcException &#123;</span><br><span class="line">        checkInvokers(invokers, invocation);   &#x2F;&#x2F; @1</span><br><span class="line">        final List&lt;Invoker&lt;T&gt;&gt; selected;          </span><br><span class="line">        final int forks &#x3D; getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);              &#x2F;&#x2F; @2</span><br><span class="line">        final int timeout &#x3D; getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);</span><br><span class="line">        if (forks &lt;&#x3D; 0 || forks &gt;&#x3D; invokers.size()) &#123;</span><br><span class="line">            selected &#x3D; invokers;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            selected &#x3D; new ArrayList&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">            for (int i &#x3D; 0; i &lt; forks; i++) &#123;</span><br><span class="line">                &#x2F;&#x2F; TODO. Add some comment here, refer chinese version for more details.</span><br><span class="line">                Invoker&lt;T&gt; invoker &#x3D; select(loadbalance, invocation, invokers, selected);</span><br><span class="line">                if (!selected.contains(invoker)) &#123;&#x2F;&#x2F;Avoid add the same invoker several times.</span><br><span class="line">                    selected.add(invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        RpcContext.getContext().setInvokers((List) selected);</span><br><span class="line">        final AtomicInteger count &#x3D; new AtomicInteger();</span><br><span class="line">        final BlockingQueue&lt;Object&gt; ref &#x3D; new LinkedBlockingQueue&lt;Object&gt;();</span><br><span class="line">        for (final Invoker&lt;T&gt; invoker : selected) &#123;   &#x2F;&#x2F; @3</span><br><span class="line">            executor.execute(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Result result &#x3D; invoker.invoke(invocation);</span><br><span class="line">                        ref.offer(result);</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        int value &#x3D; count.incrementAndGet();</span><br><span class="line">                        if (value &gt;&#x3D; selected.size()) &#123;</span><br><span class="line">                            ref.offer(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            Object ret &#x3D; ref.poll(timeout, TimeUnit.MILLISECONDS);   &#x2F;&#x2F; @4</span><br><span class="line">            if (ret instanceof Throwable) &#123;</span><br><span class="line">                Throwable e &#x3D; (Throwable) ret;</span><br><span class="line">                throw new RpcException(e instanceof RpcException ? ((RpcException) e).getCode() : 0, &quot;Failed to forking invoke provider &quot; + selected + &quot;, but no luck to perform the invocation. Last error is: &quot; + e.getMessage(), e.getCause() !&#x3D; null ? e.getCause() : e);</span><br><span class="line">            &#125;</span><br><span class="line">            return (Result) ret;</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new RpcException(&quot;Failed to forking invoke provider &quot; + selected + &quot;, but no luck to perform the invocation. Last error is: &quot; + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检查服务提供者，如果服务提供者列表为空，抛出没有服务提供者错误。</p>
<p>代码@2：获取forks属性，貌似只能通过在&lt; dubbo:reference /&gt;用&lt; dubbo:parameter key=”forks” value=””/&gt;来设置forks，其默认值为2，如果forks值大于服务提供者的数量，则将调用所有服务提供者，如果forks值小于服务提供者的数量，则使用负载均衡算法，选择forks个服务提供者。</p>
<p>代码@3：依次异步向服务提供者发起RPC调用，并将结果添加到BlockingQueue&lt; Object&gt; ref，如果服务调用发送错误，并且发生错误的个数大于等于本次调用的个数，则将错误信息放入BlockingQueue&lt; Object&gt; ref，否则，将错误数增加1。</p>
<p>代码@4：Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS)，从该队列中获取结果，如果队列未空，则会阻塞等待，直到超时，当有一个调用成功后，将返回，忽略其他调用结果。</p>
<p>本文重点分析了Dubbo集群容错机制，路由发现、路由算法、负载均衡等是如何共同协作完成Dubbo的服务调用，并详细分析了Dubbo各种集群策略，例如failover、failfast、failsafe、failback、forking、available等实现细节。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>集群容错</tag>
        <tag>failover</tag>
        <tag>failfast</tag>
        <tag>failsafe</tag>
        <tag>failback</tag>
        <tag>forking</tag>
        <tag>available</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析RocketMQ ACL实现机制</title>
    <url>/posts/a6ee7996.html</url>
    <content><![CDATA[<div id="vip-container"><p>有关RocketMQ ACL的使用请查看上一篇<a href="https://blog.csdn.net/prestigeding/article/details/94317946">《RocketMQ ACL使用指南》</a>，本文从源码的角度，分析一下RocketMQ ACL的实现原理。</p>
<blockquote>
<p>备注：RocketMQ在4.4.0时引入了ACL机制，本文代码基于RocketMQ4.5.0版本。</p>
</blockquote>
<p>根据RocketMQ ACL使用手册，我们应该首先看一下Broker服务器在开启ACL机制时如何加载配置文件，并如何工作的。</p>
<a id="more"></a>

<h2 id="1、BrokerController-initialAcl"><a href="#1、BrokerController-initialAcl" class="headerlink" title="1、BrokerController#initialAcl"></a>1、BrokerController#initialAcl</h2><p>Broker端ACL的入口代码为：BrokerController#initialAcl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialAcl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.brokerConfig.isAclEnable()) &#123;                           <span class="comment">// @1</span></span><br><span class="line">        log.info(<span class="string">&quot;The broker dose not enable acl&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;AccessValidator&gt; accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (accessValidators == <span class="keyword">null</span> || accessValidators.isEmpty()) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;The broker dose not load the AccessValidator&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AccessValidator accessValidator: accessValidators) &#123;                       <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">final</span> AccessValidator validator = accessValidator;</span><br><span class="line">        <span class="keyword">this</span>.registerServerRPCHook(<span class="keyword">new</span> RPCHook() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//Do not catch the exception</span></span><br><span class="line">                validator.validate(validator.parse(request, remoteAddr));                         <span class="comment">// @4</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterResponse</span><span class="params">(String remoteAddr, RemotingCommand request, RemotingCommand response)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本方法的实现共4个关键点。<br>代码@1：首先判断Broker是否开启了acl，通过配置参数aclEnable指定，默认为false。</p>
<p>代码@2：使用类似SPI机制，加载配置的AccessValidator,该方法返回一个列表，其实现逻辑时读取META-INF/service/org.apache.rocketmq.acl.AccessValidator文件中配置的访问验证器，默认配置内容如下：<br><img src="https://img-blog.csdnimg.cn/20190707120439720.png" alt="在这里插入图片描述"><br>代码@3：遍历配置的访问验证器(AccessValidator),并向Broker处理服务器注册钩子函数，RPCHook的doBeforeRequest方法会在服务端接收到请求，将其请求解码后，执行处理请求之前被调用;RPCHook的doAfterResponse方法会在处理完请求后，将结果返回之前被调用，其调用如图所示：<br><img src="https://img-blog.csdnimg.cn/20190707120505807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>代码@4：在RPCHook#doBeforeRequest方法中调用AccessValidator#validate, 在真实处理命令之前，先执行ACL的验证逻辑，如果拥有该操作的执行权限，则放行，否则抛出AclException。</p>
<p>接下来，我们将重点放到Broker默认实现的访问验证器：PlainAccessValidator。</p>
<h2 id="2、PlainAccessValidator"><a href="#2、PlainAccessValidator" class="headerlink" title="2、PlainAccessValidator"></a>2、PlainAccessValidator</h2><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190707120530560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li>AccessValidator<br>访问验证器接口，主要定义两个接口。<br>1）AccessResource parse(RemotingCommand request, String remoteAddr)<br>从请求头中解析本次请求对应的访问资源，即本次请求需要的访问权限。<br>2）void validate(AccessResource accessResource)<br>根据本次需要访问的权限，与请求用户拥有的权限进行对比验证，判断是拥有权限，如果没有访问该操作的权限，则抛出异常，否则放行。</li>
<li>PlainAccessValidator<br>RocketMQ默认提供的基于yml配置格式的访问验证器。</li>
</ul>
<p>接下来我们重点看一下PlainAccessValidator的parse方法与validate方法的实现细节。在讲解该方法之前，我们首先认识一下RocketMQ封装访问资源的PlainAccessResource。</p>
<h4 id="2-1-2-PlainAccessResource类图"><a href="#2-1-2-PlainAccessResource类图" class="headerlink" title="2.1.2 PlainAccessResource类图"></a>2.1.2 PlainAccessResource类图</h4><p><img src="https://img-blog.csdnimg.cn/20190707120741119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们对其属性一一做个介绍：</p>
<ul>
<li>private String accessKey<br>访问Key，用户名。</li>
<li>private String secretKey<br>用户密码。</li>
<li>private String whiteRemoteAddress<br>远程IP地址白名单。</li>
<li>private boolean admin<br>是否是管理员角色。</li>
<li>private byte defaultTopicPerm = 1<br>默认topic访问权限，即如果没有配置topic的权限，则Topic默认的访问权限为1，表示为DENY。</li>
<li>private byte defaultGroupPerm = 1<br>默认的消费组访问权限，默认为DENY。</li>
<li>private Map&lt;String, Byte&gt; resourcePermMap<br>资源需要的访问权限映射表。</li>
<li>private RemoteAddressStrategy remoteAddressStrategy<br>远程IP地址验证策略。</li>
<li>private int requestCode<br>当前请求的requestCode。</li>
<li>private byte[] content<br>请求头与请求体的内容。</li>
<li>private String signature<br>签名字符串，这是通常的套路，在客户端时，首先将请求参数排序，然后使用secretKey生成签名字符串，服务端重复这个步骤，然后对比签名字符串，如果相同，则认为登录成功，否则失败。</li>
<li>private String secretToken<br>密钥token。</li>
<li>private String recognition<br>目前作用未知，代码中目前未被使用。</li>
</ul>
<h3 id="2-2-构造方法"><a href="#2-2-构造方法" class="headerlink" title="2.2 构造方法"></a>2.2 构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlainAccessValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    aclPlugEngine = <span class="keyword">new</span> PlainPermissionLoader();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数，直接创建PlainPermissionLoader对象，从命名上来看，应该是触发acl规则的加载，即解析plain_acl.yml，接下来会重点探讨，即acl启动流程之配置文件的解析。</p>
<h3 id="2-3-parse方法"><a href="#2-3-parse方法" class="headerlink" title="2.3 parse方法"></a>2.3 parse方法</h3><p>该方法的作用就是从请求命令中解析出本次访问所需要的访问权限，最终构建AccessResource对象，为后续的校验权限做准备。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PlainAccessResource accessResource = <span class="keyword">new</span> PlainAccessResource();</span><br><span class="line"><span class="keyword">if</span> (remoteAddr != <span class="keyword">null</span> &amp;&amp; remoteAddr.contains(<span class="string">&quot;:&quot;</span>)) &#123;</span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr.split(<span class="string">&quot;:&quot;</span>)[<span class="number">0</span>]);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    accessResource.setWhiteRemoteAddress(remoteAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：首先创建PlainAccessResource，从远程地址中提取出远程访问IP地址。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getExtFields() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(<span class="string">&quot;request&#x27;s extFields value is null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">accessResource.setRequestCode(request.getCode());</span><br><span class="line">accessResource.setAccessKey(request.getExtFields().get(SessionCredentials.ACCESS_KEY));</span><br><span class="line">accessResource.setSignature(request.getExtFields().get(SessionCredentials.SIGNATURE));</span><br><span class="line">accessResource.setSecretToken(request.getExtFields().get(SessionCredentials.SECURITY_TOKEN));</span><br></pre></td></tr></table></figure>
<p>Step2：如果请求头中的扩展字段为空，则抛出异常，如果不为空，则从请求头中读取requestCode、accessKey(请求用户名)、签名字符串(signature)、secretToken。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (request.getCode()) &#123;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.SEND_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.PUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.SEND_MESSAGE_V2:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;b&quot;</span>), Permission.PUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;originTopic&quot;</span>), Permission.PUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(<span class="string">&quot;group&quot;</span>)), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.PULL_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(request.getExtFields().get(<span class="string">&quot;consumerGroup&quot;</span>)), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.QUERY_MESSAGE:</span><br><span class="line">                    accessResource.addResourceAndPerm(request.getExtFields().get(<span class="string">&quot;topic&quot;</span>), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.HEART_BEAT:</span><br><span class="line">                    HeartbeatData heartbeatData = HeartbeatData.decode(request.getBody(), HeartbeatData.class);</span><br><span class="line">                    <span class="keyword">for</span> (ConsumerData data : heartbeatData.getConsumerDataSet()) &#123;</span><br><span class="line">                        accessResource.addResourceAndPerm(getRetryTopic(data.getGroupName()), Permission.SUB);</span><br><span class="line">                        <span class="keyword">for</span> (SubscriptionData subscriptionData : data.getSubscriptionDataSet()) &#123;</span><br><span class="line">                            accessResource.addResourceAndPerm(subscriptionData.getTopic(), Permission.SUB);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.UNREGISTER_CLIENT:</span><br><span class="line">                    <span class="keyword">final</span> UnregisterClientRequestHeader unregisterClientRequestHeader =</span><br><span class="line">                        (UnregisterClientRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(UnregisterClientRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(unregisterClientRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.GET_CONSUMER_LIST_BY_GROUP:</span><br><span class="line">                    <span class="keyword">final</span> GetConsumerListByGroupRequestHeader getConsumerListByGroupRequestHeader =</span><br><span class="line">                        (GetConsumerListByGroupRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(GetConsumerListByGroupRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(getConsumerListByGroupRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> RequestCode.UPDATE_CONSUMER_OFFSET:</span><br><span class="line">                    <span class="keyword">final</span> UpdateConsumerOffsetRequestHeader updateConsumerOffsetRequestHeader =</span><br><span class="line">                        (UpdateConsumerOffsetRequestHeader) request</span><br><span class="line">                            .decodeCommandCustomHeader(UpdateConsumerOffsetRequestHeader.class);</span><br><span class="line">                    accessResource.addResourceAndPerm(getRetryTopic(updateConsumerOffsetRequestHeader.getConsumerGroup()), Permission.SUB);</span><br><span class="line">                    accessResource.addResourceAndPerm(updateConsumerOffsetRequestHeader.getTopic(), Permission.SUB);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AclException(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>Step3：根据请求命令，设置本次请求需要拥有的权限，上述代码比较简单，就是从请求中得出本次操作的Topic、消息组名称，为了方便区分topic与消费组，消费组使用消费者对应的重试主题，当成资源的Key，从这里也可以看出，当前版本需要进行ACL权限验证的请求命令如下：</p>
<ul>
<li>SEND_MESSAGE</li>
<li>SEND_MESSAGE_V2</li>
<li>CONSUMER_SEND_MSG_BACK</li>
<li>PULL_MESSAGE</li>
<li>QUERY_MESSAGE</li>
<li>HEART_BEAT</li>
<li>UNREGISTER_CLIENT</li>
<li>GET_CONSUMER_LIST_BY_GROUP</li>
<li>UPDATE_CONSUMER_OFFSET</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Content</span></span><br><span class="line">SortedMap&lt;String, String&gt; map = <span class="keyword">new</span> TreeMap&lt;String, String&gt;();</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : request.getExtFields().entrySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SessionCredentials.SIGNATURE.equals(entry.getKey())) &#123;</span><br><span class="line">        map.put(entry.getKey(), entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">accessResource.setContent(AclUtils.combineRequestContent(request, map));</span><br><span class="line"><span class="keyword">return</span> accessResource;</span><br></pre></td></tr></table></figure>
<p>Step4：对扩展字段进行排序，便于生成签名字符串，然后将扩展字段与请求体(body)写入content字段。完成从请求头中解析出本次请求需要验证的权限。</p>
<h3 id="2-4-validate-方法"><a href="#2-4-validate-方法" class="headerlink" title="2.4 validate 方法"></a>2.4 validate 方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(AccessResource accessResource)</span> </span>&#123;</span><br><span class="line">    aclPlugEngine.validate((PlainAccessResource) accessResource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>验证权限，即根据本次请求需要的权限与当前用户所拥有的权限进行对比，如果符合，则正常执行；否则抛出AclException。</p>
<p>为了揭开配置文件的解析与验证，我们将目光投入到PlainPermissionLoader。</p>
<h2 id="3、PlainPermissionLoader"><a href="#3、PlainPermissionLoader" class="headerlink" title="3、PlainPermissionLoader"></a>3、PlainPermissionLoader</h2><p>该类的主要职责：加载权限，即解析acl主要配置文件plain_acl.yml。</p>
<h3 id="3-1-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190707121053922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>下面对其核心属性与核心方法一一介绍：</p>
<ul>
<li>DEFAULT_PLAIN_ACL_FILE<br>默认acl配置文件名称，默认值为conf/plain_acl.yml。</li>
<li>String fileName<br>acl配置文件名称，默认为DEFAULT_PLAIN_ACL_FILE ,可以通过系统参数-Drocketmq.acl.plain.file=fileName指定。</li>
<li>Map&lt;String, PlainAccessResource&gt; plainAccessResourceMap<br>解析出来的权限配置映射表，以用户名为键。</li>
<li>RemoteAddressStrategyFactory remoteAddressStrategyFactory<br>远程IP解析策略工厂，用于解析白名单IP地址。</li>
<li>boolean isWatchStart<br>是否开启了文件监听，即自动监听plain_acl.yml文件，一旦该文件改变，可在不重启服务器的情况下自动生效。</li>
<li>public PlainPermissionLoader()<br>构造方法。</li>
<li>public void load()<br>加载配置文件。</li>
<li>public void validate(PlainAccessResource plainAccessResource)<br>验证是否有权限访问待访问资源。</li>
</ul>
<h3 id="3-2-PlainPermissionLoader构造方法"><a href="#3-2-PlainPermissionLoader构造方法" class="headerlink" title="3.2 PlainPermissionLoader构造方法"></a>3.2 PlainPermissionLoader构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PlainPermissionLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    load();</span><br><span class="line">    watch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中调用load与watch方法。</p>
<h3 id="3-3-load"><a href="#3-3-load" class="headerlink" title="3.3 load"></a>3.3 load</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, PlainAccessResource&gt; plainAccessResourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;RemoteAddressStrategy&gt; globalWhiteRemoteAddressStrategy = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">String path = fileHome + File.separator + fileName;</span><br><span class="line">JSONObject plainAclConfData = AclUtils.getYamlDataObject(path,JSONObject.class);</span><br></pre></td></tr></table></figure>
<p>Step1：初始化plainAccessResourceMap(用户配置的访问资源，即权限容器)、globalWhiteRemoteAddressStrategy：全局IP白名单访问策略。配置文件，默认为${ROCKETMQ_HOME}/conf/plain_acl.yml。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONArray globalWhiteRemoteAddressesList = plainAclConfData.getJSONArray(<span class="string">&quot;globalWhiteRemoteAddresses&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (globalWhiteRemoteAddressesList != <span class="keyword">null</span> &amp;&amp; !globalWhiteRemoteAddressesList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; globalWhiteRemoteAddressesList.size(); i++) &#123;</span><br><span class="line">        globalWhiteRemoteAddressStrategy.add(remoteAddressStrategyFactory.</span><br><span class="line">        getRemoteAddressStrategy(globalWhiteRemoteAddressesList.getString(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：globalWhiteRemoteAddresses：全局白名单，类型为数组。根据配置的规则，使用remoteAddressStrategyFactory获取一个访问策略，下文会重点介绍其配置规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">JSONArray accounts = plainAclConfData.getJSONArray(<span class="string">&quot;accounts&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (accounts != <span class="keyword">null</span> &amp;&amp; !accounts.isEmpty()) &#123;</span><br><span class="line">    List&lt;PlainAccessConfig&gt; plainAccessConfigList = accounts.toJavaList(PlainAccessConfig.class);</span><br><span class="line">    <span class="keyword">for</span> (PlainAccessConfig plainAccessConfig : plainAccessConfigList) &#123;</span><br><span class="line">        PlainAccessResource plainAccessResource = buildPlainAccessResource(plainAccessConfig);</span><br><span class="line">        plainAccessResourceMap.put(plainAccessResource.getAccessKey(),plainAccessResource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.globalWhiteRemoteAddressStrategy = globalWhiteRemoteAddressStrategy;</span><br><span class="line"><span class="keyword">this</span>.plainAccessResourceMap = plainAccessResourceMap;</span><br></pre></td></tr></table></figure>
<p>Step3：解析plain_acl.yml文件中的另外一个根元素accounts，用户定义的权限信息。从PlainAccessConfig的定义来看，accounts标签下支持如下标签：</p>
<ul>
<li>accessKey</li>
<li>secretKey</li>
<li>whiteRemoteAddress</li>
<li>admin</li>
<li>defaultTopicPerm</li>
<li>defaultGroupPerm</li>
<li>topicPerms</li>
<li>groupPerms<br>上述标签的说明，请参考：:<a href="https://blog.csdn.net/prestigeding/article/details/94317946">《RocketMQ ACL使用指南》</a> 。具体的解析过程比较容易，就不再细说。</li>
</ul>
<p>load方法主要完成acl配置文件的解析，将用户定义的权限加载到内存中。</p>
<h3 id="3-4-watch"><a href="#3-4-watch" class="headerlink" title="3.4 watch"></a>3.4 watch</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String watchFilePath = fileHome + fileName;</span><br><span class="line">        FileWatchService fileWatchService = <span class="keyword">new</span> FileWatchService(<span class="keyword">new</span> String[] &#123;watchFilePath&#125;, <span class="keyword">new</span> FileWatchService.Listener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChanged</span><span class="params">(String path)</span> </span>&#123;   </span><br><span class="line">                    log.info(<span class="string">&quot;The plain acl yml changed, reload the context&quot;</span>);</span><br><span class="line">                    load();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        fileWatchService.start();</span><br><span class="line">        log.info(<span class="string">&quot;Succeed to start AclWatcherService&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>.isWatchStart = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;Failed to start AclWatcherService&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>监听器，默认以500ms的频率判断文件的内容是否变化。在文件内容发生变化后调用load()方法，重新加载配置文件。那FileWatchService是如何判断两个文件的内容发生了变化呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileWatchService#hash</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">hash</span><span class="params">(String filePath)</span> <span class="keyword">throws</span> IOException, NoSuchAlgorithmException </span>&#123;</span><br><span class="line">    Path path = Paths.get(filePath);</span><br><span class="line">    md.update(Files.readAllBytes(path));</span><br><span class="line">    <span class="keyword">byte</span>[] hash = md.digest();</span><br><span class="line">    <span class="keyword">return</span> UtilAll.bytes2string(hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取文件md5签名来做对比，这里为什么不在启动时先记录上一次文件的修改时间，然后先判断其修改时间是否变化，再判断其内容是否真正发生变化。</p>
<h3 id="3-5-validate"><a href="#3-5-validate" class="headerlink" title="3.5 validate"></a>3.5 validate</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check the global white remote addr</span></span><br><span class="line"><span class="keyword">for</span> (RemoteAddressStrategy remoteAddressStrategy : globalWhiteRemoteAddressStrategy) &#123;</span><br><span class="line">    <span class="keyword">if</span> (remoteAddressStrategy.match(plainAccessResource)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：首先使用全局白名单对资源进行验证，只要一个规则匹配，则返回，表示认证成功。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (plainAccessResource.getAccessKey() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No accessKey is configured&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!plainAccessResourceMap.containsKey(plainAccessResource.getAccessKey())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No acl config for %s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br><span class="line">Step2：如果请求信息中，没有设置用户名，则抛出未配置AccessKey异常；如果Broker中并为配置该用户的配置信息，则抛出AclException。</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check the white addr for accesskey</span></span><br><span class="line">PlainAccessResource ownedAccess = plainAccessResourceMap.get(plainAccessResource.getAccessKey());</span><br><span class="line"><span class="keyword">if</span> (ownedAccess.getRemoteAddressStrategy().match(plainAccessResource)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：如果用户配置的白名单与待访问资源规则匹配的话，则直接发认证通过。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Check the signature</span></span><br><span class="line">String signature = AclUtils.calSignature(plainAccessResource.getContent(), ownedAccess.getSecretKey());</span><br><span class="line"><span class="keyword">if</span> (!signature.equals(plainAccessResource.getSignature())) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Check signature failed for accessKey=%s&quot;</span>, plainAccessResource.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：验证签名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">checkPerm(plainAccessResource, ownedAccess);</span><br></pre></td></tr></table></figure>
<p>Step5：调用checkPerm方法，验证需要的权限与拥有的权限是否匹配。</p>
<h4 id="3-5-1-checkPerm"><a href="#3-5-1-checkPerm" class="headerlink" title="3.5.1 checkPerm"></a>3.5.1 checkPerm</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (Permission.needAdminPerm(needCheckedAccess.getRequestCode()) &amp;&amp; !ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;Need admin permission for request code=%d, but accessKey=%s is not&quot;</span>, needCheckedAccess.getRequestCode(), ownedAccess.getAccessKey()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6：如果当前的请求命令属于必须是Admin用户才能访问的权限，并且当前用户并不是管理员角色，则抛出异常，如下命令需要admin角色才能进行的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Byte&gt; needCheckedPermMap = needCheckedAccess.getResourcePermMap();</span><br><span class="line">Map&lt;String, Byte&gt; ownedPermMap = ownedAccess.getResourcePermMap();</span><br><span class="line"><span class="keyword">if</span> (needCheckedPermMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// If the needCheckedPermMap is null,then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> &amp;&amp; ownedAccess.isAdmin()) &#123;</span><br><span class="line">    <span class="comment">// If the ownedPermMap is null and it is an admin user, then return</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step7：如果该请求不需要进行权限验证，则通过认证，如果当前用户的角色是管理员，并且没有配置用户权限，则认证通过，返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Byte&gt; needCheckedEntry : needCheckedPermMap.entrySet()) &#123;</span><br><span class="line">    String resource = needCheckedEntry.getKey();</span><br><span class="line">    Byte neededPerm = needCheckedEntry.getValue();</span><br><span class="line">    <span class="keyword">boolean</span> isGroup = PlainAccessResource.isRetryTopic(resource);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ownedPermMap == <span class="keyword">null</span> || !ownedPermMap.containsKey(resource)) &#123;</span><br><span class="line">        <span class="comment">// Check the default perm</span></span><br><span class="line">        <span class="keyword">byte</span> ownedPerm = isGroup ? ownedAccess.getDefaultGroupPerm() : ownedAccess.getDefaultTopicPerm();</span><br><span class="line">        <span class="keyword">if</span> (!Permission.checkPermission(neededPerm, ownedPerm)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No default permission for %s&quot;</span>, PlainAccessResource.printStr(resource, isGroup)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Permission.checkPermission(neededPerm, ownedPermMap.get(resource))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AclException(String.format(<span class="string">&quot;No default permission for %s&quot;</span>, PlainAccessResource.printStr(resource, isGroup)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step8：遍历需要权限与拥有的权限进行对比，如果配置对应的权限，则判断是否匹配；如果未配置权限，则判断默认权限时是否允许，不允许，则抛出AclException。</p>
<p>验证逻辑就介绍到这里了，下面给出其匹配流程图：<br><img src="https://img-blog.csdnimg.cn/20190707121507431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>上述阐述了从Broker服务器启动、加载acl配置文件流程、动态监听配置文件、服务端权限验证流程，接下来我们看一下客户端关于ACL需要处理的事情。</p>
<h2 id="4、AclClientRPCHook"><a href="#4、AclClientRPCHook" class="headerlink" title="4、AclClientRPCHook"></a>4、AclClientRPCHook</h2><p>回顾一下，我们引入ACL机制后，客户端的代码示例如下：<br><img src="https://img-blog.csdnimg.cn/20190707121547164.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其在创建DefaultMQProducer时，注册AclClientRPCHook钩子，会在向服务端发送远程命令前后执行其钩子函数，接下来我们重点分析一下AclClientRPCHook。</p>
<h3 id="4-1-doBeforeRequest"><a href="#4-1-doBeforeRequest" class="headerlink" title="4.1 doBeforeRequest"></a>4.1 doBeforeRequest</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBeforeRequest</span><span class="params">(String remoteAddr, RemotingCommand request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] total = AclUtils.combineRequestContent(request,</span><br><span class="line">           parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken()));   <span class="comment">// @1</span></span><br><span class="line">    String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey());                                                      <span class="comment">// @2</span></span><br><span class="line">    request.addExtField(SIGNATURE, signature);                                                                                                               <span class="comment">// @3</span></span><br><span class="line">    request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());         </span><br><span class="line">    <span class="comment">// The SecurityToken value is unneccessary,user can choose this one.</span></span><br><span class="line">    <span class="keyword">if</span> (sessionCredentials.getSecurityToken() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：将Request请求参数进行排序，并加入accessKey。</p>
<p>代码@2：对排好序的请参数，使用用户配置的密码生成签名，并最近到扩展字段Signature，然后服务端也会按照相同的算法生成Signature，如果相同，则表示签名验证成功(类似于实现登录的效果)。</p>
<p>代码@3：将Signature、AccessKey等加入到请求头的扩展字段中，服务端拿到这些元数据，结合请求头中的信息，根据配置的权限，进行权限校验。</p>
<p>关于ACL客户端生成签名是一种通用套路，就不在细讲了。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>acl</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析RocketMQ消息轨迹</title>
    <url>/posts/e8f03b64.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文沿着<a href="https://blog.csdn.net/prestigeding/article/details/95922489">《RocketMQ消息轨迹-设计篇》</a>的思路，从如下3个方面对其源码进行解读：</p>
<ol>
<li>发送消息轨迹</li>
<li>消息轨迹格式</li>
<li>存储消息轨迹数据</li>
</ol>
<h2 id="1、发送消息轨迹流程"><a href="#1、发送消息轨迹流程" class="headerlink" title="1、发送消息轨迹流程"></a>1、发送消息轨迹流程</h2><p>首先我们来看一下在消息发送端如何启用消息轨迹，示例代码如下：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceProducer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MQClientException, InterruptedException </span>&#123;</span><br><span class="line">        DefaultMQProducer producer = <span class="keyword">new</span> DefaultMQProducer(<span class="string">&quot;ProducerGroupName&quot;</span>,<span class="keyword">true</span>);      <span class="comment">// @1</span></span><br><span class="line">        producer.setNamesrvAddr(<span class="string">&quot;127.0.0.1:9876&quot;</span>);</span><br><span class="line">        producer.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    Message msg = <span class="keyword">new</span> Message(<span class="string">&quot;TopicTest&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;TagA&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;OrderID188&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;Hello world&quot;</span>.getBytes(RemotingHelper.DEFAULT_CHARSET));</span><br><span class="line">                    SendResult sendResult = producer.send(msg);</span><br><span class="line">                    System.out.printf(<span class="string">&quot;%s%n&quot;</span>, sendResult);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        producer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码可以看出其关键点是在创建DefaultMQProducer时指定开启消息轨迹跟踪。我们不妨浏览一下DefaultMQProducer与启用消息轨迹相关的构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, <span class="keyword">boolean</span> enableMsgTrace)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br></pre></td></tr></table></figure>
<p>参数如下：</p>
<ul>
<li>String producerGroup<br>生产者所属组名。</li>
<li>boolean enableMsgTrace<br>是否开启跟踪消息轨迹，默认为false。</li>
<li>String customizedTraceTopic<br>如果开启消息轨迹跟踪，用来存储消息轨迹数据所属的主题名称，默认为：RMQ_SYS_TRACE_TOPIC。</li>
</ul>
<h3 id="1-1-DefaultMQProducer构造函数"><a href="#1-1-DefaultMQProducer构造函数" class="headerlink" title="1.1 DefaultMQProducer构造函数"></a>1.1 DefaultMQProducer构造函数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook, <span class="keyword">boolean</span> enableMsgTrace,<span class="keyword">final</span> String customizedTraceTopic)</span> </span>&#123;      <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.producerGroup = producerGroup;</span><br><span class="line">    defaultMQProducerImpl = <span class="keyword">new</span> DefaultMQProducerImpl(<span class="keyword">this</span>, rpcHook);</span><br><span class="line">    <span class="comment">//if client open the message trace feature</span></span><br><span class="line">    <span class="keyword">if</span> (enableMsgTrace) &#123;                                                                                                                                                                                            <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AsyncTraceDispatcher dispatcher = <span class="keyword">new</span> AsyncTraceDispatcher(customizedTraceTopic, rpcHook);                                                         </span><br><span class="line">            dispatcher.setHostProducer(<span class="keyword">this</span>.getDefaultMQProducerImpl());</span><br><span class="line">            traceDispatcher = dispatcher;</span><br><span class="line">            <span class="keyword">this</span>.getDefaultMQProducerImpl().registerSendMessageHook(</span><br><span class="line">                <span class="keyword">new</span> SendMessageTraceHookImpl(traceDispatcher));                                                                                                                             <span class="comment">// @3</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;system mqtrace hook init failed ,maybe can&#x27;t send msg trace data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍一下其局部变量。</p>
<ul>
<li>String producerGroup<br>生产者所属组。</li>
<li>RPCHook rpcHook<br>生产者发送钩子函数。</li>
<li>boolean enableMsgTrace<br>是否开启消息轨迹跟踪。</li>
<li>String customizedTraceTopic<br>定制用于存储消息轨迹的数据。</li>
</ul>
<p>代码@2：用来构建AsyncTraceDispatcher，看其名：异步转发消息轨迹数据，稍后重点关注。</p>
<p>代码@3：构建SendMessageTraceHookImpl对象，并使用AsyncTraceDispatcher用来异步转发。</p>
<h3 id="1-2-SendMessageTraceHookImpl钩子函数"><a href="#1-2-SendMessageTraceHookImpl钩子函数" class="headerlink" title="1.2 SendMessageTraceHookImpl钩子函数"></a>1.2 SendMessageTraceHookImpl钩子函数</h3><h4 id="1-2-1-SendMessageTraceHookImpl类图"><a href="#1-2-1-SendMessageTraceHookImpl类图" class="headerlink" title="1.2.1 SendMessageTraceHookImpl类图"></a>1.2.1 SendMessageTraceHookImpl类图</h4><p><img src="https://img-blog.csdnimg.cn/20190803203518449.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>SendMessageHook<br>消息发送钩子函数，用于在消息发送之前、发送之后执行一定的业务逻辑，是记录消息轨迹的最佳扩展点。</li>
<li>TraceDispatcher<br>消息轨迹转发处理器，其默认实现类AsyncTraceDispatcher，异步实现消息轨迹数据的发送。下面对其属性做一个简单的介绍：<ul>
<li>int queueSize<br>异步转发，队列长度，默认为2048，当前版本不能修改。</li>
<li>int batchSize<br>批量消息条数，消息轨迹一次消息发送请求包含的数据条数，默认为100，当前版本不能修改。</li>
<li>int maxMsgSize<br>消息轨迹一次发送的最大消息大小，默认为128K，当前版本不能修改。</li>
<li>DefaultMQProducer traceProducer<br>  用来发送消息轨迹的消息发送者。</li>
<li>ThreadPoolExecutor traceExecuter<br>线程池，用来异步执行消息发送。</li>
<li>AtomicLong discardCount<br>记录丢弃的消息个数。</li>
<li>Thread worker<br>woker线程，主要负责从追加队列中获取一批待发送的消息轨迹数据，提交到线程池中执行。</li>
<li>ArrayBlockingQueue&lt; TraceContext&gt; traceContextQueue<br>消息轨迹TraceContext队列，用来存放待发送到服务端的消息。</li>
<li>ArrayBlockingQueue&lt; Runnable&gt; appenderQueue<br>线程池内部队列，默认长度1024。</li>
<li>DefaultMQPushConsumerImpl hostConsumer<br>消费者信息，记录消息消费时的轨迹信息。</li>
<li>String traceTopicName<br>用于跟踪消息轨迹的topic名称。</li>
</ul>
</li>
</ol>
<h4 id="1-2-2-源码分析SendMessageTraceHookImpl"><a href="#1-2-2-源码分析SendMessageTraceHookImpl" class="headerlink" title="1.2.2 源码分析SendMessageTraceHookImpl"></a>1.2.2 源码分析SendMessageTraceHookImpl</h4><h5 id="1-2-2-1-sendMessageBefore"><a href="#1-2-2-1-sendMessageBefore" class="headerlink" title="1.2.2.1 sendMessageBefore"></a>1.2.2.1 sendMessageBefore</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBefore</span><span class="params">(SendMessageContext context)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//if it is message trace data,then it doesn&#x27;t recorded</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || context.getMessage().getTopic().startsWith(((AsyncTraceDispatcher) localDispatcher).getTraceTopicName())) &#123;   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//build the context content of TuxeTraceContext</span></span><br><span class="line">    TraceContext tuxeContext = <span class="keyword">new</span> TraceContext();</span><br><span class="line">    tuxeContext.setTraceBeans(<span class="keyword">new</span> ArrayList&lt;TraceBean&gt;(<span class="number">1</span>));</span><br><span class="line">    context.setMqTraceContext(tuxeContext);</span><br><span class="line">    tuxeContext.setTraceType(TraceType.Pub);</span><br><span class="line">    tuxeContext.setGroupName(context.getProducerGroup());                                                                                                                       <span class="comment">// @2</span></span><br><span class="line">    <span class="comment">//build the data bean object of message trace</span></span><br><span class="line">    TraceBean traceBean = <span class="keyword">new</span> TraceBean();                                                                                                                                                <span class="comment">// @3</span></span><br><span class="line">    traceBean.setTopic(context.getMessage().getTopic());</span><br><span class="line">    traceBean.setTags(context.getMessage().getTags());</span><br><span class="line">    traceBean.setKeys(context.getMessage().getKeys());</span><br><span class="line">    traceBean.setStoreHost(context.getBrokerAddr());</span><br><span class="line">    traceBean.setBodyLength(context.getMessage().getBody().length);</span><br><span class="line">    traceBean.setMsgType(context.getMsgType());</span><br><span class="line">    tuxeContext.getTraceBeans().add(traceBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果topic主题为消息轨迹的Topic，直接返回。</p>
<p>代码@2：在消息发送上下文中，设置用来跟踪消息轨迹的上下环境，里面主要包含一个TraceBean集合、追踪类型（TraceType.Pub）与生产者所属的组。</p>
<p>代码@3：构建一条跟踪消息，用TraceBean来表示，记录原消息的topic、tags、keys、发送到broker地址、消息体长度等消息。</p>
<p>从上文看出，sendMessageBefore主要的用途就是在消息发送的时候，先准备一部分消息跟踪日志，存储在发送上下文环境中，此时并不会发送消息轨迹数据。</p>
<h5 id="1-2-2-2-sendMessageAfter"><a href="#1-2-2-2-sendMessageAfter" class="headerlink" title="1.2.2.2 sendMessageAfter"></a>1.2.2.2 sendMessageAfter</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageAfter</span><span class="params">(SendMessageContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//if it is message trace data,then it doesn&#x27;t recorded</span></span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span> || context.getMessage().getTopic().startsWith(((AsyncTraceDispatcher) localDispatcher).getTraceTopicName())     <span class="comment">// @1</span></span><br><span class="line">        || context.getMqTraceContext() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult().getRegionId() == <span class="keyword">null</span></span><br><span class="line">        || !context.getSendResult().isTraceOn()) &#123;</span><br><span class="line">        <span class="comment">// if switch is false,skip it</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TraceContext tuxeContext = (TraceContext) context.getMqTraceContext();</span><br><span class="line">    TraceBean traceBean = tuxeContext.getTraceBeans().get(<span class="number">0</span>);                                                                                                <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">int</span> costTime = (<span class="keyword">int</span>) ((System.currentTimeMillis() - tuxeContext.getTimeStamp()) / tuxeContext.getTraceBeans().size());     <span class="comment">// @3</span></span><br><span class="line">    tuxeContext.setCostTime(costTime);                                                                                                                                      <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (context.getSendResult().getSendStatus().equals(SendStatus.SEND_OK)) &#123;                                                                    </span><br><span class="line">        tuxeContext.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tuxeContext.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tuxeContext.setRegionId(context.getSendResult().getRegionId());                                                                                      </span><br><span class="line">    traceBean.setMsgId(context.getSendResult().getMsgId());</span><br><span class="line">    traceBean.setOffsetMsgId(context.getSendResult().getOffsetMsgId());</span><br><span class="line">    traceBean.setStoreTime(tuxeContext.getTimeStamp() + costTime / <span class="number">2</span>);</span><br><span class="line">    localDispatcher.append(tuxeContext);                                                                                                                                   <span class="comment">// @5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果topic主题为消息轨迹的Topic，直接返回。</p>
<p>代码@2：从MqTraceContext中获取跟踪的TraceBean，虽然设计成List结构体，但在消息发送场景，这里的数据永远只有一条，及时是批量发送也不例外。</p>
<p>代码@3：获取消息发送到收到响应结果的耗时。</p>
<p>代码@4：设置costTime(耗时)、success(是否发送成功)、regionId(发送到broker所在的分区)、msgId(消息ID，全局唯一)、offsetMsgId(消息物理偏移量，如果是批量消息，则是最后一条消息的物理偏移量)、storeTime，这里使用的是(客户端发送时间 + 二分之一的耗时)来表示消息的存储时间，这里是一个估值。</p>
<p>代码@5：将需要跟踪的信息通过TraceDispatcher转发到Broker服务器。其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">append</span><span class="params">(<span class="keyword">final</span> Object ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = traceContextQueue.offer((TraceContext) ctx);</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;buffer full&quot;</span> + discardCount.incrementAndGet() + <span class="string">&quot; ,context is &quot;</span> + ctx);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里一个非常关键的点是offer方法的使用，当队列无法容纳新的元素时会立即返回false，并不会阻塞。</p>
<p>接下来将目光转向TraceDispatcher的实现。</p>
<h3 id="1-3-TraceDispatcher实现原理"><a href="#1-3-TraceDispatcher实现原理" class="headerlink" title="1.3 TraceDispatcher实现原理"></a>1.3 TraceDispatcher实现原理</h3><p>TraceDispatcher，用于客户端消息轨迹数据转发到Broker，其默认实现类：AsyncTraceDispatcher。</p>
<h4 id="1-3-1-TraceDispatcher构造函数"><a href="#1-3-1-TraceDispatcher构造函数" class="headerlink" title="1.3.1 TraceDispatcher构造函数"></a>1.3.1 TraceDispatcher构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTraceDispatcher</span><span class="params">(String traceTopicName, RPCHook rpcHook)</span> <span class="keyword">throws</span> MQClientException </span>&#123;    </span><br><span class="line">    <span class="comment">// queueSize is greater than or equal to the n power of 2 of value</span></span><br><span class="line">    <span class="keyword">this</span>.queueSize = <span class="number">2048</span>;</span><br><span class="line">    <span class="keyword">this</span>.batchSize = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">this</span>.maxMsgSize = <span class="number">128000</span>;                                        </span><br><span class="line">    <span class="keyword">this</span>.discardCount = <span class="keyword">new</span> AtomicLong(<span class="number">0L</span>);         </span><br><span class="line">    <span class="keyword">this</span>.traceContextQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;TraceContext&gt;(<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">this</span>.appenderQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueSize);</span><br><span class="line">    <span class="keyword">if</span> (!UtilAll.isBlank(traceTopicName)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.traceTopicName = traceTopicName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.traceTopicName = MixAll.RMQ_SYS_TRACE_TOPIC;</span><br><span class="line">    &#125;                   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">this</span>.traceExecuter = <span class="keyword">new</span> ThreadPoolExecutor(<span class="comment">// :</span></span><br><span class="line">        <span class="number">10</span>, <span class="comment">//</span></span><br><span class="line">        <span class="number">20</span>, <span class="comment">//</span></span><br><span class="line">        <span class="number">1000</span> * <span class="number">60</span>, <span class="comment">//</span></span><br><span class="line">        TimeUnit.MILLISECONDS, <span class="comment">//</span></span><br><span class="line">        <span class="keyword">this</span>.appenderQueue, <span class="comment">//</span></span><br><span class="line">        <span class="keyword">new</span> ThreadFactoryImpl(<span class="string">&quot;MQTraceSendThread_&quot;</span>));</span><br><span class="line">    traceProducer = getAndCreateTraceProducer(rpcHook);      <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：初始化核心属性，该版本这些值都是“固化”的，用户无法修改。</p>
<ul>
<li>queueSize<br>队列长度，默认为2048，异步线程池能够积压的消息轨迹数量。</li>
<li>batchSize<br>一次向Broker批量发送的消息条数，默认为100.</li>
<li>maxMsgSize<br>向Broker汇报消息轨迹时，消息体的总大小不能超过该值，默认为128k。</li>
<li>discardCount<br>整个运行过程中，丢弃的消息轨迹数据，这里要说明一点的是，如果消息TPS发送过大，异步转发线程处理不过来时，会主动丢弃消息轨迹数据。</li>
<li>traceContextQueue<br>traceContext积压队列，客户端(消息发送、消息消费者)在收到处理结果后，将消息轨迹提交到噶队列中，则会立即返回。</li>
<li>appenderQueue<br>提交到Broker线程池中队列。</li>
<li>traceTopicName<br>用于接收消息轨迹的Topic，默认为RMQ_SYS_TRANS_HALF_TOPIC。</li>
<li>traceExecuter<br>用于发送到Broker服务的异步线程池，核心线程数默认为10，最大线程池为20，队列堆积长度2048，线程名称：MQTraceSendThread_。、</li>
<li>traceProducer<br>发送消息轨迹的Producer。</li>
</ul>
<p>代码@2：调用getAndCreateTraceProducer方法创建用于发送消息轨迹的Producer(消息发送者)，下面详细介绍一下其实现。</p>
<h4 id="1-3-2-getAndCreateTraceProducer详解"><a href="#1-3-2-getAndCreateTraceProducer详解" class="headerlink" title="1.3.2 getAndCreateTraceProducer详解"></a>1.3.2 getAndCreateTraceProducer详解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DefaultMQProducer <span class="title">getAndCreateTraceProducer</span><span class="params">(RPCHook rpcHook)</span> </span>&#123;</span><br><span class="line">        DefaultMQProducer traceProducerInstance = <span class="keyword">this</span>.traceProducer;</span><br><span class="line">        <span class="keyword">if</span> (traceProducerInstance == <span class="keyword">null</span>) &#123;  <span class="comment">//@1</span></span><br><span class="line">            traceProducerInstance = <span class="keyword">new</span> DefaultMQProducer(rpcHook);</span><br><span class="line">            traceProducerInstance.setProducerGroup(TraceConstants.GROUP_NAME);</span><br><span class="line">            traceProducerInstance.setSendMsgTimeout(<span class="number">5000</span>);</span><br><span class="line">            traceProducerInstance.setVipChannelEnabled(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// The max size of message is 128K</span></span><br><span class="line">            traceProducerInstance.setMaxMessageSize(maxMsgSize - <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> traceProducerInstance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果还未建立发送者，则创建用于发送消息轨迹的消息发送者，其GroupName为：_INNER_TRACE_PRODUCER，消息发送超时时间5s，最大允许发送消息大小118K。</p>
<h4 id="1-3-3-start"><a href="#1-3-3-start" class="headerlink" title="1.3.3 start"></a>1.3.3 start</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(String nameSrvAddr)</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isStarted.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;     <span class="comment">// @1</span></span><br><span class="line">        traceProducer.setNamesrvAddr(nameSrvAddr);</span><br><span class="line">        traceProducer.setInstanceName(TRACE_INSTANCE_NAME + <span class="string">&quot;_&quot;</span> + nameSrvAddr);</span><br><span class="line">        traceProducer.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.worker = <span class="keyword">new</span> Thread(<span class="keyword">new</span> AsyncRunnable(), <span class="string">&quot;MQ-AsyncTraceDispatcher-Thread-&quot;</span> + dispatcherId);   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">this</span>.worker.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">this</span>.worker.start();                                                                                   </span><br><span class="line">    <span class="keyword">this</span>.registerShutDownHook();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始启动，其调用的时机为启动DefaultMQProducer时，如果启用跟踪消息轨迹，则调用之。</p>
<p>代码@1：如果用于发送消息轨迹的发送者没有启动，则设置nameserver地址，并启动着。</p>
<p>代码@2：启动一个线程，用于执行AsyncRunnable任务，接下来将重点介绍。</p>
<h4 id="1-3-4-AsyncRunnable"><a href="#1-3-4-AsyncRunnable" class="headerlink" title="1.3.4 AsyncRunnable"></a>1.3.4 AsyncRunnable</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">boolean</span> stopped;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            List&lt;TraceContext&gt; contexts = <span class="keyword">new</span> ArrayList&lt;TraceContext&gt;(batchSize);     <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; batchSize; i++) &#123;</span><br><span class="line">                TraceContext context = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//get trace data element from blocking Queue — traceContextQueue</span></span><br><span class="line">                    context = traceContextQueue.poll(<span class="number">5</span>, TimeUnit.MILLISECONDS);        <span class="comment">// @2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    contexts.add(context);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (contexts.size() &gt; <span class="number">0</span>) &#123;                                                                               :</span><br><span class="line">                AsyncAppenderRequest request = <span class="keyword">new</span> AsyncAppenderRequest(contexts);  <span class="comment">// @3</span></span><br><span class="line">                traceExecuter.submit(request);                                                               </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AsyncTraceDispatcher.<span class="keyword">this</span>.stopped) &#123;</span><br><span class="line">                <span class="keyword">this</span>.stopped = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：构建待提交消息跟踪Bean，每次最多发送batchSize，默认为100条。</p>
<p>代码@2：从traceContextQueue中取出一个待提交的TraceContext，设置超时时间为5s，即如何该队列中没有待提交的TraceContext，则最多等待5s。</p>
<p>代码@3：向线程池中提交任务AsyncAppenderRequest。</p>
<h4 id="1-3-5-AsyncAppenderRequest-sendTraceData"><a href="#1-3-5-AsyncAppenderRequest-sendTraceData" class="headerlink" title="1.3.5 AsyncAppenderRequest#sendTraceData"></a>1.3.5 AsyncAppenderRequest#sendTraceData</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTraceData</span><span class="params">(List&lt;TraceContext&gt; contextList)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, List&lt;TraceTransferBean&gt;&gt; transBeanMap = <span class="keyword">new</span> HashMap&lt;String, List&lt;TraceTransferBean&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TraceContext context : contextList) &#123;        <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">if</span> (context.getTraceBeans().isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Topic value corresponding to original message entity content</span></span><br><span class="line">        String topic = context.getTraceBeans().get(<span class="number">0</span>).getTopic();     <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">// Use  original message entity&#x27;s topic as key</span></span><br><span class="line">        String key = topic;</span><br><span class="line">        List&lt;TraceTransferBean&gt; transBeanList = transBeanMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (transBeanList == <span class="keyword">null</span>) &#123;</span><br><span class="line">            transBeanList = <span class="keyword">new</span> ArrayList&lt;TraceTransferBean&gt;();</span><br><span class="line">            transBeanMap.put(key, transBeanList);</span><br><span class="line">        &#125;</span><br><span class="line">        TraceTransferBean traceData = TraceDataEncoder.encoderFromContextBean(context);    <span class="comment">// @3</span></span><br><span class="line">        transBeanList.add(traceData);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;TraceTransferBean&gt;&gt; entry : transBeanMap.entrySet()) &#123;       <span class="comment">// @4</span></span><br><span class="line">        flushData(entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：遍历收集的消息轨迹数据。</p>
<p>代码@2：获取存储消息轨迹的Topic。</p>
<p>代码@3：对TraceContext进行编码，这里是消息轨迹的传输数据，稍后对其详细看一下，了解其上传的格式。</p>
<p>代码@4：将编码后的数据发送到Broker服务器。</p>
<h4 id="1-3-6-TraceDataEncoder-encoderFromContextBean"><a href="#1-3-6-TraceDataEncoder-encoderFromContextBean" class="headerlink" title="1.3.6 TraceDataEncoder#encoderFromContextBean"></a>1.3.6 TraceDataEncoder#encoderFromContextBean</h4><p>根据消息轨迹跟踪类型，其格式会有一些不一样，下面分别来介绍其合适。</p>
<h5 id="1-3-6-1-PUB-消息发送"><a href="#1-3-6-1-PUB-消息发送" class="headerlink" title="1.3.6.1 PUB(消息发送)"></a>1.3.6.1 PUB(消息发送)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> Pub: &#123;</span><br><span class="line">    TraceBean bean = ctx.getTraceBeans().get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//append the content of context and traceBean to transferBean&#x27;s TransData</span></span><br><span class="line">    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getTopic()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getTags()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getStoreHost()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getBodyLength()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgType().ordinal()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getOffsetMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">     .append(ctx.isSuccess()).append(TraceConstants.FIELD_SPLITOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息轨迹数据的协议使用字符串拼接，字段的分隔符号为1，整个数据以2结尾，感觉这个设计还是有点“不可思议”，为什么不直接使用json协议呢？</p>
<h5 id="1-3-6-2-SubBefore-消息消费之前"><a href="#1-3-6-2-SubBefore-消息消费之前" class="headerlink" title="1.3.6.2 SubBefore(消息消费之前)"></a>1.3.6.2 SubBefore(消息消费之前)</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (TraceBean bean : ctx.getTraceBeans()) &#123;</span><br><span class="line">    sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getTimeStamp()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRegionId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getGroupName()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getRetryTimes()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">      .append(bean.getKeys()).append(TraceConstants.FIELD_SPLITOR);<span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>轨迹就是按照上述顺序拼接而成，各个字段使用1分隔，每一条记录使用2结尾。</p>
<h5 id="1-3-2-3-SubAfter（消息消费后）"><a href="#1-3-2-3-SubAfter（消息消费后）" class="headerlink" title="1.3.2.3 SubAfter（消息消费后）"></a>1.3.2.3 SubAfter（消息消费后）</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> SubAfter: &#123;</span><br><span class="line">    <span class="keyword">for</span> (TraceBean bean : ctx.getTraceBeans()) &#123;</span><br><span class="line">        sb.append(ctx.getTraceType()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getRequestId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(bean.getMsgId()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getCostTime()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.isSuccess()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(bean.getKeys()).append(TraceConstants.CONTENT_SPLITOR)<span class="comment">//</span></span><br><span class="line">          .append(ctx.getContextCode()).append(TraceConstants.FIELD_SPLITOR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式编码一样，就不重复多说。</p>
<p>经过上面的源码跟踪，消息发送端的消息轨迹跟踪流程、消息轨迹数据编码协议就清晰了，接下来我们使用一张序列图来结束本部分的讲解。<br><img src="https://img-blog.csdnimg.cn/20190803204514547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其实行文至此，只关注了消息发送的消息轨迹跟踪，消息消费的轨迹跟踪又是如何呢？其实现原理其实是一样的，就是在消息消费前后执行特定的钩子函数，其实现类为ConsumeMessageTraceHookImpl，由于其实现与消息发送的思路类似，故就不详细介绍了。</p>
<h2 id="2、-消息轨迹数据如何存储"><a href="#2、-消息轨迹数据如何存储" class="headerlink" title="2、 消息轨迹数据如何存储"></a>2、 消息轨迹数据如何存储</h2><p>其实从上面的分析，我们已经得知，RocketMQ的消息轨迹数据存储在到Broker上，那消息轨迹的主题名如何指定？其路由信息又怎么分配才好呢？是每台Broker上都创建还是只在其中某台上创建呢？RocketMQ支持系统默认与自定义消息轨迹的主题。</p>
<h3 id="2-1-使用系统默认的主题名称"><a href="#2-1-使用系统默认的主题名称" class="headerlink" title="2.1 使用系统默认的主题名称"></a>2.1 使用系统默认的主题名称</h3><p>RocketMQ默认的消息轨迹主题为：RMQ_SYS_TRACE_TOPIC，那该Topic需要手工创建吗？其路由信息呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isTraceTopicEnable()) &#123;    <span class="comment">// @1</span></span><br><span class="line">        String topic = <span class="keyword">this</span>.brokerController.getBrokerConfig().getMsgTraceTopicName();</span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">new</span> TopicConfig(topic);</span><br><span class="line">        <span class="keyword">this</span>.systemTopicList.add(topic);</span><br><span class="line">        topicConfig.setReadQueueNums(<span class="number">1</span>);                                              <span class="comment">// @2</span></span><br><span class="line">        topicConfig.setWriteQueueNums(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">this</span>.topicConfigTable.put(topicConfig.getTopicName(), topicConfig);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码出自TopicConfigManager的构造函数，在Broker启动的时候会创建topicConfigManager对象，用来管理topic的路由信息。</p>
<p>代码@1：如果Broker开启了消息轨迹跟踪(traceTopicEnable=true)时，会自动创建默认消息轨迹的topic路由信息，注意其读写队列数为1。</p>
<h3 id="2-2-用户自定义消息轨迹主题"><a href="#2-2-用户自定义消息轨迹主题" class="headerlink" title="2.2 用户自定义消息轨迹主题"></a>2.2 用户自定义消息轨迹主题</h3><p>在创建消息发送者、消息消费者时，可以显示的指定消息轨迹的Topic，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQProducer</span><span class="params">(<span class="keyword">final</span> String producerGroup, RPCHook rpcHook, <span class="keyword">boolean</span> enableMsgTrace,<span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultMQPushConsumer</span><span class="params">(<span class="keyword">final</span> String consumerGroup, RPCHook rpcHook,</span></span></span><br><span class="line"><span class="function"><span class="params">        AllocateMessageQueueStrategy allocateMessageQueueStrategy, <span class="keyword">boolean</span> enableMsgTrace, <span class="keyword">final</span> String customizedTraceTopic)</span></span></span><br></pre></td></tr></table></figure>
<p>通过customizedTraceTopic来指定消息轨迹Topic。</p>
<blockquote>
<p>温馨提示：通常在生产环境上，将不会开启自动创建主题，故需要RocketMQ运维管理人员提前创建好Topic。</p>
</blockquote>
<p>好了，本文就介绍到这里了，本文详细介绍了RocktMQ消息轨迹的实现原理，下一篇，我们将进入到多副本的学习中。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>消息轨迹</tag>
      </tags>
  </entry>
  <entry>
    <title>源码解析MyBatis Sharding-Jdbc SQL语句执行流程详解</title>
    <url>/posts/6620f9ec.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将详细介绍Mybatis SQL语句执行的全流程，本文与上篇具有一定的关联性，建议先阅读该系列中的前面3篇文章，重点掌握Mybatis Mapper类的初始化过程，因为在Mybatis中，Mapper是执行SQL语句的入口，类似下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> UserService implements IUserService &#123;</span><br><span class="line"> 	<span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.find(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开始进入本文的主题，以源码为手段，分析Mybatis执行SQL语句的流行，并且使用了数据库分库分表中间件sharding-jdbc,其版本为sharding-jdbc1.4.1。</p>
<p>为了方便大家对本文的源码分析，先给出Mybatis层面核心类的方法调用序列图。</p>
<h2 id="1、SQL执行序列图"><a href="#1、SQL执行序列图" class="headerlink" title="1、SQL执行序列图"></a>1、SQL执行序列图</h2><p><img src="https://img-blog.csdnimg.cn/20190528210928807.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<a id="more"></a>

<h2 id="2、源码解析SQL执行流程"><a href="#2、源码解析SQL执行流程" class="headerlink" title="2、源码解析SQL执行流程"></a>2、源码解析SQL执行流程</h2><p>接下来从从源码的角度对其进行剖析。</p>
<blockquote>
<p>温馨提示：在本文的末尾，还会给出一张详细的Mybatis Shardingjdbc语句执行流程图。（请勿错过哦）。</p>
</blockquote>
<h3 id="2-1-MapperProxy-invoker"><a href="#2-1-MapperProxy-invoker" class="headerlink" title="2.1 MapperProxy#invoker"></a>2.1 MapperProxy#invoker</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);                                     <span class="comment">// @2</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：创建并缓存MapperMethod对象。</p>
<p>代码@2：调用MapperMethod对象的execute方法，即mapperInterface中定义的每一个方法最终会对应一个MapperMethod。</p>
<h3 id="2-2-MapperMethod-execute"><a href="#2-2-MapperMethod-execute" class="headerlink" title="2.2 MapperMethod#execute"></a>2.2 MapperMethod#execute</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="keyword">if</span> (SqlCommandType.INSERT == command.getType()) &#123; </span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.UPDATE == command.getType()) &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.DELETE == command.getType()) &#123;</span><br><span class="line">      Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">      result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SqlCommandType.SELECT == command.getType()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">        executeWithResultHandler(sqlSession, args);</span><br><span class="line">        result = <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">        result = executeForMany(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">        result = executeForMap(sqlSession, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Unknown execution method for: &quot;</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">&quot;Mapper method &#x27;&quot;</span> + command.getName() </span><br><span class="line">          + <span class="string">&quot; attempted to return null from a method with a primitive return type (&quot;</span> + method.getReturnType() + <span class="string">&quot;).&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是根据SQL类型，insert、update、select等操作，执行对应的逻辑，本文我们以查询语句，进行跟踪，进入executeForMany(sqlSession, args)方法。</p>
<h3 id="2-3-MapperMethod-executeForMany"><a href="#2-3-MapperMethod-executeForMany" class="headerlink" title="2.3 MapperMethod#executeForMany"></a>2.3 MapperMethod#executeForMany</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;E&gt; result;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">      result = sqlSession.&lt;E&gt;selectList(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = sqlSession.&lt;E&gt;selectList(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">    <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>该方法也比较简单，最终通过SqlSession调用selectList方法。</p>
<h3 id="2-4-DefaultSqlSession-selectList"><a href="#2-4-DefaultSqlSession-selectList" class="headerlink" title="2.4 DefaultSqlSession#selectList"></a>2.4 DefaultSqlSession#selectList</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">selectList</span><span class="params">(String statement, Object parameter, RowBounds rowBounds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      MappedStatement ms = configuration.getMappedStatement(statement);   <span class="comment">// @1</span></span><br><span class="line">      List&lt;E&gt; result = executor.query(ms, wrapCollection(parameter), rowBounds, Executor.NO_RESULT_HANDLER);   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error querying database.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据资源名称获取对应的MappedStatement对象，此时的statement为资源名称，例如com.demo.UserMapper.findUser。至于MappedStatement对象的生成在上一节初始化时已详细介绍过，此处不再重复介绍。</p>
<p>代码@2：调用Executor的query方法。这里说明一下，其实一开始会进入到CachingExecutor#query方法，由于CachingExecutor的Executor delegate属性默认是SimpleExecutor，故最终还是会进入到SimpleExecutor#query中。</p>
<p>接下来我们进入到SimpleExecutor的父类BaseExecutor的query方法中。</p>
<h3 id="2-5-BaseExecutor-query"><a href="#2-5-BaseExecutor-query" class="headerlink" title="2.5 BaseExecutor#query"></a>2.5 BaseExecutor#query</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    ErrorContext.instance().resource(ms.getResource()).activity(<span class="string">&quot;executing a query&quot;</span>).object(ms.getId());</span><br><span class="line">    <span class="keyword">if</span> (closed) <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Executor was closed.&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span> &amp;&amp; ms.isFlushCacheRequired()) &#123;</span><br><span class="line">      clearLocalCache();</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;E&gt; list;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      queryStack++;</span><br><span class="line">      list = resultHandler == <span class="keyword">null</span> ? (List&lt;E&gt;) localCache.getObject(key) : <span class="keyword">null</span>;                                            <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);                   <span class="comment">// @3</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      queryStack--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (DeferredLoad deferredLoad : deferredLoads) &#123;</span><br><span class="line">        deferredLoad.load();</span><br><span class="line">      &#125;</span><br><span class="line">      deferredLoads.clear(); <span class="comment">// issue #601</span></span><br><span class="line">      <span class="keyword">if</span> (configuration.getLocalCacheScope() == LocalCacheScope.STATEMENT) &#123;                         <span class="comment">// @4</span></span><br><span class="line">        clearLocalCache(); <span class="comment">// issue #482</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍一下该方法的入参，这些类都是Mybatis的重要类：</p>
<ul>
<li>MappedStatement ms<br>映射语句，一个MappedStatemnet对象代表一个Mapper中的一个方法，是映射的最基本对象。</li>
<li>Object parameter<br>SQL语句的参数列表。</li>
<li>RowBounds rowBounds<br>行边界对象，其实就是分页参数limit与size。</li>
<li>ResultHandler resultHandler<br>结果处理Handler。</li>
<li>CacheKey key<br>Mybatis缓存Key</li>
<li>BoundSql boundSql<br>SQL与参数绑定信息，从该对象可以获取在映射文件中的SQL语句。</li>
</ul>
<p>代码@2：首先从缓存中获取，Mybatis支持一级缓存（SqlSession）与二级缓存（多个SqlSession共享）。</p>
<p>代码@3：从数据库查询结果，然后进入到doQuery方法，执行真正的查询动作。</p>
<p>代码@4：如果一级缓存是语句级别的，则语句执行完毕后，删除缓存。</p>
<h3 id="2-6-SimpleExecutor-doQuery"><a href="#2-6-SimpleExecutor-doQuery" class="headerlink" title="2.6 SimpleExecutor#doQuery"></a>2.6 SimpleExecutor#doQuery</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">doQuery</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Configuration configuration = ms.getConfiguration();</span><br><span class="line">      StatementHandler handler = configuration.newStatementHandler(wrapper, ms, parameter, rowBounds, resultHandler, boundSql);   <span class="comment">// @1</span></span><br><span class="line">      stmt = prepareStatement(handler, ms.getStatementLog());                                                                                                                   <span class="comment">// @2</span></span><br><span class="line">      <span class="keyword">return</span> handler.&lt;E&gt;query(stmt, resultHandler);                                                                                                                                        <span class="comment">// @3</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      closeStatement(stmt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：创建StatementHandler，这里会加入Mybatis的插件扩展机制(将在下篇详细介绍)，如图所示：<br><img src="https://img-blog.csdnimg.cn/20190528211610596.png" alt="在这里插入图片描述"><br>代码@2：创建Statement对象，注意，这里就是JDBC协议的java.sql.Statement对象了。</p>
<p>代码@3：使用Statment对象执行SQL语句。</p>
<p>接下来详细介绍Statement对象的创建过程与执行过程，即分布详细跟踪代码@2与代码@3。</p>
<h2 id="3、Statement对象创建流程"><a href="#3、Statement对象创建流程" class="headerlink" title="3、Statement对象创建流程"></a>3、Statement对象创建流程</h2><h3 id="3-1-java-sql-Connection对象创建"><a href="#3-1-java-sql-Connection对象创建" class="headerlink" title="3.1 java.sql.Connection对象创建"></a>3.1 java.sql.Connection对象创建</h3><h4 id="3-1-1-SimpleExecutor-prepareStatement"><a href="#3-1-1-SimpleExecutor-prepareStatement" class="headerlink" title="3.1.1 SimpleExecutor#prepareStatement"></a>3.1.1 SimpleExecutor#prepareStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Statement <span class="title">prepareStatement</span><span class="params">(StatementHandler handler, Log statementLog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    Statement stmt;</span><br><span class="line">    Connection connection = getConnection(statementLog);  <span class="comment">// @1</span></span><br><span class="line">    stmt = handler.prepare(connection);                                  <span class="comment">// @2</span></span><br><span class="line">    handler.parameterize(stmt);                                               <span class="comment">// @3</span></span><br><span class="line">    <span class="keyword">return</span> stmt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建Statement对象，分成三步：<br>代码@1：创建java.sql.Connection对象。</p>
<p>代码@2：使用Connection对象创建Statment对象。</p>
<p>代码@3：对Statement进行额外处理，特别是PrepareStatement的参数设置(ParameterHandler)。</p>
<h4 id="3-1-2-SimpleExecutor-getConnection"><a href="#3-1-2-SimpleExecutor-getConnection" class="headerlink" title="3.1.2 SimpleExecutor#getConnection"></a>3.1.2 SimpleExecutor#getConnection</h4><p>getConnection方法，根据上面流程图所示，先是进入到org.mybatis.spring.transaction.SpringManagedTransaction，再通过spring-jdbc框架，利用DataSourceUtils获取连接，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">doGetConnection</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException </span>&#123;  </span><br><span class="line">		Assert.notNull(dataSource, <span class="string">&quot;No DataSource specified&quot;</span>);</span><br><span class="line">		ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(dataSource); </span><br><span class="line">		<span class="keyword">if</span> (conHolder != <span class="keyword">null</span> &amp;&amp; (conHolder.hasConnection() || conHolder.isSynchronizedWithTransaction())) &#123;</span><br><span class="line">			conHolder.requested();</span><br><span class="line">			<span class="keyword">if</span> (!conHolder.hasConnection()) &#123;</span><br><span class="line">				conHolder.setConnection(dataSource.getConnection());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> conHolder.getConnection();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Else we either got no holder or an empty thread-bound holder here.</span></span><br><span class="line"></span><br><span class="line">		logger.debug(<span class="string">&quot;Fetching JDBC Connection from DataSource&quot;</span>);</span><br><span class="line">		Connection con = dataSource.getConnection();      <span class="comment">// @1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里省略与事务处理相关的代码</span></span><br><span class="line">		<span class="keyword">return</span> con;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：通过DataSource获取connection，那此处的DataSource是“谁”呢？看一下我们工程的配置：<br><img src="https://img-blog.csdnimg.cn/20190528212019407.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190528212039288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>故最终dataSouce.getConnection获取的连接，是从SpringShardingDataSource中获取连接。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">com.dangdang.ddframe.rdb.sharding.jdbc.ShardingDataSource#getConnection</span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardingConnection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        MetricsContext.init(shardingProperties);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingConnection(shardingContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回的结果如下：<br><img src="https://img-blog.csdnimg.cn/20190528212138293.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>备注：这里只是返回了一个ShardingConnection对象，该对象包含了分库分表上下文，但此时并没有执行具体的分库操作（切换数据源）。</p>
<p>Connection的获取流程清楚后，我们继续来看一下Statemnet对象的创建。</p>
<h3 id="3-2-java-sql-Statement对象创建"><a href="#3-2-java-sql-Statement对象创建" class="headerlink" title="3.2 java.sql.Statement对象创建"></a>3.2 java.sql.Statement对象创建</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">stmt = prepareStatement(handler, ms.getStatementLog());            </span><br></pre></td></tr></table></figure>
<p>上面语句的调用链：RoutingStatementHandler -》BaseStatementHandler</p>
<h4 id="3-2-1-BaseStatementHandler-prepare"><a href="#3-2-1-BaseStatementHandler-prepare" class="headerlink" title="3.2.1 BaseStatementHandler#prepare"></a>3.2.1 BaseStatementHandler#prepare</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">prepare</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().sql(boundSql.getSql());</span><br><span class="line">    Statement statement = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      statement = instantiateStatement(connection);    <span class="comment">// @1</span></span><br><span class="line">      setStatementTimeout(statement);                         <span class="comment">// @2</span></span><br><span class="line">      setFetchSize(statement);                                      <span class="comment">// @3</span></span><br><span class="line">      <span class="keyword">return</span> statement;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      closeStatement(statement);</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">&quot;Error preparing statement.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据Connection对象（本文中是ShardingConnection)来创建Statement对象，其默认实现类：PreparedStatementHandler#instantiateStatement方法。</p>
<p>代码@2：为Statement设置超时时间。</p>
<p>代码@3：设置fetchSize。</p>
<h4 id="3-2-2-PreparedStatementHandler-instantiateStatement"><a href="#3-2-2-PreparedStatementHandler-instantiateStatement" class="headerlink" title="3.2.2 PreparedStatementHandler#instantiateStatement"></a>3.2.2 PreparedStatementHandler#instantiateStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Statement <span class="title">instantiateStatement</span><span class="params">(Connection connection)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    String sql = boundSql.getSql();</span><br><span class="line">    <span class="keyword">if</span> (mappedStatement.getKeyGenerator() <span class="keyword">instanceof</span> Jdbc3KeyGenerator) &#123;</span><br><span class="line">      String[] keyColumnNames = mappedStatement.getKeyColumns();</span><br><span class="line">      <span class="keyword">if</span> (keyColumnNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, PreparedStatement.RETURN_GENERATED_KEYS);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql, keyColumnNames);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mappedStatement.getResultSetType() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql, mappedStatement.getResultSetType().getValue(), ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其实Statement对象的创建，就比较简单了，既然Connection是ShardingConnection，那就看一下其对应的prepareStatement方法即可。</p>
<h4 id="3-2-2-ShardingConnection-prepareStatement"><a href="#3-2-2-ShardingConnection-prepareStatement" class="headerlink" title="3.2.2 ShardingConnection#prepareStatement"></a>3.2.2 ShardingConnection#prepareStatement</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(<span class="keyword">final</span> String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;   <span class="comment">// sql，为配置在mybatis xml文件中的sql语句</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShardingPreparedStatement(<span class="keyword">this</span>, sql);</span><br><span class="line">&#125;</span><br><span class="line">ShardingPreparedStatement(<span class="keyword">final</span> ShardingConnection shardingConnection, </span><br><span class="line">            <span class="keyword">final</span> String sql, <span class="keyword">final</span> <span class="keyword">int</span> resultSetType, <span class="keyword">final</span> <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">final</span> <span class="keyword">int</span> resultSetHoldability) &#123;</span><br><span class="line">        <span class="keyword">super</span>(shardingConnection, resultSetType, resultSetConcurrency, resultSetHoldability);</span><br><span class="line">        preparedSQLRouter = shardingConnection.getShardingContext().getSqlRouteEngine().prepareSQL(sql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构建ShardingPreparedStatement对象的时候，会根据SQL语句创建解析SQL路由的解析器对象，但此时并不会执行相关的路由计算，PreparedStatement对象创建完成后，就开始进入SQL执行流程中。</p>
<h2 id="4、SQL执行流程"><a href="#4、SQL执行流程" class="headerlink" title="4、SQL执行流程"></a>4、SQL执行流程</h2><p>接下来我们继续看SimpleExecutor#doQuery方法的第3步，执行SQL语句：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">handler.&lt;E&gt;query(stmt, resultHandler)。</span><br></pre></td></tr></table></figure>
<p>首先会进入RoutingStatementHandler这个类中，进行Mybatis层面的路由（主要是根据Statement类型）<br><img src="https://img-blog.csdnimg.cn/20190528212729690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>然后进入到PreparedStatementHandler#query中。</p>
<h3 id="4-1-PreparedStatementHandler-query"><a href="#4-1-PreparedStatementHandler-query" class="headerlink" title="4.1 PreparedStatementHandler#query"></a>4.1 PreparedStatementHandler#query</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(Statement statement, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    PreparedStatement ps = (PreparedStatement) statement;</span><br><span class="line">    ps.execute();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> resultSetHandler.&lt;E&gt; handleResultSets(ps);  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：调用PreparedStatement的execute方法，由于本例是使用了Sharding-jdbc分库分表，此时调用的具体实现为：ShardingPreparedStatement。</p>
<p>代码@2：处理结果。</p>
<p>我们接下来分别来跟进execute与结果处理方法。</p>
<h3 id="4-2-ShardingPreparedStatement-execute"><a href="#4-2-ShardingPreparedStatement-execute" class="headerlink" title="4.2 ShardingPreparedStatement#execute"></a>4.2 ShardingPreparedStatement#execute</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PreparedStatementExecutor(getShardingConnection().getShardingContext().getExecutorEngine(), routeSQL()).execute(); <span class="comment">// @1</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        clearRouteContext();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里奥妙无穷，其关键点如下：<br>1）创造PreparedStatementExecutor对象，其两个核心参数：</p>
<ul>
<li>ExecutorEngine executorEngine：shardingjdbc执行引擎。</li>
<li>Collection&lt; PreparedStatementExecutorWrapper&gt; preparedStatemenWrappers<br>一个集合，每一个集合是PreparedStatement的包装类，这个集合如何而来？</li>
</ul>
<p>2）preparedStatemenWrappers是通过routeSQL方法产生的。</p>
<p>3）最终调用PreparedStatementExecutor方法的execute来执行。</p>
<p>接下来分别看一下routeSQL与execute方法。</p>
<h3 id="4-3-ShardingPreparedStatement-routeSQL"><a href="#4-3-ShardingPreparedStatement-routeSQL" class="headerlink" title="4.3 ShardingPreparedStatement#routeSQL"></a>4.3 ShardingPreparedStatement#routeSQL</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;PreparedStatementExecutorWrapper&gt; <span class="title">routeSQL</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;PreparedStatementExecutorWrapper&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        SQLRouteResult sqlRouteResult = preparedSQLRouter.route(getParameters());   <span class="comment">// @1</span></span><br><span class="line">        MergeContext mergeContext = sqlRouteResult.getMergeContext();                      </span><br><span class="line">        setMergeContext(mergeContext);</span><br><span class="line">        setGeneratedKeyContext(sqlRouteResult.getGeneratedKeyContext());</span><br><span class="line">        <span class="keyword">for</span> (SQLExecutionUnit each : sqlRouteResult.getExecutionUnits()) &#123;                      <span class="comment">// @2          </span></span><br><span class="line">            PreparedStatement preparedStatement = (PreparedStatement) getStatement(getShardingConnection().getConnection(each.getDataSource(), sqlRouteResult.getSqlStatementType()), each.getSql());     <span class="comment">// @3</span></span><br><span class="line">            replayMethodsInvocation(preparedStatement);</span><br><span class="line">            getParameters().replayMethodsInvocation(preparedStatement);</span><br><span class="line">            result.add(wrap(preparedStatement, each));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：根据SQL参数进行路由计算，本文暂不关注其具体实现细节，这些将在具体分析Sharding-jdbc时具体详解，在这里就直观看一下其结果：</p>
<p>代码@2、@3：对分库分表的结果进行遍历，然后使用底层Datasource来创建Connection，创建PreparedStatement 对象。</p>
<p>routeSQL就暂时讲到这，从这里我们得知，会在这里根据路由结果，使用底层的具体数据源创建对应的Connection与PreparedStatement 对象。</p>
<h3 id="4-4-PreparedStatementExecutor-execute"><a href="#4-4-PreparedStatementExecutor-execute" class="headerlink" title="4.4 PreparedStatementExecutor#execute"></a>4.4 PreparedStatementExecutor#execute</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Context context = MetricsContext.start(<span class="string">&quot;ShardingPreparedStatement-execute&quot;</span>);</span><br><span class="line">    eventPostman.postExecutionEvents();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isExceptionThrown = ExecutorExceptionHandler.isExceptionThrown();</span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; dataMap = ExecutorDataMap.getDataMap();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == preparedStatementExecutorWrappers.size()) &#123;     <span class="comment">// @1</span></span><br><span class="line">            PreparedStatementExecutorWrapper preparedStatementExecutorWrapper = preparedStatementExecutorWrappers.iterator().next();</span><br><span class="line">            <span class="keyword">return</span> executeInternal(preparedStatementExecutorWrapper, isExceptionThrown, dataMap);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Boolean&gt; result = executorEngine.execute(preparedStatementExecutorWrappers, <span class="keyword">new</span> ExecuteUnit&lt;PreparedStatementExecutorWrapper, Boolean&gt;() &#123;    <span class="comment">// @2</span></span><br><span class="line">        </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">execute</span><span class="params">(<span class="keyword">final</span> PreparedStatementExecutorWrapper input)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (input.getPreparedStatement().getConnection()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> executeInternal(input, isExceptionThrown, dataMap);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == result || result.isEmpty()) ? <span class="keyword">false</span> : result.get(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        MetricsContext.stop(context);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果计算出来的路由信息为1个，则同步执行。</p>
<p>代码@2：如果计算出来的路由信息有多个，则使用线程池异步执行。</p>
<p>那还有一个问题，通过PreparedStatement#execute方法执行后，如何返回结果呢？特别是异步执行的。</p>
<p>在上文其实已经谈到：</p>
<h3 id="4-4-DefaultResultSetHandler-handleResultSets"><a href="#4-4-DefaultResultSetHandler-handleResultSets" class="headerlink" title="4.4 DefaultResultSetHandler#handleResultSets"></a>4.4 DefaultResultSetHandler#handleResultSets</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Object&gt; <span class="title">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">&quot;handling results&quot;</span>).object(mappedStatement.getId());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; multipleResults = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSetCount = <span class="number">0</span>;</span><br><span class="line">    ResultSetWrapper rsw = getFirstResultSet(stmt);         <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">//省略部分代码，完整代码可以查看DefaultResultSetHandler方法。</span></span><br><span class="line">    <span class="keyword">return</span> collapseSingleResultList(multipleResults);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultSetWrapper <span class="title">getFirstResultSet</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ResultSet rs = stmt.getResultSet();              <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">while</span> (rs == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// move forward to get the first resultset in case the driver</span></span><br><span class="line">      <span class="comment">// doesn&#x27;t return the resultset as the first result (HSQLDB 2.1)</span></span><br><span class="line">      <span class="keyword">if</span> (stmt.getMoreResults()) &#123;</span><br><span class="line">        rs = stmt.getResultSet();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stmt.getUpdateCount() == -<span class="number">1</span>) &#123;</span><br><span class="line">          <span class="comment">// no more results. Must be no resultset</span></span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rs != <span class="keyword">null</span> ? <span class="keyword">new</span> ResultSetWrapper(rs, configuration) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>我们看一下其关键代码如下：<br>代码@1：调用Statement#getResultSet()方法，如果使用shardingJdbc，则会调用ShardingStatement#getResultSet()，并会处理分库分表结果集的合并，在这里就不详细进行介绍，该部分会在shardingjdbc专栏详细分析。</p>
<p>代码@2：jdbc statement中获取结果集的通用写法，这里也不过多的介绍。</p>
<p>mybatis shardingjdbc SQL执行流程就介绍到这里了，为了方便大家对上述流程的理解，最后给出SQL执行的流程图：<br><img src="https://img-blog.csdnimg.cn/2019052821331476.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>Mybatis Sharding-Jdbc的SQL执行流程就介绍到这里了，从图中也能清晰看到Mybatis的拆件机制，将在下文详细介绍。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
        <tag>Sharding</tag>
        <tag>SQL执行流程</tag>
      </tags>
  </entry>
  <entry>
    <title>踩坑记：rocketmq-console 消费TPS为0，但消息积压数却在降低是个什么“鬼”</title>
    <url>/posts/9b5ea02.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>当消息出现大量挤压后，消费端将其代码优化后，重启消费端服务器，从 rocketmq-console 上发现 TPS 为 0，如图所示：<br><img src="https://img-blog.csdnimg.cn/20191130162947883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>乍一看，第一时间得出应用还未恢复，就开始去查看相关的启动日志,通常查看的是应用服务器的 /home/baseuser/logs/rockemqlogs/rocketmq_client.logs，碰巧又看到如下的错误日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RebalanceService - [BUG] ConsumerGroup: consumergourp-1 The consumerId: consumer-client-id-clusterA-192.168.x.x@21932 not in cidAll: [consumer-client-id-clusterA-192.168.x.x@22164]</span><br></pre></td></tr></table></figure>
<p>上面的日志显示在队列负载时候，当前节点竟然不属于 consumergourp-1 消费组的活跃连接，导致一大片的报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-02 19:29:17 WARN NettyClientPublicExecutor_1 - execute the pull request exception</span><br><span class="line">org.apache.rocketmq.client.exception.MQBrokerException: CODE: 25  DESC: the consumer&#39;s subscription not latest</span><br><span class="line">For more information, please visit the url, http:&#x2F;&#x2F;rocketmq.apache.org&#x2F;docs&#x2F;faq&#x2F;</span><br><span class="line">	at org.apache.rocketmq.client.impl.MQClientAPIImpl.processPullResponse(MQClientAPIImpl.java:639)</span><br><span class="line">	at org.apache.rocketmq.client.impl.MQClientAPIImpl.access$200(MQClientAPIImpl.java:156)</span><br><span class="line">	at org.apache.rocketmq.client.impl.MQClientAPIImpl$2.operationComplete(MQClientAPIImpl.java:592)</span><br><span class="line">	at org.apache.rocketmq.remoting.netty.ResponseFuture.executeInvokeCallback(ResponseFuture.java:51)</span><br><span class="line">	at org.apache.rocketmq.remoting.netty.NettyRemotingAbstract$2.run(NettyRemotingAbstract.java:275)</span><br><span class="line">	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)</span><br><span class="line">	at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<p>乍一看确实是 rocketmq 相关的问题，导致上述 消费TPS 为0，经过半个小时的日志分析，发现这是RocketMQ 这是一种正常现象，最终会自动恢复，这里我留一个<strong>伏笔</strong>，将在我的<strong>知识星球</strong>中与广大星友讨论，<strong>经过日志分析得出 rocketmq 没问题，故后面去查看消息积压，发现消息积压明显在减少，那这就奇了怪了，咋消息积压在快速减少，但为啥消费TPS还是为0呢？</strong></p>
<p>接下来将该问题进行探讨。</p>
<blockquote>
<p>温馨提示：在问题分析部分，作者没有直接给出答案，而是一步一步探寻答案，因此会通过追踪源码来寻求答案，如果大家想急于答案，可以跳过问题分析，直接查看本文末尾的问题解答部分。<br>通过本文的阅读，您将获得如下信息：<br>1、RocketMQ 消费TPS的收集与计算逻辑。<br>2、RocketMQ 监控指标的设计思路。<br>3、RocketMQ 主从同步，消费者从主服务器拉取还是从从服务器拉取的判断逻辑。</p>
</blockquote>
<h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><h4 id="2-1-rocketmq-console-数据获获取逻辑探讨"><a href="#2-1-rocketmq-console-数据获获取逻辑探讨" class="headerlink" title="2.1 rocketmq-console 数据获获取逻辑探讨"></a>2.1 rocketmq-console 数据获获取逻辑探讨</h4><p>要解开消费TPS 显示为０的问题，我们首先要来看一下 rocketmq-console 这个页面的展示逻辑，即通过阅读 rocketmq-console的源码来解开其采集逻辑。<br><img src="https://img-blog.csdnimg.cn/20191130163430404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>得知，【消费者】界面查询各个消费组的基本信息的接口为 /consumer/groupList.query，那接下来，我们首先从源码的角度来分析该接口的实现逻辑。其入口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.rocketmq.console.controller.ConsumerController#list</span><br><span class="line"><span class="meta">@RequestMapping(value = &quot;/groupList.query&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> consumerService.queryGroupList();</span><br><span class="line">&#125;</span><br><span class="line">就是调用消费服务处理类的 queryGroupList 方法，其实现代码如下：</span><br><span class="line">ConsumerServiceImpl＃queryGroupList</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;GroupConsumeInfo&gt; <span class="title">queryGroupList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; consumerGroupSet = Sets.newHashSet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClusterInfo clusterInfo = mqAdminExt.examineBrokerClusterInfo();　　<span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">for</span> (BrokerData brokerData : clusterInfo.getBrokerAddrTable().values()) &#123;   <span class="comment">// @2</span></span><br><span class="line">            SubscriptionGroupWrapper subscriptionGroupWrapper = mqAdminExt.getAllSubscriptionGroup(brokerData.selectBrokerAddr(), <span class="number">3000L</span>);  <span class="comment">// @3</span></span><br><span class="line">            consumerGroupSet.addAll(subscriptionGroupWrapper.getSubscriptionGroupTable().keySet());                                                                 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> Throwables.propagate(err);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;GroupConsumeInfo&gt; groupConsumeInfoList = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">for</span> (String consumerGroup : consumerGroupSet) &#123;                                                <span class="comment">// @4</span></span><br><span class="line">        groupConsumeInfoList.add(queryGroup(consumerGroup));                              </span><br><span class="line">    &#125;</span><br><span class="line">    Collections.sort(groupConsumeInfoList);</span><br><span class="line">    <span class="keyword">return</span> groupConsumeInfoList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：获取集群的 broker 信息，主要是通过向 NameServer 发送 GET_BROKER_CLUSTER_INFO 请求，NameServer 返回集群包含的所有 broker 信息，包含从节点的信息，返回的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;clusterInfo&quot;: &#123;</span><br><span class="line">    &quot;brokerAddrTable&quot;: &#123;</span><br><span class="line">	   &quot;broker-a&quot;: &#123;</span><br><span class="line">	       &quot;cluster&quot;: &quot;DefaultCluster&quot;,</span><br><span class="line">			&quot;brokerName&quot;: &quot;broker-a&quot;,</span><br><span class="line">			&quot;brokerAddrs&quot;: &#123;</span><br><span class="line">				&quot;0&quot;: &quot;192.168.0.168:10911&quot;,</span><br><span class="line">				&quot;1&quot;: &quot;192.168.0.169:10911&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;,</span><br><span class="line">        &quot;broker-b&quot;: &#123;</span><br><span class="line">	       &quot;cluster&quot;: &quot;DefaultCluster&quot;,</span><br><span class="line">			&quot;brokerName&quot;: &quot;broker-b&quot;,</span><br><span class="line">			&quot;brokerAddrs&quot;: &#123;</span><br><span class="line">				&quot;0&quot;: &quot;192.168.0.170:10911&quot;,</span><br><span class="line">				&quot;1&quot;: &quot;192.168.1.171:10911&quot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	&quot;clusterAddrTable&quot;: &#123;</span><br><span class="line">		&quot;DefaultCluster&quot;: [&quot;broker-a&quot;,&quot;broker-b&quot;]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@2：遍历集群中的 brokerAddrTable 数据结构，即存储了 broker 的地址信息的 Map 。</p>
<p>代码@3：分别向集群中的主节点(brokerData.selectBrokerAddr()) 获取所有的订阅关系（即消费组的订阅信息）。然后将所有的消费者组名称存入 consumerGroupSet。</p>
<p>代码@4：遍历代码@3收集到的消费组，调用 queryGroup 依次请求消费组的运行时信息，后面接下来详细分析。</p>
<p>接下来将重点分析 queryGroup方法的实现细节。</p>
<a id="more"></a>

<p>ConsumerServiceImpl#queryGroup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> GroupConsumeInfo <span class="title">queryGroup</span><span class="params">(String consumerGroup)</span> </span>&#123;</span><br><span class="line">    GroupConsumeInfo groupConsumeInfo = <span class="keyword">new</span> GroupConsumeInfo();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ConsumeStats consumeStats = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumeStats = mqAdminExt.examineConsumeStats(consumerGroup);  <span class="comment">// @1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;examineConsumeStats exception, &quot;</span> + consumerGroup, e);</span><br><span class="line">        &#125;</span><br><span class="line">        ConsumerConnection consumerConnection = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            consumerConnection = mqAdminExt.examineConsumerConnectionInfo(consumerGroup); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;examineConsumerConnectionInfo exception, &quot;</span> + consumerGroup, e);</span><br><span class="line">        &#125;</span><br><span class="line">        groupConsumeInfo.setGroup(consumerGroup);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (consumeStats != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupConsumeInfo.setConsumeTps((<span class="keyword">int</span>)consumeStats.getConsumeTps());    <span class="comment">// @2</span></span><br><span class="line">            groupConsumeInfo.setDiffTotal(consumeStats.computeTotalDiff());                   <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (consumerConnection != <span class="keyword">null</span>) &#123;</span><br><span class="line">            groupConsumeInfo.setCount(consumerConnection.getConnectionSet().size());</span><br><span class="line">            groupConsumeInfo.setMessageModel(consumerConnection.getMessageModel());</span><br><span class="line">            groupConsumeInfo.setConsumeType(consumerConnection.getConsumeType());</span><br><span class="line">            groupConsumeInfo.setVersion(MQVersion.getVersionDesc(consumerConnection.computeMinVersion()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warn(<span class="string">&quot;examineConsumeStats or examineConsumerConnectionInfo exception, &quot;</span></span><br><span class="line">                + consumerGroup, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> groupConsumeInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面@1，@2，@3这三处代码可以得知，rocketmq-console 相关界面上的消费TPS主要来自 examineConsumeStats 方法，该方法我就不再继续深入，我们只需找到该方法向 broker 发送的请求编码，然后根据该请求编码找到 broker 的处理逻辑即可，最后跟踪发送的请求编码为：RequestCode.GET_CONSUME_STATS。</p>
<p>GET_CONSUME_STATS 命令在 broker 的处理逻辑如下：</p>
<p>AdminBrokerProcessor#getConsumeStats</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> RemotingCommand <span class="title">getConsumeStats</span><span class="params">(ChannelHandlerContext ctx, RemotingCommand request)</span> <span class="keyword">throws</span> RemotingCommandException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> GetConsumeStatsRequestHeader requestHeader =</span><br><span class="line">            (GetConsumeStatsRequestHeader) request.decodeCommandCustomHeader(GetConsumeStatsRequestHeader.class);</span><br><span class="line">        ConsumeStats consumeStats = <span class="keyword">new</span> ConsumeStats();</span><br><span class="line">        Set&lt;String&gt; topics = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">if</span> (UtilAll.isBlank(requestHeader.getTopic())) &#123;</span><br><span class="line">            topics = <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().whichTopicByConsumer(requestHeader.getConsumerGroup());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            topics.add(requestHeader.getTopic());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String topic : topics) &#123;   <span class="comment">// @1</span></span><br><span class="line">            TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().selectTopicConfig(topic);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;  <span class="comment">// @2</span></span><br><span class="line">                log.warn(<span class="string">&quot;consumeStats, topic config not exist, &#123;&#125;&quot;</span>, topic);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            &#123;                                </span><br><span class="line">                SubscriptionData findSubscriptionData =</span><br><span class="line">                    <span class="keyword">this</span>.brokerController.getConsumerManager().findSubscriptionData(requestHeader.getConsumerGroup(), topic);   <span class="comment">// @3</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == findSubscriptionData <span class="comment">//</span></span><br><span class="line">                    &amp;&amp; <span class="keyword">this</span>.brokerController.getConsumerManager().findSubscriptionDataCount(requestHeader.getConsumerGroup()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    log.warn(<span class="string">&quot;consumeStats, the consumer group[&#123;&#125;], topic[&#123;&#125;] not exist&quot;</span>, requestHeader.getConsumerGroup(), topic);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; topicConfig.getReadQueueNums(); i++) &#123;   <span class="comment">// @4</span></span><br><span class="line">                MessageQueue mq = <span class="keyword">new</span> MessageQueue();</span><br><span class="line">                mq.setTopic(topic);</span><br><span class="line">                mq.setBrokerName(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerName());</span><br><span class="line">                mq.setQueueId(i);</span><br><span class="line">                OffsetWrapper offsetWrapper = <span class="keyword">new</span> OffsetWrapper();</span><br><span class="line">                <span class="keyword">long</span> brokerOffset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, i);</span><br><span class="line">                <span class="keyword">if</span> (brokerOffset &lt; <span class="number">0</span>)</span><br><span class="line">                    brokerOffset = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">long</span> consumerOffset = <span class="keyword">this</span>.brokerController.getConsumerOffsetManager().queryOffset(<span class="comment">//</span></span><br><span class="line">                    requestHeader.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                    topic, <span class="comment">//</span></span><br><span class="line">                    i);</span><br><span class="line">                <span class="keyword">if</span> (consumerOffset &lt; <span class="number">0</span>)</span><br><span class="line">                    consumerOffset = <span class="number">0</span>;</span><br><span class="line">                offsetWrapper.setBrokerOffset(brokerOffset);                                   <span class="comment">// @5</span></span><br><span class="line">                offsetWrapper.setConsumerOffset(consumerOffset);                       <span class="comment">// @6</span></span><br><span class="line">                <span class="keyword">long</span> timeOffset = consumerOffset - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (timeOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">long</span> lastTimestamp = <span class="keyword">this</span>.brokerController.getMessageStore().getMessageStoreTimeStamp(topic, i, timeOffset);</span><br><span class="line">                    <span class="keyword">if</span> (lastTimestamp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        offsetWrapper.setLastTimestamp(lastTimestamp);                 <span class="comment">// @7</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                consumeStats.getOffsetTable().put(mq, offsetWrapper);     <span class="comment">// @8</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">double</span> consumeTps = <span class="keyword">this</span>.brokerController.getBrokerStatsManager().tpsGroupGetNums(requestHeader.getConsumerGroup(), topic); <span class="comment">// @9</span></span><br><span class="line">            consumeTps += consumeStats.getConsumeTps(); <span class="comment">// @10</span></span><br><span class="line">            consumeStats.setConsumeTps(consumeTps);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] body = consumeStats.encode();</span><br><span class="line">        response.setBody(body);</span><br><span class="line">        response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">        response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法比较长，重点关注如下关键点：<br>代码@1：遍历该消费组订阅的所有主题。消费TPS将是所有主题消费TPS的总和，其他的信息按主题、队列信息单独存放。</p>
<p>代码@2：如果 topic 的元信息不存在，则跳过该主题。</p>
<p>代码@3：如果消费组的订阅信息不存在，则跳过该订阅关系。</p>
<p>代码@4：收集该主题所有的读队列，以messagequeue为键，OffsetWrapper为值存储在 consumeStats.getOffsetTable() ，见代码@8。</p>
<p>代码@5：设置该队列的最新偏移量。</p>
<p>代码@6：设置该消费组对该队列的消费进度，设置为consumeOffset。</p>
<p>代码@7：lastTimestamp 上一次消费的消息的存储时间，实现逻辑为：取消费组对于队列的消息消费进度 -1 的消息，存储在 broker 的时间，如果对应的消息已过期被删除，则在界面上显示的时间就会为1970-01-01 08:00:00。</p>
<p>代码@9：通过 BrokerStatsManager 的 tpsGroupGetNums 方法从统计数据中获取该消费组针对该队列的消费TPS。</p>
<p>代码@10：累积消费TPS，并最终作为该消费组的总TPS。</p>
<p><strong>上面这个方法非常关键，是返回给前段页面核心的数据组装逻辑，以队列、消费组为纬度给出 brokerOffset、consumeOffset、lastTimestamp。然后将数据返回给前段页面进行展示。</strong></p>
<p>接下将聚焦到消费组消费TPS的统计处理，其入口为 <strong>tpsGroupGetNums</strong> 。</p>
<h4 id="2-2-rocketmq-消费TPS统计实现原理"><a href="#2-2-rocketmq-消费TPS统计实现原理" class="headerlink" title="2.2 rocketmq 消费TPS统计实现原理"></a>2.2 rocketmq 消费TPS统计实现原理</h4><h5 id="2-2-1-消费TPS计算逻辑"><a href="#2-2-1-消费TPS计算逻辑" class="headerlink" title="2.2.1 消费TPS计算逻辑"></a>2.2.1 消费TPS计算逻辑</h5><p>首先我们还是从 tpsGroupGetNums 方法入手，探究一下 tps 的获取逻辑，然后再探究数据的采集原理（这也是 rocketmq 监控相关）。</p>
<p>BrokerStatsManager#tpsGroupGetNums</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">tpsGroupGetNums</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String statsKey = buildStatsKey(topic, group); <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.statsTable.get(GROUP_GET_NUMS).getStatsDataInMinute(statsKey).getTps(); <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：构建统计key，其逻辑为：其键为：topic@consumerGroup，即消息主题@消费组名。</p>
<p>要读懂 代码@2 的代码，先来看一下 rocketmq 监控指标的存储数据结构，如下图所示：<br><img src="https://img-blog.csdnimg.cn/20191130163718134.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>正如上图所示：RocketMQ  使用 HashMap&lt; String, StatusItemSet&gt; 来存储监控收集的数据，其中Key 为监控指标的类型，例如 topic 发送消息数量、topic 发送消息大小、消费组获取消息个数等信息，每一项使用 StatsItemSet 存储，该存储结构内部又维护一个HashMap：ConcurrentMap，key 代表某一个具体的统计目标，例如记录消费组拉取消息的数量监控指标，那其统计的对象即 topic@consumer_group，最终数据的载体是 StatsItem，使用如下几个关键字段来记录统计信息：</p>
<ul>
<li>AtomicLong value = new AtomicLong(0)<br>总数量，统计指标TOPIC_GET_NUMS 指标为例，记录的是消息拉取的总条数，例如一次消息拉取操作获取了32条消息，则该数量增加32。</li>
<li>AtomicLong times = new AtomicLong(0)<br>改变上述 value 的次数，还是以统计指标TOPIC_GET_NUMS 指标为例，记录的是增加 value 的次数。</li>
<li>LinkedList&lt; CallSnapshot&gt; csListMinute<br>一分钟的快照信息，该 List 只会存储6个元素，每10s记录一次调用快照，超过6条，则移除第一条，这个将在下文介绍。</li>
<li>LinkedList&lt; CallSnapshot&gt; csListHour<br>一小时的快照信息，该 List 只会存储6个元素，每10分钟记录一次快照，超过6条，则移除第一条。</li>
<li>LinkedList&lt; CallSnapshot&gt; csListDay<br>一天的快照新，该List 只会存储24个元素，每1小时记录一次快照，超过24条，则移除第一条。</li>
</ul>
<p>了解了上述存储结构后，代码@2，最终其实调用的就是 StatsItemSet 的 getStatsDataInMinute 方法。</p>
<p>StatsItemSet#getStatsDataInMinute</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatsSnapshot <span class="title">getStatsDataInMinute</span><span class="params">(<span class="keyword">final</span> String statsKey)</span> </span>&#123;</span><br><span class="line">    StatsItem statsItem = <span class="keyword">this</span>.statsItemTable.get(statsKey);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != statsItem) &#123;</span><br><span class="line">        <span class="keyword">return</span> statsItem.getStatsDataInMinute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatsSnapshot();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码上最终调用 StatesItem 的 getStatsDataInMinute 方法。</p>
<p>StatesItem#getStatsDataInMinute</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StatsSnapshot <span class="title">getStatsDataInMinute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> computeStatsData(<span class="keyword">this</span>.csListMinute);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> StatsSnapshot <span class="title">computeStatsData</span><span class="params">(<span class="keyword">final</span> LinkedList&lt;CallSnapshot&gt; csList)</span> </span>&#123;</span><br><span class="line">    StatsSnapshot statsSnapshot = <span class="keyword">new</span> StatsSnapshot();</span><br><span class="line">    <span class="keyword">synchronized</span> (csList) &#123;</span><br><span class="line">        <span class="keyword">double</span> tps = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> avgpt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!csList.isEmpty()) &#123;</span><br><span class="line">            CallSnapshot first = csList.getFirst();   <span class="comment">// @1</span></span><br><span class="line">            CallSnapshot last = csList.getLast();    <span class="comment">// @2</span></span><br><span class="line">            sum = last.getValue() - first.getValue();  <span class="comment">// @3</span></span><br><span class="line">            tps = (sum * <span class="number">1000.0d</span>) / (last.getTimestamp() - first.getTimestamp());   <span class="comment">// @4</span></span><br><span class="line">            <span class="keyword">long</span> timesDiff = last.getTimes() - first.getTimes();</span><br><span class="line">            <span class="keyword">if</span> (timesDiff &gt; <span class="number">0</span>) &#123;                                                                                   <span class="comment">// @5</span></span><br><span class="line">                avgpt = (sum * <span class="number">1.0d</span>) / timesDiff;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        statsSnapshot.setSum(sum);</span><br><span class="line">        statsSnapshot.setTps(tps);</span><br><span class="line">        statsSnapshot.setAvgpt(avgpt);                                                          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> statsSnapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先取快照中的第一条消息。</p>
<p>代码@2：取快照列表中的最后一条消息。</p>
<p>代码@3：计算这两个时间点 value 的差值，即这段时间内新增的总数。</p>
<p>代码@4：计算这段时间内的tps，即每秒处理的消息条数。</p>
<p>代码@5：计算 avgpt ，即平均一次操作新增的消息条数（即平均一次操作，value 新增的个数）。</p>
<p><strong>消费组的消费TPS的计算逻辑就介绍到这里了，那还有一个疑问，即 StatsItem 中 csListMinute 中的数据从哪来呢？</strong></p>
<h5 id="2-2-2-如何采集消费TPS原始数据"><a href="#2-2-2-如何采集消费TPS原始数据" class="headerlink" title="2.2.2 如何采集消费TPS原始数据"></a>2.2.2 如何采集消费TPS原始数据</h5><p>StatsItem#init</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    samplingInSeconds();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">   <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来在创建一个新的StatsItem 的时候，就会启动一个定时任务，每隔 10s 调用 samplingInSeconds 方法进行抽样，那我们简单看一下这个方法：</p>
<p>StatsItem#samplingInSeconds</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">samplingInSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.csListMinute) &#123;</span><br><span class="line">        <span class="keyword">this</span>.csListMinute.add(<span class="keyword">new</span> CallSnapshot(System.currentTimeMillis(), <span class="keyword">this</span>.times.get(), <span class="keyword">this</span>.value</span><br><span class="line">                .get()));</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.csListMinute.size() &gt; <span class="number">7</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.csListMinute.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是将当前StatsItem 中的 value 与 变更次数(time ) 存入封装成 CallSnapshot ，然后存储在快照列表中。这里的关键是times values 这些值在什么情况下会改变呢？ </p>
<p>接着往下看，源码在消息拉取的时候，会将本次拉取的信息加入到统计信息中，其入口为：</p>
<p>PullMessageProcessor#processRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> ResponseCode.SUCCESS:</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetNums(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                        getMessageResult.getMessageCount());</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incGroupGetSize(requestHeader.getConsumerGroup(), requestHeader.getTopic(),</span><br><span class="line">                        getMessageResult.getBufferTotalSize());</span><br><span class="line">        <span class="keyword">this</span>.brokerController.getBrokerStatsManager().incBrokerGetNums(getMessageResult.getMessageCount());</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 省略其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会最终更新 StatsItem 中的 values ，而 times 是 每调用一次，加1。</p>
<p>理论基础讲解完毕后，接下来我们来回答一下题目中的现象。</p>
<h2 id="3、问题解答"><a href="#3、问题解答" class="headerlink" title="3、问题解答"></a>3、问题解答</h2><p>按照上面的讲解，通过 rocketmq-console 发起查看消费组的TPS时，Broker 会根据过去一分钟内采集的快照数据进行计算。快照信息的采集机制是 broker 端会每10s 会记录一下消费组对应的拉取消息数量与拉取次数。</p>
<p><strong>那既然消息延迟(堆积数量在不断减少)，说明消费端正在消费，按道理来说，通过上述机制进行计算，TPS 不可能会是0？那又是什么原因呢？</strong></p>
<p><strong>如果TPS为0，可以说明消费端并没有向 broker 拉取消息，因为一旦从 broker 拉取消息，有关 StatsItem 的 拉取消息总数(value) 与 拉取次数(times) 再两次采集国产中肯定不会相等，只要两者有差距，其TPS就不可能为0，那消费组在消费消息，但又不从主节点上拉取消息，这种情况会出现吗？</strong></p>
<p><strong>答案是会的，在 RocketMQ 主从同步架构中，如果需要访问的消息偏移量与当前 commitlog 最大偏移的之间的差距超过了内存的40%，消息消费将由从节点接管，故此时消费的拉取不会去主节点拉取，故上面返回的TPS就会为0。这样就能完美解答了。</strong></p>
<p>经过上面的分析，我相信大家已经非常认可这个原因了，其实我们还有一个重要的论据，大家可以分别去查看 Rocketmq 主从节点 /home/{username}/logs/rocketmqlogs/stats.log，里面会每隔1分钟在日志中打印各个消费组的消费TPS.</p>
<p>从服务器(rocketmq-slave)对应的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO - [GROUP_GET_NUMS] [t1@c1] Stats In One Minute, SUM: 785717 TPS: 15714.34 AVGPT: 8.14</span><br><span class="line">INFO - [GROUP_GET_NUMS] [t1@c1] Stats In One Minute, SUM: 940522 TPS: 15675.37 AVGPT: 8.06</span><br></pre></td></tr></table></figure>
<p>主服务器(rocketmq-master)对应的日志如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO - [GROUP_GET_NUMS] [t1@c1] Stats In One Minute, SUM: 0 TPS: 0.00 AVGPT: 0.00</span><br><span class="line">INFO - [GROUP_GET_NUMS] [t1@c1] Stats In One Minute, SUM: 0 TPS: 0.00 AVGPT: 0.00</span><br></pre></td></tr></table></figure>
<p><strong>主服务器上的TPS一定会0吗？不一定，其实也不一定。这里借着这波日志，再来总结一下 RocketMQ 主从同步时的切换逻辑。</strong></p>
<p>1、如果消费端请求的消息物理偏移量与 broker 当前最新的物理偏移量之间的差距查过内存的40%，下一次拉取会往从节点发送（当然前提是slaveReadEnable = true）。</p>
<p>2、当从节点开始接管消息消费时，下一次拉取请求一定会往从节点发送码？答案也是不一定：</p>
<ul>
<li>如果待拉取的消息偏移量与从节点最新的物理偏移量之间的差距超过内存的30%，下一次拉取请求还是会发往从节点。</li>
<li>如果待拉取的消息偏移量与从节点最新的物理偏移量之际的差距少于内存的30%，下一次拉取请求将发送到主节点。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>rocketmq-console</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发容器ConcurrentHashMap源码分析</title>
    <url>/posts/7310f98.html</url>
    <content><![CDATA[<div id="vip-container"><h1 id="1、ConcurrentHashMap-与-HashTable"><a href="#1、ConcurrentHashMap-与-HashTable" class="headerlink" title="1、ConcurrentHashMap 与 HashTable"></a>1、ConcurrentHashMap 与 HashTable</h1><p>HashTable 是 HashMap 的线程安全版本，使用的是 HashTable 的对象锁，同一时刻只能有一个线程 新增元素，获取元素。锁等待多，并发度低。而 ConcurrentHashMap 采用的是锁分段机制，就是用多把锁，让每把锁管理一部分数据。怎么实现的呢？引入了段(Segment)数据结构。</p>
<p>我们不妨来回忆一下HashMap、HashTable 的数据结构</p>
<p><img src="https://img-blog.csdn.net/20161129121630568?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>结合下文对ConcurrentHashMap的分析，可以得知ConcurrentHashMap的数据结构如下，其实就是可以简单的认为，ConcurrentHashMap就是 HashMap[] 数组，就是一个数组，数组元素是一个一个的 HashMap。</p>
<p><img src="https://img-blog.csdn.net/20161129121705356?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><a id="more"></a><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>为了更好的理解ConcurrentHashMap，最好首先阅读如下几篇文章：</p>
<ul>
<li>HashMap源码分析 <a href="http://blog.csdn.net/prestigeding/article/details/52861420">http://blog.csdn.net/prestigeding/article/details/52861420</a></li>
<li>使用Unsafe根据内存地址与偏移量访问数组元素方法：<a href="http://blog.csdn.net/prestigeding/article/details/52980801">http://blog.csdn.net/prestigeding/article/details/52980801</a></li>
<li>ReentrantLock锁分析：<a href="http://blog.csdn.net/prestigeding/article/details/53084883">http://blog.csdn.net/prestigeding/article/details/53084883</a></li>
</ul>
<h1 id="2、ConcurrentHashMap-详解"><a href="#2、ConcurrentHashMap-详解" class="headerlink" title="2、ConcurrentHashMap 详解"></a>2、ConcurrentHashMap 详解</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &#123;<span class="doctag">@link</span> java.util.Map&#125; providing additional atomic</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;putIfAbsent&lt;/tt&gt;, &lt;tt&gt;remove&lt;/tt&gt;, and &lt;tt&gt;replace&lt;/tt&gt; methods.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Memory consistency effects: As with other concurrent</span></span><br><span class="line"><span class="comment"> * collections, actions in a thread prior to placing an object into a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> ConcurrentMap&#125; as a key or value</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;package-summary.html#MemoryVisibility&quot;&gt;&lt;i&gt;happen-before&lt;/i&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * actions subsequent to the access or removal of that object from</span></span><br><span class="line"><span class="comment"> * the &#123;<span class="doctag">@code</span> ConcurrentMap&#125; in another thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This interface is a member of the</span></span><br><span class="line"><span class="comment"> * &lt;a href=&quot;&#123;<span class="doctag">@docRoot</span>&#125;/../technotes/guides/collections/index.html&quot;&gt;</span></span><br><span class="line"><span class="comment"> * Java Collections Framework&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Doug Lea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; the type of keys maintained by this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of mapped values</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConcurrentMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If the specified key is not already associated</span></span><br><span class="line"><span class="comment">     * with a value, associate it with the given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (!map.containsKey(key))</span></span><br><span class="line"><span class="comment">     *       return map.put(key, value);</span></span><br><span class="line"><span class="comment">     *   else</span></span><br><span class="line"><span class="comment">     *       return map.get(key);&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with the specified key, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with the key,</span></span><br><span class="line"><span class="comment">     *         if the implementation supports null values.)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Removes the entry for a key only if currently mapped to a given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key) &amp;&amp; map.get(key).equals(value)) &#123;</span></span><br><span class="line"><span class="comment">     *       map.remove(key);</span></span><br><span class="line"><span class="comment">     *       return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else return false;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value expected to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the value was removed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;remove&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the key or value is of an inappropriate</span></span><br><span class="line"><span class="comment">     *         type for this map</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     *         (&lt;a href=&quot;../Collection.html#optional-restrictions&quot;&gt;optional&lt;/a&gt;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the entry for a key only if currently mapped to a given value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key) &amp;&amp; map.get(key).equals(oldValue)) &#123;</span></span><br><span class="line"><span class="comment">     *       map.put(key, newValue);</span></span><br><span class="line"><span class="comment">     *       return true;</span></span><br><span class="line"><span class="comment">     *   &#125; else return false;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> oldValue value expected to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newValue value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if the value was replaced</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of a specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if a specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of a specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">replace</span><span class="params">(K key, V oldValue, V newValue)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces the entry for a key only if currently mapped to some value.</span></span><br><span class="line"><span class="comment">     * This is equivalent to</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">     *   if (map.containsKey(key)) &#123;</span></span><br><span class="line"><span class="comment">     *       return map.put(key, value);</span></span><br><span class="line"><span class="comment">     *   &#125; else return null;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     * except that the action is performed atomically.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key key with which the specified value is associated</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value associated with the specified key, or</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for the key.</span></span><br><span class="line"><span class="comment">     *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment">     *         previously associated &lt;tt&gt;null&lt;/tt&gt; with the key,</span></span><br><span class="line"><span class="comment">     *         if the implementation supports null values.)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedOperationException if the &lt;tt&gt;put&lt;/tt&gt; operation</span></span><br><span class="line"><span class="comment">     *         is not supported by this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified key or value</span></span><br><span class="line"><span class="comment">     *         prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key or value is null,</span></span><br><span class="line"><span class="comment">     *         and this map does not permit null keys or values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified key</span></span><br><span class="line"><span class="comment">     *         or value prevents it from being stored in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">replace</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-1-ConcurrentHashMap构造方法与数据结构分析"><a href="#2-1-ConcurrentHashMap构造方法与数据结构分析" class="headerlink" title="2.1 ConcurrentHashMap构造方法与数据结构分析"></a>2.1 ConcurrentHashMap构造方法与数据结构分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a new, empty map with the specified initial</span></span><br><span class="line"><span class="comment">     * capacity, load factor and concurrency level.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialCapacity the initial capacity. The implementation</span></span><br><span class="line"><span class="comment">     * performs internal sizing to accommodate this many elements.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadFactor  the load factor threshold, used to control resizing.</span></span><br><span class="line"><span class="comment">     * Resizing may be performed when the average number of elements per</span></span><br><span class="line"><span class="comment">     * bin exceeds this threshold.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> concurrencyLevel the estimated number of concurrently</span></span><br><span class="line"><span class="comment">     * updating threads. The implementation performs internal sizing</span></span><br><span class="line"><span class="comment">     * to try to accommodate this many threads.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is</span></span><br><span class="line"><span class="comment">     * negative or the load factor or concurrencyLevel are</span></span><br><span class="line"><span class="comment">     * nonpositive.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;                               <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">            concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">        <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">        <span class="keyword">int</span> sshift = <span class="number">0</span>;                                                                                          <span class="comment">//@2 start</span></span><br><span class="line">        <span class="keyword">int</span> ssize = <span class="number">1</span>;   </span><br><span class="line">        <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">            ++sshift;</span><br><span class="line">            ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">        <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;                                                              <span class="comment">//@2 end</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">        <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">            ++c;</span><br><span class="line">        <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; <span class="comment">// 每个 segment 内部容里</span></span><br><span class="line">        <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">            cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// create segments and segments[0]</span></span><br><span class="line">        Segment&lt;K,V&gt; s0 =</span><br><span class="line">            <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                             (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">        Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">        UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">        <span class="keyword">this</span>.segments = ss;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码@1 concurrencyLevel，含义，并发级别，并发度，在键不冲突的情况下，最多允许多少个线程同时访问数据不需要阻塞（理想情况下），我们应该知道，ConcurrentHashMap 的基本实现原理就是引入Segment 数据结构，将锁的粒度细化到Segment, 也就是说，如果多个线程，同时操作多个 key,如果这些 key，分布在不同的 Segment, 那这些线程的操作互不影响，当然不需要加锁，提高性能。所以 concurrencyLevel，就是要求告诉 ConcurrentHashMap, 我需要这么过个线程同时访问你而不产生锁冲突。</p>
<p>代码@2，ssize，该变量的值等于ConcurrentHashMap 中 segment 的长度，也就是 Segment[] 的长度。该值取决于concurrencyLevel, 其实就是小于concurrencyLevel 的最大的2的幂，比如concurrencyLevel= 16,那 ssize=16,如果 concurrencyLevel = 12, ssize=8，因为ssize的长度为2的幂。</p>
<p>变量shift的值，看出来了没，其实就是 ssize 2 ^ shift,其实就是表示ssize需要的二进制位。</p>
<p>segmentMask、segmentShift ，这两个属性在该表达式中使用：(h &gt;&gt;&gt; segmentShift) &amp; segmentMask)，很明显，就是用来算Segment[]数组中的下标来的。意图segmentShift = 32 - sshift，也就是利用hash的高位与代表（ssize-1）来定位下标。// 如果默认，初始容量16,那么ssize=16, sshift=4 定位端 hash 无符号向右移多少28位，（总共32位），那就是使原本32-29位参与运算（高位）</p>
<p>变量cap,就是每个Segment中HashEntity[]的长度，大于【初始容量/segment长度】的最小2的幂。</p>
<p>分析到这里，ConcurrentHashMap就构建成功了，我们先重点关注一下 Segment 的数据结构。</p>
<p>Segment 段的内部数据结构如下：</p>
<ul>
<li>类的声明：static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable</li>
<li>数据结构：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;    <span class="comment">// 内部键值对</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> count;  <span class="comment">// 元素数量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;     <span class="comment">// 结构发生变化的次数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> threshold;    <span class="comment">// 扩容时的阔值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;     <span class="comment">// 扩容因子，主要影响threshold，影响什么时候扩容</span></span><br></pre></td></tr></table></figure>

<p>对上述结构，是否似曾相识，对了，就是它，HashMap；每个 Segment 其实就是一个 HashMap; 还有一个很关键点：Segment继承自 ReentrantLock, 也就是 Segment 本身就是一把锁。</p>
<h2 id="2-2-public-V-put-K-key-V-value-源码分析"><a href="#2-2-public-V-put-K-key-V-value-源码分析" class="headerlink" title="2.2  public V put(K key, V value) 源码分析"></a>2.2  public V put(K key, V value) 源码分析</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)                                      </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;   <span class="comment">//@2</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck in ensureSegment</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment  @3</span></span><br><span class="line">            s = ensureSegment(j);                                      <span class="comment">//@4</span></span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);                   <span class="comment">//@5</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>代码@1，表明 ConcurrentHashMap不支持value为空的键值对。</p>
<p>代码@2，计算该key对应的Segment的位置（数组下标），并发包中获取数组元素的方式，采用的是UNSAFE直接操作内存的方式，而不是典型的  Segment[] a = new Segment[16],  第j个元素的值为  a[j]。如果需要详细了解UNSAFE操作数组元素的原理，请查看  另一篇博客(AtomicIntegerArray 源码分析)</p>
<p>比如一个Integer[]中，每个int是32位，占4个字节，那数组中第3个位置的开始字节是多少呢？=(3-1) &lt;&lt; 2,也就是说SHIFT的值为元素中长度的幂。怎么获取每个元素在数组中长度（字节为单位）= UNSAFE.arrayIndexScale,</p>
<p>而 UNSAFE.arrayBaseOffset,返回的是，第一个数据元素相对于对象起始地址的便宜量，该部分的详解，请参考我的技术博客【<a href="http://blog.csdn.net/prestigeding/article/details/52980801%E3%80%91">http://blog.csdn.net/prestigeding/article/details/52980801】</a></p>
<p>代码@3，就是获取j下标的segment对象。相当于  if(  (s == segments[j])== null  )</p>
<p>代码@4，我们将目光移到 ensureSegment方法中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the segment for the given index, creating it and</span></span><br><span class="line"><span class="comment">     * recording in segment table (via CAS) if not already present.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> k the index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the segment</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">        Segment&lt;K,V&gt; seg;</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>]; <span class="comment">// use segment 0 as prototype</span></span><br><span class="line">            <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">            <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">            <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">            <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                == <span class="keyword">null</span>) &#123; <span class="comment">// recheck</span></span><br><span class="line">                Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">                <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                       == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seg;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法，主要是确保segment槽的k位置的Segment不为空，如果为空，初始化。</p>
<p>代码@5，代码@4初始化k位置的segment后，将键值对加入到segment,接下重点看一下Segment的put方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);   <span class="comment">// @1</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);      <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;                         <span class="comment">// @3</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;                                                     <span class="comment">// @4           </span></span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||                                          </span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;      <span class="comment">//@5</span></span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;                                                                   <span class="comment">//@6                                                        </span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>该方法，实现思路其实和HashMap一样，就是要在Segment的HashEntity[] table的指定位置加入新的Node,如果在位置k的位置不为空，此时，说明该位置发生了hash冲突，这是需要先遍历整个链，看是否有相等的key,如果key相等，则替换该值，如果没有，则将新加入的节点的next指针指向 table[k],然后将node加入到k位置。但是，由于ConcurrentHashMap是支持多个线程同时访问的，对于单个Segment的操作，需要加锁。</p>
<p>代码@1，首先尝试获取锁，如果成功获取锁，则继续添加元素，如果获取锁失败，后面重点分析。</p>
<p>代码@2，获取该key所对应的table[]中的下标。根据该元素是否为空，有两种操作，如果为空，说明没有发生冲突，也就是走代码@6分支，就是将新创建的节点的节点放入table[k]处，当然，此时需要判断是否需要进行rehash操作（ConcurrentHashMap的是否需要rehash,就是判断阔值）。</p>
<p>代码@4，就是循环判断table[k]的链条中，是否有key与待操作key相等，如果相等，直接替换就好。由于@3开始，其实就是整个put方法，会在锁保护中。</p>
<p>上述过程，应该很好理解，所以，现在重点关注两个方法，一是scanAndLockForPut，二是rehash(比较好奇，是否与HashMap相同，应该是一样的吧，呵呵)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Scans for a node containing given key while trying to</span></span><br><span class="line"><span class="comment">         * acquire lock, creating and returning one if not found. Upon</span></span><br><span class="line"><span class="comment">         * return, guarantees that lock is held. UNlike in most</span></span><br><span class="line"><span class="comment">         * methods, calls to method equals are not screened: Since</span></span><br><span class="line"><span class="comment">         * traversal speed doesn&#x27;t matter, we might as well help warm</span></span><br><span class="line"><span class="comment">         * up the associated code and accesses as well.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> a new node if key not found, else null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> HashEntry&lt;K,V&gt; <span class="title">scanAndLockForPut</span><span class="params">(K key, <span class="keyword">int</span> hash, V value)</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; first = entryForHash(<span class="keyword">this</span>, hash);</span><br><span class="line">            HashEntry&lt;K,V&gt; e = first;</span><br><span class="line">            HashEntry&lt;K,V&gt; node = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// negative while locating node</span></span><br><span class="line">            <span class="keyword">while</span> (!tryLock()) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; f; <span class="comment">// to recheck first below</span></span><br><span class="line">                <span class="keyword">if</span> (retries &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">// speculatively create node</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (key.equals(e.key))</span><br><span class="line">                        retries = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        e = e.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (++retries &gt; MAX_SCAN_RETRIES) &#123;</span><br><span class="line">                    lock();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((retries &amp; <span class="number">1</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         (f = entryForHash(<span class="keyword">this</span>, hash)) != first) &#123;</span><br><span class="line">                    e = first = f; <span class="comment">// re-traverse if entry changed</span></span><br><span class="line">                    retries = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在没有成功获取锁的情况下，先不急于阻塞，而是乐观的估计获取锁的线程操作的key与当前操作的key没关系，那我该干嘛就干嘛，自旋尝试获取锁（尝试MAX_SCAN_RETRIES，如果未成功获取锁）尝试超过最大尝试次数，为了性能考虑，该线程阻塞，参加代码@2。</p>
<p>@3，每隔一次，检查一下 Segment HashEntity[] table 处k的位置的元素是否发生变化，如果发生变化，则重试次数设置为-1，继续尝试获取锁。该方法如果在阻塞在lock()方法，时，一旦获取锁，则进入到final V put(K key, int hash, V value, boolean onlyIfAbsent) 方法中，进行常规的put方法（与HashMap操作类似。）</p>
<p>接下来重点看一下代码@7，如果当前segment中容量大于阔值，并小于允许的最大长度时，需要进行rehash,下面分析一下rehash源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Doubles size of table and repacks entries, also adding the</span></span><br><span class="line"><span class="comment">         * given node to new table</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Reclassify nodes in each list to new table.  Because we</span></span><br><span class="line"><span class="comment">             * are using power-of-two expansion, the elements from</span></span><br><span class="line"><span class="comment">             * each bin must either stay at same index, or move with a</span></span><br><span class="line"><span class="comment">             * power of two offset. We eliminate unnecessary node</span></span><br><span class="line"><span class="comment">             * creation by catching cases where old nodes can be</span></span><br><span class="line"><span class="comment">             * reused because their next fields won&#x27;t change.</span></span><br><span class="line"><span class="comment">             * Statistically, at the default threshold, only about</span></span><br><span class="line"><span class="comment">             * one-sixth of them need cloning when a table</span></span><br><span class="line"><span class="comment">             * doubles. The nodes they replace will be garbage</span></span><br><span class="line"><span class="comment">             * collectable as soon as they are no longer referenced by</span></span><br><span class="line"><span class="comment">             * any reader thread that may be in the midst of</span></span><br><span class="line"><span class="comment">             * concurrently traversing table. Entry accesses use plain</span></span><br><span class="line"><span class="comment">             * array indexing because they are followed by volatile</span></span><br><span class="line"><span class="comment">             * table write.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">            <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">            HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">                (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">            <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">                HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">//  Single node on list</span></span><br><span class="line">                        newTable[idx] = e;</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                        HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                        <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                             last != <span class="keyword">null</span>;</span><br><span class="line">                             last = last.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                            <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                                lastIdx = k;</span><br><span class="line">                                lastRun = last;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        newTable[lastIdx] = lastRun;</span><br><span class="line">                        <span class="comment">// Clone remaining nodes</span></span><br><span class="line">                        <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            V v = p.value;</span><br><span class="line">                            <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                            <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                            HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                            newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">            node.setNext(newTable[nodeIndex]);</span><br><span class="line">            newTable[nodeIndex] = node;</span><br><span class="line">            table = newTable;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>在理解了HashMap的rehash方法后，再来看该方法，应该能很好的理解，故不做重复讲解了。</p>
<h3 id="2-2-2-public-V-putIfAbsent-K-key-V-value"><a href="#2-2-2-public-V-putIfAbsent-K-key-V-value" class="headerlink" title="2.2.2 public V putIfAbsent(K key, V value)"></a>2.2.2 public V putIfAbsent(K key, V value)</h3><p>该方法的语义是，如果存在key，则直接返回key关联的value,如果key不存在，则加入该键值对，并返回null；该步骤是原子操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject</span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>)</span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法与put方法的实现基本相同，唯一不同的是，对已经存在key时，put方法是直接覆盖旧值，而putIfAbsent是，返回旧值。</p>
<h3 id="2-2-3-public-void-putAll-Map-m"><a href="#2-2-3-public-void-putAll-Map-m" class="headerlink" title="2.2.3 public void putAll(Map m)"></a>2.2.3 public void putAll(Map m)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>直接将传人的Map类型的参数，遍历，调用put方法。</p>
<p>看过了put函数，我们将目标转向到get方法中，瞧一瞧get相关方法的实现：</p>
<h3 id="2-2-4-public-V-get-Object-key-源码分析"><a href="#2-2-4-public-V-get-Object-key-源码分析" class="headerlink" title="2.2.4 public V get(Object key)源码分析"></a>2.2.4 public V get(Object key)源码分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value to which the specified key is mapped,</span></span><br><span class="line"><span class="comment">     * or &#123;<span class="doctag">@code</span> null&#125; if this map contains no mapping for the key.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;More formally, if this map contains a mapping from a key</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> k&#125; to a value &#123;<span class="doctag">@code</span> v&#125; such that &#123;<span class="doctag">@code</span> key.equals(k)&#125;,</span></span><br><span class="line"><span class="comment">     * then this method returns &#123;<span class="doctag">@code</span> v&#125;; otherwise it returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> null&#125;.  (There can be at most one such mapping.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// manually integrate access methods to reduce overhead</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上文中可以看到，get方法并没有加锁，只是根据key的hash，然后算出Segment槽的位置，不是直接根据下标去获取Segment，也不是直接根据下标去Segment 的 HashEntity[] tab中去获取元素，而是使用了 UNSAFE.getObjectVolatile方法，直接操作内存，并使用volatile方式获取，最大程度保证可见性。有人或许有疑问，为什么get方法不加读锁，阻止其他写入请求呢？其实这样做意义并不大，ConcurrentHashMap的是一个容器，数据存储，提供基本的 put,get操作，对单一一个get请求加锁，没什么意义，因为get方法并不会改变ConcurrentHashMap的内部结构，在当前线程获取到key中的值，然后其他线程删除了该key,这在业务场景上本身就是正常不过的操作。所以get方法并不需要加锁。</p>
<p>2.3 浏览源码，发现无论是replace方法，还是remove方法等操作内部等都和HashMap相似，因为Segment就是一个带锁的HashMap。所以，接下来，我们可以这样思考，put,replace,remove这些方法比HashMap效率高，因为提供了并发度，那这些获取全局的属性的方法呢，比如keys,size等这些方法，性能又是如何呢？我们将目光转向size，keys等遍历方法。</p>
<h3 id="2-3-1-public-int-size方法"><a href="#2-3-1-public-int-size方法" class="headerlink" title="2.3.1 public int size方法"></a>2.3.1 public int size方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of key-value mappings in this map.  If the</span></span><br><span class="line"><span class="comment">     * map contains more than &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt; elements, returns</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Integer.MAX_VALUE&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of key-value mappings in this map</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Try a few times to get accurate count. On failure due to</span></span><br><span class="line">        <span class="comment">// continuous async changes in table, resort to locking.</span></span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">int</span> size;</span><br><span class="line">        <span class="keyword">boolean</span> overflow; <span class="comment">// true if size overflows 32 bits</span></span><br><span class="line">        <span class="keyword">long</span> sum;         <span class="comment">// sum of modCounts</span></span><br><span class="line">        <span class="keyword">long</span> last = <span class="number">0L</span>;   <span class="comment">// previous sum</span></span><br><span class="line">        <span class="keyword">int</span> retries = -<span class="number">1</span>; <span class="comment">// first iteration isn&#x27;t retry</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                        ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">                &#125;</span><br><span class="line">                sum = <span class="number">0L</span>;</span><br><span class="line">                size = <span class="number">0</span>;</span><br><span class="line">                overflow = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sum += seg.modCount;</span><br><span class="line">                        <span class="keyword">int</span> c = seg.count;</span><br><span class="line">                        <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">                            overflow = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sum == last)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                last = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                    segmentAt(segments, j).unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> overflow ? Integer.MAX_VALUE : size;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法的核心实现原理：从上文的解读，我想大家应该已经了解每一个Segment就是一个HashMap,HashMap中有两个变量，modCount，表示数据结构发生变化次数，比如put一个未在HashMap中包含的key,比如remove,比如clear方法，每调用一次上述方法，modCount就加1，也就是影响size属性的操作，都会将modeCount加一；另一个变量size，记录HashMap中键值对的个数。那ConcurrentHashMap的size方法，如果结构没有发生改变，只需将各个Segment的size相加，就可以得到ConcurrentHashMap的size,然并卯，在相加的过程其他线程如果有改变Segment内部的结构的话，导致size不准确，该方法的实现办法，是先乐观的尝试计算相加的过程最多三次，最少两次，如果前后两次的modCount一样，就说明在计算size的过程中，其他线程并没有改变ConcurrentHashMap的结构没有变化，则可以直接将size返回，结束该方法的调用，如果有变化，则需要依次对所有Segment申请加锁操作，只有获取全部锁后，然后对每个segment的size相加，然后是否锁，并返回size值。</p>
<p>代码@1,如果重试次数达到 (RETRIES_BEFORE_LOCK +１　,默认为2)次数后，说明需要加锁才能计算。</p>
<p>代码@2，对Segment相加计算size</p>
<p>代码@3，就是实现，判断连续两次计算出的modCount相等，说明该size值正确，否则，继续尝试，获取去请求锁。</p>
<h3 id="2-3-2-public-boolean-isEmpty-方法源码解读"><a href="#2-3-2-public-boolean-isEmpty-方法源码解读" class="headerlink" title="2.3.2 public boolean isEmpty() 方法源码解读"></a>2.3.2 public boolean isEmpty() 方法源码解读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map contains no key-value mappings</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Sum per-segment modCounts to avoid mis-reporting when</span></span><br><span class="line"><span class="comment">         * elements are concurrently added and removed in one segment</span></span><br><span class="line"><span class="comment">         * while checking another, in which case the table was never</span></span><br><span class="line"><span class="comment">         * actually empty at any point. (The sum ensures accuracy up</span></span><br><span class="line"><span class="comment">         * through at least 1&lt;&lt;31 per-segment modifications before</span></span><br><span class="line"><span class="comment">         * recheck.)  Methods size() and containsValue() use similar</span></span><br><span class="line"><span class="comment">         * constructions for stability checks.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                sum += seg.modCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum != <span class="number">0L</span>) &#123; <span class="comment">// recheck unless no modifications</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (seg.count != <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    sum -= seg.modCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法的核心实现原理：就是遍历有所有的segment，一旦发现有存在size不等于0的segment，则返回false；如果发现所有的segment的size为0，则再次遍历，如果两次遍历时 modCount一样，则返回true,否则返回false。</p>
<p>大家再看看如下方法：</p>
<h3 id="2-3-3-public-boolean-containsKey-Object-key"><a href="#2-3-3-public-boolean-containsKey-Object-key" class="headerlink" title="2.3.3 public boolean containsKey(Object key)"></a>2.3.3 public boolean containsKey(Object key)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tests if the specified object is a key in this table.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  key   possible key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if and only if the specified object</span></span><br><span class="line"><span class="comment">     *         is a key in this table, as determined by the</span></span><br><span class="line"><span class="comment">     *         &lt;tt&gt;equals&lt;/tt&gt; method; &lt;tt&gt;false&lt;/tt&gt; otherwise.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified key is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s; <span class="comment">// same as get() except no need for volatile value read</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="keyword">long</span> u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;</span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (tab = s.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile</span><br><span class="line">                     (tab, ((<span class="keyword">long</span>)(((tab.length - <span class="number">1</span>) &amp; h)) &lt;&lt; TSHIFT) + TBASE);</span><br><span class="line">                 e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                K k;</span><br><span class="line">                <span class="keyword">if</span> ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-4-public-boolean-containsValue-Object-value"><a href="#2-3-4-public-boolean-containsValue-Object-value" class="headerlink" title="2.3.4 public boolean containsValue(Object value)"></a>2.3.4 public boolean containsValue(Object value)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Returns &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">   * specified value. Note: This method requires a full internal</span></span><br><span class="line"><span class="comment">   * traversal of the hash table, and so is much slower than</span></span><br><span class="line"><span class="comment">   * method &lt;tt&gt;containsKey&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value value whose presence in this map is to be tested</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this map maps one or more keys to the</span></span><br><span class="line"><span class="comment">   *         specified value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> NullPointerException if the specified value is null</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Same idea as size()</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">      <span class="keyword">final</span> Segment&lt;K,V&gt;[] segments = <span class="keyword">this</span>.segments;</span><br><span class="line">      <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">long</span> last = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> retries = -<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          outer: <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">                  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                      ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">long</span> hashSum = <span class="number">0L</span>;</span><br><span class="line">              <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">                  HashEntry&lt;K,V&gt;[] tab;</span><br><span class="line">                  Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">                  <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (tab = seg.table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; tab.length; i++) &#123;</span><br><span class="line">                          HashEntry&lt;K,V&gt; e;</span><br><span class="line">                          <span class="keyword">for</span> (e = entryAt(tab, i); e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                              V v = e.value;</span><br><span class="line">                              <span class="keyword">if</span> (v != <span class="keyword">null</span> &amp;&amp; value.equals(v)) &#123;</span><br><span class="line">                                  found = <span class="keyword">true</span>;</span><br><span class="line">                                  <span class="keyword">break</span> outer;</span><br><span class="line">                              &#125;</span><br><span class="line">                          &#125;</span><br><span class="line">                      &#125;</span><br><span class="line">                      sum += seg.modCount;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (retries &gt; <span class="number">0</span> &amp;&amp; sum == last)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              last = sum;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">                  segmentAt(segments, j).unlock();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> found;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-5-public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet-遍历元素方法。"><a href="#2-3-5-public-Set-lt-Map-Entry-lt-K-V-gt-gt-entrySet-遍历元素方法。" class="headerlink" title="2.3.5 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 遍历元素方法。"></a>2.3.5 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet(); 遍历元素方法。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> (es != <span class="keyword">null</span>) ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            V v = ConcurrentHashMap.<span class="keyword">this</span>.get(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> v != <span class="keyword">null</span> &amp;&amp; v.equals(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.remove(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.size();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ConcurrentHashMap.<span class="keyword">this</span>.isEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; e = <span class="keyword">super</span>.nextEntry();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WriteThroughEntry(e.key, e.value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nextSegmentIndex;</span><br><span class="line">        <span class="keyword">int</span> nextTableIndex;</span><br><span class="line">        HashEntry&lt;K,V&gt;[] currentTable;</span><br><span class="line">        HashEntry&lt;K, V&gt; nextEntry;</span><br><span class="line">        HashEntry&lt;K, V&gt; lastReturned;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            nextSegmentIndex = segments.length - <span class="number">1</span>;</span><br><span class="line">            nextTableIndex = -<span class="number">1</span>;</span><br><span class="line">            advance();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set nextEntry to first node of next non-empty table</span></span><br><span class="line"><span class="comment">         * (in backwards order, to simplify checks).</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">()</span> </span>&#123;       <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nextTableIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((nextEntry = entryAt(currentTable,</span><br><span class="line">                                             nextTableIndex--)) != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nextSegmentIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    Segment&lt;K,V&gt; seg = segmentAt(segments, nextSegmentIndex--);</span><br><span class="line">                    <span class="keyword">if</span> (seg != <span class="keyword">null</span> &amp;&amp; (currentTable = seg.table) != <span class="keyword">null</span>)</span><br><span class="line">                        nextTableIndex = currentTable.length - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> HashEntry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;     <span class="comment">// @2</span></span><br><span class="line">            HashEntry&lt;K,V&gt; e = nextEntry;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            lastReturned = e; <span class="comment">// cannot assign until after null check</span></span><br><span class="line">            <span class="keyword">if</span> ((nextEntry = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                advance();</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextEntry != <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastReturned == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.remove(lastReturned.key);</span><br><span class="line">            lastReturned = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteThroughEntry</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractMap</span>.<span class="title">SimpleEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        WriteThroughEntry(K k, V v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k,v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Set our entry&#x27;s value and write through to the map. The</span></span><br><span class="line"><span class="comment">         * value to return is somewhat arbitrary here. Since a</span></span><br><span class="line"><span class="comment">         * WriteThroughEntry does not necessarily track asynchronous</span></span><br><span class="line"><span class="comment">         * changes, the most recent &quot;previous&quot; value could be</span></span><br><span class="line"><span class="comment">         * different from what we return (or could even have been</span></span><br><span class="line"><span class="comment">         * removed in which case the put will re-establish). We do not</span></span><br><span class="line"><span class="comment">         * and cannot guarantee more.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">            V v = <span class="keyword">super</span>.setValue(value);</span><br><span class="line">            ConcurrentHashMap.<span class="keyword">this</span>.put(getKey(), value);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>上述代码主要关注两点：第一是遍历元素的方法；第二是调用该迭代器的size,isEmpty等方法。</p>
<p>代码@1，advance，该方法主要是从segments[]数组中的最后一个元素开始，找出segment中HashEntity[] table数组中最后一个元素开始遍历，找到一个不为空nextEntity,这里返回的nextEntity,就是 table[]数组中的元素，不包括链表中的HashEntity，链表中的HashEntity遍历在代码@2 nextEntry 方法中，实现真的挺优雅的。</p>
<p>第二个特点是，调用迭代器的size、contains，isEmpty等方法，都是对ConcurrentHashMap对应方法的调用。</p>
<p>最后，通过上述的分析，我想对ConcurrentHashMap做一个简单的总结：</p>
<ol>
<li><p>结合上述源码分析，我们可以清楚的认为，一个Segment就是一个与HashMap相同的结构，当然每个Segment就是一把锁，该类的核心思想，就是通过对key的第一次hash,定位的不是以前的HashEntity,而是一个Segemnt,然后对该key限定在该Segment中执行，，这样可以同时允许多个线程向ConcurrentHashMap同时添加元素（当然，要分散到不同的Segment类，故提供了并发度。）</p>
</li>
<li><p>ConcurrentHashMap是一个并发容器，所谓的并发容器并不是说在使用过程中一定不需要加锁，并发容器能提    供的保证是多个线程同时访问该容器，同时调用会改变内部结构的方法时，比如put方法时，不会破坏内部结构    以至于不能提供服务或提供错误服务（数据视图）。怎么理解并不是一定不要加锁这句话，我举一个例子，比如我们用ConcurrentHashMap来存储数据，完成如下操作1、第一步，设置一个key 为”status”:1,然后经过复杂的逻辑处理，由存入一个金额 key为amount,值为10； 伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcurrentHashMap a &#x3D; new ConcurrentHashMap();</span><br><span class="line">   </span><br><span class="line">     逻辑代码</span><br><span class="line">   </span><br><span class="line">     void eval(参数 ...) &#123;</span><br><span class="line">   </span><br><span class="line">           a.put(&quot;status&quot;,1);</span><br><span class="line">   </span><br><span class="line">           &#x2F;&#x2F;经过计算</span><br><span class="line">   </span><br><span class="line">           a.put(&quot;amount&quot;: 10);</span><br><span class="line">   </span><br><span class="line">          &#x2F;&#x2F;付款</span><br><span class="line">   </span><br><span class="line">         if(  a.get(&quot;status&quot;)&#x3D;&#x3D;1  ) &#123;</span><br><span class="line">   </span><br><span class="line">          &#x2F;&#x2F;执行付款操作</span><br><span class="line">   </span><br><span class="line">         &#125; </span><br><span class="line">   </span><br><span class="line">     &#125;  </span><br></pre></td></tr></table></figure>

<p>从上面的代码，如果多个线程执行eval方法，肯定会有问题。所以，还是需要加锁，说白了，ConcurrentHashMap只对单个方法负责，比如对 put 方法负责，只是对调用一次put方法，保证该操作，不会受到其他线程的影响。</p>
</li>
<li><p>ConcurrentHash采取如下方法从Segment[] segments,HashEntity[]  table,数组中获取元素，其准确实施性依次增强。</p>
</li>
</ol>
<ul>
<li>segment[下标],table[下标]</li>
<li>使用UNSAFE根据便宜量直接操作内存方式，使用(voliate方式)</li>
<li>重试一定次数后，加锁。</li>
</ul>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>源码</tag>
        <tag>并发容器</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>java并发锁ReentrantReadWriteLock读写锁源码分析</title>
    <url>/posts/9ba20a53.html</url>
    <content><![CDATA[<div id="vip-container"><h1 id="1、ReentrantReadWriterLock-基础"><a href="#1、ReentrantReadWriterLock-基础" class="headerlink" title="1、ReentrantReadWriterLock 基础"></a>1、ReentrantReadWriterLock 基础</h1><p>所谓读写锁，是对访问资源共享锁和排斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。</p>
<p>java.util.concurrent.locks中关于多写锁的接口：ReadWriteLock。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for reading.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for reading.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the lock used for writing.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the lock used for writing.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提一个问题，是否觉得 ReentrantReadWriteLock 会实现 Lock 接口吗？与 ReentrantLock 有什么关系？</p>
<a id="more"></a>

<p>答案是否定的，ReentrantReadWriterLock 通过两个内部类实现 Lock 接口，分别是 ReadLock,WriterLock 类。与 ReentrantLock一样，ReentrantReadWriterLock 同样使用自己的内部类Sync（继承AbstractQueuedSynchronizer）实现CLH算法。为了方便对读写锁获取机制的了解，先介绍一下Sync内部类中几个属性，采用了位运算：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Read vs write count extraction constants and functions.</span></span><br><span class="line"><span class="comment">         * Lock state is logically divided into two unsigned shorts:</span></span><br><span class="line"><span class="comment">         * The lower one representing the exclusive (writer) lock hold count,</span></span><br><span class="line"><span class="comment">         * and the upper the shared (reader) hold count.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line">        <span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>首先ReentrantReadWriterLock使用一个32位的int类型来表示锁被占用的线程数（ReentrantLock中的state）,用所以，采取的办法是，高16位用来表示读锁占有的线程数量，用低16位表示写锁被同一个线程申请的次数。</p>
<ul>
<li>SHARED_SHIFT，表示读锁占用的位数，常量16</li>
<li>SHARED_UNIT，  增加一个读锁，按照上述设计，就相当于增加 SHARED_UNIT；</li>
<li>MAX_COUNT   ，表示申请读锁最大的线程数量，为65535</li>
<li>EXCLUSIVE_MASK  :表示计算写锁的具体值时，该值为 15个1,用 getState &amp; EXCLUSIVE_MASK算出写锁的线程数，大于1表示重入。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure>

<p>举例说明，比如，现在当前，申请读锁的线程数为13个，写锁一个，那state怎么表示？</p>
<p>上文说过，用一个32位的int类型的高16位表示读锁线程数，13的二进制为 1101,那state的二进制表示为</p>
<p>00000000 00001101 00000000 00000001，十进制数为 851969， 接下在具体获取锁时，需要根据这个 851968 这个值得出上文中的 13 与 1。要算成13，只需要将state 无符号向左移位16位置，得出00000000 00001101，就出13，根据851969要算成低16位置，只需要用该00000000 00001101 00000000 00000001 &amp; 111111111111111（15位），就可以得出00000001,就是利用了1&amp;1得1,1&amp;0得0这个技巧。</p>
<p>移位元素，如果一个数值向左移(&lt;)一位，在没越界（超过该类型表示的最大值）的情况下，想当于操作数 * 2</p>
<p>如果一个数值向右(&gt;) 移动移位，在没有越界的情况下，想到于操作数 除以2。</p>
<p>然后再关注如下几个与线程本地变量相关的属性：  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The number of reentrant read locks held by current thread.</span></span><br><span class="line"><span class="comment">         * Initialized only in constructor and readObject.</span></span><br><span class="line"><span class="comment">         * Removed whenever a thread&#x27;s read hold count drops to 0.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The hold count of the last thread to successfully acquire</span></span><br><span class="line"><span class="comment">         * readLock. This saves ThreadLocal lookup in the common case</span></span><br><span class="line"><span class="comment">         * where the next thread to release is the last one to</span></span><br><span class="line"><span class="comment">         * acquire. This is non-volatile since it is just used</span></span><br><span class="line"><span class="comment">         * as a heuristic, and would be great for threads to cache.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Can outlive the Thread for which it is caching the read</span></span><br><span class="line"><span class="comment">         * hold count, but avoids garbage retention by not retaining a</span></span><br><span class="line"><span class="comment">         * reference to the Thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">         * model&#x27;s final field and out-of-thin-air guarantees.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * firstReader is the first thread to have acquired the read lock.</span></span><br><span class="line"><span class="comment">         * firstReaderHoldCount is firstReader&#x27;s hold count.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;More precisely, firstReader is the unique thread that last</span></span><br><span class="line"><span class="comment">         * changed the shared count from 0 to 1, and has not released the</span></span><br><span class="line"><span class="comment">         * read lock since then; null if there is no such thread.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Cannot cause garbage retention unless the thread terminated</span></span><br><span class="line"><span class="comment">         * without relinquishing its read locks, since tryReleaseShared</span></span><br><span class="line"><span class="comment">         * sets it to null.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Accessed via a benign data race; relies on the memory</span></span><br><span class="line"><span class="comment">         * model&#x27;s out-of-thin-air guarantees for references.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;This allows tracking of read holds for uncontended read</span></span><br><span class="line"><span class="comment">         * locks to be very cheap.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br></pre></td></tr></table></figure>

<p>上述这4个变量，其实就是完成一件事情，将获取读锁的线程放入线程本地变量(ThreadLocal)，方便从整个上 下文，根据当前线程获取持有锁的次数信息。其实 firstReader,firstReaderHoldCount ,cachedHoldCounter 这三个变量就是为readHolds变量服务的，是一个优化手段，尽量减少直接使用readHolds.get方法的次数，firstReader与firstReadHoldCount保存第一个获取读锁的线程，也就是readHolds中并不会保存第一个获取读锁的线程；cachedHoldCounter 缓存的是最后一个获取线程的HolderCount信息，该变量主要是在如果当前线程多次获取读锁时，减少从readHolds中获取HoldCounter的次数。请结合如下代码理解上述观点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">    firstReader = current;</span><br><span class="line">    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">    firstReaderHoldCount++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">        readHolds.set(rh);</span><br><span class="line">    rh.count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、ReentrantReadWriterLock源码分析"><a href="#2、ReentrantReadWriterLock源码分析" class="headerlink" title="2、ReentrantReadWriterLock源码分析"></a>2、ReentrantReadWriterLock源码分析</h2><h2 id="2-1-ReadLock-源码分析"><a href="#2-1-ReadLock-源码分析" class="headerlink" title="2.1 ReadLock 源码分析"></a>2.1 ReadLock 源码分析</h2><h3 id="2-1-1-lock方法"><a href="#2-1-1-lock方法" class="headerlink" title="2.1.1 lock方法"></a>2.1.1 lock方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Acquires the read lock.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;Acquires the read lock if the write lock is not held by</span></span><br><span class="line"><span class="comment">         * another thread and returns immediately.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * &lt;p&gt;If the write lock is held by another thread then</span></span><br><span class="line"><span class="comment">         * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment">         * purposes and lies dormant until the read lock has been acquired.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>sync.acquireShared方法存在于AbstractQueuedSynchronizer类中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared mode, ignoring interrupts.  Implemented by</span></span><br><span class="line"><span class="comment">     * first invoking at least once &#123;<span class="doctag">@link</span> #tryAcquireShared&#125;,</span></span><br><span class="line"><span class="comment">     * returning on success.  Otherwise the thread is queued, possibly</span></span><br><span class="line"><span class="comment">     * repeatedly blocking and unblocking, invoking &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125; until success.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument.  This value is conveyed to</span></span><br><span class="line"><span class="comment">     *        &#123;<span class="doctag">@link</span> #tryAcquireShared&#125; but is otherwise uninterpreted</span></span><br><span class="line"><span class="comment">     *        and can represent anything you like.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    <span class="comment">//@1</span></span><br><span class="line">            doAcquireShared(arg);           <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据常识，具体获取锁的过程在子类中实现，果不其然，tryAcquireShared方法在ReentrantReadWriterLock的Sync类中实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If write lock held by another thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. Otherwise, this thread is eligible for</span></span><br><span class="line"><span class="comment">             *    lock wrt state, so ask if it should block</span></span><br><span class="line"><span class="comment">             *    because of queue policy. If not, try</span></span><br><span class="line"><span class="comment">             *    to grant by CASing state and updating count.</span></span><br><span class="line"><span class="comment">             *    Note that step does not check for reentrant</span></span><br><span class="line"><span class="comment">             *    acquires, which is postponed to full version</span></span><br><span class="line"><span class="comment">             *    to avoid having to check hold count in</span></span><br><span class="line"><span class="comment">             *    the more typical non-reentrant case.</span></span><br><span class="line"><span class="comment">             * 3. If step 2 fails either because thread</span></span><br><span class="line"><span class="comment">             *    apparently not eligible or CAS fails or count</span></span><br><span class="line"><span class="comment">             *    saturated, chain to version with full retry loop.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();    <span class="comment">//@1 start</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;                                                     <span class="comment">// @1 end</span></span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;                          </span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;    <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;                                      <span class="comment">//@21                               </span></span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;  <span class="comment">//@22</span></span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;                                            <span class="comment">// @23</span></span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);      <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>尝试获取共享锁代码解读：</p>
<p>@1 start–end ，如果有线程已经抢占了写锁，并且不是当前线程，则直接返回-1，通过排队获取锁。</p>
<p>@2,如果线程不需要阻塞，并且获取读锁的线程数没有超过最大值，并且使用 CAS更新共享锁线程数量成功的话；表示成获取读锁，然后进行内部变量的相关更新操作；先关注一下，成功获取读锁后，内部变量的更新操作：</p>
<p>@21,如果r=0, 表示，当前线程为第一个获取读锁的线程</p>
<p>@22,如果第一个获取读锁的对象为当前对象，将firstReaderHoldCount 加一</p>
<p>@23，成功获取锁后，如果不是第一个获取多锁的线程，将该线程持有锁的次数信息，放入线程本地变量中，方便在整个请求上下文（请求锁、释放锁等过程中）使用持有锁次数信息。</p>
<p>@3 在讲解代码@3之前，我们先重点分析@2处的第一个条件，是否需要阻塞方法：readerShouldBlock，在具体的子类中，现在查看的是NonfairSync中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">/* As a heuristic to avoid indefinite writer starvation,</span></span><br><span class="line"><span class="comment">             * block if the thread that momentarily appears to be head</span></span><br><span class="line"><span class="comment">             * of queue, if one exists, is a waiting writer.  This is</span></span><br><span class="line"><span class="comment">             * only a probabilistic effect since a new reader will not</span></span><br><span class="line"><span class="comment">             * block if there is a waiting writer behind other enabled</span></span><br><span class="line"><span class="comment">             * readers that have not yet drained from the queue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();   <span class="comment">//该方法，具体又是在 AbstractQueuedSynchronizer中</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if the apparent first queued thread, if one</span></span><br><span class="line"><span class="comment">     * exists, is waiting in exclusive mode.  If this method returns</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> true&#125;, and the current thread is attempting to acquire in</span></span><br><span class="line"><span class="comment">     * shared mode (that is, this method is invoked from &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     * #tryAcquireShared&#125;) then it is guaranteed that the current thread</span></span><br><span class="line"><span class="comment">     * is not the first queued thread.  Used only as a heuristic in</span></span><br><span class="line"><span class="comment">     * ReentrantReadWriteLock.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>该方法如果头节点不为空，并头节点的下一个节点不为空，并且不是共享模式【独占模式，写锁】、并且线程不为空。则返回true,说明有当前申请读锁的线程占有写锁，并有其他写锁在申请。为什么要判断head节点的下一个节点不为空，或是thread不为空呢？因为第一个节点head节点是当前持有写锁的线程，也就是当前申请读锁的线程，这里，也就是锁降级的关键所在，如果占有的写锁不是当前线程，那线程申请读锁会直接失败。</p>
<p>现在继续回到@3，讲解如果第一次尝试获取读锁失败后，该如何处理。首先，进入该方法的条件如下：</p>
<ul>
<li>没有写锁被占用时，尝试通过一次CAS去获取锁时，更新失败（说明有其他读锁在申请）。</li>
<li>当前线程占有写锁，并且没有有其他写锁在当前线程的下一个节点等待获取写锁。；其实如果是这种情况，除非当前线程占有锁的下个线程取消，否则进入fullTryAcquireShared方法也无法获取锁。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Full version of acquire for reads, that handles CAS misses</span></span><br><span class="line"><span class="comment">         * and reentrant reads not dealt with in tryAcquireShared.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;                                     <span class="comment">//@31</span></span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;                             <span class="comment">//@32</span></span><br><span class="line">                    <span class="comment">// Make sure we&#x27;re not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;                              <span class="comment">//@33</span></span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;                                                              <span class="comment">//@34</span></span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId()) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)                           </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;     <span class="comment">// @35</span></span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码@31,首先再次判断，如果当前线程不是写锁的持有者，直接返回-1，结束尝试获取读锁，需要排队去申请读锁。</p>
<p>代码@32，如果需要阻塞，说明除了当前线程持有写锁外，还有其他线程已经排队在申请写锁，故，即使申请读锁的线程已经持有写锁（写锁内部再次申请读锁，俗称锁降级）还是会失败，因为有其他线程也在申请写锁，此时，只能结束本次申请读锁的请求，转而去排队，否则，将造成死锁。代码@34，就是从readHolds中移除当前线程的持有数，然后返回-1，结束尝试获取锁步骤（结束tryAcquireShared 方法）然后去排队获取。</p>
<p>代码@33，因为，如果当前线程是第一个获取了写锁，那其他线程无法申请写锁（该部分在分析完，读写锁的队列机制后，才回来做更详细的解答。）</p>
<p>代码@35,表示成功获取读锁，后续就是更新readHolds等内部变量，该部分在上文中已有讲解。如果是通过@35尝试获取锁成功，这就是写锁内部–》再次申请读锁（锁降级）的原理。</p>
<p>至此，完成尝试获取锁步骤 tryAcquireShared 方法，我们再次回到 acquireShared，如果返回-1,那么需要排队申请,具体请看 doAcquireShared(arg);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)    <span class="comment">//@1</span></span><br><span class="line">            doAcquireShared(arg);           <span class="comment">//@2</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Acquires in shared uninterruptible mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);   <span class="comment">//@1</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// @2,开始自旋重试</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();   <span class="comment">// @3</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;                                   <span class="comment">// @4</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);         </span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);    <span class="comment">//@5</span></span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())                                              <span class="comment">// @6</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取共享锁解读：</p>
<p>代码@1，在队列尾部增加一个节点。锁模式为共享模式。</p>
<p>代码@3，获取该节点的前置节点。</p>
<p>代码@4，如果该节点的前置节点为head(头部)，为什么前置节点是head时，可以再次尝试呢？在讲解ReentrantLock时，也讲过，head节点的初始化在第一次产生锁争用时初始化，刚开始初始化的head节点是不代表线程的，故可以尝试获取锁。如果获取失败，则将进入到shouldParkAfterFailedAcquire和parkAndCheckInterrupt方法中，线程阻塞，等待被唤醒。</p>
<p>重点分析一下获取锁后的操作：setHeadAndPropagate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue, and checks if successor may be waiting</span></span><br><span class="line"><span class="comment">     * in shared mode, if so propagating if either propagate &gt; 0 or</span></span><br><span class="line"><span class="comment">     * PROPAGATE status was set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> propagate the return value from a tryAcquireShared</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below </span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;   <span class="comment">// @1</span></span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())    <span class="comment">// @2</span></span><br><span class="line">                doReleaseShared();          <span class="comment">//@3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets head of queue to be node, thus dequeuing. Called only by</span></span><br><span class="line"><span class="comment">     * acquire methods.  Also nulls out unused fields for sake of GC</span></span><br><span class="line"><span class="comment">     * and to suppress unnecessary signals and traversals.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        head = node;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;</span><br><span class="line">        node.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signal successor and ensure</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;   <span class="comment">//@4</span></span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;   <span class="comment">//@5</span></span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))   <span class="comment">//@6</span></span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed      //@7</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>释放共享锁的步骤：</p>
<p>代码@1,如果读锁（共享锁）获取成功，或头部节点为空，或头节点取消，或刚获取读锁的线程的下一个节点为空，或在节点的下个节点也在申请读锁，则在CLH队列中传播下去唤醒线程，怎么理解这个传播呢，就是只要获取成功到读锁，那就要传播到下一个节点（如果一下个节点继续是读锁的申请，只要成功获取，就再下一个节点，直到队列尾部或为写锁的申请，停止传播）。具体请看doReleaseShared方法。</p>
<p>代码@4，从队列的头部开始遍历每一个节点。</p>
<p>代码@5，如果节点状态为 Node.SIGNAL,将状态设置为0，设置成功，唤醒线程。为什么会设置不成功，可能改节点被取消；还有一种情况就是有多个线程在运行该代码段，这就是PROPAGATE的含义吧，传播，请看代码@7的理解。</p>
<p>代码@6，如果状态为0，则设置为Node.PROPAGATE，设置为传播，该值然后会在什么时候变化呢？在判断该节点的下一个节点是否需要阻塞时，会判断，如果状态不是Node.SIGNAL或取消状态，为了保险起见，会将前置节点状态设置为Node.SIGNAL，然后再次判断，是否需要阻塞。</p>
<p>代码@7，如果处理过一次 unparkSuccessor 方法后，头节点没有发生变化，就退出该方法，那head在什么时候会改变呢？当然在是抢占锁成功的时候，head节点代表获取锁的节点。一旦获取锁成功，则又会进入setHeadAndPropagate方法，当然又会触发doReleaseShared方法，传播特性应该就是表现在这里吧。再想一下，同一时间，可以有多个多线程占有锁，那在锁释放时，写锁的释放比较简单，就是从头部节点下的第一个非取消节点，唤醒线程即可，为了在释放读锁的上下文环境中获取代表读锁的线程，将信息存入在 readHolds ThreadLocal变量中。</p>
<p>到这里为止，读锁的申请就讲解完毕了，先给出如下流程图：</p>
<p><img src="https://img-blog.csdn.net/20161122154102536?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p>
<p>​                                    尝试获取读锁过程</p>
<p>从队列中获取读锁的流程如下：</p>
<h3 id="2-1-2-ReadLock-的-unlock方法详解"><a href="#2-1-2-ReadLock-的-unlock方法详解" class="headerlink" title="  2.1.2 ReadLock 的 unlock方法详解"></a><img src="https://img-blog.csdn.net/20161122154203111?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">  2.1.2 ReadLock 的 unlock方法详解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//AbstractQueuedSynchronizer的  realseShared方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ReentrantReadWriterLock.Sync tryReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123; </span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;                               <span class="comment">// @1 start               </span></span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">                    firstReader = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    firstReaderHoldCount--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != current.getId())</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">int</span> count = rh.count;</span><br><span class="line">                <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    readHolds.remove();</span><br><span class="line">                    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">                &#125;</span><br><span class="line">                --rh.count;                                                            <span class="comment">// @1 end</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;                                                               <span class="comment">// @2</span></span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">AbstractQueuedSynchronizer的doReleaseShared</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Release action for shared mode -- signal successor and ensure</span></span><br><span class="line"><span class="comment">     * propagation. (Note: For exclusive mode, release just amounts</span></span><br><span class="line"><span class="comment">     * to calling unparkSuccessor of head if it needs signal.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">         * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">         * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">         * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">         * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">         * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">         * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">         * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">         * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>锁的释放，比较简单，代码@1，主要是将当前线程所持有的锁的数量信息得到（从firstReader或cachedHoldCounter，或readHolds中获取 ），然后将数量减少1,如果持有数为1，则直接将该线程变量从readHolds ThreadLocal变量中移除，避免垃圾堆积。</p>
<p>代码@2，就是在无限循环中将共享锁的数量减少一，在释放锁阶段，只有当所有的读锁，写锁被占有，才会去执行doReleaseShared 方法。</p>
<h2 id="2-2-WriterLock-源码分析"><a href="#2-2-WriterLock-源码分析" class="headerlink" title="2.2 WriterLock 源码分析"></a>2.2 WriterLock 源码分析</h2><h3 id="2-2-1-lock方法详解"><a href="#2-2-1-lock方法详解" class="headerlink" title="2.2.1 lock方法详解"></a>2.2.1 lock方法详解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line">对上述代码是不是似曾相识，对了，在学习ReentrantLock时候，看到的一样，acquire是在AbstractQueuedSynchronizer中，关键是在 tryAcquire方法，是在不同的子类中实现的。那我们将目光移到ReentrantReadWriterLock.Sync中</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Walkthrough:</span></span><br><span class="line"><span class="comment">             * 1. If read count nonzero or write count nonzero</span></span><br><span class="line"><span class="comment">             *    and owner is a different thread, fail.</span></span><br><span class="line"><span class="comment">             * 2. If count would saturate, fail. (This can only</span></span><br><span class="line"><span class="comment">             *    happen if count is already nonzero.)</span></span><br><span class="line"><span class="comment">             * 3. Otherwise, this thread is eligible for lock if</span></span><br><span class="line"><span class="comment">             *    it is either a reentrant acquire or</span></span><br><span class="line"><span class="comment">             *    queue policy allows it. If so, update state</span></span><br><span class="line"><span class="comment">             *    and set owner.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;                                   <span class="comment">// @1</span></span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())                <span class="comment">//@2</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)              </span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                setState(c + acquires);                                                             <span class="comment">//@3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||                                                               </span><br><span class="line">                !compareAndSetState(c, c + acquires))                                   <span class="comment">//@4</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);                                             <span class="comment">//@5</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>代码@1,如果锁的state不为0，说明有写锁，或读锁，或两种锁持有。</p>
<p>代码@2，如果写锁为0，再加上c!=0，说明此时有读锁，自然返回false，表示只能排队去获取写锁；如果写锁不为0，如果持有写锁的线程不为当前线程，自然返回false,排队去获取写锁。</p>
<p>代码@3，表示，当前线程持有写锁，现在是重入，所以只需要修改锁的额数量即可。</p>
<p>代码@4，表示，表示通过一次CAS去获取锁的时候失败，说明被别的线程抢去了，也返回false,排队去重试获取锁。</p>
<p>代码@5，成获取写锁后，将当前线程设置为占有写锁的线程。尝试获取锁方法结束。如果该方法返回false,则进入到acquireQueue方法去排队获取写锁，写锁的获取过程，与ReentrantLock获取方法一样，就不过多的解读了。</p>
<p>读写锁的实现原理就分析到这了，走过路过的朋友，欢迎拍砖讨论。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>juc</tag>
        <tag>源码</tag>
        <tag>读写琐</tag>
        <tag>ReentrantReadWriteLock</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 RocketMQ DLedger 多副本之 Leader 选主</title>
    <url>/posts/8b1a2fc4.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文将按照<a href="https://blog.csdn.net/prestigeding/article/details/99101912">《RocketMQ 多副本前置篇：初探raft协议》</a>的思路来学习RocketMQ选主逻辑。首先先回顾一下关于Leader的一些思考：</p>
<ol>
<li>节点状态<br> 需要引入3种节点状态：Follower(跟随者)、Candidate(候选者)，该状态下的节点会发起投票请求，Leader(主节点)。</li>
<li>选举计时器<br> Follower、Candidate两个状态时，需要维护一个定时器，每次定时时间从150ms-300ms直接进行随机，即每个节点的定时过期不一样，Follower状态时，定时器到点后，触发一轮投票。节点在收到投票请求、Leader的心跳请求并作出响应后，需要重置定时器。</li>
<li>投票轮次Team<br> Candidate状态的节点，每发起一轮投票，Team加一。</li>
<li>投票机制<br> 每一轮一个节点只能为一个节点投赞成票，例如节点A中维护的轮次为3，并且已经为节点B投了赞成票，如果收到其他节点，投票轮次为3，则会投反对票，如果收到轮次为4的节点，是又可以投赞成票的。</li>
<li>成为Leader的条件<br> 必须得到集群中初始数量的大多数，例如如果集群中有3台，则必须得到两票，如果其中一台服务器宕机，剩下的两个节点，还能进行选主吗？答案是可以的，因为可以得到2票，超过初始集群中3的一半，所以通常集群中的机器各位尽量为奇数，因为4台的可用性与3台的一样。</li>
</ol>
<blockquote>
<p>温馨提示：本文是从源码的角度分析 DLedger 选主实现原理，可能比较鼓噪，文末给出了选主流程图。</p>
</blockquote>
<p>@<a href="%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">TOC</a></p>
<h2 id="1、DLedger关于选主的核心类图"><a href="#1、DLedger关于选主的核心类图" class="headerlink" title="1、DLedger关于选主的核心类图"></a>1、DLedger关于选主的核心类图</h2><p><img src="https://img-blog.csdnimg.cn/20190817201207350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="1-1-DLedgerConfig"><a href="#1-1-DLedgerConfig" class="headerlink" title="1.1 DLedgerConfig"></a>1.1 DLedgerConfig</h3><p>多副本模块相关的配置信息，例如集群节点信息。</p>
<h3 id="1-2-MemberState"><a href="#1-2-MemberState" class="headerlink" title="1.2 MemberState"></a>1.2 MemberState</h3><p>节点状态机，即raft协议中的follower、candidate、leader三种状态的状态机实现。</p>
<h3 id="1-3-raft协议相关"><a href="#1-3-raft协议相关" class="headerlink" title="1.3 raft协议相关"></a>1.3 raft协议相关</h3><h4 id="1-3-1-DLedgerClientProtocol"><a href="#1-3-1-DLedgerClientProtocol" class="headerlink" title="1.3.1 DLedgerClientProtocol"></a>1.3.1 DLedgerClientProtocol</h4><p>DLedger客户端协议，主要定义如下三个方法，在后面的日志复制部分会重点阐述。</p>
<ul>
<li>CompletableFuture&lt; GetEntriesResponse&gt; get(GetEntriesRequest request)<br>客户端从服务器获取日志条目（获取数据）</li>
<li>CompletableFuture&lt; AppendEntryResponse&gt; append(AppendEntryRequest request)<br>客户端向服务器追加日志（存储数据）</li>
<li>CompletableFuture&lt; MetadataResponse&gt; metadata(MetadataRequest request)<br>获取元数据。</li>
</ul>
<h4 id="1-3-2-DLedgerProtocol"><a href="#1-3-2-DLedgerProtocol" class="headerlink" title="1.3.2 DLedgerProtocol"></a>1.3.2 DLedgerProtocol</h4><p>DLedger服务端协议，主要定义如下三个方法。</p>
<ul>
<li>CompletableFuture&lt; VoteResponse&gt; vote(VoteRequest request)<br>发起投票请求。</li>
<li>CompletableFuture&lt; HeartBeatResponse&gt; heartBeat(HeartBeatRequest request)<br>Leader向从节点发送心跳包。</li>
<li>CompletableFuture&lt; PullEntriesResponse&gt; pull(PullEntriesRequest request)<br>拉取日志条目，在日志复制部分会详细介绍。</li>
<li>CompletableFuture&lt; PushEntryResponse&gt; push(PushEntryRequest request)<br>推送日志条件，在日志复制部分会详细介绍。</li>
</ul>
<h4 id="1-3-3-协议处理Handler"><a href="#1-3-3-协议处理Handler" class="headerlink" title="1.3.3 协议处理Handler"></a>1.3.3 协议处理Handler</h4><p>DLedgerClientProtocolHandler、DLedgerProtocolHander协议处理器。</p>
<h3 id="1-4-DLedgerRpcService"><a href="#1-4-DLedgerRpcService" class="headerlink" title="1.4 DLedgerRpcService"></a>1.4 DLedgerRpcService</h3><p>DLedger Server(节点)之间的网络通信，默认基于Netty实现，其实现类为：DLedgerRpcNettyService。</p>
<h3 id="1-5-DLedgerLeaderElector"><a href="#1-5-DLedgerLeaderElector" class="headerlink" title="1.5 DLedgerLeaderElector"></a>1.5 DLedgerLeaderElector</h3><p>Leader选举实现器。</p>
<h3 id="1-6-DLedgerServer"><a href="#1-6-DLedgerServer" class="headerlink" title="1.6 DLedgerServer"></a>1.6 DLedgerServer</h3><p>Dledger Server，Dledger节点的封装类。</p>
<p>接下来将从DLedgerLeaderElector开始剖析DLedger是如何实现Leader选举的。（基于raft协议）。</p>
<a id="more"></a>

<h2 id="2、源码分析Leader选举"><a href="#2、源码分析Leader选举" class="headerlink" title="2、源码分析Leader选举"></a>2、源码分析Leader选举</h2><h3 id="2-1-DLedgerLeaderElector-类图"><a href="#2-1-DLedgerLeaderElector-类图" class="headerlink" title="2.1 DLedgerLeaderElector 类图"></a>2.1 DLedgerLeaderElector 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190817201557322.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们先一一来介绍其属性的含义：</p>
<ul>
<li>Random random<br>随机数生成器，对应raft协议中选举超时时间是一随机数。</li>
<li>DLedgerConfig dLedgerConfig<br>配置参数。</li>
<li>MemberState memberState<br>节点状态机。</li>
<li>DLedgerRpcService dLedgerRpcService<br>rpc服务，实现向集群内的节点发送心跳包、投票的RPC实现。<br>l- ong lastLeaderHeartBeatTime<br>上次收到心跳包的时间戳。</li>
<li>long lastSendHeartBeatTime<br>上次发送心跳包的时间戳。</li>
<li>long lastSuccHeartBeatTime<br>上次成功收到心跳包的时间戳。</li>
<li>int heartBeatTimeIntervalMs<br>一个心跳包的周期，默认为2s。</li>
<li>int maxHeartBeatLeak<br>允许最大的N个心跳周期内未收到心跳包，状态为Follower的节点只有超过 maxHeartBeatLeak * heartBeatTimeIntervalMs 的时间内未收到主节点的心跳包，才会重新进入 Candidate 状态，重新下一轮的选举。</li>
<li>long nextTimeToRequestVote<br>发送下一个心跳包的时间戳。</li>
<li>boolean needIncreaseTermImmediately<br>是否应该立即发起投票。</li>
<li>int minVoteIntervalMs<br>最小的发送投票间隔时间，默认为300ms。</li>
<li>int maxVoteIntervalMs<br>最大的发送投票的间隔，默认为1000ms。</li>
<li>List&lt; RoleChangeHandler&gt; roleChangeHandlers<br>注册的节点状态处理器，通过 addRoleChangeHandler 方法添加。</li>
<li>long lastVoteCost<br>上一次投票的开销。</li>
<li>StateMaintainer stateMaintainer<br>状态机管理器。</li>
</ul>
<h3 id="2-2-启动选举状态管理器"><a href="#2-2-启动选举状态管理器" class="headerlink" title="2.2 启动选举状态管理器"></a>2.2 启动选举状态管理器</h3><p>通过 DLedgerLeaderElector 的 startup 方法启动状态管理机，代码如下：<br>DLedgerLeaderElector#startup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stateMaintainer.start();   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (RoleChangeHandler roleChangeHandler : roleChangeHandlers) &#123;   <span class="comment">// @2</span></span><br><span class="line">        roleChangeHandler.startup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：启动状态维护管理器。</p>
<p>代码@2：遍历状态改变监听器并启动它，可通过DLedgerLeaderElector 的 addRoleChangeHandler 方法增加状态变化监听器。</p>
<p>其中的是启动状态管理器线程，其run方法实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (running.get()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doWork();    </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Unexpected Error in running &#123;&#125; &quot;</span>, getName(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    latch.countDown();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>从上面来看，主要是循环调用doWork方法，接下来重点看其doWork的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DLedgerLeaderElector.<span class="keyword">this</span>.dLedgerConfig.isEnableLeaderElector()) &#123;   <span class="comment">// @1</span></span><br><span class="line">            DLedgerLeaderElector.<span class="keyword">this</span>.refreshIntervals(dLedgerConfig);                 <span class="comment">// @2</span></span><br><span class="line">            DLedgerLeaderElector.<span class="keyword">this</span>.maintainState();                                           <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">10</span>);                                                                                                    <span class="comment">// @4</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        DLedgerLeaderElector.logger.error(<span class="string">&quot;Error in heartbeat&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果该节点参与Leader选举，则首先调用@2重置定时器，然后驱动状态机(@3)，是接下来重点需要剖析的。</p>
<p>代码@4：没执行一次选主，休息10ms。</p>
<p>DLedgerLeaderElector#maintainState</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintainState</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memberState.isLeader()) &#123;  </span><br><span class="line">        maintainAsLeader();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memberState.isFollower()) &#123;</span><br><span class="line">        maintainAsFollower();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maintainAsCandidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据当前的状态机状态，执行对应的操作，从raft协议中可知，总共存在3种状态：</p>
<ul>
<li>leader<br>领导者，主节点，该状态下，需要定时向从节点发送心跳包，用来传播数据、确保其领导地位。</li>
<li>follower<br>从节点，该状态下，会开启定时器，尝试进入到candidate状态，以便发起投票选举，同时一旦收到主节点的心跳包，则重置定时器。</li>
<li>candidate<br>候选者，该状态下的节点会发起投票，尝试选择自己为主节点，选举成功后，不会存在该状态下的节点。</li>
</ul>
<p>我们在继续往下看之前，需要知道 memberState 的初始值是什么？我们追溯到创建 MemberState 的地方，发现其初始状态为 CANDIDATE。那我们接下从 maintainAsCandidate 方法开始跟进。</p>
<blockquote>
<p>温馨提示：在raft协议中，节点的状态默认为follower，DLedger的实现从candidate开始，一开始，集群内的所有节点都会尝试发起投票，这样第一轮要达成选举几乎不太可能。</p>
</blockquote>
<h3 id="2-3-选举状态机状态流转"><a href="#2-3-选举状态机状态流转" class="headerlink" title="2.3 选举状态机状态流转"></a>2.3 选举状态机状态流转</h3><p>整个状态机的驱动，由线程反复执行maintainState方法。下面重点来分析其状态的驱动。</p>
<h4 id="2-3-1-maintainAsCandidate-方法"><a href="#2-3-1-maintainAsCandidate-方法" class="headerlink" title="2.3.1  maintainAsCandidate 方法"></a>2.3.1  maintainAsCandidate 方法</h4><p>DLedgerLeaderElector#maintainAsCandidate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (System.currentTimeMillis() &lt; nextTimeToRequestVote &amp;&amp; !needIncreaseTermImmediately) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> term;</span><br><span class="line"><span class="keyword">long</span> ledgerEndTerm;</span><br><span class="line"><span class="keyword">long</span> ledgerEndIndex;</span><br></pre></td></tr></table></figure>
<p>Step1：首先先介绍几个变量的含义：</p>
<ul>
<li>nextTimeToRequestVote<br>下一次发发起的投票的时间，如果当前时间小于该值，说明计时器未过期，此时无需发起投票。</li>
<li>needIncreaseTermImmediately<br>是否应该立即发起投票。如果为true，则忽略计时器，该值默认为false，当收到从主节点的心跳包并且当前状态机的轮次大于主节点的轮次，说明集群中Leader的投票轮次小于从几点的轮次，应该立即发起新的投票。</li>
<li>term<br>投票轮次。</li>
<li>ledgerEndTerm<br>Leader节点当前的投票轮次。</li>
<li>ledgerEndIndex<br>当前日志的最大序列，即下一条日志的开始index，在日志复制部分会详细介绍。</li>
</ul>
<p>DLedgerLeaderElector#maintainAsCandidate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (memberState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!memberState.isCandidate()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lastParseResult == VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT || needIncreaseTermImmediately) &#123;</span><br><span class="line">        <span class="keyword">long</span> prevTerm = memberState.currTerm();</span><br><span class="line">        term = memberState.nextTerm();</span><br><span class="line">        logger.info(<span class="string">&quot;&#123;&#125;_[INCREASE_TERM] from &#123;&#125; to &#123;&#125;&quot;</span>, memberState.getSelfId(), prevTerm, term);</span><br><span class="line">        lastParseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        term = memberState.currTerm();</span><br><span class="line">    &#125;</span><br><span class="line">    ledgerEndIndex = memberState.getLedgerEndIndex();</span><br><span class="line">    ledgerEndTerm = memberState.getLedgerEndTerm();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：初始化team、ledgerEndIndex 、ledgerEndTerm 属性，其实现关键点如下：</p>
<ul>
<li>如果上一次的投票结果为待下一次投票或应该立即开启投票，并且根据当前状态机获取下一轮的投票轮次，稍后会着重讲解一下状态机轮次的维护机制。</li>
<li>如果上一次的投票结果不是WAIT_TO_VOTE_NEXT(等待下一轮投票)，则投票轮次依然为状态机内部维护的轮次。</li>
</ul>
<p>DLedgerLeaderElector#maintainAsCandidate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (needIncreaseTermImmediately) &#123;</span><br><span class="line">    nextTimeToRequestVote = getNextTimeToRequestVote();</span><br><span class="line">    needIncreaseTermImmediately = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：如果needIncreaseTermImmediately为true，则重置该标记位为false，并重新设置下一次投票超时时间，其实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getNextTimeToRequestVote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> System.currentTimeMillis() + lastVoteCost + minVoteIntervalMs + random.nextInt(maxVoteIntervalMs - minVoteIntervalMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一次倒计时：当前时间戳 + 上次投票的开销 + 最小投票间隔(300ms) +  （1000- 300 ）之间的随机值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> List&lt;CompletableFuture&lt;VoteResponse&gt;&gt; quorumVoteResponses = voteForQuorumResponses(term, ledgerEndTerm, ledgerEndIndex);</span><br></pre></td></tr></table></figure>
<p>Step4：向集群内的其他节点发起投票请，并返回投票结果列表，稍后会重点分析其投票过程。可以预见，接下来就是根据各投票结果进行仲裁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> AtomicLong knownMaxTermInGroup = <span class="keyword">new</span> AtomicLong(-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">final</span> AtomicInteger allNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> AtomicInteger validNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> AtomicInteger acceptedNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> AtomicInteger notReadyTermNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> AtomicInteger biggerLedgerNum = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">final</span> AtomicBoolean alreadyHasLeader = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>Step5：在进行投票结果仲裁之前，先来介绍几个局部变量的含义：</p>
<ul>
<li>knownMaxTermInGroup<br>已知的最大投票轮次。</li>
<li>allNum<br>所有投票票数。</li>
<li>validNum<br>有效投票数。 </li>
<li>acceptedNum<br>获得的投票数。 </li>
<li>notReadyTermNum<br>未准备投票的节点数量，如果对端节点的投票轮次小于发起投票的轮次，则认为对端未准备好，对端节点使用本次的轮次进入 - Candidate 状态。</li>
<li>biggerLedgerNum<br> 发起投票的节点的ledgerEndTerm小于对端节点的个数。</li>
<li>alreadyHasLeader<br>是否已经存在Leader。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (CompletableFuture&lt;VoteResponse&gt; future : quorumVoteResponses) &#123;</span><br><span class="line">   <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step5：遍历投票结果，收集投票结果，接下来重点看其内部实现。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x.getVoteResult() != VoteResponse.RESULT.UNKNOWN) &#123;</span><br><span class="line">    validNum.incrementAndGet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step6：如果投票结果不是UNKNOW，则有效投票数量增1。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (knownMaxTermInGroup) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (x.getVoteResult()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACCEPT:</span><br><span class="line">            acceptedNum.incrementAndGet();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECT_ALREADY_VOTED:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECT_ALREADY_HAS_LEADER:</span><br><span class="line">            alreadyHasLeader.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECT_TERM_SMALL_THAN_LEDGER:</span><br><span class="line">        <span class="keyword">case</span> REJECT_EXPIRED_VOTE_TERM:</span><br><span class="line">            <span class="keyword">if</span> (x.getTerm() &gt; knownMaxTermInGroup.get()) &#123;</span><br><span class="line">                knownMaxTermInGroup.set(x.getTerm());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECT_EXPIRED_LEDGER_TERM:</span><br><span class="line">        <span class="keyword">case</span> REJECT_SMALL_LEDGER_END_INDEX:</span><br><span class="line">            biggerLedgerNum.incrementAndGet();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECT_TERM_NOT_READY:</span><br><span class="line">            notReadyTermNum.incrementAndGet();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step7：统计投票结构，几个关键点如下：</li>
<li>ACCEPT<br>赞成票，acceptedNum加一，只有得到的赞成票超过集群节点数量的一半才能成为Leader。</li>
<li>REJECT_ALREADY_VOTED<br>拒绝票，原因是已经投了其他节点的票。</li>
<li>REJECT_ALREADY_HAS_LEADER<br>拒绝票，原因是因为集群中已经存在Leaer了。alreadyHasLeader设置为true，无需在判断其他投票结果了，结束本轮投票。</li>
<li>REJECT_TERM_SMALL_THAN_LEDGER<br>拒绝票，如果自己维护的term小于远端维护的ledgerEndTerm，则返回该结果，如果对端的team大于自己的team，需要记录对端最大的投票轮次，以便更新自己的投票轮次。</li>
<li>REJECT_EXPIRED_VOTE_TERM<br>拒绝票，如果自己维护的term小于远端维护的term，更新自己维护的投票轮次。</li>
<li>REJECT_EXPIRED_LEDGER_TERM<br>拒绝票，如果自己维护的 ledgerTerm小于对端维护的ledgerTerm，则返回该结果。如果是此种情况，增加计数器- biggerLedgerNum的值。</li>
<li>REJECT_SMALL_LEDGER_END_INDEX<br>拒绝票，如果对端的ledgerTeam与自己维护的ledgerTeam相等，但是自己维护的dedgerEndIndex小于对端维护的值，返回该值，增加biggerLedgerNum计数器的值。</li>
<li>REJECT_TERM_NOT_READY<br>拒绝票，对端的投票轮次小于自己的team，则认为对端还未准备好投票，对端使用自己的投票轮次，是自己进入到Candidate状态。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    voteLatch.await(<span class="number">3000</span> + random.nextInt(maxVoteIntervalMs), TimeUnit.MILLISECONDS);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step8：等待收集投票结果，并设置超时时间。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lastVoteCost = DLedgerUtils.elapsed(startVoteTimeMs);</span><br><span class="line">VoteResponse.ParseResult parseResult;</span><br><span class="line"><span class="keyword">if</span> (knownMaxTermInGroup.get() &gt; term) &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT;</span><br><span class="line">    nextTimeToRequestVote = getNextTimeToRequestVote();</span><br><span class="line">    changeRoleToCandidate(knownMaxTermInGroup.get());</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (alreadyHasLeader.get()) &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT;</span><br><span class="line">    nextTimeToRequestVote = getNextTimeToRequestVote() + heartBeatTimeIntervalMs * maxHeartBeatLeak;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!memberState.isQuorum(validNum.get())) &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE;</span><br><span class="line">    nextTimeToRequestVote = getNextTimeToRequestVote();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (memberState.isQuorum(acceptedNum.get())) &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.PASSED;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (memberState.isQuorum(acceptedNum.get() + notReadyTermNum.get())) &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.REVOTE_IMMEDIATELY;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (memberState.isQuorum(acceptedNum.get() + biggerLedgerNum.get())) &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.WAIT_TO_REVOTE;</span><br><span class="line">    nextTimeToRequestVote = getNextTimeToRequestVote();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    parseResult = VoteResponse.ParseResult.WAIT_TO_VOTE_NEXT;</span><br><span class="line">    nextTimeToRequestVote = getNextTimeToRequestVote();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step9：根据收集的投票结果判断是否能成为Leader。<blockquote>
<p>温馨提示：在讲解关键点之前，我们先定义先将（当前时间戳 + 上次投票的开销 + 最小投票间隔(300ms) +  （1000- 300 ）之间的随机值）定义为“ 1个常规计时器”。</p>
</blockquote>
</li>
</ul>
<p>其关键点如下：</p>
<ul>
<li>如果对端的投票轮次大于发起投票的节点，则该节点使用对端的轮次，重新进入到Candidate状态，并且重置投票计时器，其值为“1个常规计时器”</li>
<li>如果已经存在Leader，该节点重新进入到Candidate,并重置定时器，该定时器的时间： “1个常规计时器” + heartBeatTimeIntervalMs * maxHeartBeatLeak ，其中 heartBeatTimeIntervalMs 为一次心跳间隔时间，<br>maxHeartBeatLeak 为  允许最大丢失的心跳包，即如果Flower节点在多少个心跳周期内未收到心跳包，则认为Leader已下线。</li>
<li>如果收到的有效票数未超过半数，则重置计时器为“ 1个常规计时器”，然后等待重新投票，注意状态为WAIT_TO_REVOTE，该状态下的特征是下次投票时不增加投票轮次。</li>
<li>如果得到的赞同票超过半数，则成为Leader。</li>
<li>如果得到的赞成票加上未准备投票的节点数超过半数，则应该立即发起投票，故其结果为REVOTE_IMMEDIATELY。</li>
<li>如果得到的赞成票加上对端维护的ledgerEndIndex超过半数，则重置计时器，继续本轮次的选举。</li>
<li>其他情况，开启下一轮投票。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (parseResult == VoteResponse.ParseResult.PASSED) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;[&#123;&#125;] [VOTE_RESULT] has been elected to be the leader in term &#123;&#125;&quot;</span>, memberState.getSelfId(), term);</span><br><span class="line">    changeRoleToLeader(term);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step10：如果投票成功，则状态机状态设置为Leader，然后状态管理在驱动状态时会调用DLedgerLeaderElector#maintainState时，将进入到maintainAsLeader方法。</li>
</ul>
<h4 id="2-3-2-maintainAsLeader-方法"><a href="#2-3-2-maintainAsLeader-方法" class="headerlink" title="2.3.2  maintainAsLeader 方法"></a>2.3.2  maintainAsLeader 方法</h4><p>经过maintainAsCandidate 投票选举后，被其他节点选举成为领导后，会执行该方法，其他节点的状态还是Candidate，并在计时器过期后，又尝试去发起选举。接下来重点分析成为Leader节点后，该节点会做些什么？</p>
<p>DLedgerLeaderElector#maintainAsLeader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintainAsLeader</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DLedgerUtils.elapsed(lastSendHeartBeatTime) &gt; heartBeatTimeIntervalMs) &#123;  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">long</span> term;</span><br><span class="line">        String leaderId;</span><br><span class="line">        <span class="keyword">synchronized</span> (memberState) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!memberState.isLeader()) &#123;     <span class="comment">// @2</span></span><br><span class="line">                <span class="comment">//stop sending</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            term = memberState.currTerm();</span><br><span class="line">            leaderId = memberState.getLeaderId();</span><br><span class="line">            lastSendHeartBeatTime = System.currentTimeMillis();    <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">        sendHeartbeats(term, leaderId);    <span class="comment">// @4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先判断上一次发送心跳的时间与当前时间的差值是否大于心跳包发送间隔，如果超过，则说明需要发送心跳包。</p>
<p>代码@2：如果当前不是leader节点，则直接返回，主要是为了二次判断。</p>
<p>代码@3：重置心跳包发送计时器。</p>
<p>代码@4：向集群内的所有节点发送心跳包，稍后会详细介绍心跳包的发送。</p>
<h4 id="2-3-3-maintainAsFollower方法"><a href="#2-3-3-maintainAsFollower方法" class="headerlink" title="2.3.3  maintainAsFollower方法"></a>2.3.3  maintainAsFollower方法</h4><p>当 Candidate 状态的节点在收到主节点发送的心跳包后，会将状态变更为follower，那我们先来看一下在follower状态下，节点会做些什么事情？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maintainAsFollower</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DLedgerUtils.elapsed(lastLeaderHeartBeatTime) &gt; <span class="number">2</span> * heartBeatTimeIntervalMs) &#123;   </span><br><span class="line">        <span class="keyword">synchronized</span> (memberState) &#123;</span><br><span class="line">            <span class="keyword">if</span> (memberState.isFollower() &amp;&amp; (DLedgerUtils.elapsed(lastLeaderHeartBeatTime) &gt; maxHeartBeatLeak * heartBeatTimeIntervalMs)) &#123;</span><br><span class="line">                logger.info(<span class="string">&quot;[&#123;&#125;][HeartBeatTimeOut] lastLeaderHeartBeatTime: &#123;&#125; heartBeatTimeIntervalMs: &#123;&#125; lastLeader=&#123;&#125;&quot;</span>, memberState.getSelfId(), <span class="keyword">new</span> Timestamp(lastLeaderHeartBeatTime), heartBeatTimeIntervalMs, memberState.getLeaderId());</span><br><span class="line">                changeRoleToCandidate(memberState.currTerm());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果maxHeartBeatLeak (默认为3)个心跳包周期内未收到心跳，则将状态变更为Candidate。</p>
<p>状态机的驱动就介绍到这里，在上面的流程中，其实我们忽略了两个重要的过程，一个是发起投票请求与投票请求响应、发送心跳包与心跳包响应，那我们接下来将重点介绍这两个过程。</p>
<h3 id="2-4-投票与投票请求"><a href="#2-4-投票与投票请求" class="headerlink" title="2.4 投票与投票请求"></a>2.4 投票与投票请求</h3><p>节点的状态为 Candidate 时会向集群内的其他节点发起投票请求(个人觉得理解为拉票更好)，向对方询问是否愿意选举我为Leader，对端节点会根据自己的情况对其投赞成票、拒绝票，如果是拒绝票，还会给出拒绝原因，具体由voteForQuorumResponses、handleVote 这两个方法来实现，接下来我们分别对这两个方法进行详细分析。</p>
<h4 id="2-4-1-voteForQuorumResponses"><a href="#2-4-1-voteForQuorumResponses" class="headerlink" title="2.4.1 voteForQuorumResponses"></a>2.4.1 voteForQuorumResponses</h4><p>发起投票请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;CompletableFuture&lt;VoteResponse&gt;&gt; voteForQuorumResponses(<span class="keyword">long</span> term, <span class="keyword">long</span> ledgerEndTerm,</span><br><span class="line">    <span class="keyword">long</span> ledgerEndIndex) <span class="keyword">throws</span> Exception &#123;   <span class="comment">// @1</span></span><br><span class="line">    List&lt;CompletableFuture&lt;VoteResponse&gt;&gt; responses = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String id : memberState.getPeerMap().keySet()) &#123;               <span class="comment">// @2</span></span><br><span class="line">        VoteRequest voteRequest = <span class="keyword">new</span> VoteRequest();                  <span class="comment">// @3 start</span></span><br><span class="line">        voteRequest.setGroup(memberState.getGroup());</span><br><span class="line">        voteRequest.setLedgerEndIndex(ledgerEndIndex);</span><br><span class="line">        voteRequest.setLedgerEndTerm(ledgerEndTerm);</span><br><span class="line">        voteRequest.setLeaderId(memberState.getSelfId());</span><br><span class="line">        voteRequest.setTerm(term);</span><br><span class="line">        voteRequest.setRemoteId(id);</span><br><span class="line">        CompletableFuture&lt;VoteResponse&gt; voteResponse;          <span class="comment">// @3 end</span></span><br><span class="line">        <span class="keyword">if</span> (memberState.getSelfId().equals(id)) &#123;                             <span class="comment">// @4</span></span><br><span class="line">            voteResponse = handleVote(voteRequest, <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//async</span></span><br><span class="line">            voteResponse = dLedgerRpcService.vote(voteRequest);  <span class="comment">// @5</span></span><br><span class="line">        &#125;</span><br><span class="line">        responses.add(voteResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> responses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先先解释一下参数的含义：</p>
<ul>
<li>long term<br>发起投票的节点当前的投票轮次。</li>
<li>long ledgerEndTerm<br>发起投票节点维护的已知的最大投票轮次。</li>
<li>long ledgerEndIndex<br>发起投票节点维护的已知的最大日志条目索引。</li>
</ul>
<p>代码@2：遍历集群内的节点集合，准备异步发起投票请求。这个集合在启动的时候指定，不能修改。</p>
<p>代码@3：构建投票请求。</p>
<p>代码@4：如果是发送给自己的，则直接调用handleVote进行投票请求响应，如果是发送给集群内的其他节点，则通过网络发送投票请求，对端节点调用各自的handleVote对集群进行响应。</p>
<p>接下来重点关注 handleVote 方法，重点探讨其投票处理逻辑。</p>
<h4 id="2-4-2-handleVote-方法"><a href="#2-4-2-handleVote-方法" class="headerlink" title="2.4.2 handleVote 方法"></a>2.4.2 handleVote 方法</h4><p>由于handleVote 方法会并发被调用，因为可能同时收到多个节点的投票请求，故本方法都被synchronized方法包含，锁定的对象为状态机 memberState 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!memberState.isPeerMember(request.getLeaderId())) &#123;</span><br><span class="line">    logger.warn(<span class="string">&quot;[BUG] [HandleVote] remoteId=&#123;&#125; is an unknown member&quot;</span>, request.getLeaderId());</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(newVoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_UNKNOWN_LEADER));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!self &amp;&amp; memberState.getSelfId().equals(request.getLeaderId())) &#123;</span><br><span class="line">    logger.warn(<span class="string">&quot;[BUG] [HandleVote] selfId=&#123;&#125; but remoteId=&#123;&#125;&quot;</span>, memberState.getSelfId(), request.getLeaderId());</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_UNEXPECTED_LEADER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：为了逻辑的完整性对其请求进行检验，除非有BUG存在，否则是不会出现上述问题的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getTerm() &lt; memberState.currTerm()) &#123;    <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_EXPIRED_VOTE_TERM));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getTerm() == memberState.currTerm()) &#123;   <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">if</span> (memberState.currVoteFor() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//let it go</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memberState.currVoteFor().equals(request.getLeaderId())) &#123;</span><br><span class="line">         <span class="comment">//repeat just let it go</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (memberState.getLeaderId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_ALREADY__HAS_LEADER));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_ALREADY_VOTED));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;            <span class="comment">// @3</span></span><br><span class="line">    <span class="comment">//stepped down by larger term</span></span><br><span class="line">    changeRoleToCandidate(request.getTerm());</span><br><span class="line">    needIncreaseTermImmediately = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//only can handleVote when the term is consistent</span></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_TERM_NOT_READY));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：判断发起节点、响应节点维护的team进行投票“仲裁”，分如下3种情况讨论：</p>
<ul>
<li>如果发起投票节点的 term 小于当前节点的 term<br>此种情况下投拒绝票，也就是说在 raft 协议的世界中，谁的 term 越大，越有话语权。 </li>
<li>如果发起投票节点的 term 等于当前节点的 term<br>如果两者的 term 相等，说明两者都处在同一个投票轮次中，地位平等，接下来看该节点是否已经投过票。<ul>
<li>如果未投票、或已投票给请求节点，则继续后面的逻辑（请看step3）。</li>
<li>如果该节点已存在的Leader节点，则拒绝并告知已存在Leader节点。</li>
<li>如果该节点还未有Leader节点，但已经投了其他节点的票，则拒绝请求节点，并告知已投票。</li>
</ul>
</li>
<li>如果发起投票节点的 term 大于当前节点的 term<br>拒绝请求节点的投票请求，并告知自身还未准备投票，自身会使用请求节点的投票轮次立即进入到Candidate状态。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getLedgerEndTerm() &lt; memberState.getLedgerEndTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_EXPIRED_LEDGER_TERM));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getLedgerEndTerm() == memberState.getLedgerEndTerm() &amp;&amp; request.getLedgerEndIndex() &lt; memberState.getLedgerEndIndex()) &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.REJECT_SMALL_LEDGER_END_INDEX));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (request.getTerm() &lt; memberState.getLedgerEndTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.getLedgerEndTerm()).voteResult(VoteResponse.RESULT.REJECT_TERM_SMALL_THAN_LEDGER));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
Step3：判断请求节点的 ledgerEndTerm 与当前节点的 ledgerEndTerm，这里主要是判断日志的复制进度。</li>
<li>如果请求节点的 ledgerEndTerm  小于当前节点的 ledgerEndTerm 则拒绝，其原因是请求节点的日志复制进度比当前节点低，这种情况是不能成为主节点的。</li>
<li>如果 ledgerEndTerm  相等，但是 ledgerEndIndex 比当前节点小，则拒绝，原因与上一条相同。</li>
<li>如果请求的 term 小于 ledgerEndTerm 以同样的理由拒绝。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memberState.setCurrVoteFor(request.getLeaderId());</span><br><span class="line"><span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> VoteResponse(request).term(memberState.currTerm()).voteResult(VoteResponse.RESULT.ACCEPT));</span><br></pre></td></tr></table></figure>
<p>Step4：经过层层条件帅选，将宝贵的赞成票投给请求节点。</p>
<p>经过几轮投票，最终一个节点能成功被推举出来，选为主节点。主节点为了维持其领导地位，需要定时向从节点发送心跳包，接下来我们重点看一下心跳包的发送与响应。</p>
<h3 id="2-5-心跳包与心跳包响应"><a href="#2-5-心跳包与心跳包响应" class="headerlink" title="2.5 心跳包与心跳包响应"></a>2.5 心跳包与心跳包响应</h3><h4 id="2-5-1-sendHeartbeats"><a href="#2-5-1-sendHeartbeats" class="headerlink" title="2.5.1 sendHeartbeats"></a>2.5.1 sendHeartbeats</h4><p>Step1：遍历集群中的节点，异步发送心跳包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> CompletableFuture&lt;HeartBeatResponse&gt; future = dLedgerRpcService.heartBeat(heartBeatRequest);</span><br><span class="line">    future.whenComplete((HeartBeatResponse x, Throwable ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span> (DLedgerResponseCode.valueOf(x.getCode())) &#123;</span><br><span class="line">                <span class="keyword">case</span> SUCCESS:</span><br><span class="line">                    succNum.incrementAndGet();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> EXPIRED_TERM:</span><br><span class="line">                    maxTerm.set(x.getTerm());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> INCONSISTENT_LEADER:</span><br><span class="line">                    inconsistLeader.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> TERM_NOT_READY:</span><br><span class="line">                    notReadyNum.incrementAndGet();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (memberState.isQuorum(succNum.get())</span><br><span class="line">                || memberState.isQuorum(succNum.get() + notReadyNum.get())) &#123;</span><br><span class="line">                beatLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Parse heartbeat response failed&quot;</span>, t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allNum.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (allNum.get() == memberState.peerSize()) &#123;</span><br><span class="line">                beatLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：统计心跳包发送响应结果，关键点如下：</p>
<ul>
<li>SUCCESS<br>心跳包成功响应。</li>
<li>EXPIRED_TERM<br>主节点的投票 term 小于从节点的投票轮次。</li>
<li>INCONSISTENT_LEADER<br>从节点已经有了新的主节点。</li>
<li>TERM_NOT_READY<br>从节点未准备好。</li>
</ul>
<p>这些响应值，我们在处理心跳包时重点探讨。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">beatLatch.await(heartBeatTimeIntervalMs, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (memberState.isQuorum(succNum.get())) &#123;   <span class="comment">// @1</span></span><br><span class="line">    lastSuccHeartBeatTime = System.currentTimeMillis();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;[&#123;&#125;] Parse heartbeat responses in cost=&#123;&#125; term=&#123;&#125; allNum=&#123;&#125; succNum=&#123;&#125; notReadyNum=&#123;&#125; inconsistLeader=&#123;&#125; maxTerm=&#123;&#125; peerSize=&#123;&#125; lastSuccHeartBeatTime=&#123;&#125;&quot;</span>,</span><br><span class="line">                memberState.getSelfId(), DLedgerUtils.elapsed(startHeartbeatTimeMs), term, allNum.get(), succNum.get(), notReadyNum.get(), inconsistLeader.get(), maxTerm.get(), memberState.peerSize(), <span class="keyword">new</span> Timestamp(lastSuccHeartBeatTime));</span><br><span class="line">    <span class="keyword">if</span> (memberState.isQuorum(succNum.get() + notReadyNum.get())) &#123;    <span class="comment">// @2</span></span><br><span class="line">        lastSendHeartBeatTime = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxTerm.get() &gt; term) &#123;                                                          <span class="comment">// @3</span></span><br><span class="line">        changeRoleToCandidate(maxTerm.get());</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inconsistLeader.get()) &#123;                                                            <span class="comment">// @4</span></span><br><span class="line">        changeRoleToCandidate(term);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DLedgerUtils.elapsed(lastSuccHeartBeatTime) &gt; maxHeartBeatLeak * heartBeatTimeIntervalMs) &#123;</span><br><span class="line">        changeRoleToCandidate(term);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对收集的响应结果做仲裁，其实现关键点：</p>
<ul>
<li>如果成功的票数大于进群内的半数，则表示集群状态正常，正常按照心跳包间隔发送心跳包(见代码@1)。</li>
<li>如果成功的票数加上未准备的投票的节点数量超过集群内的半数，则立即发送心跳包(见代码@2)。</li>
<li>如果从节点的投票轮次比主节点的大，则使用从节点的投票轮次，或从节点已经有了另外的主节点，节点状态从 Leader 转换为 Candidate。</li>
</ul>
<p>接下来我们重点看一下心跳包的处理逻辑。</p>
<h4 id="2-5-2-handleHeartBeat"><a href="#2-5-2-handleHeartBeat" class="headerlink" title="2.5.2 handleHeartBeat"></a>2.5.2 handleHeartBeat</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (request.getTerm() &lt; memberState.currTerm()) &#123;</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse().term(memberState.currTerm()).code(DLedgerResponseCode.EXPIRED_TERM.getCode()));</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getTerm() == memberState.currTerm()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.getLeaderId().equals(memberState.getLeaderId())) &#123;</span><br><span class="line">        lastLeaderHeartBeatTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果主节点的 term 小于 从节点的term，发送反馈给主节点，告知主节点的 term 已过时；如果投票轮次相同，并且发送心跳包的节点是该节点的主节点，则返回成功。</p>
<p>下面重点讨论主节点的 term 大于从节点的情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (memberState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.getTerm() &lt; memberState.currTerm()) &#123;   <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse().term(memberState.currTerm()).code(DLedgerResponseCode.EXPIRED_TERM.getCode()));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getTerm() == memberState.currTerm()) &#123;  <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (memberState.getLeaderId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            changeRoleToFollower(request.getTerm(), request.getLeaderId());</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.getLeaderId().equals(memberState.getLeaderId())) &#123;</span><br><span class="line">            lastLeaderHeartBeatTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//this should not happen, but if happened</span></span><br><span class="line">            logger.error(<span class="string">&quot;[&#123;&#125;][BUG] currTerm &#123;&#125; has leader &#123;&#125;, but received leader &#123;&#125;&quot;</span>, memberState.getSelfId(), memberState.currTerm(), memberState.getLeaderId(), request.getLeaderId());</span><br><span class="line">            <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse().code(DLedgerResponseCode.INCONSISTENT_LEADER.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//To make it simple, for larger term, do not change to follower immediately</span></span><br><span class="line">        <span class="comment">//first change to candidate, and notify the state-maintainer thread</span></span><br><span class="line">        changeRoleToCandidate(request.getTerm());</span><br><span class="line">        needIncreaseTermImmediately = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//TOOD notify</span></span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(<span class="keyword">new</span> HeartBeatResponse().code(DLedgerResponseCode.TERM_NOT_READY.getCode()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：加锁来处理（这里更多的是从节点第一次收到主节点的心跳包）</p>
<p>代码@1：如果主节的投票轮次小于当前投票轮次，则返回主节点投票轮次过期。</p>
<p>代码@2：如果投票轮次相同。</p>
<ul>
<li>如果当前节点的主节点字段为空，则使用主节点的ID，并返回成功。</li>
<li>如果当前节点的主节点就是发送心跳包的节点，则更新上一次收到心跳包的时间戳，并返回成功。</li>
<li>如果从节点的主节点与发送心跳包的节点ID不同，说明有另外一个Leaer，按道理来说是不会发送的，如果发生，则返回已存在- 主节点，标记该心跳包处理结束。</li>
</ul>
<p>代码@3：如果主节点的投票轮次大于从节点的投票轮次，则认为从节点并为准备好，则从节点进入Candidate 状态，并立即发起一次投票。</p>
<p>心跳包的处理就介绍到这里。</p>
<p>RocketMQ 多副本之 Leader 选举的源码分析就介绍到这里了，为了加强对源码的理解，先梳理流程图如下：<br><img src="https://img-blog.csdnimg.cn/20190817204737273.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>raft</tag>
        <tag>选主</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析 RocketMQ DLedger(多副本) 之日志复制(传播)</title>
    <url>/posts/91680207.html</url>
    <content><![CDATA[<div id="vip-container"><p>本文紧接着 源码分析 RocketMQ DLedger(多副本) 之日志追加流程  ，继续 Leader 处理客户端 append 的请求流程中最至关重要的一环：日志复制。</p>
<p>DLedger 多副本的日志转发由 DLedgerEntryPusher 实现，接下来将对其进行详细介绍。</p>
<blockquote>
<p>温馨提示：由于本篇幅较长，为了更好的理解其实现，大家可以带着如下疑问来通读本篇文章：<br>1、raft 协议中有一个非常重要的概念：已提交日志序号，该如何实现。<br>2、客户端向 DLedger 集群发送一条日志，必须得到集群中大多数节点的认可才能被认为写入成功。<br>3、raft 协议中追加、提交两个动作如何实现。</p>
</blockquote>
<p>@<a href="%E6%9C%AC%E8%8A%82%E7%9B%AE%E5%BD%95">TOC</a></p>
<p>日志复制(日志转发)由 DLedgerEntryPusher 实现，具体类图如下：<br><img src="https://img-blog.csdnimg.cn/2019091421331888.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主要由如下4个类构成：</p>
<ul>
<li>DLedgerEntryPusher<br>DLedger 日志转发与处理核心类，该内会启动如下3个对象，其分别对应一个线程。</li>
<li>EntryHandler<br>日志接收处理线程，当节点为从节点时激活。</li>
<li>QuorumAckChecker<br>日志追加ACK投票处理线程，当前节点为主节点时激活。</li>
<li>EntryDispatcher<br>日志转发线程，当前节点为主节点时追加。</li>
</ul>
<p>接下来我们将详细介绍上述4个类，从而揭晓日志复制的核心实现原理。</p>
<h2 id="1、DLedgerEntryPusher"><a href="#1、DLedgerEntryPusher" class="headerlink" title="1、DLedgerEntryPusher"></a>1、DLedgerEntryPusher</h2><h3 id="1-1-核心类图"><a href="#1-1-核心类图" class="headerlink" title="1.1 核心类图"></a>1.1 核心类图</h3><p><img src="https://img-blog.csdnimg.cn/20190914213606209.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>DLedger 多副本日志推送的核心实现类，里面会创建 EntryDispatcher、QuorumAckChecker、EntryHandler 三个核心线程。其核心属性如下：</p>
<ul>
<li>DLedgerConfig dLedgerConfig<br>多副本相关配置。</li>
<li>DLedgerStore dLedgerStore<br>存储实现类。</li>
<li>MemberState memberState<br>节点状态机。</li>
<li>DLedgerRpcService dLedgerRpcService<br>RPC 服务实现类，用于集群内的其他节点进行网络通讯。</li>
<li>Map&lt;Long, ConcurrentMap&lt;String, Long&gt;&gt; peerWaterMarksByTerm<br>每个节点基于投票轮次的当前水位线标记。键值为投票轮次，值为 ConcurrentMap&lt;String/** 节点id*/, Long/** 节点对应的日志序号*/&gt;。</li>
<li>Map&lt;Long, ConcurrentMap&lt;Long, TimeoutFuture<AppendEntryResponse>&gt;&gt; pendingAppendResponsesByTerm<br>用于存放追加请求的响应结果(Future模式)。</li>
<li>EntryHandler entryHandler<br>从节点上开启的线程，用于接收主节点的 push 请求（append、commit、append）。</li>
<li>QuorumAckChecker quorumAckChecker<br>主节点上的追加请求投票器。</li>
<li>Map&lt;String, EntryDispatcher&gt; dispatcherMap<br>主节点日志请求转发器，向从节点复制消息等。</li>
</ul>
<p>接下来介绍一下其核心方法的实现。</p>
<h3 id="1-2-构造方法"><a href="#1-2-构造方法" class="headerlink" title="1.2 构造方法"></a>1.2 构造方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DLedgerEntryPusher</span><span class="params">(DLedgerConfig dLedgerConfig, MemberState memberState, DLedgerStore dLedgerStore,</span></span></span><br><span class="line"><span class="function"><span class="params">    DLedgerRpcService dLedgerRpcService)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dLedgerConfig = dLedgerConfig;</span><br><span class="line">    <span class="keyword">this</span>.memberState = memberState;</span><br><span class="line">    <span class="keyword">this</span>.dLedgerStore = dLedgerStore;</span><br><span class="line">    <span class="keyword">this</span>.dLedgerRpcService = dLedgerRpcService;</span><br><span class="line">    <span class="keyword">for</span> (String peer : memberState.getPeerMap().keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!peer.equals(memberState.getSelfId())) &#123;</span><br><span class="line">            dispatcherMap.put(peer, <span class="keyword">new</span> EntryDispatcher(peer, logger));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法的重点是会根据集群内的节点，依次构建对应的 EntryDispatcher 对象。</p>
<h3 id="1-3-startup"><a href="#1-3-startup" class="headerlink" title="1.3 startup"></a>1.3 startup</h3><p>DLedgerEntryPusher#startup</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    entryHandler.start();</span><br><span class="line">    quorumAckChecker.start();</span><br><span class="line">    <span class="keyword">for</span> (EntryDispatcher dispatcher : dispatcherMap.values()) &#123;</span><br><span class="line">        dispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>依次启动 EntryHandler、QuorumAckChecker 与 EntryDispatcher 线程。</p>
<blockquote>
<p>备注：DLedgerEntryPusher 的其他核心方法在详细分析其日志复制原理的过程中会一一介绍。</p>
</blockquote>
<p>接下来将从 EntryDispatcher、QuorumAckChecker、EntryHandler 来阐述 RocketMQ DLedger(多副本)的实现原理。</p>
<h2 id="2、EntryDispatcher-详解"><a href="#2、EntryDispatcher-详解" class="headerlink" title="2、EntryDispatcher 详解"></a>2、EntryDispatcher 详解</h2><h3 id="2-1-核心类图"><a href="#2-1-核心类图" class="headerlink" title="2.1 核心类图"></a>2.1 核心类图</h3><p><img src="https://img-blog.csdnimg.cn/20190914215700841.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其核心属性如下。</p>
<ul>
<li>AtomicReference&lt;PushEntryRequest.Type&gt; type = new AtomicReference&lt;&gt;(PushEntryRequest.Type.COMPARE)<br>向从节点发送命令的类型，可选值：PushEntryRequest.Type.COMPARE、TRUNCATE、APPEND、COMMIT，下面详细说明。</li>
<li>long lastPushCommitTimeMs = -1<br>上一次发送提交类型的时间戳。</li>
<li>String peerId<br>目标节点ID。</li>
<li>long compareIndex = -1<br>已完成比较的日志序号。</li>
<li>long writeIndex = -1<br>已写入的日志序号。</li>
<li>int maxPendingSize = 1000<br>允许的最大挂起日志数量。</li>
<li>long term = -1<pre><code> Leader 节点当前的投票轮次。</code></pre>
</li>
<li>String leaderId = null<br>Leader 节点ID。</li>
<li>long lastCheckLeakTimeMs = System.currentTimeMillis()<br>上次检测泄漏的时间，所谓的泄漏，就是看挂起的日志请求数量是否查过了 maxPendingSize 。</li>
<li>ConcurrentMap&lt;Long, Long&gt; pendingMap = new ConcurrentHashMap&lt;&gt;()<br>记录日志的挂起时间，key：日志的序列(entryIndex)，value：挂起时间戳。</li>
<li>Quota quota = new Quota(dLedgerConfig.getPeerPushQuota())<br>配额。</li>
</ul>
<h3 id="2-2-Push-请求类型"><a href="#2-2-Push-请求类型" class="headerlink" title="2.2 Push 请求类型"></a>2.2 Push 请求类型</h3><p>DLedger 主节点向从从节点复制日志总共定义了4类请求类型，其枚举类型为 PushEntryRequest.Type，其值分别为 COMPARE、TRUNCATE、APPEND、COMMIT。</p>
<ul>
<li>COMPARE<br>如果 Leader 发生变化，新的 Leader 需要与他的从节点的日志条目进行比较，以便截断从节点多余的数据。 </li>
<li>TRUNCATE<br>如果 Leader 通过索引完成日志对比，则 Leader 将发送  TRUNCATE 给它的从节点。</li>
<li>APPEND<br>将日志条目追加到从节点。</li>
<li>COMMIT<br>通常，leader 会将提交的索引附加到 append 请求，但是如果 append 请求很少且分散，leader 将发送一个单独的请求来通知从节点提交的索引。</li>
</ul>
<p>对主从节点的请求类型有了一个初步的认识后，我们将从 EntryDispatcher 的业务处理入口 doWork 方法开始讲解。</p>
<a id="more"></a>

<h3 id="2-3-doWork-方法详解"><a href="#2-3-doWork-方法详解" class="headerlink" title="2.3 doWork 方法详解"></a>2.3 doWork 方法详解</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkAndFreshState()) &#123;                                            <span class="comment">// @1</span></span><br><span class="line">            waitForRunning(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type.get() == PushEntryRequest.Type.APPEND) &#123;   <span class="comment">// @2</span></span><br><span class="line">            doAppend();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            doCompare();                                                           <span class="comment">// @3</span></span><br><span class="line">        &#125;</span><br><span class="line">        waitForRunning(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        DLedgerEntryPusher.logger.error(<span class="string">&quot;[Push-&#123;&#125;]Error in &#123;&#125; writeIndex=&#123;&#125; compareIndex=&#123;&#125;&quot;</span>, peerId, getName(), writeIndex, compareIndex, t);</span><br><span class="line">        DLedgerUtils.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检查状态，是否可以继续发送 append 或 compare。</p>
<p>代码@2：如果推送类型为APPEND，主节点向从节点传播消息请求。</p>
<p>代码@3：主节点向从节点发送对比数据差异请求（当一个新节点被选举成为主节点时，往往这是第一步）。</p>
<h4 id="2-3-1-checkAndFreshState-详解"><a href="#2-3-1-checkAndFreshState-详解" class="headerlink" title="2.3.1 checkAndFreshState 详解"></a>2.3.1 checkAndFreshState 详解</h4><p>EntryDispatcher#checkAndFreshState</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkAndFreshState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!memberState.isLeader()) &#123;     <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (term != memberState.currTerm() || leaderId == <span class="keyword">null</span> || !leaderId.equals(memberState.getLeaderId())) &#123;     <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">synchronized</span> (memberState) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!memberState.isLeader()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PreConditions.check(memberState.getSelfId().equals(memberState.getLeaderId()), DLedgerResponseCode.UNKNOWN);</span><br><span class="line">            term = memberState.currTerm();</span><br><span class="line">            leaderId = memberState.getSelfId();</span><br><span class="line">            changeState(-<span class="number">1</span>, PushEntryRequest.Type.COMPARE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果节点的状态不是主节点，则直接返回 false。则结束 本次 doWork 方法。因为只有主节点才需要向从节点转发日志。</p>
<p>代码@2：如果当前节点状态是主节点，但当前的投票轮次与状态机轮次或 leaderId 还未设置，或 leaderId 与状态机的 leaderId 不相等，这种情况通常是集群触发了重新选举，设置其term、leaderId与状态机同步，即将发送COMPARE 请求。</p>
<p>接下来看一下 changeState (改变状态)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(<span class="keyword">long</span> index, PushEntryRequest.Type target)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">&quot;[Push-&#123;&#125;]Change state from &#123;&#125; to &#123;&#125; at &#123;&#125;&quot;</span>, peerId, type.get(), target, index);</span><br><span class="line">    <span class="keyword">switch</span> (target) &#123;</span><br><span class="line">        <span class="keyword">case</span> APPEND:      <span class="comment">// @1</span></span><br><span class="line">            compareIndex = -<span class="number">1</span>;</span><br><span class="line">            updatePeerWaterMark(term, peerId, index);</span><br><span class="line">            quorumAckChecker.wakeup();</span><br><span class="line">            writeIndex = index + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> COMPARE:    <span class="comment">// @2</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.type.compareAndSet(PushEntryRequest.Type.APPEND, PushEntryRequest.Type.COMPARE)) &#123;</span><br><span class="line">                compareIndex = -<span class="number">1</span>;</span><br><span class="line">                pendingMap.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TRUNCATE:     <span class="comment">// @3</span></span><br><span class="line">            compareIndex = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    type.set(target);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>代码@1：如果将目标类型设置为 append，则重置 compareIndex ，并设置 writeIndex 为当前 index 加1。</p>
<p>代码@2：如果将目标类型设置为 COMPARE，则重置 compareIndex 为负一，接下将向各个从节点发送 COMPARE 请求类似，并清除已挂起的请求。</p>
<p>代码@3：如果将目标类型设置为 TRUNCATE，则重置 compareIndex 为负一。</p>
<p>接下来具体来看一下 APPEND、COMPARE、TRUNCATE 等请求。</p>
<h4 id="2-3-2-append-请求详解"><a href="#2-3-2-append-请求详解" class="headerlink" title="2.3.2 append 请求详解"></a>2.3.2 append 请求详解</h4><p>EntryDispatcher#doAppend</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAppend</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!checkAndFreshState()) &#123;                                                 <span class="comment">// @1</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.get() != PushEntryRequest.Type.APPEND) &#123;        <span class="comment">// @2</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (writeIndex &gt; dLedgerStore.getLedgerEndIndex()) &#123;    <span class="comment">// @3</span></span><br><span class="line">            doCommit();</span><br><span class="line">            doCheckAppendResponse();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingMap.size() &gt;= maxPendingSize || (DLedgerUtils.elapsed(lastCheckLeakTimeMs) &gt; <span class="number">1000</span>)) &#123;     <span class="comment">// @4</span></span><br><span class="line">            <span class="keyword">long</span> peerWaterMark = getPeerWaterMark(term, peerId);</span><br><span class="line">            <span class="keyword">for</span> (Long index : pendingMap.keySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; peerWaterMark) &#123;</span><br><span class="line">                    pendingMap.remove(index);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lastCheckLeakTimeMs = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pendingMap.size() &gt;= maxPendingSize) &#123;    <span class="comment">// @5</span></span><br><span class="line">            doCheckAppendResponse();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        doAppendInner(writeIndex);                               <span class="comment">// @6</span></span><br><span class="line">        writeIndex++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：检查状态，已经在上面详细介绍。</p>
<p>代码@2：如果请求类型不为 APPEND，则退出，结束本轮 doWork 方法执行。</p>
<p>代码@3：writeIndex 表示当前追加到从该节点的序号，通常情况下主节点向从节点发送 append 请求时，会附带主节点的已提交指针，但如何 append 请求发不那么频繁，writeIndex 大于 leaderEndIndex 时（由于pending请求超过其 pending 请求的队列长度（默认为1w)，时，会阻止数据的追加，此时有可能出现 writeIndex 大于 leaderEndIndex 的情况，此时单独发送 COMMIT 请求。</p>
<p>代码@4：检测 pendingMap(挂起的请求数量)是否发送泄漏，即挂起队列中容量是否超过允许的最大挂起阀值。获取当前节点关于本轮次的当前水位线(已成功 append 请求的日志序号)，如果发现正在挂起请求的日志序号小于水位线，则丢弃。</p>
<p>代码@5：如果挂起的请求（等待从节点追加结果）大于 maxPendingSize 时，检查并追加一次 append 请求。</p>
<p>代码@6：具体的追加请求。</p>
<h5 id="2-3-2-1-doCommit-发送提交请求"><a href="#2-3-2-1-doCommit-发送提交请求" class="headerlink" title="2.3.2.1 doCommit 发送提交请求"></a>2.3.2.1 doCommit 发送提交请求</h5><p>EntryDispatcher#doCommit</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCommit</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DLedgerUtils.elapsed(lastPushCommitTimeMs) &gt; <span class="number">1000</span>) &#123;   <span class="comment">// @1</span></span><br><span class="line">        PushEntryRequest request = buildPushRequest(<span class="keyword">null</span>, PushEntryRequest.Type.COMMIT);   <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">//Ignore the results</span></span><br><span class="line">        dLedgerRpcService.push(request);                                                                                        <span class="comment">// @3</span></span><br><span class="line">        lastPushCommitTimeMs = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果上一次单独发送 commit 的请求时间与当前时间相隔低于 1s，放弃本次提交请求。</p>
<p>代码@2：构建提交请求。</p>
<p>代码@3：通过网络向从节点发送 commit 请求。</p>
<p>接下来先了解一下如何构建 commit 请求包。</p>
<p>EntryDispatcher#buildPushRequest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PushEntryRequest <span class="title">buildPushRequest</span><span class="params">(DLedgerEntry entry, PushEntryRequest.Type target)</span> </span>&#123;</span><br><span class="line">    PushEntryRequest request = <span class="keyword">new</span> PushEntryRequest();</span><br><span class="line">    request.setGroup(memberState.getGroup());  </span><br><span class="line">    request.setRemoteId(peerId);                          </span><br><span class="line">    request.setLeaderId(leaderId);</span><br><span class="line">    request.setTerm(term);</span><br><span class="line">    request.setEntry(entry);</span><br><span class="line">    request.setType(target);</span><br><span class="line">    request.setCommitIndex(dLedgerStore.getCommittedIndex());</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提交包请求字段主要包含如下字段：DLedger 节点所属组、从节点 id、主节点 id，当前投票轮次、日志内容、请求类型与 committedIndex(主节点已提交日志序号)。</p>
<h5 id="2-3-2-2-doCheckAppendResponse-检查并追加请求"><a href="#2-3-2-2-doCheckAppendResponse-检查并追加请求" class="headerlink" title="2.3.2.2 doCheckAppendResponse 检查并追加请求"></a>2.3.2.2 doCheckAppendResponse 检查并追加请求</h5><p>EntryDispatcher#doCheckAppendResponse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doCheckAppendResponse</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> peerWaterMark = getPeerWaterMark(term, peerId);   <span class="comment">// @1</span></span><br><span class="line">    Long sendTimeMs = pendingMap.get(peerWaterMark + <span class="number">1</span>); </span><br><span class="line">    <span class="keyword">if</span> (sendTimeMs != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() - sendTimeMs &gt; dLedgerConfig.getMaxPushTimeOutMs()) &#123; <span class="comment">// @2</span></span><br><span class="line">        logger.warn(<span class="string">&quot;[Push-&#123;&#125;]Retry to push entry at &#123;&#125;&quot;</span>, peerId, peerWaterMark + <span class="number">1</span>);</span><br><span class="line">        doAppendInner(peerWaterMark + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的作用是检查 append 请求是否超时，其关键实现如下：</p>
<ul>
<li>获取已成功 append 的序号。</li>
<li>从挂起的请求队列中获取下一条的发送时间，如果不为空并去超过了 append 的超时时间，则再重新发送 append 请求，最大超时时间默认为 1s，可以通过 maxPushTimeOutMs 来改变默认值。</li>
</ul>
<h5 id="2-3-2-3-doAppendInner-追加请求"><a href="#2-3-2-3-doAppendInner-追加请求" class="headerlink" title="2.3.2.3 doAppendInner 追加请求"></a>2.3.2.3 doAppendInner 追加请求</h5><p>向从节点发送 append 请求。</p>
<p>EntryDispatcher#doAppendInner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAppendInner</span><span class="params">(<span class="keyword">long</span> index)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    DLedgerEntry entry = dLedgerStore.get(index);   <span class="comment">// @1</span></span><br><span class="line">    PreConditions.check(entry != <span class="keyword">null</span>, DLedgerResponseCode.UNKNOWN, <span class="string">&quot;writeIndex=%d&quot;</span>, index);</span><br><span class="line">    checkQuotaAndWait(entry);                                   <span class="comment">// @2</span></span><br><span class="line">    PushEntryRequest request = buildPushRequest(entry, PushEntryRequest.Type.APPEND);   <span class="comment">// @3</span></span><br><span class="line">    CompletableFuture&lt;PushEntryResponse&gt; responseFuture = dLedgerRpcService.push(request);   <span class="comment">// @4</span></span><br><span class="line">    pendingMap.put(index, System.currentTimeMillis());                                                                          <span class="comment">// @5</span></span><br><span class="line">    responseFuture.whenComplete((x, ex) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PreConditions.check(ex == <span class="keyword">null</span>, DLedgerResponseCode.UNKNOWN);</span><br><span class="line">            DLedgerResponseCode responseCode = DLedgerResponseCode.valueOf(x.getCode());</span><br><span class="line">            <span class="keyword">switch</span> (responseCode) &#123;</span><br><span class="line">                <span class="keyword">case</span> SUCCESS:                                                                                                                <span class="comment">// @6</span></span><br><span class="line">                    pendingMap.remove(x.getIndex());</span><br><span class="line">                    updatePeerWaterMark(x.getTerm(), peerId, x.getIndex());</span><br><span class="line">                    quorumAckChecker.wakeup();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> INCONSISTENT_STATE:                                                                                         <span class="comment">// @7</span></span><br><span class="line">                    logger.info(<span class="string">&quot;[Push-&#123;&#125;]Get INCONSISTENT_STATE when push index=&#123;&#125; term=&#123;&#125;&quot;</span>, peerId, x.getIndex(), x.getTerm());</span><br><span class="line">                    changeState(-<span class="number">1</span>, PushEntryRequest.Type.COMPARE);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    logger.warn(<span class="string">&quot;[Push-&#123;&#125;]Get error response code &#123;&#125; &#123;&#125;&quot;</span>, peerId, responseCode, x.baseInfo());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;&quot;</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    lastPushCommitTimeMs = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先根据序号查询出日志。</p>
<p>代码@2：检测配额，如果超过配额，会进行一定的限流，其关键实现点：</p>
<ul>
<li>首先触发条件：append 挂起请求数已超过最大允许挂起数；基于文件存储并主从差异超过300m，可通过 peerPushThrottlePoint 配置。</li>
<li>每秒追加的日志超过 20m(可通过 peerPushQuota 配置)，则会 sleep 1s中后再追加。</li>
</ul>
<p>代码@3：构建 PUSH  请求日志。</p>
<p>代码@4：通过 Netty 发送网络请求到从节点，从节点收到请求会进行处理(本文并不会探讨与网络相关的实现细节)。</p>
<p>代码@5：用 pendingMap 记录待追加的日志的发送时间，用于发送端判断是否超时的一个依据。</p>
<p>代码@6：请求成功的处理逻辑，其关键实现点如下：</p>
<ul>
<li>移除 pendingMap 中的关于该日志的发送超时时间。</li>
<li>更新已成功追加的日志序号(按投票轮次组织，并且每个从服务器一个键值对)。</li>
<li>唤醒 quorumAckChecker 线程(主要用于仲裁 append 结果)，后续会详细介绍。</li>
</ul>
<p>代码@7：Push 请求出现状态不一致情况，将发送 COMPARE 请求，来对比主从节点的数据是否一致。</p>
<p>日志转发 append 追加请求类型就介绍到这里了，接下来我们继续探讨另一个请求类型 compare。</p>
<h4 id="2-3-3-compare-请求详解"><a href="#2-3-3-compare-请求详解" class="headerlink" title="2.3.3  compare 请求详解"></a>2.3.3  compare 请求详解</h4><p>COMPARE 类型的请求有 doCompare 方法发送，首先该方法运行在 while (true) 中，故在查阅下面代码时，要注意其退出循环的条件。<br>EntryDispatcher#doCompare</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkAndFreshState()) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (type.get() != PushEntryRequest.Type.COMPARE</span><br><span class="line">    &amp;&amp; type.get() != PushEntryRequest.Type.TRUNCATE) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (compareIndex == -<span class="number">1</span> &amp;&amp; dLedgerStore.getLedgerEndIndex() == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：验证是否执行，有几个关键点如下：</p>
<ul>
<li>判断是否是主节点，如果不是主节点，则直接跳出。</li>
<li>如果是请求类型不是 COMPARE 或 TRUNCATE 请求，则直接跳出。</li>
<li>如果已比较索引 和 ledgerEndIndex 都为 -1 ，表示一个新的 DLedger 集群，则直接跳出。</li>
</ul>
<p>EntryDispatcher#doCompare</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">    compareIndex = dLedgerStore.getLedgerEndIndex();</span><br><span class="line">    logger.info(<span class="string">&quot;[Push-&#123;&#125;][DoCompare] compareIndex=-1 means start to compare&quot;</span>, peerId);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareIndex &gt; dLedgerStore.getLedgerEndIndex() || compareIndex &lt; dLedgerStore.getLedgerBeginIndex()) &#123;</span><br><span class="line">    logger.info(<span class="string">&quot;[Push-&#123;&#125;][DoCompare] compareIndex=&#123;&#125; out of range &#123;&#125;-&#123;&#125;&quot;</span>, peerId, compareIndex, dLedgerStore.getLedgerBeginIndex(), dLedgerStore.getLedgerEndIndex());</span><br><span class="line">    compareIndex = dLedgerStore.getLedgerEndIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果 compareIndex 为 -1 或compareIndex 不在有效范围内，则重置待比较序列号为当前已已存储的最大日志序号：ledgerEndIndex。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DLedgerEntry entry = dLedgerStore.get(compareIndex);</span><br><span class="line">PreConditions.check(entry != <span class="keyword">null</span>, DLedgerResponseCode.INTERNAL_ERROR, <span class="string">&quot;compareIndex=%d&quot;</span>, compareIndex);</span><br><span class="line">PushEntryRequest request = buildPushRequest(entry, PushEntryRequest.Type.COMPARE);</span><br><span class="line">CompletableFuture&lt;PushEntryResponse&gt; responseFuture = dLedgerRpcService.push(request);</span><br><span class="line">PushEntryResponse response = responseFuture.get(<span class="number">3</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>Step3：根据序号查询到日志，并向从节点发起 COMPARE 请求，其超时时间为 3s。</p>
<p>EntryDispatcher#doCompare</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> truncateIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (response.getCode() == DLedgerResponseCode.SUCCESS.getCode()) &#123;   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (compareIndex == response.getEndIndex()) &#123;</span><br><span class="line">        changeState(compareIndex, PushEntryRequest.Type.APPEND);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        truncateIndex = compareIndex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.getEndIndex() &lt; dLedgerStore.getLedgerBeginIndex() </span><br><span class="line">        || response.getBeginIndex() &gt; dLedgerStore.getLedgerEndIndex()) &#123;    <span class="comment">// @2</span></span><br><span class="line">    truncateIndex = dLedgerStore.getLedgerBeginIndex();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareIndex &lt; response.getBeginIndex()) &#123;                                    <span class="comment">// @3</span></span><br><span class="line">    truncateIndex = dLedgerStore.getLedgerBeginIndex();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (compareIndex &gt; response.getEndIndex()) &#123;                                      <span class="comment">// @4</span></span><br><span class="line">    compareIndex = response.getEndIndex();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;                                                                                                              <span class="comment">// @5</span></span><br><span class="line">	compareIndex--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compareIndex &lt; dLedgerStore.getLedgerBeginIndex()) &#123;                          <span class="comment">// @6</span></span><br><span class="line">    truncateIndex = dLedgerStore.getLedgerBeginIndex();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step4：根据响应结果计算需要截断的日志序号，其主要实现关键点如下：</p>
<ul>
<li>代码@1：如果两者的日志序号相同，则无需截断，下次将直接先从节点发送 append 请求；否则将 truncateIndex  设置为响应结果中的 endIndex。</li>
<li>代码@2：如果从节点存储的最大日志序号小于主节点的最小序号，或者从节点的最小日志序号大于主节点的最大日志序号，即两者不相交，这通常发生在从节点崩溃很长一段时间，而主节点删除了过期的条目时。truncateIndex 设置为主节点的 ledgerBeginIndex，即主节点目前最小的偏移量。</li>
<li>代码@3：如果已比较的日志序号小于从节点的开始日志序号，很可能是从节点磁盘发送损耗，从主节点最小日志序号开始同步。</li>
<li>代码@4：如果已比较的日志序号大于从节点的最大日志序号，则已比较索引设置为从节点最大的日志序号，触发数据的继续同步。</li>
<li>代码@5：如果已比较的日志序号大于从节点的开始日志序号，但小于从节点的最大日志序号，则待比较索引减一。</li>
<li>代码@6：如果比较出来的日志序号小于主节点的最小日志需要，则设置为主节点的最小序号。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (truncateIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">    changeState(truncateIndex, PushEntryRequest.Type.TRUNCATE);</span><br><span class="line">    doTruncate(truncateIndex);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5：如果比较出来的日志序号不等于 -1 ，则向从节点发送 TRUNCATE 请求。</p>
<h5 id="2-3-3-1-doTruncate-详解"><a href="#2-3-3-1-doTruncate-详解" class="headerlink" title="2.3.3.1 doTruncate 详解"></a>2.3.3.1 doTruncate 详解</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTruncate</span><span class="params">(<span class="keyword">long</span> truncateIndex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PreConditions.check(type.get() == PushEntryRequest.Type.TRUNCATE, DLedgerResponseCode.UNKNOWN);</span><br><span class="line">    DLedgerEntry truncateEntry = dLedgerStore.get(truncateIndex);</span><br><span class="line">    PreConditions.check(truncateEntry != <span class="keyword">null</span>, DLedgerResponseCode.UNKNOWN);</span><br><span class="line">    logger.info(<span class="string">&quot;[Push-&#123;&#125;]Will push data to truncate truncateIndex=&#123;&#125; pos=&#123;&#125;&quot;</span>, peerId, truncateIndex, truncateEntry.getPos());</span><br><span class="line">    PushEntryRequest truncateRequest = buildPushRequest(truncateEntry, PushEntryRequest.Type.TRUNCATE);</span><br><span class="line">    PushEntryResponse truncateResponse = dLedgerRpcService.push(truncateRequest).get(<span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    PreConditions.check(truncateResponse != <span class="keyword">null</span>, DLedgerResponseCode.UNKNOWN, <span class="string">&quot;truncateIndex=%d&quot;</span>, truncateIndex);</span><br><span class="line">    PreConditions.check(truncateResponse.getCode() == DLedgerResponseCode.SUCCESS.getCode(), DLedgerResponseCode.valueOf(truncateResponse.getCode()), <span class="string">&quot;truncateIndex=%d&quot;</span>, truncateIndex);</span><br><span class="line">    lastPushCommitTimeMs = System.currentTimeMillis();</span><br><span class="line">    changeState(truncateIndex, PushEntryRequest.Type.APPEND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要就是构建 truncate 请求到从节点。</p>
<p>关于服务端的消息复制转发就介绍到这里了，主节点负责向从服务器PUSH请求，从节点自然而然的要处理这些请求，接下来我们就按照主节点发送的请求，来具体分析一下从节点是如何响应的。</p>
<h2 id="3、EntryHandler-详解"><a href="#3、EntryHandler-详解" class="headerlink" title="3、EntryHandler 详解"></a>3、EntryHandler 详解</h2><p>EntryHandler 同样是一个线程，当节点状态为从节点时激活。</p>
<h3 id="3-1-核心类图"><a href="#3-1-核心类图" class="headerlink" title="3.1 核心类图"></a>3.1 核心类图</h3><p><img src="https://img-blog.csdnimg.cn/20190914220450532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其核心属性如下：</p>
<ul>
<li>long lastCheckFastForwardTimeMs<br>上一次检查主服务器是否有 push 消息的时间戳。</li>
<li>ConcurrentMap&lt;Long, Pair&lt;PushEntryRequest, CompletableFuture&lt; PushEntryResponse&gt;&gt;&gt; writeRequestMap<br>append 请求处理队列。</li>
<li>BlockingQueue&lt;Pair&lt;PushEntryRequest, CompletableFuture&lt; PushEntryResponse&gt;&gt;&gt; compareOrTruncateRequests<br>COMMIT、COMPARE、TRUNCATE 相关请求</li>
</ul>
<h3 id="3-2-handlePush"><a href="#3-2-handlePush" class="headerlink" title="3.2 handlePush"></a>3.2 handlePush</h3><p>从上文得知，主节点会主动向从节点传播日志，从节点会通过网络接受到请求数据进行处理，其调用链如图所示：<br><img src="https://img-blog.csdnimg.cn/20190914220604630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>最终会调用 EntryHandler 的 handlePush 方法。</p>
<p>EntryHandler#handlePush</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;PushEntryResponse&gt; <span class="title">handlePush</span><span class="params">(PushEntryRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//The timeout should smaller than the remoting layer&#x27;s request timeout</span></span><br><span class="line">    CompletableFuture&lt;PushEntryResponse&gt; future = <span class="keyword">new</span> TimeoutFuture&lt;&gt;(<span class="number">1000</span>);      <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">switch</span> (request.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> APPEND:                                                                                                          <span class="comment">// @2</span></span><br><span class="line">            PreConditions.check(request.getEntry() != <span class="keyword">null</span>, DLedgerResponseCode.UNEXPECTED_ARGUMENT);</span><br><span class="line">            <span class="keyword">long</span> index = request.getEntry().getIndex();</span><br><span class="line">            Pair&lt;PushEntryRequest, CompletableFuture&lt;PushEntryResponse&gt;&gt; old = writeRequestMap.putIfAbsent(index, <span class="keyword">new</span> Pair&lt;&gt;(request, future));</span><br><span class="line">            <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;[MONITOR]The index &#123;&#125; has already existed with &#123;&#125; and curr is &#123;&#125;&quot;</span>, index, old.getKey().baseInfo(), request.baseInfo());</span><br><span class="line">                future.complete(buildResponse(request, DLedgerResponseCode.REPEATED_PUSH.getCode()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> COMMIT:                                                                                                           <span class="comment">// @3</span></span><br><span class="line">            compareOrTruncateRequests.put(<span class="keyword">new</span> Pair&lt;&gt;(request, future));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> COMPARE:</span><br><span class="line">        <span class="keyword">case</span> TRUNCATE:                                                                                                     <span class="comment">// @4</span></span><br><span class="line">            PreConditions.check(request.getEntry() != <span class="keyword">null</span>, DLedgerResponseCode.UNEXPECTED_ARGUMENT);</span><br><span class="line">            writeRequestMap.clear();</span><br><span class="line">            compareOrTruncateRequests.put(<span class="keyword">new</span> Pair&lt;&gt;(request, future));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.error(<span class="string">&quot;[BUG]Unknown type &#123;&#125; from &#123;&#125;&quot;</span>, request.getType(), request.baseInfo());</span><br><span class="line">            future.complete(buildResponse(request, DLedgerResponseCode.UNEXPECTED_ARGUMENT.getCode()));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从几点处理主节点的 push 请求，其实现关键点如下。</p>
<p>代码@1：首先构建一个响应结果Future，默认超时时间 1s。</p>
<p>代码@2：如果是 APPEND 请求，放入到 writeRequestMap 集合中，如果已存在该数据结构，说明主节点重复推送，构建返回结果，其状态码为 REPEATED_PUSH。放入到 writeRequestMap 中，由 doWork 方法定时去处理待写入的请求。</p>
<p>代码@3：如果是提交请求， 将请求存入 compareOrTruncateRequests 请求处理中，由 doWork 方法异步处理。</p>
<p>代码@4：如果是 COMPARE 或 TRUNCATE 请求，将待写入队列 writeRequestMap  清空，并将请求放入 compareOrTruncateRequests 请求队列中，由 doWork 方法异步处理。</p>
<p>接下来，我们重点来分析 doWork 方法的实现。</p>
<h3 id="3-3-doWork-方法详解"><a href="#3-3-doWork-方法详解" class="headerlink" title="3.3 doWork 方法详解"></a>3.3 doWork 方法详解</h3><p>EntryHandler#doWork</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!memberState.isFollower()) &#123;     <span class="comment">// @1</span></span><br><span class="line">            waitForRunning(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (compareOrTruncateRequests.peek() != <span class="keyword">null</span>) &#123;    <span class="comment">// @2</span></span><br><span class="line">            Pair&lt;PushEntryRequest, CompletableFuture&lt;PushEntryResponse&gt;&gt; pair = compareOrTruncateRequests.poll();</span><br><span class="line">            PreConditions.check(pair != <span class="keyword">null</span>, DLedgerResponseCode.UNKNOWN);</span><br><span class="line">            <span class="keyword">switch</span> (pair.getKey().getType()) &#123;</span><br><span class="line">                <span class="keyword">case</span> TRUNCATE:</span><br><span class="line">                    handleDoTruncate(pair.getKey().getEntry().getIndex(), pair.getKey(), pair.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> COMPARE:</span><br><span class="line">                    handleDoCompare(pair.getKey().getEntry().getIndex(), pair.getKey(), pair.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> COMMIT:</span><br><span class="line">                    handleDoCommit(pair.getKey().getCommitIndex(), pair.getKey(), pair.getValue());</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">long</span> nextIndex = dLedgerStore.getLedgerEndIndex() + <span class="number">1</span>;</span><br><span class="line">            Pair&lt;PushEntryRequest, CompletableFuture&lt;PushEntryResponse&gt;&gt; pair = writeRequestMap.remove(nextIndex);</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkAbnormalFuture(dLedgerStore.getLedgerEndIndex());</span><br><span class="line">                waitForRunning(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            PushEntryRequest request = pair.getKey();</span><br><span class="line">            handleDoAppend(nextIndex, request, pair.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        DLedgerEntryPusher.logger.error(<span class="string">&quot;Error in &#123;&#125;&quot;</span>, getName(), t);</span><br><span class="line">        DLedgerUtils.sleep(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果当前节点的状态不是从节点，则跳出。</p>
<p>代码@2：如果 compareOrTruncateRequests 队列不为空，说明有COMMIT、COMPARE、TRUNCATE 等请求，这类请求优先处理。值得注意的是这里使用是 peek、poll 等非阻塞方法，然后根据请求的类型，调用对应的方法。稍后详细介绍。</p>
<p>代码@3：如果只有 append 类请求，则根据当前节点最大的消息序号，尝试从 writeRequestMap 容器中，获取下一个消息复制请求(ledgerEndIndex + 1) 为 key 去查找。如果不为空，则执行 doAppend 请求，如果为空，则调用 checkAbnormalFuture 来处理异常情况。</p>
<p>接下来我们来重点分析各个处理细节。</p>
<h4 id="3-3-1-handleDoCommit"><a href="#3-3-1-handleDoCommit" class="headerlink" title="3.3.1 handleDoCommit"></a>3.3.1 handleDoCommit</h4><p>处理提交请求，其处理比较简单，就是调用 DLedgerStore 的 updateCommittedIndex 更新其已提交偏移量，故我们还是具体看一下DLedgerStore 的 updateCommittedIndex 方法。</p>
<p>DLedgerMmapFileStore#updateCommittedIndex</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCommittedIndex</span><span class="params">(<span class="keyword">long</span> term, <span class="keyword">long</span> newCommittedIndex)</span> </span>&#123;   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (newCommittedIndex == -<span class="number">1</span></span><br><span class="line">            || ledgerEndIndex == -<span class="number">1</span></span><br><span class="line">            || term &lt; memberState.currTerm()</span><br><span class="line">            || newCommittedIndex == <span class="keyword">this</span>.committedIndex) &#123;                               <span class="comment">// @2</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newCommittedIndex &lt; <span class="keyword">this</span>.committedIndex</span><br><span class="line">            || newCommittedIndex &lt; <span class="keyword">this</span>.ledgerBeginIndex) &#123;                             <span class="comment">// @3</span></span><br><span class="line">        logger.warn(<span class="string">&quot;[MONITOR]Skip update committed index for new=&#123;&#125; &lt; old=&#123;&#125; or new=&#123;&#125; &lt; beginIndex=&#123;&#125;&quot;</span>, newCommittedIndex, <span class="keyword">this</span>.committedIndex, newCommittedIndex, <span class="keyword">this</span>.ledgerBeginIndex);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> endIndex = ledgerEndIndex;</span><br><span class="line">    <span class="keyword">if</span> (newCommittedIndex &gt; endIndex) &#123;                                                       <span class="comment">// @4</span></span><br><span class="line">            <span class="comment">//If the node fall behind too much, the committedIndex will be larger than enIndex.</span></span><br><span class="line">        newCommittedIndex = endIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    DLedgerEntry dLedgerEntry = get(newCommittedIndex);                        <span class="comment">// @5                </span></span><br><span class="line">    PreConditions.check(dLedgerEntry != <span class="keyword">null</span>, DLedgerResponseCode.DISK_ERROR);</span><br><span class="line">    <span class="keyword">this</span>.committedIndex = newCommittedIndex;</span><br><span class="line">    <span class="keyword">this</span>.committedPos = dLedgerEntry.getPos() + dLedgerEntry.getSize();     <span class="comment">// @6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先介绍一下方法的参数：</p>
<ul>
<li>long term<br>主节点当前的投票轮次。</li>
<li>long newCommittedIndex:<br>主节点发送日志复制请求时的已提交日志序号。</li>
</ul>
<p>代码@2：如果待更新提交序号为 -1 或 投票轮次小于从节点的投票轮次或主节点投票轮次等于从节点的已提交序号，则直接忽略本次提交动作。</p>
<p>代码@3：如果主节点的已提交日志序号小于从节点的已提交日志序号或待提交序号小于当前节点的最小有效日志序号，则输出警告日志[MONITOR]，并忽略本次提交动作。</p>
<p>代码@4：如果从节点落后主节点太多，则重置 提交索引为从节点当前最大有效日志序号。</p>
<p>代码@5：尝试根据待提交序号从从节点查找数据，如果数据不存在，则抛出 DISK_ERROR 错误。</p>
<p>代码@6：更新 commitedIndex、committedPos 两个指针，DledgerStore会定时将已提交指针刷入 checkpoint 文件，达到持久化 commitedIndex 指针的目的。</p>
<h4 id="3-3-2-handleDoCompare"><a href="#3-3-2-handleDoCompare" class="headerlink" title="3.3.2 handleDoCompare"></a>3.3.2 handleDoCompare</h4><p>处理主节点发送过来的 COMPARE 请求，其实现也比较简单，最终调用 buildResponse 方法构造响应结果。</p>
<p>EntryHandler#buildResponse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PushEntryResponse <span class="title">buildResponse</span><span class="params">(PushEntryRequest request, <span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">    PushEntryResponse response = <span class="keyword">new</span> PushEntryResponse();</span><br><span class="line">    response.setGroup(request.getGroup());</span><br><span class="line">    response.setCode(code);</span><br><span class="line">    response.setTerm(request.getTerm());</span><br><span class="line">    <span class="keyword">if</span> (request.getType() != PushEntryRequest.Type.COMMIT) &#123;</span><br><span class="line">        response.setIndex(request.getEntry().getIndex());</span><br><span class="line">    &#125;</span><br><span class="line">    response.setBeginIndex(dLedgerStore.getLedgerBeginIndex());</span><br><span class="line">    response.setEndIndex(dLedgerStore.getLedgerEndIndex());</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要也是返回当前从几点的 ledgerBeginIndex、ledgerEndIndex 以及投票轮次，供主节点进行判断比较。</p>
<h4 id="3-3-3-handleDoTruncate"><a href="#3-3-3-handleDoTruncate" class="headerlink" title="3.3.3 handleDoTruncate"></a>3.3.3 handleDoTruncate</h4><p>handleDoTruncate 方法实现比较简单，删除从节点上 truncateIndex 日志序号之后的所有日志，具体调用dLedgerStore 的 truncate 方法，由于其存储与 RocketMQ 的存储设计基本类似故本文就不在详细介绍，简单介绍其实现要点：根据日志序号，去定位到日志文件，如果命中具体的文件，则修改相应的读写指针、刷盘指针等，并将所在在物理文件之后的所有文件删除。大家如有兴趣，可以查阅笔者的《RocketMQ技术内幕》第4章：RocketMQ 存储相关内容。</p>
<h4 id="3-3-4-handleDoAppend"><a href="#3-3-4-handleDoAppend" class="headerlink" title="3.3.4 handleDoAppend"></a>3.3.4 handleDoAppend</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleDoAppend</span><span class="params">(<span class="keyword">long</span> writeIndex, PushEntryRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">    CompletableFuture&lt;PushEntryResponse&gt; future)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PreConditions.check(writeIndex == request.getEntry().getIndex(), DLedgerResponseCode.INCONSISTENT_STATE);</span><br><span class="line">        DLedgerEntry entry = dLedgerStore.appendAsFollower(request.getEntry(), request.getTerm(), request.getLeaderId());</span><br><span class="line">        PreConditions.check(entry.getIndex() == writeIndex, DLedgerResponseCode.INCONSISTENT_STATE);</span><br><span class="line">        future.complete(buildResponse(request, DLedgerResponseCode.SUCCESS.getCode()));</span><br><span class="line">        dLedgerStore.updateCommittedIndex(request.getTerm(), request.getCommitIndex());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;[HandleDoWrite] writeIndex=&#123;&#125;&quot;</span>, writeIndex, t);</span><br><span class="line">        future.complete(buildResponse(request, DLedgerResponseCode.INCONSISTENT_STATE.getCode()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实现也比较简单，调用DLedgerStore 的 appendAsFollower 方法进行日志的追加，与appendAsLeader 在日志存储部分相同，只是从节点无需再转发日志。</p>
<h4 id="3-3-5-checkAbnormalFuture"><a href="#3-3-5-checkAbnormalFuture" class="headerlink" title="3.3.5 checkAbnormalFuture"></a>3.3.5 checkAbnormalFuture</h4><p>该方法是本节的重点，doWork 的从服务器存储的最大有效日志序号(ledgerEndIndex) + 1 序号，尝试从待写请求中获取不到对应的请求时调用，这种情况也很常见，例如主节点并么有将最新的数据 PUSH 给从节点。接下来我们详细来看看该方法的实现细节。<br>EntryHandler#checkAbnormalFuture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (DLedgerUtils.elapsed(lastCheckFastForwardTimeMs) &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">lastCheckFastForwardTimeMs  = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">if</span> (writeRequestMap.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果上一次检查的时间距现在不到1s，则跳出；如果当前没有积压的append请求，同样跳出，因为可以同样明确的判断出主节点还未推送日志。</p>
<p>EntryHandler#checkAbnormalFuture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Pair&lt;PushEntryRequest, CompletableFuture&lt;PushEntryResponse&gt;&gt; pair : writeRequestMap.values()) &#123;</span><br><span class="line">    <span class="keyword">long</span> index = pair.getKey().getEntry().getIndex();             <span class="comment">// @1</span></span><br><span class="line">    <span class="comment">//Fall behind</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt;= endIndex) &#123;                                                   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DLedgerEntry local = dLedgerStore.get(index);</span><br><span class="line">            PreConditions.check(pair.getKey().getEntry().equals(local), DLedgerResponseCode.INCONSISTENT_STATE);</span><br><span class="line">            pair.getValue().complete(buildResponse(pair.getKey(), DLedgerResponseCode.SUCCESS.getCode()));</span><br><span class="line">            logger.warn(<span class="string">&quot;[PushFallBehind]The leader pushed an entry index=&#123;&#125; smaller than current ledgerEndIndex=&#123;&#125;, maybe the last ack is missed&quot;</span>, index, endIndex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;[PushFallBehind]The leader pushed an entry index=&#123;&#125; smaller than current ledgerEndIndex=&#123;&#125;, maybe the last ack is missed&quot;</span>, index, endIndex, t);</span><br><span class="line">            pair.getValue().complete(buildResponse(pair.getKey(), DLedgerResponseCode.INCONSISTENT_STATE.getCode()));</span><br><span class="line">        &#125;</span><br><span class="line">        writeRequestMap.remove(index);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Just OK</span></span><br><span class="line">    <span class="keyword">if</span> (index ==  endIndex + <span class="number">1</span>) &#123;    <span class="comment">// @3</span></span><br><span class="line">        <span class="comment">//The next entry is coming, just return</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Fast forward</span></span><br><span class="line">    TimeoutFuture&lt;PushEntryResponse&gt; future  = (TimeoutFuture&lt;PushEntryResponse&gt;) pair.getValue();    <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">if</span> (!future.isTimeOut()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; minFastForwardIndex) &#123;                                                                                                                <span class="comment">// @5</span></span><br><span class="line">        minFastForwardIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：遍历当前待写入的日志追加请求(主服务器推送过来的日志复制请求)，找到需要快速快进的的索引。其关键实现点如下：</p>
<ul>
<li>代码@1：首先获取待写入日志的序号。</li>
<li>代码@2：如果待写入的日志序号小于从节点已追加的日志(endIndex)，并且日志的确已存储在从节点，则返回成功，并输出警告日志【PushFallBehind】，继续监测下一条待写入日志。</li>
<li>代码@3：如果待写入 index 等于 endIndex + 1，则结束循环，因为下一条日志消息已经在待写入队列中，即将写入。</li>
<li>代码@4：如果待写入 index 大于 endIndex + 1，并且未超时，则直接检查下一条待写入日志。</li>
<li>代码@5：如果待写入 index 大于 endIndex + 1，并且已经超时，则记录该索引，使用 minFastForwardIndex 存储。</li>
</ul>
<p>EntryHandler#checkAbnormalFuture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (minFastForwardIndex == Long.MAX_VALUE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Pair&lt;PushEntryRequest, CompletableFuture&lt;PushEntryResponse&gt;&gt; pair = writeRequestMap.get(minFastForwardIndex);</span><br><span class="line"><span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：如果未找到需要快速失败的日志序号或 writeRequestMap 中未找到其请求，则直接结束检测。</p>
<p>EntryHandler#checkAbnormalFuture</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.warn(<span class="string">&quot;[PushFastForward] ledgerEndIndex=&#123;&#125; entryIndex=&#123;&#125;&quot;</span>, endIndex, minFastForwardIndex);</span><br><span class="line">pair.getValue().complete(buildResponse(pair.getKey(), DLedgerResponseCode.INCONSISTENT_STATE.getCode()));</span><br></pre></td></tr></table></figure>
<p>Step4：则向主节点报告从节点已经与主节点发生了数据不一致，从节点并没有写入序号 minFastForwardIndex 的日志。如果主节点收到此种响应，将会停止日志转发，转而向各个从节点发送 COMPARE 请求，从而使数据恢复一致。</p>
<p>行为至此，已经详细介绍了主服务器向从服务器发送请求，从服务做出响应，那接下来就来看一下，服务端收到响应结果后的处理，我们要知道主节点会向它所有的从节点传播日志，主节点需要在指定时间内收到超过集群一半节点的确认，才能认为日志写入成功，那我们接下来看一下其实现过程。</p>
<h2 id="4、QuorumAckChecker"><a href="#4、QuorumAckChecker" class="headerlink" title="4、QuorumAckChecker"></a>4、QuorumAckChecker</h2><p>日志复制投票器，一个日志写请求只有得到集群内的的大多数节点的响应，日志才会被提交。</p>
<h3 id="4-1-类图"><a href="#4-1-类图" class="headerlink" title="4.1 类图"></a>4.1 类图</h3><p><img src="https://img-blog.csdnimg.cn/20190914221601709.png" alt="在这里插入图片描述"><br>其核心属性如下：</p>
<ul>
<li>long lastPrintWatermarkTimeMs<br>上次打印水位线的时间戳，单位为毫秒。</li>
<li>long lastCheckLeakTimeMs<br>上次检测泄漏的时间戳，单位为毫秒。</li>
<li>long lastQuorumIndex<br>已投票仲裁的日志序号。</li>
</ul>
<h3 id="4-2-doWork-详解"><a href="#4-2-doWork-详解" class="headerlink" title="4.2 doWork 详解"></a>4.2 doWork 详解</h3><p>QuorumAckChecker#doWork </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (DLedgerUtils.elapsed(lastPrintWatermarkTimeMs) &gt; <span class="number">3000</span>) &#123;    </span><br><span class="line">    logger.info(<span class="string">&quot;[&#123;&#125;][&#123;&#125;] term=&#123;&#125; ledgerBegin=&#123;&#125; ledgerEnd=&#123;&#125; committed=&#123;&#125; watermarks=&#123;&#125;&quot;</span>,</span><br><span class="line">            memberState.getSelfId(), memberState.getRole(), memberState.currTerm(), dLedgerStore.getLedgerBeginIndex(), dLedgerStore.getLedgerEndIndex(), dLedgerStore.getCommittedIndex(), JSON.toJSONString(peerWaterMarksByTerm));</span><br><span class="line">    lastPrintWatermarkTimeMs = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step1：如果离上一次打印 watermak 的时间超过3s，则打印一下当前的 term、ledgerBegin、ledgerEnd、committed、peerWaterMarksByTerm 这些数据日志。</p>
<p>QuorumAckChecker#doWork</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!memberState.isLeader()) &#123;   <span class="comment">// @2</span></span><br><span class="line">    waitForRunning(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step2：如果当前节点不是主节点，直接返回，不作为。</p>
<p>QuorumAckChecker#doWork</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pendingAppendResponsesByTerm.size() &gt; <span class="number">1</span>) &#123;   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (Long term : pendingAppendResponsesByTerm.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (term == currTerm) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Long, TimeoutFuture&lt;AppendEntryResponse&gt;&gt; futureEntry : pendingAppendResponsesByTerm.get(term).entrySet()) &#123;</span><br><span class="line">            AppendEntryResponse response = <span class="keyword">new</span> AppendEntryResponse();</span><br><span class="line">            response.setGroup(memberState.getGroup());</span><br><span class="line">            response.setIndex(futureEntry.getKey());</span><br><span class="line">            response.setCode(DLedgerResponseCode.TERM_CHANGED.getCode());</span><br><span class="line">            response.setLeaderId(memberState.getLeaderId());</span><br><span class="line">            logger.info(<span class="string">&quot;[TermChange] Will clear the pending response index=&#123;&#125; for term changed from &#123;&#125; to &#123;&#125;&quot;</span>, futureEntry.getKey(), term, currTerm);</span><br><span class="line">            futureEntry.getValue().complete(response);</span><br><span class="line">        &#125;</span><br><span class="line">        pendingAppendResponsesByTerm.remove(term);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (peerWaterMarksByTerm.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Long term : peerWaterMarksByTerm.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (term == currTerm) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;[TermChange] Will clear the watermarks for term changed from &#123;&#125; to &#123;&#125;&quot;</span>, term, currTerm);</span><br><span class="line">        peerWaterMarksByTerm.remove(term);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step3：清理pendingAppendResponsesByTerm、peerWaterMarksByTerm 中本次投票轮次的数据，避免一些不必要的内存使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Long&gt; peerWaterMarks = peerWaterMarksByTerm.get(currTerm);</span><br><span class="line"><span class="keyword">long</span> quorumIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (Long index : peerWaterMarks.values()) &#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Long another : peerWaterMarks.values()) &#123;  <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (another &gt;= index) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memberState.isQuorum(num) &amp;&amp; index &gt; quorumIndex) &#123;  <span class="comment">// @3</span></span><br><span class="line">        quorumIndex = index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">dLedgerStore.updateCommittedIndex(currTerm, quorumIndex);  <span class="comment">// @4</span></span><br></pre></td></tr></table></figure>
<p>Step4：根据各个从节点反馈的进度，进行仲裁，确定已提交序号。为了加深对这段代码的理解，再来啰嗦一下 peerWaterMarks 的作用，存储的是各个从节点当前已成功追加的日志序号。例如一个三节点的 DLedger 集群，peerWaterMarks 数据存储大概如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">“dledger_group_01_0” : 100,</span><br><span class="line">&quot;dledger_group_01_1&quot; : 101,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 dledger_group_01_0 为从节点1的ID，当前已复制的序号为 100，而 dledger_group_01_1 为节点2的ID，当前已复制的序号为 101。再加上主节点，如何确定可提交序号呢？</p>
<ul>
<li>代码@1：首先遍历 peerWaterMarks 的 value 集合，即上述示例中的 {100, 101}，用临时变量 index 来表示待投票的日志序号，需要集群内超过半数的节点的已复制序号超过该值，则该日志能被确认提交。</li>
<li>代码@2：遍历 peerWaterMarks 中的所有已提交序号，与当前值进行比较，如果节点的已提交序号大于等于待投票的日志序号(index)，num 加一，表示投赞成票。</li>
<li>代码@3：对 index 进行仲裁，如果超过半数 并且 index 大于 quorumIndex，更新 quorumIndex 的值为 index。quorumIndex 经过遍历的，得出当前最大的可提交日志序号。</li>
<li>代码@4：更新 committedIndex 索引，方便 DLedgerStore 定时将 committedIndex 写入 checkpoint 中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConcurrentMap&lt;Long, TimeoutFuture&lt;AppendEntryResponse&gt;&gt; responses = pendingAppendResponsesByTerm.get(currTerm);</span><br><span class="line"><span class="keyword">boolean</span> needCheck = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> ackNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (quorumIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Long i = quorumIndex; i &gt;= <span class="number">0</span>; i--) &#123;  <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            CompletableFuture&lt;AppendEntryResponse&gt; future = responses.remove(i);   <span class="comment">// @2</span></span><br><span class="line">            <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;                                                                                              <span class="comment">// @3</span></span><br><span class="line">                needCheck = lastQuorumIndex != -<span class="number">1</span> &amp;&amp; lastQuorumIndex != quorumIndex &amp;&amp; i != lastQuorumIndex;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!future.isDone()) &#123;                                                                                <span class="comment">// @4</span></span><br><span class="line">                AppendEntryResponse response = <span class="keyword">new</span> AppendEntryResponse();</span><br><span class="line">                response.setGroup(memberState.getGroup());</span><br><span class="line">                response.setTerm(currTerm);</span><br><span class="line">                response.setIndex(i);</span><br><span class="line">                response.setLeaderId(memberState.getSelfId());</span><br><span class="line">                response.setPos(((AppendFuture) future).getPos());</span><br><span class="line">                future.complete(response);</span><br><span class="line">            &#125;</span><br><span class="line">            ackNum++;                                                                                                      <span class="comment">// @5</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">&quot;Error in ack to index=&#123;&#125; term=&#123;&#125;&quot;</span>, i, currTerm, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step5：处理 quorumIndex 之前的挂起请求，需要发送响应到客户端,其实现步骤：</p>
<ul>
<li><p>代码@1：从 quorumIndex 开始处理，没处理一条，该序号减一，直到大于0或主动退出，请看后面的退出逻辑。</p>
</li>
<li><p>代码@2：responses 中移除该日志条目的挂起请求。</p>
</li>
<li><p>代码@3：如果未找到挂起请求，说明前面挂起的请求已经全部处理完毕，准备退出，退出之前再 设置 needCheck 的值，其依据如下(三个条件必须同时满足)：</p>
<ul>
<li>最后一次仲裁的日志序号不等于-1</li>
<li>并且最后一次不等于本次新仲裁的日志序号</li>
<li>最后一次仲裁的日志序号不等于最后一次仲裁的日志。正常情况一下，条件一、条件二通常为true，但这一条大概率会返回false。</li>
</ul>
</li>
<li><p>代码@4：向客户端返回结果。</p>
</li>
<li><p>代码@5：ackNum，表示本次确认的数量。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (ackNum == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = quorumIndex + <span class="number">1</span>; i &lt; Integer.MAX_VALUE; i++) &#123;</span><br><span class="line">        TimeoutFuture&lt;AppendEntryResponse&gt; future = responses.get(i);</span><br><span class="line">        <span class="keyword">if</span> (future == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (future.isTimeOut()) &#123;</span><br><span class="line">            AppendEntryResponse response = <span class="keyword">new</span> AppendEntryResponse();</span><br><span class="line">            response.setGroup(memberState.getGroup());</span><br><span class="line">            response.setCode(DLedgerResponseCode.WAIT_QUORUM_ACK_TIMEOUT.getCode());</span><br><span class="line">            response.setTerm(currTerm);</span><br><span class="line">            response.setIndex(i);</span><br><span class="line">            response.setLeaderId(memberState.getSelfId());</span><br><span class="line">            future.complete(response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitForRunning(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step6：如果本次确认的个数为0，则尝试去判断超过该仲裁序号的请求，是否已经超时，如果已超时，则返回超时响应结果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (DLedgerUtils.elapsed(lastCheckLeakTimeMs) &gt; <span class="number">1000</span> || needCheck) &#123;</span><br><span class="line">    updatePeerWaterMark(currTerm, memberState.getSelfId(), dLedgerStore.getLedgerEndIndex());</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Long, TimeoutFuture&lt;AppendEntryResponse&gt;&gt; futureEntry : responses.entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (futureEntry.getKey() &lt; quorumIndex) &#123;</span><br><span class="line">            AppendEntryResponse response = <span class="keyword">new</span> AppendEntryResponse();</span><br><span class="line">            response.setGroup(memberState.getGroup());</span><br><span class="line">            response.setTerm(currTerm);</span><br><span class="line">            response.setIndex(futureEntry.getKey());</span><br><span class="line">            response.setLeaderId(memberState.getSelfId());</span><br><span class="line">            response.setPos(((AppendFuture) futureEntry.getValue()).getPos());</span><br><span class="line">            futureEntry.getValue().complete(response);</span><br><span class="line">            responses.remove(futureEntry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lastCheckLeakTimeMs = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Step7：检查是否发送泄漏。其判断泄漏的依据是如果挂起的请求的日志序号小于已提交的序号，则移除。</p>
<p>Step8：一次日志仲裁就结束了，最后更新 lastQuorumIndex 为本次仲裁的的新的提交值。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>rocketmq</category>
      </categories>
      <tags>
        <tag>rocketmq</tag>
        <tag>多副本</tag>
        <tag>主从切换</tag>
        <tag>DLedger</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Dubbo序列化-源码分析kryo各数据类型的序列化编码机制</title>
    <url>/posts/caabd6c1.html</url>
    <content><![CDATA[<div id="vip-container"><p>kryo序列化原理：<br>用过dubbo的开发人员，在选取序列化时都会根据“经验”来选kryo为序列化框，其原因是序列化协议非常高效，超过java原生序列化协议、hessian2协议，那kryo为什么高效呢？<br><strong>序列化协议，所谓的高效，通常应该从两方面考虑：</strong></p>
<ul>
<li>序列化后的二进制序列大小。（核心）</li>
<li>序列化、反序列化的速率。</li>
</ul>
<p>本节将重点探讨，kryo在减少序列化化二进制流上做的努力。</p>
<ul>
<li>序列化：将各种数据类型（基本类型、包装类型、对象、数组、集合）等序列化为byte数组的过程。</li>
<li>反序列化：将byte数组转换为各种数据类型（基本类型、包装类型、对象、数组、集合）。</li>
</ul>
<p>java中定义的数据类型所对应的序列化器在Kryo的构造函数中构造，其代码截图：<br><img src="https://img-blog.csdn.net/20180812195919737?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>接下来将详细介绍java常用的数据类型的序列化机制，即Kryo是如何编码二进制流。</p>
<a id="more"></a>

<h2 id="1、DefaultSerializers-IntSerializer-int类型序列化"><a href="#1、DefaultSerializers-IntSerializer-int类型序列化" class="headerlink" title="1、DefaultSerializers$IntSerializer int类型序列化"></a>1、DefaultSerializers$IntSerializer int类型序列化</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class IntSerializer extends Serializer&lt;Integer&gt; &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		setImmutable(true);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void write (Kryo kryo, Output output, Integer object) &#123;</span><br><span class="line">		output.writeInt(object, false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Integer read (Kryo kryo, Input input, Class&lt;Integer&gt; type) &#123;</span><br><span class="line">		return input.readInt(false);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-Integer-—-gt-byte-序列化"><a href="#1-1-Integer-—-gt-byte-序列化" class="headerlink" title="1.1 Integer —&gt; byte[] (序列化)"></a>1.1 Integer —&gt; byte[] (序列化)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Output#writeInt (int value, boolean optimizePositive) </span><br><span class="line">public int writeInt (int value, boolean optimizePositive) throws KryoException &#123; &#x2F;&#x2F; @1</span><br><span class="line">return writeVarInt(value, optimizePositive);  &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：boolean optimizePositive，是否优化绝对值。如果optimizePositive:false，则会对value进行移位运算，如果是正数，则存放的值为原值的两倍，如果是负数的话，存放的值为绝对值的两倍减去一，其算法为：value = (value &lt;&lt; 1) ^ (value &gt;&gt; 31)，在反序列化时，通过该算法恢复原值：((result &gt;&gt;&gt; 1) ^ -(result &amp; 1))。</p>
<p>代码@2：调用writeVarInt，采用变长编码来存储int而不是固定4字节。<br>Output#writeVarInt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int writeVarInt (int value, boolean optimizePositive) throws KryoException &#123;</span><br><span class="line">		if (!optimizePositive) value &#x3D; (value &lt;&lt; 1) ^ (value &gt;&gt; 31);</span><br><span class="line">		if (value &gt;&gt;&gt; 7 &#x3D;&#x3D; 0) &#123;                                           &#x2F;&#x2F; @1 </span><br><span class="line">			require(1);                                                    </span><br><span class="line">			buffer[position++] &#x3D; (byte)value;                  </span><br><span class="line">			return 1;</span><br><span class="line">		&#125;</span><br><span class="line">		if (value &gt;&gt;&gt; 14 &#x3D;&#x3D; 0) &#123;                                          &#x2F;&#x2F; @2</span><br><span class="line">			require(2);</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &amp; 0x7F) | 0x80);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 7);</span><br><span class="line">			return 2;</span><br><span class="line">		&#125;</span><br><span class="line">		if (value &gt;&gt;&gt; 21 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			require(3);</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &amp; 0x7F) | 0x80);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 7 | 0x80);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 14);</span><br><span class="line">			return 3;</span><br><span class="line">		&#125;</span><br><span class="line">		if (value &gt;&gt;&gt; 28 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			require(4);</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &amp; 0x7F) | 0x80);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 7 | 0x80);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 14 | 0x80);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 21);</span><br><span class="line">			return 4;</span><br><span class="line">		&#125;</span><br><span class="line">		require(5);</span><br><span class="line">		buffer[position++] &#x3D; (byte)((value &amp; 0x7F) | 0x80);</span><br><span class="line">		buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 7 | 0x80);</span><br><span class="line">		buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 14 | 0x80);</span><br><span class="line">		buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 21 | 0x80);</span><br><span class="line">		buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 28);</span><br><span class="line">		return 5;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其思想是采取变长字节来存储int类型的数据，int在java是固定4字节，由于在应用中，一般使用的int数据都不会很大，4个字节中，存在高位字节全是存储0的情况，故kryo为了减少在序列化流中的大小，尽量按需分配，kryo采用1-5个字节来存储int数据，为什么int类型在JAVA中最多4个字节，为什么变长int可能需要5个字节才能存储呢？这与变长字节需要标志位有关，下文根据代码来推测kryo关于int序列化byte数组的编码规则。<br>代码@1：value &gt;&gt;&gt; 7 == 0 ，一个数字，无符号右移(高位补0)7位后为0，说明该数字只占一个字节，并且高两位必须为0，也就是该数字的范围在0-127（2^7 -1）,对于字节的高位，低位的说明如下：<br><img src="https://img-blog.csdn.net/20180812200302841?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>如果该值范围为0-127直接，则使用1个字节存储int即可。在操作缓存区时buffer[position++] = (byte)value，需要向Output的缓存区申请1个字节的空间，然后进行赋值，并返回本次申请的存储空间，对于require方法在Byte[]、String序列化时重点讲解，包含缓存区的扩容，Output与输出流结合使用时的相关机制。</p>
<p>代码@2：value &gt;&gt;&gt; 14 == 0，如果数字的范围在0到2^14-1范围之间，则需要两个字节存储，这里为什么是14，其主要原因是，对于一个字节中的8位，kryo需要将高位用来当标记位，用来 标识是否还需要读取下一个字节。1：表示需要，0：表示不需要，也就是一个数据的结束。在变长int存储过中,一个字节8位kryo可用来存储数字有效位为 7 位 。举例演示一下：<br>kryo两字节能存储的数据的特点是高字节中前两位为0，例如：<br>0011 1011     0 010 1001<br>其存储方式为<br>buffer[0] =  先存储最后字节的低7位，010 1001 ，然后第一位之前，加1，表示还需要申请第二个字节来存储。此时buffer[0] = 1010 1001<br>buffer[1] =  存储 011 1011 0(这个0是原第一个字节未存储的部分) ，此时buffer[1]的8位中的高位为0，表示存储结束。<br>下图展示了kryo用2个字节存储一个int类型的数据的示意图。<br><img src="https://img-blog.csdn.net/20180812201011880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>同理，用3个字节可以表示2^21 -1。<br>kryo使用变长字节(1-5)个字节来存储int类型（java中固定占4字节）。</p>
<h3 id="1-2-int反序列化（byte-—-gt-int）"><a href="#1-2-int反序列化（byte-—-gt-int）" class="headerlink" title="1.2 int反序列化（byte[] —&gt; int）"></a>1.2 int反序列化（byte[] —&gt; int）</h3><p>反序列化就是根据上述编码规则，将byte[]序列化为int数字。<br>buffer[0] = 低位，，buffer[1] 高位,具体解码实现为：<br>Input#readVarInt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Reads a 1-5 byte int. It is guaranteed that a varible length encoding will be used. *&#x2F;</span><br><span class="line">	public int readVarInt (boolean optimizePositive) throws KryoException &#123;</span><br><span class="line">		if (require(1) &lt; 5) return readInt_slow(optimizePositive);</span><br><span class="line">		int b &#x3D; buffer[position++];</span><br><span class="line">		int result &#x3D; b &amp; 0x7F;</span><br><span class="line">		if ((b &amp; 0x80) !&#x3D; 0) &#123;</span><br><span class="line">			byte[] buffer &#x3D; this.buffer;</span><br><span class="line">			b &#x3D; buffer[position++];</span><br><span class="line">			result |&#x3D; (b &amp; 0x7F) &lt;&lt; 7;</span><br><span class="line">			if ((b &amp; 0x80) !&#x3D; 0) &#123;</span><br><span class="line">				b &#x3D; buffer[position++];</span><br><span class="line">				result |&#x3D; (b &amp; 0x7F) &lt;&lt; 14;</span><br><span class="line">				if ((b &amp; 0x80) !&#x3D; 0) &#123;</span><br><span class="line">					b &#x3D; buffer[position++];</span><br><span class="line">					result |&#x3D; (b &amp; 0x7F) &lt;&lt; 21;</span><br><span class="line">					if ((b &amp; 0x80) !&#x3D; 0) &#123;</span><br><span class="line">						b &#x3D; buffer[position++];</span><br><span class="line">						result |&#x3D; (b &amp; 0x7F) &lt;&lt; 28;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return optimizePositive ? result : ((result &gt;&gt;&gt; 1) ^ -(result &amp; 1));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Input#require(count)返回的是缓存区剩余字节数（可读）。其实现思路是，一个一个字节的读取，读到第一个字节后，首先提取有效存储位的数据，buffer[ 0 ] &amp; 0x7F，然后判断高位是否为1，如果不为1，直接返回，如果为1，则继续读取第二位buffer[1],同样首先提取有效数据位（低7位），然后对这数据向左移7位，在与buffer[0] 进行或运算。也就是，varint的存放是小端序列，越先读到的位，在整个int序列中越靠近低位。<br>2、String序列化，其实现类DefaultSerializers$StringSerializer。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class StringSerializer extends Serializer&lt;String&gt; &#123;</span><br><span class="line">	&#123;</span><br><span class="line">		setImmutable(true);</span><br><span class="line">		setAcceptsNull(true);      &#x2F;&#x2F; @1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void write (Kryo kryo, Output output, String object) &#123;</span><br><span class="line">		output.writeString(object);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String read (Kryo kryo, Input input, Class&lt;String&gt; type) &#123;</span><br><span class="line">		return input.readString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure>
<p>代码@1：String位不可变、允许为空，也就是序列化时需要考虑String s = null的情况。</p>
<h3 id="2-1-序列化-（String-—-gt-byte-）"><a href="#2-1-序列化-（String-—-gt-byte-）" class="headerlink" title="2.1 序列化 （String —-&gt; byte[]）"></a>2.1 序列化 （String —-&gt; byte[]）</h3><p>Output#writeString </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void writeString (String value) throws KryoException &#123;</span><br><span class="line">		if (value &#x3D;&#x3D; null) &#123;                                                                                &#x2F;&#x2F; @1</span><br><span class="line">			writeByte(0x80); &#x2F;&#x2F; 0 means null, bit 8 means UTF8.</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		int charCount &#x3D; value.length();      </span><br><span class="line">		if (charCount &#x3D;&#x3D; 0) &#123;    &#x2F;&#x2F; @2</span><br><span class="line">			writeByte(1 | 0x80); &#x2F;&#x2F; 1 means empty string, bit 8 means UTF8.</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F; Detect ASCII.</span><br><span class="line">		boolean ascii &#x3D; false;</span><br><span class="line">		if (charCount &gt; 1 &amp;&amp; charCount &lt; 64) &#123;  &#x2F;&#x2F; @3</span><br><span class="line">			ascii &#x3D; true;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; charCount; i++) &#123;</span><br><span class="line">				int c &#x3D; value.charAt(i);</span><br><span class="line">				if (c &gt; 127) &#123;</span><br><span class="line">					ascii &#x3D; false;</span><br><span class="line">					break;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ascii) &#123;     &#x2F;&#x2F; @4</span><br><span class="line">			if (capacity - position &lt; charCount)</span><br><span class="line">				writeAscii_slow(value, charCount);</span><br><span class="line">			else &#123;</span><br><span class="line">				value.getBytes(0, charCount, buffer, position);</span><br><span class="line">				position +&#x3D; charCount;</span><br><span class="line">			&#125;</span><br><span class="line">			buffer[position - 1] |&#x3D; 0x80;</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			writeUtf8Length(charCount + 1);      &#x2F;&#x2F; @5</span><br><span class="line">			int charIndex &#x3D; 0;</span><br><span class="line">			if (capacity - position &gt;&#x3D; charCount) &#123;     &#x2F;&#x2F; @6</span><br><span class="line">				&#x2F;&#x2F; Try to write 8 bit chars.</span><br><span class="line">				byte[] buffer &#x3D; this.buffer;</span><br><span class="line">				int position &#x3D; this.position;</span><br><span class="line">				for (; charIndex &lt; charCount; charIndex++) &#123;</span><br><span class="line">					int c &#x3D; value.charAt(charIndex);</span><br><span class="line">					if (c &gt; 127) break;</span><br><span class="line">					buffer[position++] &#x3D; (byte)c;</span><br><span class="line">				&#125;</span><br><span class="line">				this.position &#x3D; position;</span><br><span class="line">			&#125;</span><br><span class="line">			if (charIndex &lt; charCount) writeString_slow(value, charCount, charIndex);    &#x2F;&#x2F; @7</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>首先对字符串编码成字节序列，通常采用的编码方式为length:具体内容，通常的做法，表示字符串序列长度为固定字节，例如4位，那kryo是如何来表示的呢？请看下文分析。<br>代码@1：如果字符串为null,采用一个字节来表示长度，长度为0，并且该字节的高位填充1，表示字符串使用UTF-8编码，null字符串的最终表示为：1000 0000。<br>代码@2：空字符串表示，长度用1来表示，同样高位使用1填充表示字符串使用UTF-8编码，空字符串最终表示为：1000 0001。注：长度为1表示空字符串。<br>代码@3：如果字符长度大于1并且小于64，依次检查字符，如果其ascii小于127，则认为可以用ascii来表示单个字符，不能超过127的原因是，其中字节的高一位需要表示编码，0表示ascii,当用ascii编码来表示字符串是，第高2位需要用来表示是否结束标记。<br>代码@4：如果使用ascii编码，则单个字符，使用一个字节表示，高1位表示编码标记为，高2位表示是否结束标记。<br>代码@5：按照UTF-8编码，写入其长度，用变长int(varint)写入字符串长度，具体实现如下：<br>Output#writeUtf8Length</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void writeUtf8Length (int value) &#123;</span><br><span class="line">		if (value &gt;&gt;&gt; 6 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			require(1);</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">		&#125; else if (value &gt;&gt;&gt; 13 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			require(2);</span><br><span class="line">			byte[] buffer &#x3D; this.buffer;</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value | 0x40 | 0x80); &#x2F;&#x2F; Set bit 7 and 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 6);</span><br><span class="line">		&#125; else if (value &gt;&gt;&gt; 20 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			require(3);</span><br><span class="line">			byte[] buffer &#x3D; this.buffer;</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value | 0x40 | 0x80); &#x2F;&#x2F; Set bit 7 and 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &gt;&gt;&gt; 6) | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 13);</span><br><span class="line">		&#125; else if (value &gt;&gt;&gt; 27 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			require(4);</span><br><span class="line">			byte[] buffer &#x3D; this.buffer;</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value | 0x40 | 0x80); &#x2F;&#x2F; Set bit 7 and 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &gt;&gt;&gt; 6) | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &gt;&gt;&gt; 13) | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 20);</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			require(5);</span><br><span class="line">			byte[] buffer &#x3D; this.buffer;</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value | 0x40 | 0x80); &#x2F;&#x2F; Set bit 7 and 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &gt;&gt;&gt; 6) | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &gt;&gt;&gt; 13) | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)((value &gt;&gt;&gt; 20) | 0x80); &#x2F;&#x2F; Set bit 8.</span><br><span class="line">			buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 27);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>用来表示字符串长度的编码规则（int），第8位（高位）表示字符串的编码，第7位（高位）表示是否还需要读取下一个字节，也就是结束标记，1表示未结束，0表示结束。一个字节共8位，只有低6位用来存放数据， varint采取的是小端序列。<br>代码@6：如果当前缓存区有足够的空间，先尝试将字符串中单字节数据写入到buffer中，碰到第一个非单字节字符时，结束。<br>代码@7：将剩余空间写入缓存区，其实现方法：Output#writeString_slow(value, charCount, charIndex)<br>Output#writeString_slow</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void writeString_slow (CharSequence value, int charCount, int charIndex) &#123;</span><br><span class="line">		for (; charIndex &lt; charCount; charIndex++) &#123;                                                                            &#x2F;&#x2F; @1</span><br><span class="line">			if (position &#x3D;&#x3D; capacity) require(Math.min(, charCount - charIndex));                               &#x2F;&#x2F; @2</span><br><span class="line">			int c &#x3D; value.charAt(charIndex);                                                                                        &#x2F;&#x2F; @3</span><br><span class="line">			if (c &lt;&#x3D; 0x007F) &#123;                                                                                                               &#x2F;&#x2F; @4</span><br><span class="line">				buffer[position++] &#x3D; (byte)c;</span><br><span class="line">			&#125; else if (c &gt; 0x07FF) &#123;                                                                                                       &#x2F;&#x2F; @5</span><br><span class="line">				buffer[position++] &#x3D; (byte)(0xE0 | c &gt;&gt; 12 &amp; 0x0F);</span><br><span class="line">				require(2);</span><br><span class="line">				buffer[position++] &#x3D; (byte)(0x80 | c &gt;&gt; 6 &amp; 0x3F);</span><br><span class="line">				buffer[position++] &#x3D; (byte)(0x80 | c &amp; 0x3F);</span><br><span class="line">			&#125; else &#123;                                                                                                                                &#x2F;&#x2F; @6</span><br><span class="line">				buffer[position++] &#x3D; (byte)(0xC0 | c &gt;&gt; 6 &amp; 0x1F);</span><br><span class="line">				require(1);</span><br><span class="line">				buffer[position++] &#x3D; (byte)(0x80 | c &amp; 0x3F);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：循环遍历字符的字符。<br>代码@2：如果当前缓存区已经写满，尝试申请（capacity 与 charCount - charIndex ）的最小值，这里无需担心字符不是单字节申请charCount - charIndex空间不足的问题，后面我们会详细分析require方法，字节不够时会触发缓存区扩容或刷写到流中，再重复利用缓存区。<br>代码@3：int c = value.charAt(charIndex); 将字符类型转换为int类型，一个中文字符对应一个 int数字，这是因为java使用unicode编码，每个字符占用2个字节，char向int类型转换，就是将2字节的字节编码，转换成对应的二进制，然后用10进制表示的数字。<br>代码@4：如果值小于等0x7F(127)，直接存储在1个字节中，此时高位4个字节的范围在（0-7）<br>代码@5：如果值大于0x07FF(二进制 0000 0111 1111 1111)，第一个大于0x7F的值为(0000 1000 0000 0000),即2^12，数据有效位至少12位，使用3字节来存储，具体存储方式为：</p>
<ul>
<li>buffer[0] ：buffer[position++] = (byte)(0xE0 | c &gt;&gt; 12 &amp; 0x0F);  首先将c右移12位再与0x0F进行与操作，其意义就是先提取c的第16-13（4位的值），并与0xE0取或，最终的值为  0xE (16-13)位的值，从Input读取字符串可以看出，是根据0xE0作为存储该字符需要3个字节的依据，并且只取16-13位的值作为其高位的有效位，也就是说字符编码的值，不会超过0XFFFF,也就是两个字节(正好与java unicode编码吻合)。</li>
<li>buffer[1]：存储第12-7(共6位)，c &gt;&gt; 6 &amp; 0x3F，然后与0X80进行或，高位设置为1，表示UTF-8编码，其实再反序列化时，这个高位设置为1，未有实际作用。</li>
<li>buffer[2]：存储第6-1(共6位)，0x80 | c &amp; 0x3F，同样高位置1。</li>
</ul>
<h3 id="2-2-字符串反序列化-（byte-—-gt-String）"><a href="#2-2-字符串反序列化-（byte-—-gt-String）" class="headerlink" title="2.2 字符串反序列化 （byte[] —-&gt; String）"></a>2.2 字符串反序列化 （byte[] —-&gt; String）</h3><p>在讲解反序列化时，总结一下String序列化的编码规则</p>
<p>String序列化规则：String序列化的整体结构为  length + 内容,注意，这里的length不是内容字节的长度，而是String字符的长度。</p>
<ul>
<li><p>如果是null,则用1个字节表示，其二进制为 1000 0000。</p>
</li>
<li><p>如果是””空字符串，则用1个字节表示，其二进制为1000 0001。</p>
</li>
<li><p>如果字符长度大于1·且小于64，并且字符全是ascii字符（小等于127），则每个字符用一个字节表示，最后一个字节的高位置1，表示String字符的结束。【优化点，如果是ascii字符，编码时不需要使用length+内容的方式，而是直接写入内容】</p>
</li>
<li><p>如果不满足上述条件，则需要使用length + 内容的方式。</p>
<ul>
<li><p>用一个变长int写入字符的长度，每一字节，高两位分别为 编码标记（1:utf8）、是否结束标记（1:否;0:结束）</p>
</li>
<li><p>将内容用utf-8编码写入字节序列中，utf8，用变长字节（1-3）个字节表示一个字符（英文、中文）。每一个字节，使用6为，高两位为标志位。【16位】<br>3字节的存储为   【4位】 + 【6位】 + 【6位】，根据第一个字节高4位判断得出 需要几个字节来存储一个字符。<br>其反序列化的入口为Input#readString，就是按照上述规则进行解析即可，就不深入探讨了，有兴趣的话，可以自己去指定地方查阅。</p>
</li>
<li><p>boolean类型序列化：DefaultSerializers$BooleanSerializer<br>序列化：使用1个字节存储boolean类型，如果为true，则写入1，否则写入0。</p>
</li>
<li><p>byte类型序列化：DefaultSerializers$ByteSerializer<br>序列化：直接将byte写入字节流中即可。</p>
</li>
</ul>
</li>
</ul>
<h2 id="5、char类型序列化：DefaultSerializers-CharSerializer"><a href="#5、char类型序列化：DefaultSerializers-CharSerializer" class="headerlink" title="5、char类型序列化：DefaultSerializers$CharSerializer"></a>5、char类型序列化：DefaultSerializers$CharSerializer</h2><p>Output#writeChar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Writes a 2 byte char. Uses BIG_ENDIAN byte order. *&#x2F;</span><br><span class="line">	public void writeChar (char value) throws KryoException &#123;</span><br><span class="line">		require(2);</span><br><span class="line">		buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 8);</span><br><span class="line">		buffer[position++] &#x3D; (byte)value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>序列化：char在java中使用2字节存储（unicode),kryo在序列化时，按大端字节的顺序，将char写入字节流</p>
<h2 id="6、short类型序列化：DefaultSerializers-ShortSerializer"><a href="#6、short类型序列化：DefaultSerializers-ShortSerializer" class="headerlink" title="6、short类型序列化：DefaultSerializers$ShortSerializer"></a>6、short类型序列化：DefaultSerializers$ShortSerializer</h2><p>Output#writeShort</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Writes a 2 byte short. Uses BIG_ENDIAN byte order. *&#x2F;</span><br><span class="line">	public void writeShort (int value) throws KryoException &#123;</span><br><span class="line">		require(2);</span><br><span class="line">		buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 8);</span><br><span class="line">		buffer[position++] &#x3D; (byte)value;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>序列化：与char类型序列化一样，采用大端字节顺序存储。</p>
<h2 id="7、long类型序列化：DefaultSerializers-LongSerializer"><a href="#7、long类型序列化：DefaultSerializers-LongSerializer" class="headerlink" title="7、long类型序列化：DefaultSerializers$LongSerializer"></a>7、long类型序列化：DefaultSerializers$LongSerializer</h2><p>Output#writeLong</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int writeLong (long value, boolean optimizePositive) throws KryoException &#123;</span><br><span class="line">		return writeVarLong(value, optimizePositive);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>序列化：采取变长字节（1-9）位来存储long，其编码规则与int变长类型一致，每个字节的高位用来表示是否结束，1：表示还需要继续读取下一个字节，0：表示结束。</p>
<h2 id="8、float类型序列化：DefaultSerializers-FloatSerializer"><a href="#8、float类型序列化：DefaultSerializers-FloatSerializer" class="headerlink" title="8、float类型序列化：DefaultSerializers$FloatSerializer"></a>8、float类型序列化：DefaultSerializers$FloatSerializer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Writes a 4 byte float. *&#x2F;</span><br><span class="line">public void writeFloat (float value) throws KryoException &#123;</span><br><span class="line">	writeInt(Float.floatToIntBits(value));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** Writes a 4 byte int. Uses BIG_ENDIAN byte order. *&#x2F;</span><br><span class="line">public void writeInt (int value) throws KryoException &#123;</span><br><span class="line">	require(4);</span><br><span class="line">	byte[] buffer &#x3D; this.buffer;</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt; 24);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt; 16);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt; 8);</span><br><span class="line">	buffer[position++] &#x3D; (byte)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>序列化：首先将float按照IEEE 754编码标准，转换为int类型，然后按大端序列，使用固定长度4字节来存储float，这里之所以不使用变长字节来存储float，是因为，使用Float.floatToIntBits(value)产生的值，比较大，基本都需要使用4字才能存储，如果使用变长字节，则需要5字节，反而消耗的存储空间更大。</p>
<h2 id="9、DefaultSerializers-DoubleSerializer"><a href="#9、DefaultSerializers-DoubleSerializer" class="headerlink" title="9、DefaultSerializers$DoubleSerializer"></a>9、DefaultSerializers$DoubleSerializer</h2><p>Output#writeDouble序列化：首先将Double按照IEEE 754编码标准转换为Long，然后才去固定8字节存储。<br>到目前为止，介绍了8种基本类型(boolean、byte、char、short、int、float、long、double)和String类型的序列化与反序列化。</p>
<h2 id="10、BigInteger序列化：DefaultSerializers-BigIntegerSerializer"><a href="#10、BigInteger序列化：DefaultSerializers-BigIntegerSerializer" class="headerlink" title="10、BigInteger序列化：DefaultSerializers$BigIntegerSerializer"></a>10、BigInteger序列化：DefaultSerializers$BigIntegerSerializer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;** Writes an 8 byte double. *&#x2F;</span><br><span class="line">public void writeDouble (double value) throws KryoException &#123;</span><br><span class="line">	writeLong(Double.doubleToLongBits(value));</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;** Writes an 8 byte long. Uses BIG_ENDIAN byte order. *&#x2F;</span><br><span class="line">public void writeLong (long value) throws KryoException &#123;</span><br><span class="line">	require(8);</span><br><span class="line">	byte[] buffer &#x3D; this.buffer;</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 56);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 48);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 40);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 32);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 24);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 16);</span><br><span class="line">	buffer[position++] &#x3D; (byte)(value &gt;&gt;&gt; 8);</span><br><span class="line">	buffer[position++] &#x3D; (byte)value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BigInteger序列化实现,整体格式与String类型一样，由length + 内容构成。<br>1、如果为null，则写入一个字节，其值为0，表示长度为0。<br>2、如果为BigInteger.ZERO,则长度写入2，随后再写入1个字节的内容，字节内容为0，表示ZERO。<br>3、将BigInteger转换成byte[]数组，首先写入长度=（byte数组长度 + 1）,然后写入byte数组的内容即可。</p>
<h2 id="11、BigDecimal序列化：DefaultSerializers-BigDecimalSerializer"><a href="#11、BigDecimal序列化：DefaultSerializers-BigDecimalSerializer" class="headerlink" title="11、BigDecimal序列化：DefaultSerializers$BigDecimalSerializer"></a>11、BigDecimal序列化：DefaultSerializers$BigDecimalSerializer</h2><p>BigDecimal的序列化与BigInteger一样，首先是通过BigDecimal#unscaledValue方法返回对应的BigInteger,然后序列化，在反序列化时通过BigInteger创建对应的BigDecimal即可。</p>
<h2 id="12、Class实例序列化：DefaultSerializers-ClassSerializer"><a href="#12、Class实例序列化：DefaultSerializers-ClassSerializer" class="headerlink" title="12、Class实例序列化：DefaultSerializers$ClassSerializer"></a>12、Class实例序列化：DefaultSerializers$ClassSerializer</h2><p>DefaultSerializers$ClassSerializer#write</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void write (Kryo kryo, Output output, Class object) &#123;</span><br><span class="line">	kryo.writeClass(output, object); &#x2F;&#x2F; @1</span><br><span class="line">	output.writeByte((object !&#x3D; null &amp;&amp; object.isPrimitive()) ? 1 : 0); &#x2F;&#x2F; @2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：调用Kryo的writeClass方法序列化Class实例。<br>代码@2：写入是否是包装类型（针对8种基本类型）。<br>接下来我们重点分析Kryo#writeClass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Registration writeClass (Output output, Class type) &#123;</span><br><span class="line">   if (output &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;output cannot be null.&quot;);</span><br><span class="line">   try &#123;</span><br><span class="line">       return classResolver.writeClass(output, type);    &#x2F;&#x2F; @1</span><br><span class="line">   &#125; finally &#123;</span><br><span class="line">      if (depth &#x3D;&#x3D; 0 &amp;&amp; autoReset) reset();    &#x2F;&#x2F; @2</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先调用ClassResolver.wreteClass方法。<br>代码@2：完成一次写入后，需要重置Kryo中的临时数据结构，这也就是kryo实例非线程安全的原因，其中几个重要的数据结构会再ClassResolver.writeClass中详细说明。<br>DefaultClassResolver#writeClass </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Registration writeClass (Output output, Class type) &#123;</span><br><span class="line">    if (type &#x3D;&#x3D; null) &#123;   &#x2F;&#x2F; @1</span><br><span class="line">	if (TRACE || (DEBUG &amp;&amp; kryo.getDepth() &#x3D;&#x3D; 1))</span><br><span class="line">            log(&quot;Write&quot;, null);</span><br><span class="line">	output.writeVarInt(Kryo.NULL, true);</span><br><span class="line">  return null;</span><br><span class="line">    &#125;</span><br><span class="line">    Registration registration &#x3D; kryo.getRegistration(type);     &#x2F;&#x2F; @2</span><br><span class="line">    if (registration.getId() &#x3D;&#x3D; NAME)                                      &#x2F;&#x2F; @3</span><br><span class="line">writeName(output, type, registration);</span><br><span class="line">    else &#123;</span><br><span class="line">		if (TRACE) </span><br><span class="line">trace(&quot;kryo&quot;, &quot;Write class &quot; + registration.getId() + &quot;: &quot; + className(type));</span><br><span class="line">		output.writeVarInt(registration.getId() + 2, true);    &#x2F;&#x2F; @4</span><br><span class="line">   &#125;</span><br><span class="line">   return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果type为null，则存储Kryo.NULL(0)，使用变长int来存储，0在变长int中占用1个字节。<br>代码@2：根据type从kryo获取类注册信息，如果有调用kryo#public Registration register (Class type)方法，则会返回其注册关系。<br>代码@3：如果不存在注册关系，则需要将类型的全名写入。<br>代码@4：如果存在注册关系，则registration.getId()将不等于Kryo.NAME(-1)，则将(registration.getId() + 2)使用变长int写入字节流即可。<br>从这里看出，如果将类预先注册到kryo中，序列化字节流将变的更小，所谓的kryo类注册机制就是将字符串的类全路径名替换为数字，但数字的分配与注册顺序相关，所有，如果要使用类注册机制，必须在kryo对象创建时首先注册，确保注册顺序一致。<br>解析来重点分析一下writeName方法<br>DefaultClassResolver#writeName</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void writeName (Output output, Class type, Registration registration) &#123;</span><br><span class="line">	output.writeVarInt(NAME + 2, true);      &#x2F;&#x2F; @1</span><br><span class="line">	if (classToNameId !&#x3D; null) &#123;      &#x2F;&#x2F; @2</span><br><span class="line">		int nameId &#x3D; classToNameId.get(type, -1);    &#x2F;</span><br><span class="line">		if (nameId !&#x3D; -1) &#123;   &#x2F;&#x2F;</span><br><span class="line">			if (TRACE) trace(&quot;kryo&quot;, &quot;Write class name reference &quot; + nameId + &quot;: &quot; + className(type));</span><br><span class="line">			output.writeVarInt(nameId, true);</span><br><span class="line">			return;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#x2F;&#x2F; Only write the class name the first time encountered in object graph.</span><br><span class="line">	if (TRACE) trace(&quot;kryo&quot;, &quot;Write class name: &quot; + className(type));</span><br><span class="line">	int nameId &#x3D; nextNameId++;    &#x2F;&#x2F; @3</span><br><span class="line">	if (classToNameId &#x3D;&#x3D; null) classToNameId &#x3D; new IdentityObjectIntMap();    &#x2F;&#x2F; @4</span><br><span class="line">	classToNameId.put(type, nameId);     &#x2F;&#x2F; @5</span><br><span class="line">	output.writeVarInt(nameId, true);        &#x2F;&#x2F; @6</span><br><span class="line">	output.writeString(type.getName());   &#x2F;&#x2F; @7</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：由于是要写入类的全路径名，故首先使用变长int编码写入一个标记，表示是存储的类名，而不是一个ID。其标志位为 NAME+2 = 1。，存储0表示null。<br>代码@2：如果classToNameId 不为空（IdentityObjectIntMap&lt; Class&gt;），根据type获取nameId，如果不为空并且从缓存中能获取到nameId，则直接写入nameId,而不是写入类名，这里指在一次序列化过程中，同一个类名例如（cn.uce.test.Test）只写入一次，其他级联（重复）出现时，为其分配一个ID，进行缓存，具体可以从下面的代码中得知其意图。<br>代码@3：首先分配一全局递增的nameId。<br>代码@4：如果classToNameId 为空，则创建一个实例。<br>代码@5：将type与nameId进行缓存。<br>代码@6：写入nameId。<br>代码@7：写入type的全路径名。<br>注意Kryo#writeClass ,一次序列化Class实例后会调用reset方法，最终会清除本次classToNameId ,classToNameId并不能做一个全据的缓存的主要原因是，在不同的JVM虚拟机中，同一个class type对应的nameId不一定相同，故无法实现共存，只能是作为一个优化，在一次类序列化中，如果存在同一个类型，则第一个写入类全路径名，后面出现的则使用id(int)来存储，节省空间。<br>为了加深上述理解，我们再来看一下Class实例的反序列化：<br>DefaultClassResolver#readClass</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Registration readClass (Input input) &#123;</span><br><span class="line">	int classID &#x3D; input.readVarInt(true);    &#x2F;&#x2F; @1</span><br><span class="line">	switch (classID) &#123;</span><br><span class="line">	case Kryo.NULL:                                 &#x2F;&#x2F; @2</span><br><span class="line">		if (TRACE || (DEBUG &amp;&amp; kryo.getDepth() &#x3D;&#x3D; 1)) log(&quot;Read&quot;, null);</span><br><span class="line">		return null;</span><br><span class="line">	case NAME + 2: &#x2F;&#x2F; Offset for NAME and NULL.      &#x2F;&#x2F; @3</span><br><span class="line">		return readName(input);</span><br><span class="line">	&#125;</span><br><span class="line">	if (classID &#x3D;&#x3D; memoizedClassId) return memoizedClassIdValue;</span><br><span class="line">	Registration registration &#x3D; idToRegistration.get(classID - 2);  </span><br><span class="line">	if (registration &#x3D;&#x3D; null) throw new KryoException(&quot;Encountered unregistered class ID: &quot; + (classID - 2));</span><br><span class="line">  if (TRACE) trace(&quot;kryo&quot;, &quot;Read class &quot; + (classID - 2) + &quot;: &quot; + className(registration.getType()));</span><br><span class="line">	memoizedClassId &#x3D; classID;</span><br><span class="line">	memoizedClassIdValue &#x3D; registration;</span><br><span class="line">	return registration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先读取一个变长int。<br>代码@2：如果为Kryo.NULL表示为null，直接返回null即可。<br>代码@3：如果为NAME + 2则表示为存储的是类的全路径名，则调用readName解析类的名字。<br>代码@4：如果不为上述值，说明存储的是类型对应的ID值，也就是使用了类注册机制。 之所以idToRegistration.get(classID - 2)，是因为在存储时就是nameId + 2。因为，0（代表null），1：代表按类全路径名存储，nameId是从3开始存储。<br>接下来再重点看一下readName的实现：<br>DefaultClassResolver#readName</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected Registration readName (Input input) &#123;</span><br><span class="line">	int nameId &#x3D; input.readVarInt(true);   </span><br><span class="line">	if (nameIdToClass &#x3D;&#x3D; null) nameIdToClass &#x3D; new IntMap();</span><br><span class="line">	Class type &#x3D; nameIdToClass.get(nameId);    </span><br><span class="line">	if (type &#x3D;&#x3D; null) &#123;</span><br><span class="line">		&#x2F;&#x2F; Only read the class name the first time encountered in object graph.</span><br><span class="line">		String className &#x3D; input.readString();</span><br><span class="line">		type &#x3D; getTypeByName(className);</span><br><span class="line">		if (type &#x3D;&#x3D; null) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				type &#x3D; Class.forName(className, false, kryo.getClassLoader());</span><br><span class="line">			&#125; catch (ClassNotFoundException ex) &#123;</span><br><span class="line">				if (WARN) warn(&quot;kryo&quot;, &quot;Unable to load class &quot; + className + &quot; with kryo&#39;s ClassLoader. Retrying with current..&quot;);</span><br><span class="line">				try &#123;</span><br><span class="line">					type &#x3D; Class.forName(className);</span><br><span class="line">				&#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">					throw new KryoException(&quot;Unable to find class: &quot; + className, ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			if (nameToClass &#x3D;&#x3D; null) nameToClass &#x3D; new ObjectMap();</span><br><span class="line">			nameToClass.put(className, type);</span><br><span class="line">		   &#125;</span><br><span class="line">		  nameIdToClass.put(nameId, type);</span><br><span class="line">		 if (TRACE) trace(&quot;kryo&quot;, &quot;Read class name: &quot; + className);</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		if (TRACE) trace(&quot;kryo&quot;, &quot;Read class name reference &quot; + nameId + &quot;: &quot; + className(type));</span><br><span class="line">	&#125;</span><br><span class="line">	return kryo.getRegistration(type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先读取类的id，因为在序列化类时，如果序列化字符串时，首先先用变长int存储类型的nameId，然后再序列化类的全路径名，这样在一次反序列化时，第一次序列化时，将全列的全路径使用Class.forName实例化对象后，然后存储在局部方法缓存中（IntMap）中，在这一次序列化时再碰到同类型时，则根据id则可以找到对象。</p>
<p>Class实例序列化总结：<br><strong>Class实例序列化需求：序列化类的全路径名，反序列化时根据Class.forName生成对应的实例。</strong></p>
<p><strong>kryo序列化Class实例的编码规则：</strong><br>1、如果为null，用变长int，实际使用1个字节，存储值为0。<br>2、如果该类通过类注册机制注册到kryo时，则序列化 (nameId + 2)，用变长int存储。<br>3、如果该类未通过类注册机制注册到kryo，在一次序列化过程中（包含级联）时，类型第一次出现时，会分配一个nameId，将nameId+type全路径序列化，后续再出现该类型，则只序列化nameId即可。</p>
<h2 id="13、DefaultSerializers-DateSerializer"><a href="#13、DefaultSerializers-DateSerializer" class="headerlink" title="13、DefaultSerializers$DateSerializer"></a>13、DefaultSerializers$DateSerializer</h2><p>java.Util.Date、java.sql.Date等序列化时，只需序列化Date#getTime()返回的long类型，反序列化时根据long类型创建对应的实例即可。long类型的编码使用变长long格式进行序列化。</p>
<h2 id="14、枚举类型Enum序列化DefaultSerializers-EnumSerializer"><a href="#14、枚举类型Enum序列化DefaultSerializers-EnumSerializer" class="headerlink" title="14、枚举类型Enum序列化DefaultSerializers$EnumSerializer"></a>14、枚举类型Enum序列化DefaultSerializers$EnumSerializer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class EnumSerializer extends Serializer&lt;Enum&gt; &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			setImmutable(true);</span><br><span class="line">			setAcceptsNull(true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		private Object[] enumConstants;</span><br><span class="line"></span><br><span class="line">		public EnumSerializer (Class&lt;? extends Enum&gt; type) &#123;</span><br><span class="line">			enumConstants &#x3D; type.getEnumConstants();</span><br><span class="line">			if (enumConstants &#x3D;&#x3D; null) throw new IllegalArgumentException(&quot;The type must be an enum: &quot; + type);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public void write (Kryo kryo, Output output, Enum object) &#123;</span><br><span class="line">			if (object &#x3D;&#x3D; null) &#123;</span><br><span class="line">				output.writeVarInt(NULL, true);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			output.writeVarInt(object.ordinal() + 1, true);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		public Enum read (Kryo kryo, Input input, Class&lt;Enum&gt; type) &#123;</span><br><span class="line">			int ordinal &#x3D; input.readVarInt(true);</span><br><span class="line">			if (ordinal &#x3D;&#x3D; NULL) return null;</span><br><span class="line">			ordinal--;</span><br><span class="line">			if (ordinal &lt; 0 || ordinal &gt; enumConstants.length - 1)</span><br><span class="line">				throw new KryoException(&quot;Invalid ordinal for enum \&quot;&quot; + type.getName() + &quot;\&quot;: &quot; + ordinal);</span><br><span class="line">			Object constant &#x3D; enumConstants[ordinal];</span><br><span class="line">			return (Enum)constant;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>枚举类型序列化（支持null）：<br>1、如果为null，则使用变长int，实际用一个字节存储0。<br>2、如果不为null，使用变长int，存储object.ordinal()+1,也就是序列化该值在枚举类型常量数组中的下标，由于0代表为空，则下标从1开始。<br>在反序列化时，通过Enum.class.getEnumConstants()获取枚举类型的常量数组，然后从二进制流中获取下标即可。</p>
<h2 id="15、EnumSet-类型序列化：DefaultSerializers-EnumSetSerializer"><a href="#15、EnumSet-类型序列化：DefaultSerializers-EnumSetSerializer" class="headerlink" title="15、EnumSet 类型序列化：DefaultSerializers$EnumSetSerializer"></a>15、EnumSet 类型序列化：DefaultSerializers$EnumSetSerializer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class EnumSetSerializer extends Serializer&lt;EnumSet&gt; &#123;</span><br><span class="line">	public void write (Kryo kryo, Output output, EnumSet object) &#123;</span><br><span class="line">		Serializer serializer;</span><br><span class="line">		if (object.isEmpty()) &#123;     &#x2F;&#x2F; @1</span><br><span class="line">			EnumSet tmp &#x3D; EnumSet.complementOf(object);    &#x2F;&#x2F; @2</span><br><span class="line">			if (tmp.isEmpty()) throw new KryoException(&quot;An EnumSet must have a defined Enum to be serialized.&quot;);</span><br><span class="line">			serializer &#x3D; kryo.writeClass(output, tmp.iterator().next().getClass()).getSerializer();    &#x2F;&#x2F; @3</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			serializer &#x3D; kryo.writeClass(output, object.iterator().next().getClass()).getSerializer();</span><br><span class="line">		&#125;</span><br><span class="line">		output.writeInt(object.size(), true);  &#x2F;&#x2F; @4</span><br><span class="line">		for (Object element : object)     &#x2F;&#x2F; @5</span><br><span class="line">			serializer.write(kryo, output, element);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	public EnumSet read (Kryo kryo, Input input, Class&lt;EnumSet&gt; type) &#123;</span><br><span class="line">		Registration registration &#x3D; kryo.readClass(input);</span><br><span class="line">		EnumSet object &#x3D; EnumSet.noneOf(registration.getType());</span><br><span class="line">		Serializer serializer &#x3D; registration.getSerializer();</span><br><span class="line">		int length &#x3D; input.readInt(true);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; length; i++)</span><br><span class="line">			object.add(serializer.read(kryo, input, null));</span><br><span class="line">		return object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public EnumSet copy (Kryo kryo, EnumSet original) &#123;</span><br><span class="line">		return EnumSet.copyOf(original);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值。在序列化EnumSet时，需要将EnumSet中存储的枚举类型进行序列化，然后再序列每一个枚举值。<br>序列化过程：<br>-<br>代码@1：如果序列化的EnumSet为空，则通过代码EnumSet.complementOf方法创建一个其元素类型与指定EnumSet里元素类型相同的EnumSet集合，新EnumSet集合包含原EnumSet集合所不包含的、此类枚举类剩下的枚举值（即新EnumSet集合和原EnumSet集合的集合元素加起来是该枚举类的所有枚举值）。</p>
<p>代码@3：首先序列化EnumSet中的枚举类型Class实例，并获取枚举类型对应的序列器。</p>
<p>代码@4：序列化EnumSet中元素的个数。</p>
<p>代码@5：逐一序列化EnumSet中元素（一个个枚举值）。</p>
<h2 id="16、StringBuffer序列化DefaultSerializers-StringBufferSerializer"><a href="#16、StringBuffer序列化DefaultSerializers-StringBufferSerializer" class="headerlink" title="16、StringBuffer序列化DefaultSerializers$StringBufferSerializer"></a>16、StringBuffer序列化DefaultSerializers$StringBufferSerializer</h2><p>序列化：与String序列化一致。</p>
<h2 id="17、StringBuilder序列化DefaultSerializers-StringBuilderSerializer"><a href="#17、StringBuilder序列化DefaultSerializers-StringBuilderSerializer" class="headerlink" title="17、StringBuilder序列化DefaultSerializers$StringBuilderSerializer"></a>17、StringBuilder序列化DefaultSerializers$StringBuilderSerializer</h2><p>序列化：与String序列化一致。</p>
<h2 id="18、TreeMap序列化DefaultSerializers-TreeMapSerializer"><a href="#18、TreeMap序列化DefaultSerializers-TreeMapSerializer" class="headerlink" title="18、TreeMap序列化DefaultSerializers$TreeMapSerializer"></a>18、TreeMap序列化DefaultSerializers$TreeMapSerializer</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static public class TreeMapSerializer extends MapSerializer &#123;</span><br><span class="line">	public void write (Kryo kryo, Output output, Map map) &#123;</span><br><span class="line">		TreeMap treeMap &#x3D; (TreeMap)map;</span><br><span class="line">		kryo.writeClassAndObject(output, treeMap.comparator());</span><br><span class="line">		super.write(kryo, output, map);</span><br><span class="line">	&#125;</span><br><span class="line">          &#x2F;&#x2F;  ...省略部分代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TreeMap的序列，首先，先序列化TreeMap的比较器，然后再序列化TreeMap中的数据。<br>序列化数据请看MapSerializer<br>MapSerializer#write </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void write (Kryo kryo, Output output, Map map) &#123;</span><br><span class="line">		int length &#x3D; map.size();</span><br><span class="line">		output.writeInt(length, true);</span><br><span class="line"></span><br><span class="line">		Serializer keySerializer &#x3D; this.keySerializer;</span><br><span class="line">		if (keyGenericType !&#x3D; null) &#123;</span><br><span class="line">			if (keySerializer &#x3D;&#x3D; null) keySerializer &#x3D; kryo.getSerializer(keyGenericType);</span><br><span class="line">			keyGenericType &#x3D; null;</span><br><span class="line">		&#125;</span><br><span class="line">		Serializer valueSerializer &#x3D; this.valueSerializer;</span><br><span class="line">		if (valueGenericType !&#x3D; null) &#123;</span><br><span class="line">			if (valueSerializer &#x3D;&#x3D; null) valueSerializer &#x3D; kryo.getSerializer(valueGenericType);</span><br><span class="line">			valueGenericType &#x3D; null;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (Iterator iter &#x3D; map.entrySet().iterator(); iter.hasNext();) &#123;</span><br><span class="line">			Entry entry &#x3D; (Entry)iter.next();</span><br><span class="line">			if (keySerializer !&#x3D; null) &#123;</span><br><span class="line">				if (keysCanBeNull)</span><br><span class="line">					kryo.writeObjectOrNull(output, entry.getKey(), keySerializer);</span><br><span class="line">				else</span><br><span class="line">					kryo.writeObject(output, entry.getKey(), keySerializer);</span><br><span class="line">			&#125; else</span><br><span class="line">				kryo.writeClassAndObject(output, entry.getKey());</span><br><span class="line">			if (valueSerializer !&#x3D; null) &#123;</span><br><span class="line">				if (valuesCanBeNull)</span><br><span class="line">					kryo.writeObjectOrNull(output, entry.getValue(), valueSerializer);</span><br><span class="line">				else</span><br><span class="line">					kryo.writeObject(output, entry.getValue(), valueSerializer);</span><br><span class="line">			&#125; else</span><br><span class="line">				kryo.writeClassAndObject(output, entry.getValue());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其序列化方法就是遍历Map中的元素，调用Kryo#writeClassAndObject进行序列化，Kryo#writeClassAndObject涉及到Kryo整个序列化流程，将在下节介绍。</p>
<p>本节就讲述到这里了，，本节详细分析了Kryo对各种数据类型的序列化机制，其再降低序列化大小方面做了如下优化：</p>
<p>1、Kryo序列化的“对象”是数据以及少量元信息，这和JAVA默认的序列化的本质区别，java默认的序列化的目的是语言层面的，将类、对象的所有信息都序列化了，也就是就算是不加载class的定义，也能根据序列化后的信息动态构建类的所有信息。而Kryo反序列化时，必须能加载类的定义，这样Kryo能节省大量的字节空间。<br>2、使用变长int、变长long存储int、long类型，大大节省空间。<br>3、元数据（字符串类型）使用缓存机制，重复出现的字符串使用int来存储，节省存储空间。<br>4、字符串类型使用UTF-8存储，但会使用ascii码进一步优化空间。</p>
<p>下一节，将重点分析Kryo序列化的过程，其入口函数：Kryo#writeClassAndObject。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>dubbo</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>dubbo</tag>
        <tag>序列化</tag>
        <tag>kryo</tag>
        <tag>协议设计</tag>
      </tags>
  </entry>
  <entry>
    <title>源码分析Kafka 消息拉取流程</title>
    <url>/posts/497923c7.html</url>
    <content><![CDATA[<div id="vip-container"><h2 id="１、KafkaConsumer-poll-详解"><a href="#１、KafkaConsumer-poll-详解" class="headerlink" title="１、KafkaConsumer poll 详解"></a>１、KafkaConsumer poll 详解</h2><p>消息拉起主要入口为：KafkaConsumer#poll方法，其声明如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Duration timeout)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">return</span> poll(time.timer(timeout), <span class="keyword">true</span>);                                     <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码＠１：参数为超时时间，使用 java 的 Duration 来定义。<br>代码＠２：调用内部的 poll 方法。</p>
<p>KafkaConsumer#poll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ConsumerRecords&lt;K, V&gt; <span class="title">poll</span><span class="params">(<span class="keyword">final</span> Timer timer, <span class="keyword">final</span> <span class="keyword">boolean</span> includeMetadataInTimeout)</span> </span>&#123;  <span class="comment">// @1</span></span><br><span class="line">    acquireAndEnsureOpen();                                                                                                               <span class="comment">// @2</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.subscriptions.hasNoSubscriptionOrUserAssignment()) &#123;                                                  <span class="comment">// @3</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Consumer is not subscribed to any topics or assigned any partitions&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// poll for new data until the timeout expires</span></span><br><span class="line">        <span class="keyword">do</span> &#123;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　<span class="comment">// @4</span></span><br><span class="line">            client.maybeTriggerWakeup();                                                                                               <span class="comment">//@5</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (includeMetadataInTimeout) &#123;                       　　　　　　　　　　　　　　　　　　　 <span class="comment">// @6 　　　　　　　　　　　　　　　　　　　　                                                          </span></span><br><span class="line">                <span class="keyword">if</span> (!updateAssignmentMetadataIfNeeded(timer)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!updateAssignmentMetadataIfNeeded(time.timer(Long.MAX_VALUE))) &#123;        </span><br><span class="line">                    log.warn(<span class="string">&quot;Still waiting for metadata&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = pollForFetches(timer);   <span class="comment">// @7</span></span><br><span class="line">            <span class="keyword">if</span> (!records.isEmpty()) &#123;                                                                                                           </span><br><span class="line">                <span class="keyword">if</span> (fetcher.sendFetches() &gt; <span class="number">0</span> || client.hasPendingRequests()) &#123;                                           <span class="comment">// @8</span></span><br><span class="line">                    client.pollNoWakeup();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.interceptors.onConsume(<span class="keyword">new</span> ConsumerRecords&lt;&gt;(records));                         <span class="comment">// @９</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (timer.notExpired());                                                                                                         </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ConsumerRecords.empty();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码＠１：首先先对其参数含义进行讲解。</p>
<ul>
<li>boolean includeMetadataInTimeout<br>拉取消息的超时时间是否包含更新元数据的时间，默认为true，即包含。</li>
</ul>
<p>代码＠２：检查是否可以拉取消息，其主要判断依据如下：</p>
<ul>
<li>KafkaConsumer 是否有其他线程再执行，如果有，则抛出异常，因为 - KafkaConsumer 是线程不安全的，同一时间只能一个线程执行。</li>
<li>KafkaConsumer 没有被关闭。</li>
</ul>
<p>代码＠３：如果当前消费者未订阅任何主题或者没有指定队列，则抛出错误，结束本次消息拉取。</p>
<p>代码＠４：使用 do while 结构循环拉取消息，直到超时或拉取到消息。</p>
<p>代码＠５：避免在禁止禁用wakeup时，有请求想唤醒时则抛出异常，例如在下面的@8时，会禁用wakeup。</p>
<p>代码＠６：更新相关元数据，为真正向 broker 发送消息拉取请求做好准备，该方法将在下面详细介绍，现在先简单介绍其核心实现点：</p>
<ul>
<li>如有必要，先向 broker 端拉取最新的订阅信息(包含消费组内的在线的消费客户端)。</li>
<li>执行已完成(异步提交)的 offset 提交请求的回调函数。</li>
<li>维护与 broker 端的心跳请求，确保不会被“踢出”消费组。</li>
<li>更新元信息。</li>
<li>如果是自动提交消费偏移量，则自动提交偏移量。</li>
<li>更新各个分区下次待拉取的偏移量。</li>
</ul>
<p>这里会有一个更新元数据是否占用消息拉取的超时时间，默认为 true。</p>
<p>代码＠７：调用 pollForFetches 向broker拉取消息，该方法将在下文详细介绍。</p>
<p>代码＠８：如果拉取到的消息集合不为空，再返回该批消息之前，如果还有挤压的拉取请求，可以继续发送拉取请求，但此时会禁用warkup，主要的目的是用户在处理消息时，KafkaConsumer 还可以继续向broker 拉取消息。</p>
<p>代码＠９：执行消费拦截器。</p>
<p>接下来对上文提到的代码＠６、＠７进行详细介绍。</p>
<a id="more"></a>

<h4 id="1-1-KafkaConsumer-updateAssignmentMetadataIfNeeded-详解"><a href="#1-1-KafkaConsumer-updateAssignmentMetadataIfNeeded-详解" class="headerlink" title="1.1 KafkaConsumer updateAssignmentMetadataIfNeeded 详解"></a>1.1 KafkaConsumer updateAssignmentMetadataIfNeeded 详解</h4><p>KafkaConsumer＃updateAssignmentMetadataIfNeeded</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateAssignmentMetadataIfNeeded</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.poll(timer)) &#123;                            <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> updateFetchPositions(timer);                                                  <span class="comment">// @2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要理解这个方法实现的用途，我们就必须依次对 coordinator.poll 方法与 updateFetchPositions 方法。</p>
<h5 id="1-1-1-ConsumerCoordinator-poll"><a href="#1-1-1-ConsumerCoordinator-poll" class="headerlink" title="1.1.1 ConsumerCoordinator#poll"></a>1.1.1 ConsumerCoordinator#poll</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">poll</span><span class="params">(Timer timer)</span> </span>&#123;</span><br><span class="line">    invokeCompletedOffsetCommitCallbacks();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions.partitionsAutoAssigned()) &#123;  <span class="comment">// @2</span></span><br><span class="line">        pollHeartbeat(timer.currentTimeMs());       <span class="comment">// @21</span></span><br><span class="line">        <span class="keyword">if</span> (coordinatorUnknown() &amp;&amp; !ensureCoordinatorReady(timer)) &#123;   <span class="comment">//@22</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rejoinNeededOrPending()) &#123;                                                       <span class="comment">// @23</span></span><br><span class="line">            <span class="keyword">if</span> (subscriptions.hasPatternSubscription()) &#123;                              <span class="comment">// @231</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.metadata.timeToAllowUpdate(time.milliseconds()) == <span class="number">0</span>) &#123;  </span><br><span class="line">                    <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!client.ensureFreshMetadata(timer)) &#123;                                  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ensureActiveGroup(timer)) &#123;                                                <span class="comment">// @232</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                                            <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (metadata.updateRequested() &amp;&amp; !client.hasReadyNodes(timer.currentTimeMs())) &#123;</span><br><span class="line">            client.awaitMetadataUpdate(timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maybeAutoCommitOffsetsAsync(timer.currentTimeMs());   <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码＠1：执行已完成的 offset (消费进度)提交请求的回调函数。</p>
<p>代码@2：队列负载算法为自动分配（即 Kafka 根据消费者个数与分区书动态负载分区）的相关的处理逻辑。其实现关键点如下：</p>
<ul>
<li>代码@21：更新发送心跳相关的时间，例如heartbeatTimer、sessionTimer、pollTimer 分别代表发送最新发送心跳的时间、会话最新活跃时间、最新拉取消息。</li>
<li>代码@22：如果不存在协调器或协调器已断开连接，则返回 false，结束本次拉取。如果协调器就绪，则继续往下走。</li>
<li>代码@23：判断是否需要触发重平衡，即消费组内的所有消费者重新分配topic中的分区信息，例如元数据发送变化，判断是否需要重新重平衡的关键点如下：<ul>
<li>如果队列负载是通过用户指定的，则返回 false，表示无需重平衡。</li>
<li>如果队列是自动负载，topic 队列元数据发生了变化，则需要重平衡。</li>
<li>如果队列是自动负载，订阅关系发生了变化，则需要重平衡。<br>如果需要重重平衡，则同步更新元数据，此过程会阻塞。详细的重平衡将单独重点介绍，这里暂时不深入展开。</li>
</ul>
</li>
</ul>
<p>代码@3：用户手动为消费组指定负载的队列的相关处理逻辑，其实现关键如下：</p>
<ul>
<li>如果需要更新元数据，并且还没有分区准备好，则同步阻塞等待元数据更新完毕。</li>
</ul>
<p>代码@4：如果开启了自动提交消费进度，并且已到下一次提交时间，则提交。Kafka 消费者可以通过设置属性 enable.auto.commit 来开启自动提交，该参数默认为 true，则默认会每隔 5s 提交一次消费进度，提交间隔可以通过参数 auto.commit.interval.ms 设置。</p>
<p>接下来继续探讨 updateAssignmentMetadataIfNeeded (更新元数据)的第二个步骤，更新拉取位移。</p>
<h5 id="1-1-2-updateFetchPositions-详解"><a href="#1-1-2-updateFetchPositions-详解" class="headerlink" title="1.1.2 updateFetchPositions 详解"></a>1.1.2 updateFetchPositions 详解</h5><p>KafkaConsumer#updateFetchPositions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateFetchPositions</span><span class="params">(<span class="keyword">final</span> Timer timer)</span> </span>&#123;</span><br><span class="line">    cachedSubscriptionHashAllFetchPositions = subscriptions.hasAllFetchPositions();  </span><br><span class="line">    <span class="keyword">if</span> (cachedSubscriptionHashAllFetchPositions) &#123;           <span class="comment">// @1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; !coordinator.refreshCommittedOffsetsIfNeeded(timer))   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    subscriptions.resetMissingPositions();                         <span class="comment">// @3</span></span><br><span class="line">    fetcher.resetOffsetsIfNeeded();                                    <span class="comment">// @4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：如果订阅关系中的所有分区都有有效的位移，则返回 true。</p>
<p>代码@2：如果存在任意一个分区没有有效的位移信息，则需要向 broker 发送请求，从broker 获取该消费组，该分区的消费进度。相关的实现细节将在后续文章【Kafka 消费进度】专题文章中详细介绍。</p>
<p>代码@3：如果经过第二步，订阅关系中还某些分区还是没有获取到有效的偏移量，则使用偏移量重置策略进行重置，如果未配置，则抛出异常。</p>
<p>代码@4：发送一个异步请求去重置那些正等待重置位置的分区。有关 Kafka 消费消费进度、重平衡等知识将会在后续文章中深入探讨，本文只需了解 poll 消息的核心处理流程。</p>
<p>从 KafkaConsumer#poll 中流程可以看到，通过 updateAssignmentMetadataIfNeeded 对元数据、重平衡，更新拉取偏移量等工作处理完成后，下一步就是需要向 broker 拉取消息了，其实现入口为：KafkaConsumer 的 pollForFetches 方法。</p>
<h4 id="1-2-消息拉取"><a href="#1-2-消息拉取" class="headerlink" title="1.2 消息拉取"></a>1.2 消息拉取</h4><p>KafkaConsumer#pollForFetches</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; pollForFetches(Timer timer) &#123;</span><br><span class="line">        <span class="keyword">long</span> pollTimeout = coordinator == <span class="keyword">null</span> ? timer.remainingMs() :</span><br><span class="line">                Math.min(coordinator.timeToNextPoll(timer.currentTimeMs()), timer.remainingMs());   <span class="comment">// @1</span></span><br><span class="line">        <span class="comment">// if data is available already, return it immediately</span></span><br><span class="line">        <span class="keyword">final</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; records = fetcher.fetchedRecords();    <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> records;</span><br><span class="line">        &#125;</span><br><span class="line">        fetcher.sendFetches();                               <span class="comment">// @3</span></span><br><span class="line">        <span class="comment">// We do not want to be stuck blocking in poll if we are missing some positions</span></span><br><span class="line">        <span class="comment">// since the offset lookup may be backing off after a failure</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the use of cachedSubscriptionHashAllFetchPositions means we MUST call</span></span><br><span class="line">        <span class="comment">// updateAssignmentMetadataIfNeeded before this method.</span></span><br><span class="line">        <span class="keyword">if</span> (!cachedSubscriptionHashAllFetchPositions &amp;&amp; pollTimeout &gt; retryBackoffMs) &#123;   <span class="comment">// @4</span></span><br><span class="line">            pollTimeout = retryBackoffMs;</span><br><span class="line">        &#125;</span><br><span class="line">        Timer pollTimer = time.timer(pollTimeout);</span><br><span class="line">        client.poll(pollTimer, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> !fetcher.hasCompletedFetches();</span><br><span class="line">        &#125;);         <span class="comment">// @5</span></span><br><span class="line">        timer.update(pollTimer.currentTimeMs());   <span class="comment">// @6</span></span><br><span class="line">        <span class="keyword">if</span> (coordinator != <span class="keyword">null</span> &amp;&amp; coordinator.rejoinNeededOrPending()) &#123;  <span class="comment">// @7</span></span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fetcher.fetchedRecords();   <span class="comment">// @8</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：计算本次拉取的超时时间，其计算逻辑如下：</p>
<ul>
<li>如果协调器为空，则返回当前定时器剩余时间即可。</li>
<li>如果协调器不为空，其逻辑较为复杂，为下面返回的超时间与当前定时器剩余时间相比取最小值。</li>
<li>如果不开启自动提交位移并且未加入消费组，则超时时间为Long.MAX_VALUE。</li>
<li>如果不开启自动提交位移并且已加入消费组，则返回距离下一次发送心跳包还剩多少时间。</li>
<li>如果开启自动提交位移，则返回 距离下一次自动提交位移所需时间 与 距离下一次发送心跳包所需时间 之间的最小值。</li>
</ul>
<p>代码@2：如果数据已经拉回到本地，直接返回数据。将在下文详细介绍 Fetcher 的 fetchedRecords 方法。</p>
<p>代码@3:组装发送请求，并将存储在待发送请求列表中。</p>
<p>代码@4：如果已缓存的分区信息中存在某些分区缺少偏移量，如果拉取的超时时间大于失败重试需要阻塞的时间，则更新此次拉取的超时时间为失败重试需要的间隔时间，主要的目的是不希望在 poll 过程中被阻塞【后续会详细介绍 Kafka 拉取消息的线程模型，再来回顾一下这里】。</p>
<p>代码@5：通过调用NetworkClient 的 poll 方法发起消息拉取操作（触发网络读写）。</p>
<p>代码@6：更新本次拉取的时间。</p>
<p>代码@7：检查是需要重平衡。</p>
<p>代码@8：将从 broker 读取到的数据返回（即封装成消息）。</p>
<p>从上面消息拉取流程来看，有几个比较重要的方法，例如 Fetcher 类相关的方法，NetworkClient 的 poll 方法，那我们接下来来重点探讨。</p>
<p>我们先用一张流程图总结一下消息拉取的全过程：<br><img src="https://img-blog.csdnimg.cn/20191208193241248.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>接下来我们将重点看一下 KafkaConsumer 的 pollForFetches 详细过程，也就是需要详细探究 Fetcher 类的实现细节。</p>
<h2 id="2、Fetcher-类详解"><a href="#2、Fetcher-类详解" class="headerlink" title="2、Fetcher 类详解"></a>2、Fetcher 类详解</h2><p>Fetcher 封装消息拉取的方法，可以看成是消息拉取的门面类。</p>
<h4 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h4><p><img src="https://img-blog.csdnimg.cn/20191208193319781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>我们首先一一介绍一下 Fetcher 的核心属性与核心方法。</p>
<ul>
<li>ConsumerNetworkClient client<br>消费端网络客户端，Kafka 负责网络通讯实现类。</li>
<li>int minBytes<br>一次消息拉取需要拉取的最小字节数，如果不组，会阻塞，默认值为1字节，如果增大这个值会增大吞吐，但会增加延迟，可以通参数 fetch.min.bytes 改变其默认值。</li>
<li>int maxBytes<br>一次消息拉取允许拉取的最大字节数，但这不是绝对的，如果一个分区的第一批记录超过了该值，也会返回。默认为50M,可通过参数 fetch.max.bytes 改变其默认值。同时不能超过 broker的配置参数(message.max.bytes) 和 主题级别的配置(max.message.bytes)。</li>
<li>int maxWaitMs<br>在 broker 如果符合拉取条件的数据小于 minBytes 时阻塞的时间，默认为 500ms ，可通属性 fetch.max.wait.ms 进行定制。</li>
<li>int fetchSize<br>每一个分区返回的最大消息字节数，如果分区中的第一批消息大于 fetchSize 也会返回。</li>
<li>long retryBackoffMs<br>失败重试后需要阻塞的时间，默认为 100 ms，可通过参数 retry.backoff.ms 定制。</li>
<li>long requestTimeoutMs<br>客户端向 broker 发送请求最大的超时时间，默认为 30s，可以通过 request.timeout.ms 参数定制。</li>
<li>int maxPollRecords<br>单次拉取返回的最大记录数，默认值 500，可通过参数 max.poll.records 进行定制。</li>
<li>boolean checkCrcs<br>是否检查消息的 crcs 校验和，默认为 true，可通过参数 check.crcs 进行定制。</li>
<li>Metadata metadata<br>元数据。</li>
<li>FetchManagerMetrics sensors<br>消息拉取的统计服务类。</li>
<li>SubscriptionState subscriptions<br>订阅信息状态。</li>
<li>ConcurrentLinkedQueue&lt; CompletedFetch&gt; completedFetches<br>已完成的 Fetch 的请求结果，待消费端从中取出数据。</li>
<li>Deserializer&lt; K&gt; keyDeserializer<br>key 的反序列化器。</li>
<li>Deserializer&lt; V&gt; valueDeserializer<br>value 的饭序列化器。</li>
<li>IsolationLevel isolationLevel<br>Kafka的隔离级别（与事务消息相关），后续在研究其事务相关时再进行探讨。</li>
<li>Map&lt;Integer, FetchSessionHandler&gt; sessionHandlers<br>拉取会话监听器。</li>
</ul>
<p>接下来我们将按照消息流程，一起来看一下 Fetcher 的核心方法。</p>
<h4 id="2-2-Fetcher-核心方法"><a href="#2-2-Fetcher-核心方法" class="headerlink" title="2.2 Fetcher 核心方法"></a>2.2 Fetcher 核心方法</h4><h5 id="2-2-1-Fetcher-fetchedRecords"><a href="#2-2-1-Fetcher-fetchedRecords" class="headerlink" title="2.2.1 Fetcher#fetchedRecords"></a>2.2.1 Fetcher#fetchedRecords</h5><p>Fetcher#fetchedRecords</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetchedRecords() &#123;</span><br><span class="line">    Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched = <span class="keyword">new</span> HashMap&lt;&gt;();   <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">int</span> recordsRemaining = maxPollRecords;                                                              </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (recordsRemaining &gt; <span class="number">0</span>) &#123;                                                                                  <span class="comment">// @2</span></span><br><span class="line">            <span class="keyword">if</span> (nextInLineRecords == <span class="keyword">null</span> || nextInLineRecords.isFetched) &#123;                           <span class="comment">// @3</span></span><br><span class="line">                CompletedFetch completedFetch = completedFetches.peek();</span><br><span class="line">                <span class="keyword">if</span> (completedFetch == <span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    nextInLineRecords = parseCompletedFetch(completedFetch);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    FetchResponse.PartitionData partition = completedFetch.partitionData;</span><br><span class="line">                    <span class="keyword">if</span> (fetched.isEmpty() &amp;&amp; (partition.records == <span class="keyword">null</span> || partition.records.sizeInBytes() == <span class="number">0</span>)) &#123;</span><br><span class="line">                        completedFetches.poll();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                completedFetches.poll();</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;                                                                                                                         <span class="comment">// @4</span></span><br><span class="line">                List&lt;ConsumerRecord&lt;K, V&gt;&gt; records = fetchRecords(nextInLineRecords, recordsRemaining);</span><br><span class="line">                TopicPartition partition = nextInLineRecords.partition;</span><br><span class="line">                <span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">                    List&lt;ConsumerRecord&lt;K, V&gt;&gt; currentRecords = fetched.get(partition);</span><br><span class="line">                    <span class="keyword">if</span> (currentRecords == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        fetched.put(partition, records);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        List&lt;ConsumerRecord&lt;K, V&gt;&gt; newRecords = <span class="keyword">new</span> ArrayList&lt;&gt;(records.size() + currentRecords.size());</span><br><span class="line">                        newRecords.addAll(currentRecords);</span><br><span class="line">                        newRecords.addAll(records);</span><br><span class="line">                        fetched.put(partition, newRecords);</span><br><span class="line">                    &#125;</span><br><span class="line">                    recordsRemaining -= records.size();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (KafkaException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fetched.isEmpty())</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetched;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先先解释两个局部变量的含义：</p>
<ul>
<li>Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt; fetched 按分区存放已拉取的消息，返回给客户端进行处理。</li>
<li>recordsRemaining：剩余可拉取的消息条数。</li>
</ul>
<p>代码@2：循环去取已经完成了 Fetch 请求的消息，该 while 循环有两个跳出条件：</p>
<ul>
<li>如果拉取的消息已经达到一次拉取的最大消息条数，则跳出循环。</li>
<li>缓存中所有拉取结果已处理。</li>
</ul>
<p>代码@3、@4 主要完成从缓存中解析数据的两个步骤，初次运行的时候，会进入分支@3，然后从 调用 parseCompletedFetch 解析成 PartitionRecords 对象，然后代码@4的职责就是从解析 PartitionRecords ，将消息封装成 ConsumerRecord，返回给消费端线程处理。</p>
<p>代码@3的实现要点如下：</p>
<ul>
<li>首先从 completedFetches (Fetch请求的返回结果) 列表中获取一个 Fetcher 请求，主要使用的 Queue 的 peek()方法，并不会从该队列中移除该元素。</li>
<li>然后调用 parseCompletedFetch 对处理结果进行解析返回 PartitionRecords。</li>
<li>处理成功后，调用 Queue 的方法将已处理过的 Fetcher结果移除。</li>
</ul>
<p>从上面可知，上述方法的核心方法是：parseCompletedFetch。</p>
<p>代码@4的实现要点无非就是调用 fetchRecords 方法，按分区组装成 Map&lt;TopicPartition, List&lt;ConsumerRecord&lt;K, V&gt;&gt;&gt;，供消费者处理，例如供业务处理。</p>
<p>接下来将重点探讨上述两个方法的实现细节。</p>
<h6 id="2-2-1-1-Fetcher-parseCompletedFetch"><a href="#2-2-1-1-Fetcher-parseCompletedFetch" class="headerlink" title="2.2.1.1 Fetcher#parseCompletedFetch"></a>2.2.1.1 Fetcher#parseCompletedFetch</h6><p>在尝试探讨该方法之前，我们首先对其入参进行一个梳理，特别是先认识其主要数据结构。</p>
<p>1、CompletedFetch 相关类图<br><img src="https://img-blog.csdnimg.cn/2019120819365575.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>从上图可以看出，CompleteFetch 核心属性主要如下：</p>
<ul>
<li>TopicPartition partition<br>分区信息，返回结果都是以分区为纬度。</li>
<li>long fetchedOffset<br>本次拉取的开始偏移量。</li>
<li>FetchResponse.PartitionData partitionData<br>返回的分区数据。</li>
<li>FetchResponseMetricAgregator metricAggregator<br>统计指标相关。</li>
<li>short responseVersion<br>broker 端的版本号。</li>
</ul>
<p>分区的数据是使用 PartitionData 来进行封装的。我们也来简单的了解一下其内部数据结果。</p>
<ul>
<li>Errors error<br>分区拉取的相应结果，Errors.NONE 表示请求成功。</li>
<li>long highWatermark<br>broker 端关于该分区的高水位线，即小于该偏移量的消息对于消费端是可见的。</li>
<li>long lastStableOffset<br>分区中小于该偏移量的消息的事务状态已得到确认，要么是已提交，要么是已回滚，与事务相关，后面会专门探讨。</li>
<li>List&lt; AbortedTransaction&gt; abortedTransactions<br>已拒绝的事物。</li>
<li>T records<br>分区数据，是 BaseRecords 的子类。</li>
</ul>
<p>2、parseCompletedFetch 详解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PartitionRecords <span class="title">parseCompletedFetch</span><span class="params">(CompletedFetch completedFetch)</span> </span>&#123;</span><br><span class="line">    TopicPartition tp = completedFetch.partition;</span><br><span class="line">    FetchResponse.PartitionData&lt;Records&gt; partition = completedFetch.partitionData;</span><br><span class="line">    <span class="keyword">long</span> fetchOffset = completedFetch.fetchedOffset;</span><br><span class="line">    PartitionRecords partitionRecords = <span class="keyword">null</span>;</span><br><span class="line">    Errors error = partition.error;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!subscriptions.isFetchable(tp)) &#123;       <span class="comment">// @1</span></span><br><span class="line">            log.debug(<span class="string">&quot;Ignoring fetched records for partition &#123;&#125; since it is no longer fetchable&quot;</span>, tp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.NONE) &#123;         <span class="comment">// @2</span></span><br><span class="line">            Long position = subscriptions.position(tp);</span><br><span class="line">            <span class="keyword">if</span> (position == <span class="keyword">null</span> || position != fetchOffset) &#123;    <span class="comment">// @21</span></span><br><span class="line">                log.debug(<span class="string">&quot;Discarding stale fetch response for partition &#123;&#125; since its offset &#123;&#125; does not match &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;the expected offset &#123;&#125;&quot;</span>, tp, fetchOffset, position);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.trace(<span class="string">&quot;Preparing to read &#123;&#125; bytes of data for partition &#123;&#125; with offset &#123;&#125;&quot;</span>,</span><br><span class="line">                        partition.records.sizeInBytes(), tp, position);</span><br><span class="line">            Iterator&lt;? extends RecordBatch&gt; batches = partition.records.batches().iterator();   <span class="comment">// @22</span></span><br><span class="line">            partitionRecords = <span class="keyword">new</span> PartitionRecords(tp, completedFetch, batches);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!batches.hasNext() &amp;&amp; partition.records.sizeInBytes() &gt; <span class="number">0</span>) &#123;   <span class="comment">// @23</span></span><br><span class="line">                <span class="keyword">if</span> (completedFetch.responseVersion &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                    Map&lt;TopicPartition, Long&gt; recordTooLargePartitions = Collections.singletonMap(tp, fetchOffset);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RecordTooLargeException(<span class="string">&quot;There are some messages at [Partition=Offset]: &quot;</span> +</span><br><span class="line">                                recordTooLargePartitions + <span class="string">&quot; whose size is larger than the fetch size &quot;</span> + <span class="keyword">this</span>.fetchSize +</span><br><span class="line">                                <span class="string">&quot; and hence cannot be returned. Please considering upgrading your broker to 0.10.1.0 or &quot;</span> +</span><br><span class="line">                                <span class="string">&quot;newer to avoid this issue. Alternately, increase the fetch size on the client (using &quot;</span> +</span><br><span class="line">                                ConsumerConfig.MAX_PARTITION_FETCH_BYTES_CONFIG + <span class="string">&quot;)&quot;</span>,</span><br><span class="line">                                recordTooLargePartitions);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// This should not happen with brokers that support FetchRequest/Response V3 or higher (i.e. KIP-74)</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> KafkaException(<span class="string">&quot;Failed to make progress reading messages at &quot;</span> + tp + <span class="string">&quot;=&quot;</span> +</span><br><span class="line">                            fetchOffset + <span class="string">&quot;. Received a non-empty fetch response from the server, but no &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;complete records were found.&quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partition.highWatermark &gt;= <span class="number">0</span>) &#123;   <span class="comment">// @24</span></span><br><span class="line">                log.trace(<span class="string">&quot;Updating high watermark for partition &#123;&#125; to &#123;&#125;&quot;</span>, tp, partition.highWatermark);</span><br><span class="line">                subscriptions.updateHighWatermark(tp, partition.highWatermark);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partition.logStartOffset &gt;= <span class="number">0</span>) &#123;    <span class="comment">// @25</span></span><br><span class="line">                log.trace(<span class="string">&quot;Updating log start offset for partition &#123;&#125; to &#123;&#125;&quot;</span>, tp, partition.logStartOffset);</span><br><span class="line">                    subscriptions.updateLogStartOffset(tp, partition.logStartOffset);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (partition.lastStableOffset &gt;= <span class="number">0</span>) &#123; <span class="comment">// @26</span></span><br><span class="line">                log.trace(<span class="string">&quot;Updating last stable offset for partition &#123;&#125; to &#123;&#125;&quot;</span>, tp, partition.lastStableOffset);</span><br><span class="line">                    subscriptions.updateLastStableOffset(tp, partition.lastStableOffset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.NOT_LEADER_FOR_PARTITION ||</span><br><span class="line">                       error == Errors.REPLICA_NOT_AVAILABLE ||</span><br><span class="line">                       error == Errors.KAFKA_STORAGE_ERROR) &#123;                       <span class="comment">// @3</span></span><br><span class="line">                log.debug(<span class="string">&quot;Error in fetch for partition &#123;&#125;: &#123;&#125;&quot;</span>, tp, error.exceptionName());</span><br><span class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_TOPIC_OR_PARTITION) &#123;          <span class="comment">// @4</span></span><br><span class="line">            log.warn(<span class="string">&quot;Received unknown topic or partition error in fetch for partition &#123;&#125;&quot;</span>, tp);</span><br><span class="line">            <span class="keyword">this</span>.metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.OFFSET_OUT_OF_RANGE) &#123;                        <span class="comment">// @5</span></span><br><span class="line">            <span class="keyword">if</span> (fetchOffset != subscriptions.position(tp)) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;Discarding stale fetch response for partition &#123;&#125; since the fetched offset &#123;&#125; &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;does not match the current offset &#123;&#125;&quot;</span>, tp, fetchOffset, subscriptions.position(tp));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subscriptions.hasDefaultOffsetResetPolicy()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Fetch offset &#123;&#125; is out of range for partition &#123;&#125;, resetting offset&quot;</span>, fetchOffset, tp);</span><br><span class="line">                    subscriptions.requestOffsetReset(tp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OffsetOutOfRangeException(Collections.singletonMap(tp, fetchOffset));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.TOPIC_AUTHORIZATION_FAILED) &#123;             <span class="comment">// @6</span></span><br><span class="line">            log.warn(<span class="string">&quot;Not authorized to read from topic &#123;&#125;.&quot;</span>, tp.topic());</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TopicAuthorizationException(Collections.singleton(tp.topic()));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error == Errors.UNKNOWN_SERVER_ERROR) &#123;                </span><br><span class="line">            log.warn(<span class="string">&quot;Unknown error fetching data for topic-partition &#123;&#125;&quot;</span>, tp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unexpected error code &quot;</span> + error.code() + <span class="string">&quot; while fetching data&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;   <span class="comment">// @7</span></span><br><span class="line">        <span class="keyword">if</span> (partitionRecords == <span class="keyword">null</span>)</span><br><span class="line">            completedFetch.metricAggregator.record(tp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (error != Errors.NONE)</span><br><span class="line">           <span class="comment">// we move the partition to the end if there was an error. This way, it&#x27;s more likely that partitions for</span></span><br><span class="line">           <span class="comment">// the same topic can remain together (allowing for more efficient serialization).</span></span><br><span class="line">           subscriptions.movePartitionToEnd(tp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> partitionRecords;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码虽然比较长，其实整体还是比较简单，只是需要针对各种异常处理，打印对应的日志，接下来详细介绍该方法的实现关键点。</p>
<p>代码@1：判断该分区是否可拉取，如果不可拉取，则忽略这批拉取的消息，判断是可拉取的要点如下：</p>
<ul>
<li>当前消费者负载的队列包含该分区。</li>
<li>当前消费者针对该队列并没有被用户设置为暂停（消费端限流）。</li>
<li>当前消费者针对该队列有有效的拉取偏移量。</li>
</ul>
<p>代码@2：该分支是处理正常返回的相关逻辑。其关键点如下：</p>
<ul>
<li>如果当前针对该队列的消费位移 与 发起 fetch 请求时的 偏移量不一致，则认为本次拉取非法，直接返回 null ，如代码@21。</li>
<li>从返回结构中获取本次拉取的数据，使用数据迭代器，其基本数据单位为 RecordBatch，即一个发送批次，如代码@22。</li>
<li>如果返回结果中没有包含至少一个批次的消息，但是 sizeInBytes 又大于0，则直接抛出错误，根据服务端的版本，其错误信息有所不同，但主要是建议我们如何处理，如果 broker 的版本低于 0.10.1.0，则建议升级 broker 版本，或增大客户端的 fetch size，这种错误是因为一个批次的消息已经超过了本次拉取允许的最大拉取消息大小，如代码@23。</li>
<li>依次更新消费者本地关于该队列的订阅缓存信息的 highWatermark、logStartOffset、lastStableOffset。</li>
</ul>
<p>从代码@3到@8 是多种异常信息的处理。<br>代码@3：如果出现如下3种错误码，则使用 debug 打印错误日志，并且向服务端请求元数据并更新本地缓存。</p>
<ul>
<li>NOT_LEADER_FOR_PARTITION<br>请求的节点上不是该分区的 Leader 分区。</li>
<li>REPLICA_NOT_AVAILABLE<br>该分区副本之间无法复制</li>
<li>KAFKA_STORAGE_ERROR<br>存储异常。</li>
</ul>
<p>Kafka 认为上述错误是可恢复的，而且对消费不会造成太大影响，故只是用 debug 打印日志，然后更新本地缓存即可。</p>
<p>代码@4：如果出现 UNKNOWN_TOPIC_OR_PARTITION 未知主题与分区时，则使用 warn 级别输出错误日志，并更新元数据。</p>
<p>代码@5：针对 OFFSET_OUT_OF_RANGE 偏移量超过范围异常的处理逻辑，其实现关键点如下：</p>
<ul>
<li>如果此次拉取的开始偏移量与消费者本地缓存的偏移量不一致，则丢弃，说明该消息已过期，打印错误日志。</li>
<li>如果此次拉取的开始偏移量与消费者本地缓存的偏移量一致，说明此时的偏移量非法，如果有配置重置偏移量策略，则使用重置偏移量，否则抛出        OffsetOutOfRangeException 错误。</li>
</ul>
<p>代码@6：如果是 TOPIC_AUTHORIZATION_FAILED 没有权限(ACL)则抛出异常。</p>
<p>代码@7：如果本次拉取的结果不是NONE(成功)，并且是可恢复的，将该队列的订阅关系移动到消费者缓存列表的末尾。如果成功，则返回拉取到的分区数据，其封装对象为 PartitionRecords。</p>
<p>接下来我们再来看看 2.1.1 fetchedRecords 中的另外一个核心方法。</p>
<h6 id="2-2-1-2-fetchRecords"><a href="#2-2-1-2-fetchRecords" class="headerlink" title="2.2.1.2 fetchRecords()"></a>2.2.1.2 fetchRecords()</h6><p>在介绍该方法之前同样先来看一下参数 PartitionRecords 的内部结构。</p>
<p>1、PartitionRecords 类图<br><img src="https://img-blog.csdnimg.cn/20191208194302768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>主要的核心属性如下：</p>
<ul>
<li>TopicPartition partition<br>分区信息。</li>
<li>CompletedFetch completedFetch<br>Fetch请求完成结果</li>
<li>Iterator&lt;? extends RecordBatch&gt; batches<br>本次 Fetch 操作获取的结果集。</li>
<li>Set&lt; Long&gt; abortedProducerIds<br>与事物相关，后续会专门的章节详细介绍。</li>
<li>PriorityQueue&lt;FetchResponse.AbortedTransaction&gt; abortedTransactions<br>与事物相关，后续会专门的章节详细介绍。</li>
<li>int recordsRead<br>已读取的记录条数。</li>
<li>int bytesRead<br>已读取的记录字节数。</li>
<li>RecordBatch currentBatch<br>当前遍历的批次。</li>
<li>Record lastRecord<br>该迭代器最后一条消息。</li>
<li>long nextFetchOffset<br>下次待拉取的偏移量。</li>
</ul>
<p>2、fetchRecords 详解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;ConsumerRecord&lt;K, V&gt;&gt; fetchRecords(PartitionRecords partitionRecords, <span class="keyword">int</span> maxRecords) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!subscriptions.isAssigned(partitionRecords.partition)) &#123;   <span class="comment">// @1</span></span><br><span class="line">            <span class="comment">// this can happen when a rebalance happened before fetched records are returned to the consumer&#x27;s poll call</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for partition &#123;&#125; since it is no longer assigned&quot;</span>,</span><br><span class="line">                    partitionRecords.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!subscriptions.isFetchable(partitionRecords.partition)) &#123; <span class="comment">// @2</span></span><br><span class="line">        <span class="comment">// this can happen when a partition is paused before fetched records are returned to the consumer&#x27;s</span></span><br><span class="line">        <span class="comment">// poll call or if the offset is being reset</span></span><br><span class="line">        log.debug(<span class="string">&quot;Not returning fetched records for assigned partition &#123;&#125; since it is no longer fetchable&quot;</span>,</span><br><span class="line">                    partitionRecords.partition);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> position = subscriptions.position(partitionRecords.partition);       <span class="comment">// @3</span></span><br><span class="line">        <span class="keyword">if</span> (partitionRecords.nextFetchOffset == position) &#123;      <span class="comment">// @4</span></span><br><span class="line">            List&lt;ConsumerRecord&lt;K, V&gt;&gt; partRecords = partitionRecords.fetchRecords(maxRecords);</span><br><span class="line">            <span class="keyword">long</span> nextOffset = partitionRecords.nextFetchOffset;</span><br><span class="line">            log.trace(<span class="string">&quot;Returning fetched records at offset &#123;&#125; for assigned partition &#123;&#125; and update &quot;</span> +</span><br><span class="line">                        <span class="string">&quot;position to &#123;&#125;&quot;</span>, position, partitionRecords.partition, nextOffset);</span><br><span class="line">            subscriptions.position(partitionRecords.partition, nextOffset);</span><br><span class="line"></span><br><span class="line">            Long partitionLag = subscriptions.partitionLag(partitionRecords.partition, isolationLevel);  </span><br><span class="line">            <span class="keyword">if</span> (partitionLag != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLag(partitionRecords.partition, partitionLag);</span><br><span class="line"></span><br><span class="line">            Long lead = subscriptions.partitionLead(partitionRecords.partition);</span><br><span class="line">            <span class="keyword">if</span> (lead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.sensors.recordPartitionLead(partitionRecords.partition, lead);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> partRecords;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   <span class="comment">// @5</span></span><br><span class="line">            <span class="comment">// these records aren&#x27;t next in line based on the last consumed position, ignore them</span></span><br><span class="line">            <span class="comment">// they must be from an obsolete request</span></span><br><span class="line">            log.debug(<span class="string">&quot;Ignoring fetched records for &#123;&#125; at offset &#123;&#125; since the current position is &#123;&#125;&quot;</span>,</span><br><span class="line">                        partitionRecords.partition, partitionRecords.nextFetchOffset, position);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    partitionRecords.drain();</span><br><span class="line">    <span class="keyword">return</span> emptyList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：从 PartitionRecords 中提取消息之前，再次判断订阅消息中是否包含当前分区，如果不包含，则使用 debug 打印日志，很有可能是发生了重平衡。</p>
<p>代码@2：是否允许拉取，如果用户主动暂停消费，则忽略本次拉取的消息。备注：Kafka 消费端如果消费太快，可以进行限流。</p>
<p>代码@3：从本地消费者缓存中获取该队列已消费的偏移量，在发送拉取消息时，就是从该偏移量开始拉取的。</p>
<p>代码@4：如果本地缓存已消费偏移量与从服务端拉回的起始偏移量相等的话，则认为是一个有效拉取，否则则认为是一个过期的拉取，该批消息已被消费，见代码@5。如果是一个有效请求，则使用 sensors 收集统计信息，并返回拉取到的消息， 返回结果被封装在 List&lt;ConsumerRecord&lt;K, V&gt;&gt; 。</p>
<h5 id="2-2-2-sendFetches"><a href="#2-2-2-sendFetches" class="headerlink" title="2.2.2 sendFetches"></a>2.2.2 sendFetches</h5><p>“发送” fetch 请求，注意这里并不会触发网络操作，而是组装拉取请求，将其放入网络缓存区。</p>
<p>Fetcher#sendFetches</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">sendFetches</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; fetchRequestMap = prepareFetchRequests();  <span class="comment">// @1</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.FetchRequestData&gt; entry : fetchRequestMap.entrySet()) &#123;   <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">final</span> Node fetchTarget = entry.getKey();</span><br><span class="line">        <span class="keyword">final</span> FetchSessionHandler.FetchRequestData data = entry.getValue();</span><br><span class="line">        <span class="keyword">final</span> FetchRequest.Builder request = FetchRequest.Builder</span><br><span class="line">            .forConsumer(<span class="keyword">this</span>.maxWaitMs, <span class="keyword">this</span>.minBytes, data.toSend())</span><br><span class="line">            .isolationLevel(isolationLevel)</span><br><span class="line">            .setMaxBytes(<span class="keyword">this</span>.maxBytes)</span><br><span class="line">            .metadata(data.metadata())</span><br><span class="line">            .toForget(data.toForget());   <span class="comment">// @3</span></span><br><span class="line"> </span><br><span class="line">        client.send(fetchTarget, request)    <span class="comment">// @4</span></span><br><span class="line">            .addListener(<span class="keyword">new</span> RequestFutureListener&lt;ClientResponse&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(ClientResponse resp)</span> </span>&#123;  <span class="comment">// @5</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">                        FetchResponse&lt;Records&gt; response = (FetchResponse&lt;Records&gt;) resp.responseBody();</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            log.error(<span class="string">&quot;Unable to find FetchSessionHandler for node &#123;&#125;. Ignoring fetch response.&quot;</span>,</span><br><span class="line">                                fetchTarget.id());</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (!handler.handleResponse(response)) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        Set&lt;TopicPartition&gt; partitions = <span class="keyword">new</span> HashSet&lt;&gt;(response.responseData().keySet());</span><br><span class="line">                        FetchResponseMetricAggregator metricAggregator = <span class="keyword">new</span> FetchResponseMetricAggregator(sensors, partitions);</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;TopicPartition, FetchResponse.PartitionData&lt;Records&gt;&gt; entry : </span><br><span class="line">                                 response.responseData().entrySet()) &#123;</span><br><span class="line">                            TopicPartition partition = entry.getKey();</span><br><span class="line">                            <span class="keyword">long</span> fetchOffset = data.sessionPartitions().get(partition).fetchOffset;</span><br><span class="line">                            FetchResponse.PartitionData&lt;Records&gt; fetchData = entry.getValue();</span><br><span class="line">                            completedFetches.add(<span class="keyword">new</span> CompletedFetch(partition, fetchOffset, fetchData, metricAggregator,</span><br><span class="line">                                resp.requestHeader().apiVersion()));</span><br><span class="line">                            &#125;    <span class="comment">// @6</span></span><br><span class="line"></span><br><span class="line">                            sensors.fetchLatency.record(resp.requestLatencyMs());</span><br><span class="line">                        &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(RuntimeException e)</span> </span>&#123;  <span class="comment">// @7</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (Fetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        FetchSessionHandler handler = sessionHandler(fetchTarget.id());</span><br><span class="line">                        <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            handler.handleError(e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fetchRequestMap.size();</span><br><span class="line">&#125;</span><br><span class="line">​~~~java</span><br><span class="line">上面的方法比较长，其实现的关键点如下：</span><br><span class="line">代码@<span class="number">1</span>：通过调用 Fetcher 的 prepareFetchRequests 方法按节点组装拉取请求，将在后面详细介绍。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">2</span>：遍历上面的待发请求，进一步组装请求。下面就是分节点发送拉取请求。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">3</span>：构建 FetchRequest 拉取请求对象。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">4</span>：调用 NetworkClient 的 send 方法将其发送到发送缓存区，本文不会详细介绍网络方面的实现，但下文会截图说明拉取请求发送缓存区的一个关键点。</span><br><span class="line"></span><br><span class="line">代码@<span class="number">5</span>：这里会注册事件监听器，当消息从 broker 拉取到本地后触发回调，即消息拉取请求收到返回结果后会将返回结果放入到completedFetches 中（代码@<span class="number">6</span>），这就和上文消息拉取时 Fetcher 的 fetchedRecords 方法形成闭环。</span><br><span class="line">代码@<span class="number">7</span>：消息拉取一次处理。</span><br><span class="line"></span><br><span class="line">接下来详细介绍 prepareFetchRequests 方法。</span><br><span class="line"></span><br><span class="line">###### 2.2.2.1 Fetcher prepareFetchRequests 方法详解</span><br><span class="line">​~~~java</span><br><span class="line"><span class="keyword">private</span> Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; prepareFetchRequests() &#123;</span><br><span class="line">    Map&lt;Node, FetchSessionHandler.Builder&gt; fetchable = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (TopicPartition partition : fetchablePartitions()) &#123;    <span class="comment">// @1</span></span><br><span class="line">        Node node = metadata.partitionInfoIfCurrent(partition).map(PartitionInfo::leader).orElse(<span class="keyword">null</span>);  <span class="comment">// @2</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;    <span class="comment">// @3</span></span><br><span class="line">            metadata.requestUpdate();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.isUnavailable(node)) &#123;   <span class="comment">// @4</span></span><br><span class="line">           client.maybeThrowAuthFailure(node);</span><br><span class="line">           log.trace(<span class="string">&quot;Skipping fetch for partition &#123;&#125; because node &#123;&#125; is awaiting reconnect backoff&quot;</span>, partition, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (client.hasPendingRequests(node)) &#123;   <span class="comment">// @5</span></span><br><span class="line">            log.trace(<span class="string">&quot;Skipping fetch for partition &#123;&#125; because there is an in-flight request to &#123;&#125;&quot;</span>, partition, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// if there is a leader and no in-flight requests, issue a new fetch</span></span><br><span class="line">            FetchSessionHandler.Builder builder = fetchable.get(node);    <span class="comment">// @7</span></span><br><span class="line">            <span class="keyword">if</span> (builder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                FetchSessionHandler handler = sessionHandler(node.id());</span><br><span class="line">                <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    handler = <span class="keyword">new</span> FetchSessionHandler(logContext, node.id());</span><br><span class="line">                    sessionHandlers.put(node.id(), handler);</span><br><span class="line">                &#125;</span><br><span class="line">                builder = handler.newBuilder();</span><br><span class="line">                fetchable.put(node, builder);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> position = <span class="keyword">this</span>.subscriptions.position(partition);</span><br><span class="line">            builder.add(partition, <span class="keyword">new</span> FetchRequest.PartitionData(position, FetchRequest.INVALID_LOG_START_OFFSET,</span><br><span class="line">            <span class="keyword">this</span>.fetchSize, Optional.empty()));</span><br><span class="line">            log.debug(<span class="string">&quot;Added &#123;&#125; fetch request for partition &#123;&#125; at offset &#123;&#125; to node &#123;&#125;&quot;</span>, isolationLevel,</span><br><span class="line">                    partition, position, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Map&lt;Node, FetchSessionHandler.FetchRequestData&gt; reqs = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();  </span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Node, FetchSessionHandler.Builder&gt; entry : fetchable.entrySet()) &#123;</span><br><span class="line">        reqs.put(entry.getKey(), entry.getValue().build());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reqs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码@1：首先通过调用 fetchablePartitions() 获取可发起拉取任务的分区信息，下文简单介绍一下。</p>
<p>代码@2：如果该分区在客户端本地缓存中获取该分区的 Leader 节点信息。</p>
<p>代码@3：如果其 Leader 节点信息为空，则发起更新元数据请求，本次拉取任务将不会包含该分区。</p>
<p>代码@4：如果客户端与该分区的 Leader 连接为完成，如果是因为权限的原因则抛出ACL相关异常，否则打印日志，本次拉取请求不会包含该分区。</p>
<p>代码@5：判断该节点是否有挂起的拉取请求，即发送缓存区中是待发送的请求,如果有，本次将不会被拉取。</p>
<p>代码@6：构建拉取请求，分节点组织请求。</p>
<h6 id="2-2-2-2-NetworkClient-send-方法关键点"><a href="#2-2-2-2-NetworkClient-send-方法关键点" class="headerlink" title="2.2.2.2 NetworkClient send 方法关键点"></a>2.2.2.2 NetworkClient send 方法关键点</h6><p><img src="https://img-blog.csdnimg.cn/2019120819462738.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>NetworkClient 的 send 方法只是将其放入 unsent 中。<br><img src="https://img-blog.csdnimg.cn/20191208194637842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>与上文的 client.hasPendingRequests(node) 方法遥相呼应。</p>
<p>3、总结<br>上面的源码分析有点长，也有点枯燥，我们还是画一张流程图来进行总结。<br><img src="https://img-blog.csdnimg.cn/20191208194720402.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20191208194726675.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ByZXN0aWdlZGluZw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>Kafka 的消息拉取流程还是比较复杂的，后面会基于上述流程，重点进行拆解，例如消费进度提交，负载队列重平衡等等。</p>
</div>

			<script src="https://my.openwrite.cn/js/readmore.js" type="text/javascript"></script>
			<script>
			var isMobile = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);
			if (!isMobile) {
			    var btw = new BTWPlugin();
			    btw.init({
			        "id": "vip-container",
			        "blogId": "18019-1573088808868-542",
			        "name": "中间件兴趣圈",
			        "qrcode": "https://img-blog.csdnimg.cn/20190314214003962.jpg",
			        "keyword": "more"
			    });
			}
			</script>
		]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>kafka</tag>
        <tag>消息拉取</tag>
      </tags>
  </entry>
</search>
